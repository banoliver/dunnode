<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Dunnode</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwMCIgem9vbUFuZFBhbj0ibWFnbmlmeSIgdmlld0JveD0iMCAwIDE1MDAgMTQ5OS45OTk5MzMiIGhlaWdodD0iMjAwMCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmVyc2lvbj0iMS4wIj48ZGVmcz48ZmlsdGVyIHg9IjAlIiB5PSIwJSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgaWQ9IjVmNDZiYjVkODMiPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAxIDAgMCAwIDAgMSAwIDAgMCAwIDEgMCAwIDAgMSAwIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiLz48L2ZpbHRlcj48ZmlsdGVyIHg9IjAlIiB5PSIwJSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgaWQ9ImE4ZDkzMWZlNGEiPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAxIDAgMCAwIDAgMSAwIDAgMCAwIDEgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiLz48L2ZpbHRlcj48Y2xpcFBhdGggaWQ9ImQ0ZGMxYjdjNGUiPjxwYXRoIGQ9Ik0gMCAwIEwgMTUwMCAwIEwgMTUwMCAxNTAwIEwgMCAxNTAwIFogTSAwIDAgIiBjbGlwLXJ1bGU9Im5vbnplcm8iLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0iYTM0NTRiYWVlOSI+PHJlY3QgeD0iMCIgd2lkdGg9IjE1MDAiIHk9IjAiIGhlaWdodD0iMTUwMCIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSIwMWRlZmRjZGMyIj48cGF0aCBkPSJNIDIzNC4zNzEwOTQgMjM0LjM3MTA5NCBMIDEyNjUuNjI4OTA2IDIzNC4zNzEwOTQgTCAxMjY1LjYyODkwNiAxMjY1LjYyODkwNiBMIDIzNC4zNzEwOTQgMTI2NS42Mjg5MDYgWiBNIDIzNC4zNzEwOTQgMjM0LjM3MTA5NCAiIGNsaXAtcnVsZT0ibm9uemVybyIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSI2MjgyNTY1YTg1Ij48cGF0aCBkPSJNIDAuMzcxMDk0IDAuMzcxMDk0IEwgMTAzMS42Mjg5MDYgMC4zNzEwOTQgTCAxMDMxLjYyODkwNiAxMDMxLjYyODkwNiBMIDAuMzcxMDk0IDEwMzEuNjI4OTA2IFogTSAwLjM3MTA5NCAwLjM3MTA5NCAiIGNsaXAtcnVsZT0ibm9uemVybyIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSIwZTMxZmMwNTJhIj48cmVjdCB4PSIwIiB3aWR0aD0iMTAzMiIgeT0iMCIgaGVpZ2h0PSIxMDMyIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9Ijg0M2M1YTMxODIiPjxwYXRoIGQ9Ik0gNTU3LjAwMzkwNiAzNjcuNSBMIDEzMjIuMDAzOTA2IDM2Ny41IEwgMTMyMi4wMDM5MDYgMTEzMi41IEwgNTU3LjAwMzkwNiAxMTMyLjUgWiBNIDU1Ny4wMDM5MDYgMzY3LjUgIiBjbGlwLXJ1bGU9Im5vbnplcm8iLz48L2NsaXBQYXRoPjxtYXNrIGlkPSIxODIzNGE3Y2Y3Ij48ZyBmaWx0ZXI9InVybCgjNWY0NmJiNWQ4MykiPjxnIGZpbHRlcj0idXJsKCNhOGQ5MzFmZTRhKSIgdHJhbnNmb3JtPSJtYXRyaXgoMS4wMDEzMDUsIDAsIDAsIDEuMDAxMzA1LCAwLCAwKSI+PGltYWdlIHg9IjAiIHk9IjAiIHdpZHRoPSI3NjYiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBdjRBQUFMK0NBQUFBQUR3RGs5bEFBQUFBbUpMUjBRQS80ZVB6TDhBQUJjRFNVUkJWSGljN2QxWmM1N2xmY2Z4QzF1YkIyekxiQWE4eVBzS0JHaE1Bc1RXQTJRQUV4WmpqQmVaZGpMVDZUQTliS2ZMUytnYjZVelBrMVp5VHpwVFM2TEVqMFJJbS9Rd00yaXhaV3V6WmNWeGJVdnFnUjJRWkYxNnR2dStyLy95L1J3bGdPMkxtZS8vYVN6OW9DRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZDTnRha2ZzTlQ2TmZkU1B3R09DTXUvL2MrYkpqZ0FGRVZZL25mLzZWajdJeHdBQ2lJcy83bTV2MzF6RndlQWdnakxQd3g5K3ZRdURnQUZrWmIvN2ZZM3cxb09BTVdRbG44WVBmZG80QUJRREhINVR4OThPUVFPQUlVUWwzOFk2Mm9PSVR3NGdEREpBU0EvOHZLLzBybjd3WDlhdSt2Tm5aczRBT1JIWHY0TE4wK3QrZE4vWHJ1YkEwQ081T1VmaGo3ZS9QMS80UUNRSTRINTMyMDYvc2lpLzdwMmQya1hCNEJjQ013L0RKM2RzT1MvTjNFQXlJZkUvR2UzdnJic2ozQUF5SVhFL01PVnJyYmxmK2orQWZCOUFHUktaUDdqUnc0Ky9BZWJkcGY0UmhpeUpUTC9NSGwycFhkeEFNaVl6UHhIMzl1NjRoL25BSkFwbWZuUDNUM3h5TXAvaGdOQWhtVG1INzQ5OVhqc1QzRUF5SXpRL0c4L1hvci9TUTRBR1JHYS8vM1pmeFFIZ0V4SXpYL3EwRXVyL3ZtbTNhVmQ3WHdmQUkyUm1uKzQrbUQySDlXMHU3U1RiNFNoSVdMenYxemFWZWt2NFFEUUlMSDVMNTc5UjNFQWFJalkvTVBRaWMyVi95SU9BSTJRbS8vZHB2Y2kzL3BhcW1sM2FTZS9DVVpkNU9iLzBPdy9pcThDb1U2Qzg1L2QvdU5xLzFJT0FIVVJuUDlLcy84by9pY1E2aUE1LzJ1dnJqRDdqMnJhd3dHZ1JwTHpqOHorb3pnQTFFaDAvaVBIVjU3OVIzRUFxSW5vL09mbVBxcnFhNStMY0FDb2dlajh3OGlwVFRYL0dBNEFWWk9kLzYwbk91djRVUndBcWlRNy96QjZmbDA5UDR3RFFGV0U1ei8xNG92MS9VQU9BRlVRbm44WU85OVU1NC9rQUZDUjlQeXZ2TFdqN2gvTEFhQUM2Zm5QLytGVXJWLzdYSVFEd0txazV4K0dUenpWeUEvbkFMQUs4Zm5mYVgyM3NaK0FBMENVK1B6RHlKa3FaLzlSVFh0S085c1hKdVl5ZVE0c2taLy9UTWVQR3Y0NW12YVVkclFIRGdETHlNOC9qSDNlMHZoUHdnRmdCUXJ5di9yYXZpeCtHZzRBRDFHUWY1ZzZrODByT1FBc295SC8wZU5iTXZxWk9BQXNvU0gvZTdYUC9xTTRBQ3lpSWY4d1hNZnNQNG9Ed0hkVTVIL3JxV05aL25RY0FCNVFrWCs5cy84b0RnQWhCQzM1VC83Z2hZeC9SZzRBUVV2KzRWcFh2YlAvS0E0QVd2Sy8zTURzUDRvRGNFOUovdk8zUHMzc2E1K0xjQURPS2NtLzBkbC9GQWZnbXBiODc3UTFPUHVQYXRwVDJyR1JPYlJQV3ZJUHcyZlg1L1ZUTiswcDdlQ2ZCM0JKVGY0ek8xL043eWR2M3NzQnVLUW0vekIyUG9QWmZ4UUg0SktlL0RPYS9VZHhBQTdweVQ5TVp6VDdqK0lBM0ZHVS84ajd6K1g5UzNBQXppaksvOTc4aDNsODYyc3BEc0FWUmZtSDRjOHluUDFIY1FDT2FNby80OWwvRkFmZ2hxYjh3MmhYdHJQL0tBN0FDVlg1VDc2VTlldy9pZ053UVZYKzRkcTV6R2YvVVJ5QUE3cnl2L3oyamdKL05RN0FQRjM1NXpUN2o3cC9BT01jZ0ZXNjhnOURuK1F6KzQ5cTNsdmFzVEZ3QUVZcHkvOU8yenRGLzVMTmUwc2Q3UnlBVGNyeUQ4UG5jcHY5UjNFQVptbkxmMmJYa1FTL0tnZGdsTGI4YzU3OVIzRUFKdW5MLy9WOFovOVJISUJCNnZJUDA2ZFR2WmtETUVkZi9pTS95MzMySDlXOHQ5VEJOOElNMFpkL0liUC9LQTdBRkgzNWg2SFQ3U2wvK2VaOUhJQVpDdk8vdGZsbzJnZHdBR1lvekwrNDJYOFVCMkNFeHZ3bmlwdjlSM0VBSm1qTVA0d1hPUHVQNGdBTVVKbi82RTg3VWo4aEJBN0FBSlg1ei8veFpNS3ZmUzdTdksvVXdiOGRXakdWK1llaGswK21mc0lESElCcU92Ty9zNjd3Mlg4VUI2Q1l6dnpEVUlMWmZ4UUhvSmJTL0dmMi9ERDFFeGJqQUpSU21uOFk2MG95KzQvaUFGUlNtLzhiZTFNL1lSa09RQ0d0K1lmcnlXYi9VYzM3U2gwYjV6a0FSY1ExVkszaEQ1NU4vWVNITmU4cmRiUnpBSHFvemY5ZStFREd0NzZXNGdCVVVadC8rRGJ0N0QrS0ExQkViLzYzbnZsSjZpZEVjQUJxNk0wL1hQNjhMZlVUWWpnQUpSVG5QL0ZuaDFJL0lZNERVRUZ4L21HOFMvTHI3eC9BK0h6cWQyQVZrZ09xNVBJNzIxSS9ZVlgzdnhIR0FRaW1PZis1MjBKbS8xRWNnSENhOHcvREo1OUkvWVJLT0FEUlZPZC9lLzNicVo5UUdRY2dtT3I4dzhqNVIxTS9vUW9jZ0ZpNjg3KysvNVhVVDZnS0J5Q1U3dnpEbGZQTnFaOVFIUTVBSk9YNWp4M2JuZm9KMVhvd2grWUFKRkdlLzhLTno5YWtma1BWbXZlVnRyZHpBSklvenorTWZQaE02aWZVb0hrL0J5Q0s5dnp2cm4xZitMZStsdUlBUk5HZWZ4Zyt2VEgxRTJyREFRaWlQdi9aWjk5SS9ZUmFjUUJpcU04L1hEa3ZkdllmMWJ5L3RKMnZBZ21nUC8rSkh3cWUvVWMxNytmTG9BTG96eitNbjFQNU45SENBYVNuc3B5bExyOHJlL1lmeFFFa1p5RC91ZHVmcVByYTV5SWNRR0lHOHRjdys0L2lBSkt5a1AvdGpXK2xma0lET0lDRUxPUWZScnMwelA2ak9JQmtUT1EvZmVEbDFFOW9EQWVRaUluOHc1aVcyWDhVQjVDRWpmeXZkS3FaL1VlMThKM2c0dG5JZjJIbWxKN1pmeFFIVURnYitZZmhqelROL3FNNGdJSVp5Zi91MnVOYXYvVzFGQWRRS0NQNWgrRXp5bWIvVVMzN096bUFvbGpKZi9hNTExTS9JVE1jUUdHczVLOXk5aC9Wc3I5eis4WTUvclVvdVRPVC8vaVJnNm1ma0tYNy94ZUFBOGlabWZ6RGhNN1pmMVRMQVE0Z2QzYVNHWDF2YStvblpJd0R5SjJkL09mdW5MRHh0YzlGT0lDYzJjay9ESDJxZC9ZZnhRSGt5bEQrdDl2ZlRQMkVQSEFBT1RLVWZ4ZzlwM3IySDhVQjVNWlMvdE1IbGMvK296aUFuRmpLUDR4MWFaLzlSM0VBdVRDVnY0WFpmMVRMZ2M3dEd6aUFiSm5LMzhic1A2cmxRSWtEeUphcC9NUHd4NXRUUHlGWEhFREdiT1YvdDhuSTdEK0tBOGlVcmZ6RDBOa05xWitRTnc0Z1E4YnluOTM2V3VvbjVLL2xRR243aGpuK2VZQU1HTXMvWE9reU5QdVBhamxRMnJhUkEyaWN0ZnlOemY2ak9JQk1XTXMvVEo0MTk3ZTBNZzRnQStaYXNUZjdqK0lBR21ZdWY0dXoveWdPb0VIbThnOURweDVQL1lRQ2NRQU5zWmYvN2NkTHFaOVFLQTZnQWZieU56djdqK0lBNm1Zdy82bERMNlYrUXRGYURuUnU1d0RxWUREL2NOWHU3RCtxbFFPb2g4WDhMNWQycFg1Q0FoeEFIU3ptdjNEVDlPdy9pZ09vbWNYOHc5QUoyN1AvS0E2Z1JpYnpOL052KzY4ZEIxQVRrL2w3bVAxSHRSN29aQTVkTFp2NXoyNy9jZW9uSk5SNm9ITWJCMUFWbS9rN21mMUh0UjdrQUtwaU5QOXJyL3FZL1VkeEFGVXhtcitmMlg4VUIxQUZxNUdNSEhjeis0L2lBQ3F5bXIrcjJYOFVCMUNCMWZ6RHQ1OTVtdjFIY1FDck1wdi83U2M2VXo5Qmh0YURuVnY1UmxpRTJmekQ2UGwxcVo4Z0JBY1FaVGYvcVJkZlRQMEVNVGlBQ0x2NWg3SHpUYW1mSUFjSHNDTEQrVjk1YTBmcUowakNBYXpBY1A3emZ6akYxejRYNHdBZVlqai9NUHp4MDZtZklBd0hzSXpsL08rMHZwdjZDZUp3QUV0WXpqK01uUEU3KzQvaUFCWXhuZjlNeDQ5U1AwRWlEdUE3cHZNUFk1KzNwSDZDU0swSE83Y3loUWpXODcvNjJyN1VUeENLTFZBSXdYcitZZXFNOGIvQituRUF3WHorbzhlM3BINkNYQnlBOWZ6dnpYM0V0NzdpV2c5MmJ0dHdiOUx2QVJqUFB3eWYycFQ2Q2FLMUh1emM2dmdBck9kLzYwbG0vNnRyUGVUNEFLem56K3kvTXNjSFlENy95Uis4a1BvSjhyazlBUFA1aDJ0ZHpQNHJjM29BOXZPL3pPeS9LaTRQd0g3Kzg3Yys1V3VmVmJsL0FCTUxxZDlSSVB2NWgrRVRUNlYrZ2hhdGh6cTNicGh6ZEFBTzhyL1R4dXkvYXM0T3dFSCtZZmpzK3RSUFVNVFZBWGpJZjJibnE2bWZvSXFqQS9DUWZ4Zzd6K3kvSm00T3dFWCt6UDVyNXVRQVhPUWZwcG45MTh6RkFmaklZdVQ5NTFJL1FTRUgzd2Z3a2YrOStRLzUxbGNkekIrQWovekQ4R2ZNL3V0aS9BQ2M1SC9ycVdPcG42Q1Y2UU53a244WTdXTDJYeS9EQitBbC84bVhtUDNYci9WUTU5YjFGZy9BUy83aDJqbG0vdzB3ZWdCdThyLzg5bzdVVDlDdHplSUJ1TW1mMlgvRERCNkFtL3pEMENmTS9odGw3Z0Q4NUgrbjdaM1VUekRBMkFINHlUOE1uMlAybndGVEIrQW9mMmIvR1RGMEFJN3lEMWVZL1dmRXpBRjR5di9xNjh6K3MyTGtBRHpsSDZaUHUvcmJ6WmVKQTNEVnc4alBtUDFucU8xUTV4YmxXeUJYK1RQN3oxamI0V082eDNDdThnOURwOXRUUDhFWTVRZmdLLzlibTQrbWZvSTVxZy9BVi83TS92T2crQUNjNVQvQjdEOFBhZy9BV2Y1aG5ObC9MdG9PSDl1NjRlNmt0Z1B3bHYvb1R6dFNQOEdvdHNQSHRxeS9wK3dBdk9VLy84ZVRmTzB6SndvUHdGditZZWprazZtZllKZTZBM0NYLzUxMXpQNXpwT3dBM09VZmhwajk1MHJWQWZqTGYyYjNrZFJQTUU3UkFmakxQNHgxTWZ2UG1ab0Q4SmovRzN0VFA4RStKUWZnTVA5d25kbC9BVlFjZ01jUWhqOTROdlVUWEZCd0FCN3p2eGMrNEZ0ZmhSQi9BQjd6RDk4eSt5K0s4QU53bWYrdFozNlMrZ2wraUQ0QWwvbUh5K2VZL1JkSDhBSDR6SC9pNWVkVFA4R1Z0c1BIdHF5WE9JZjJtWDhZUCsvMGJ6eVZ0c1BIdGdqODV3R2NWakQ2N3JiVVQvQ203Zm1qOGc3QWFmN3orL2pOYitIV1BmL0s4RGR6cVYreGhOTi85Sy9wVU9vWE9EVDdkZjl2WmRYdk5mOFgza3I5QW5kbXYrNi8wQytzZnEvNS85V2pxVi9nak1qNFEvRDUzZitPcjU1Si9RUlhaZ2UvbEJpLzEwLy9zOVJmb05uQi9ndGZTb3pmYWY2Yi9pTDFDeHdSSEwvVC9OODVtUG9GYm9pTzMyZitiVi80L0IxUDhZVEg3elAvSTIra2ZvRVA0dU4zbWYrYUwvaEgzUXVnSUg2WCtlOTlQL1VMSEZBUnY4djhmNzRwOVF2TVV4Sy94L3czbjBuOUF1dlV4Tzh4L3hNN1VyL0FOa1h4Tzh6L3NiL2txNTQ1dXZtMW92Z2Q1bi8wbGRRdk1FeFovUDd5Yi9wcnAvK0FUd0hVeGU4dmY0YitlYms1MlAvdnl1TDNsejlELzN6Y0hPeS84Ri9hNG5lMzkyZm9ud3VsOGJ2NzlHZm9ud08xOFh2TG42Ri85aFRIN3kxL2h2NVpVeDIvcy93WittZE1lZnpPOG1mb255bjE4ZnZLbjZGL2xtNE85dmQ4cFR0K1gva3o5TStPaWZoOTVjL1FQeXRHNG5lVlAwUC9qSmlKMzFYK0RQMHpZU2grVC9rejlNK0NxZmc5NWMvUXYzRTNCNzYwRkwrai9CbjZOOHhjL0k3eVoramZJSVB4TzhxZm9YOURUTWJ2WisvUDBMOFJOd2Y2THhpTTM4K25QMFAvK3BtTjMwMytEUDNyWmpoK04va3o5SytUNmZpOTVNL1F2ejQzQi9wN2ZtVTNmaS81TS9TdmgvbjRuZVRQMEw4T0R1SjNrajlELzVxNWlOOUovZ3o5YStRa2ZoLzVNL1N2emN5Z2svaDk1TS9RdnhhTzRuZVJQMFAvR3N3TTlsMXdFNytML0JuNlYyMW1zTy9DVi9PcFgxRWcrL2t6OUsrV3UvZzk1TS9RdnpvTzQvZVFQMFAvYXJpTTM4SGVuNkYvRlp6RzcrRFRuNkYvUlRNRC9UN2p0NTgvUS85S1pnYjZlMzdsTTM3NytUUDBYNTNyK00zbno5Qi9WYzdqTjU4L1EvOVZ1SS9mZXY0TS9lT0lQMWpQbjZGL0RQR0hFS3puejlCL1pjVC9nT244R2ZxdmlQaS9ZenAvaHY0cklQNUZMT2ZQMFA5aHhMK0U1ZndaK2k5SC9Nc1l6cCtoL3pJM0JvbC9HY1A1TS9SZjRzWmczd1hpWDhady9nejlGeUgrRmRuOXpTRkQvKy9kR09nbi9wWFkvZlJuNlA4bk53YjZleTRSLzByTTVzL1Evd0hpWDRYWi9CbjZoeENJdndLcitUUDBENEg0SzdLYVAwTi80cStDMGZ3WitoTi9OWXptNzM3b2YyT2c3d0x4VjJRMGYrZEQveHNEZlQyWEZsSy9RZ0diK2ZzZStoTi8xV3ptNzNub1QvdzFNSm0vNDZFLzhkZkVaUDV1aC83RVh5T0wrWHNkK2hOL3pTem03M1BvVC94MXNKaS94NkUvOGRmRjRPOFJIUTc5aWI5T0JqLzkzUTM5Ynd6MFhpRCt1dGpMMzl2UW4vZ2JZQzkvWDBOLzRtK0l1ZnhkRGYySnYwSG04bmMwOUw5UjdpUCt4bGpMMzgvUS8wYTVyNmRNL0kyeGxyK1hvVC94WjhKYS9qNkcvc1NmRVdQNXV4ajZYeDhnL293WXk5L0IwSi80TTJRcmYvdERmK0xQbEszOHJRLzlpVDlqcHZJM1B2UW4vc3laeXQvMDBKLzRjMkFxZjhORGYrTFBoYVhmS3RvZCtoTi9UaXg5K2xzZCtoTi9iZ3psYjNUb1QvdzVNcFMveWFILzlYTGZCZUxQalozOExRNzlyNWY3ZWdhSVB6OTI4cmMzOUNmKzNKbkozOXpRbi9nTFlDWi9ZME4vNGkrRW1meE5EZjJKdnlCVzhyYzA5Q2Yrd2xqSjM4N1FuL2dMWkNSL00wUC82WUcrN2tIaUw0cVIvSTBNL1ltL1lEYnl0ekgwSi83QzJjamZ3dENmK0JPd2tiLytvVC94SjJIaWQ0enFoLzdFbjRpSlQzL2xRMy9pVDhaQy9ycUgvdFBsZnVKUHhVTCttb2YreEorVWdmd1ZELzJKUHpFRCthc2QraytYKzNxSVB5bjkrV3NkK2hPL0FQcnoxem4wSjM0UjlPZXZjZWhQL0VLb3oxL2gwSi80eFZDZnY3cWgvM1M1ci90cjRwZEJlLzdhaHY3RUw0cjIvSFVOL1lsZkdPWDVxeHI2VHcwUXZ6REs4MWMwOUNkK2daVG5yMmJvVC93aTZmcU40M0phaHY1VEE3MDl4QytRN2s5L0hVTi80aGRMZGY0cWh2N0VMNWpxL0JVTS9ZbGZOTTM1eXgvNkU3OXdtdk9YUHZRbmZ2RVU1eTk4NkUvOENpak9YL1RRZjZyY1IvenlLYzVmOE5CL3F0elgvV3ZpbDA5di9uS0gvc1N2aHQ3OHBRNzlpVjhSdGZrTEhmb1R2eXBxOHhjNTlDZCtaYlRtTDNIb1QvenFhTTFmM3RDZitCWFNtciswb2Y5VXViZUgrTlVSK2Z2SHlvUU4vWWxmS2FXZi9xS0cvc1N2bHM3OEpRMzlpVjh4bmZuTEdmb1R2Mm9xOHhjejlDZCs1VlRtTDJUb1AzV3BqL2gxMDVpL2pLSC8xS1crN20rSVh6ZU4rVXNZK2srV2lkOEFqZm1uSC9wUGxudDdpTjhBaGZrbkgvb1R2eGtLODA4ODlDZCtRL1RsbjNib1QveW02TXMvNWRDZitJMVJsMy9Db2Y5a3ViZjdOOFJ2aWJyOGt3MzlKOHU5M2Q4aytyV1JFM1g1SnhyNkU3OUpRc1l6VlVzejlKOHNYK3doZm9PMGZmcW5HUG9UdjFuSzhrOHc5Q2QrdzVUbFgvalFuL2hOMDVWLzBVTi80amRPVi83RkR2MkozenhWK1JjNjlDZCtCMVRsWCtEUW4vaGRVSlYvWVVQL2lRSGlkMEZUL2tVTi9ZbmZEVTM1RnpQMG55ajNFcjhYaXZJdlpPZy9VZTd0L2szK3Z3eGtVSlIvQVVOLzRuZEdULzc1RC8ySjN4MDkrZWM5OUNkK2gvVGtuKy9Rbi9oZFVyUDN6M1hvVC94T3FmbjB6M0hvUDFHKzJFUDhMbW5KUDcraFAvRTdwaVgvdkliK3hPK2Frdnh6R3ZvVHYzTks4czlsNkUvODd1bklQNCtoUC9GRFNmN1pELzJKSDBGTC9sa1AvY2NIaUI5QlNmNFpELzNIeTczRWp4Q1U1Si9wMEgrODNOdjkzeG4rZkZCTVEvNVpEdjJKSDR0b3lEKzdvVC94WXdrRitXYzI5Q2QrTEtNZy80eUcvc1NQaHlqSVA1T2hQL0ZqQmZMMy9sa00vWWtmSzVMLzZkLzQwSCs4ZkxIN2Y3SjRDcXdSbjMvRFEzL2lSNVQ0L0JzYytoTS9WaUU5LzhhRy9zU1BWVW5QdjVHaFAvR2pBdUg1TnpEMEozNVVKRHovdW9mKzQ1ZDZpUitWQ00rL3pxRS84YU1xc3ZPdmIraFAvS2lTN1B6ckdmb1RQNm9tT3Y4Nmh2N0VqeHFJenIvbW9UL3hveWFTODY5MTZFLzhxSkhrL0dzYitoTS9haVk1LzFxRy91T1hldi90dC9rOUJTaFl4NVdGYWwzOTEzOThQdlZ6b1pEZ1QvK3FoLzdYeWhlNytlU0hLWnQrViswbi96L3d5WS82eVAzMHIyN296eWMvR2lBMi82cUcvc1FQbTQ3K0gvK3pCM21UK3VsZmVlalBKei9NMmovRkp6OXlKL1hUZi9XaFA1LzhzR3p6NzFmOTVQOTdQdm1SQmFHZi9xc00vYStWLzdPSFQzNFk5dGdsUHZuaDF2RjdrZmgvU2Z5d3J1a1hzZmdQcDM0YWtMZVhaNGtmUlJENVc5OFZodjdYTGwzcy9sMkNwd0FGZTNqb1A4WW5QL0lnOGROLytkRC9hcGxQZm5peGJPalBKejg4T1ROUC9QQ3E3VCtJSDI1OVAvUW5mbml6NXArSkgyNDlHUG9UUHdvZzdndWZQOThVK0ZJbm5OcjgrNFdGc1YvK0haLzg4T2lMK2JGZkVEOEswc2ovMjlBY1BQWXZDeGU3L3pmMUs0QWtudjZiUTZtZkFLU3lMdlVEQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXgvdzlZZkdBZEJ2SWhQUUFBQUFCSlJVNUVya0pnZ2c9PSIgaGVpZ2h0PSI3NjYiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiLz48L2c+PC9nPjwvbWFzaz48Y2xpcFBhdGggaWQ9ImRhNzJjZTM0NzUiPjxyZWN0IHg9IjAiIHdpZHRoPSI3NjciIHk9IjAiIGhlaWdodD0iNzY3Ii8+PC9jbGlwUGF0aD48cGF0dGVybiBpZD0iYmVlMTM2YWRjMyIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgd2lkdGg9Ijc2NyIgcGF0dGVyblRyYW5zZm9ybT0ibWF0cml4KDAuOTk4Njk2LCAwLCAwLCAwLjk5ODY5NiwgLTIwOS4wMDAwNDksIDExMzIuOTE5OTQyKSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDc2NyA3NjciIGhlaWdodD0iNzY3IiB4PSIwIiB5PSIwIj48Zz48ZyBjbGlwLXBhdGg9InVybCgjZGE3MmNlMzQ3NSkiPjxnIG1hc2s9InVybCgjMTgyMzRhN2NmNykiPjxnIHRyYW5zZm9ybT0ibWF0cml4KDEuMDAxMzA1LCAwLCAwLCAxLjAwMTMwNSwgMCwgMCkiPjxpbWFnZSB4PSIwIiB5PSIwIiB3aWR0aD0iNzY2IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQXY0QUFBTCtDQUlBQUFCYUI0ZnVBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFnQUVsRVFWUjRuTzNkWDVOZTFYMG4rdC9hKytrL0dMcWhuVkdNRFdROFo4NEU1MXhGT0c4Z2RlNW1FdXpKaGEvSGY1TGN6V3ZRYXpoVk1BR0owVG54VkRsSFpUQUNaTWVuN0hReU9iazROdUM1U0kzRkRGaGdwRzVFZzRTNlcxTC8yWHYvemtVTGtJU0FsdFRkejdPZjUvT3BjaVZWdHNPcTdMWFgvdlozcjJldkNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUExV0dQUUIyNVptVEsyWG1DeEZSWnI3dzdUOTIxUURnRGxYREhnQzdVZzI2M0x4U1pyNFFhKy85OWJOblQ1eDRlOWdqQW9CZTBoLzB3L2RQL2pabnA3YzJzc3Z1Z2ExdW95NFJNZHZtdDc3MXlMQ0hCZ0I5b3ZYcGh6cWEyVXZ2WldSRVdadXBOK295MitaR1hUUkFBSEJidEQ3OWNPTEVQMStldlgrN3JVdUp5TXhTNmhKdHBnWUlBRzZMNk5NYngzN3liajA3MVg1d05YY3VtZ0FFQUxkUDlPbU40NHNYbS9XcjBYUlJybnROS1FBQndPMFFmZnJrNlIrOW5aRlZOWWk4OGQ4UWdBQmdkMnh6N3BPTXJFb2RtVGYvRzZXVWlLNjdZUlAwNXFENi9uTkxOa0VEd1BXMFBqM3o4MTljZUd0cHE0M3VVLzhUSHpaQVVkVnpWN2MyQjFWRW1XbGFEUkFBaE9qVE82LytldTN3MSs0Nzl2enk1MXk2ektoS0ZRSVFBTnhBOU9tWnpIenBsMnZuejYxbktYSHpscDliL0tjRklBQzRudWpUUDAvL2ZEWHZuNnZPTHUzMjhnbEFBUEFoMGFkL25ubzU0NzJWZXJPTmlQemtsdWZQVUVJQUFtRENpVDY5OUZjdnZ0MVd6ZlRXZEpUYnY0SUNFQUFUekkvYmU2bXRtcW50cVhKbmx5K2p5K2k2ZG0ybTNwb2F6RFR0bGRuNHp6OSs2L2ppbWIwZUpnQ01ISzFQWC8zZEx5Nit0YlRaWkhkWDEzQW5QYlZkdGJEZGJkUWxzOXpUZmZ1UC85VmVEUklBUm8zbzAxZS8rdlhhSCs3bVYrNjdrVkZLbEU0QUFtRDhpVDU5bFprLy9hL3ZuTDNRWmlsN2N4MEZJQUFtZ09qVFk5Ly80ZXN6M2NhbG1kKzV4ZEVXZDB3QUFtQ3NpVDQ5ZHVMRVAxK2VmYURwNnMvL3R1SHRFb0FBR0ZPaVQ3ODk4NU9WYW5iUVhOclkrL1FUQWhBQVkwajA2YmZqaXhmYjlZMXN1anY1d004dUNVQUFqQkhScC9lT1BuKzJsTXlvOTZQMytkaDFBU2czQnlVaVpob0JDSURlRVgxNjc5akp0ek9xa3BFSGNEVXpTb202cW1MdXFnQUVRQitKUHVQZ1o3KzhjR1o1SzdydVlQNXhPNU5HQUFLZ2owU2ZjZkRLNmJYSEhyM3YyTW5sZy95SENrQUE5SkhvTXc0eTg2V1gxOCsvY3lYYmJsOSs2dlhwQkNBQStrWDBHUk5QTDY3bjNMM1YyYVdoWEZNQkNJQytFSDNHeEZNdlo3eTNNdGphenF4eUR6L3VmRHRLUkZiVklFSUFBbUJraVQ3ajQ2a1hmOXRVN2ZUMnpEQUhVYUxreHdHbzJ4eEVSQ1VBQVRBeVJKL3g4Y1NwTTRObVVPMzNCMzUyNDhNQUZCRURBUWlBVVNMNmpKV2YvZkw5TTB0WG9xdEg0c0tXaUl3UWdBQVlKYVB3aEdUUHZITDYwbU9Qemgvd3I5dy9od0FFd0NnUmZjWktadjcwSDg4dlhZZzIydEc2dUFJUUFLTmhsSjZPN0lYLzh1eHZwdHNySDB3dmxCRzh1QUlRQU1NMmVrOUg3czZKRS8rOFBqWFhsdWtEL3JiaGJSQ0FBQmdlMFdjTVBYMXlLYXVvbXRHK3ZBSVFBTU13eXM5Rzd0QlRMeTVWVFdSbXFVYisrdDRVZ0RicXlLenU2UVFnQVBiSnlEOGF1U1BIbmwydXMyNEd6YkFIc2pzZkJhRHRadkRGYlFFSWdQMGorb3luNHo5OHQ2M2JMS082M2VlV0JDQUE5cC9vTTdiKzV0VEZLOXRiYll6NGxwOVBFSUFBMkUrOWVpaHlPNTc3eWZyQzdMMnZmM0F1U2pYc3NkdytBUWlBL1NINmpLM0Z4VHkzL3Y3VmRpT3pLajI5emdJUUFIdXRwNDlFZHVYWTg4dWxETnB1cS9RMSswVEVKd0xRMVRwQ0FBTGdEdlg1aWNqbmVlYmtTdGR0bHpLeUh6ZThIVHNCS0NPNmJ2REY3ZTByZGRmbFZyMzFILy90dnhuMnlBRG9FOUZuekIxOTdseGtSdDNEN1Q2M2xoRWxNdXBTclUrdlRUWFRwWVFBQk1EdWlUNWo3dWl6WjB0VlNpbmRzRWV5cDdLVTBuVXhFSUFBdUUyaXovajd1MSs4LzlhNXE5dWxqT0tCcG5kRkFBTGd0bzNaczVCYitOV3ZMLzNoMSthUFBiOFV2ZDdzL0trRUlBQnV3MWcrQzdsQlpwNzYrNVdsUzAyNXRsVjRMQWxBQU95SzZETVJqdjNndC9WRzIzeHhObkpjbzg4T0FRaUF6eUg2VElUang4ODA4OU5sVUdlTzEzYm5XN3NoQU5YTklFcTBkU01BQVJDaXorUjQrb1hsTEZsMTQvdks2MmJYQWxDV2RuTjZRd0FDWUlmb015bWVlbkdwWklrMngzT3Y4NmZLaUpJcEFBRnd6V1E5QmlmYzB5KzhFM1ZkdHJlSFBaQ0RKd0FCY0kzb00wR2VQclZTdHB2SmVlUDFDUUlRQUtMUGhQbkJTeGV1YkcxMFZVN3dwUmVBQUNiYXhENy9KdFJ6UDE1ZHVHZnU5VXZMd3g3STBBbEFBQk5LOUprc2k0dDU3dktGamZacTExVVR0dC81bGdRZ2dJbmo2VGR4anAxY0xqRm9jOXUxLzlBTkFXalFUcGNTMjVVUElRS01KNCsvaWZQTXlaV3UyNjZxNkNaMnUvT3Q3ZXgvcWtxZFYrcDFBUWhnWElrK2srallqODVsbDFIWEUveHJyMDlWU21RS1FBQmpTL1NaUkVlZlBSdFZLVldWWTM2azE1MFRnQURHbGVnem9YNyt5d3RubHE1MkdjVWMrSFFDRU1ENDhkaWJVSytjWG4zczBibGpMeXhGbWdPZlF3QUNHQ2NlZXhNcU0zLzhEeXZMbDVyTVlzZlBiZ2hBQU9OQjlKbGN6L3pOYjZ1cmJic3dJL2pzM2cwQnFKa3FrZHNEM3dFQzZKTnEyQU5nYUtxcmJUcy9WU3B6NERaa1JrUVhYZDZ6TlRmZDF0dURadEJNL2FjWHp2d2ZQLzZmd3g0YUFMdWk5WmxvUjE5WTdrcFc3YkRIMFUrWlhTbURrdHRYWmpZMFFBQjlJZnBNdEtkZVhLcTZVdnpHL1M0SVFBRDlJdnBNdW1QUHYxTkszZVgyc0FmU2J3SVFRRitJUHBQdW1aTXJYVGFSWFRqTzlLNEpRQUNqejlPTytNRkxGOWFialE4UHNlSnVDVUFBbzh5dmU0anBldkMvM3Y5bDN6YmNLNlZVRVYwWDVhTmZnWDFoYy83N1A3eDA0b1F0VlFERDUybEhMQzdtdWZVTFY1cXRpUFRXYTI5OTFBRE5iejk4dFZyTmlDOTA4OS82bHY4dkF3eU5KWmlJaUtQUG42OUsxWFhiWnNSK3lPd2lTaHZkN3doQUFNTm04U1ZpWjdOejEwUkVGQzlsOWtWR2xpaVpLUUFCREpkbGwydU9QbmN1TXFPMi9Xc2ZDVUFBUTJmQjVacWp6NTR0VllsU3BkTk05NWtBQkRCRWxsbys5dk5mWG5ocitXclRSVEV4OXA4QUJEQVVGbGsrOXVycDFjT1B6aDE5WWRtR253TWpBQUVjTU1zckg4dk1VLyt3c3JUYWxpN0NhNjhEZEZNQTJxalhvcFRaNWo0QkNHRFBXVmk1d2JHL2VidSsyalFMTThNZXlDVDZLQUJGWFQydzhhQUFCTEFmL0p5SEc5UlhtMlorcWxRcW55RzR0c1dxUkpYeHdkVFN4dFRsMmVhK2pYcnRyNTliOHlWb2dMM2lyMGx1OXZRTDU3S1UwcG9jdzVTUlZhbTZydE1BQWV3dHJRODN5MUtpeThodTJBT1phTmZlZkdtQUFQYWF2eUM1aGFkT25vdXFWTzJ3eDBGRWFJQUE5cFRXaDF1cFN1a0U0MUdoQVFMWVF4NXUzTm9QVGwyNDNHeGtwa2t5VWpSQUFIZkpjc210UGZ1M3ExK2NtWHZqMHJKV1lRVGRISUNxOWNpWVRRRUk0UE5aS0xtMXhjVThkL25pMVdZcnN5dW15VWphQ1VBUjBUWHhRQ3NBQWV5S0paSlBkZXo1ODZWVWJXNDUwbXZFNWM3dUxBRUlZQmNzam55cVowNnVkTjEyS2NWWjdyMGdBQUhzaG1XUnozTDB1WE9SR1hYdFNLKytFSUFBUHBzRmtjOXk5Tm16Y2s4ZkNVQUFuOFpTeU9mNDJTOC9PSE4rT3hzN2Z2cEhBQUw0SklzZ24rT1YxeTQvOXZ0Zk9IWnllZGdENFE1ZEg0QTI2N1dJbUdubkJDQmdZbG4rK0J5WitaTy9YemwvcVcwaXZQbnFyNTBBVkNMbk5yOHNBQUdUek1MSDV6ditnN2RqbzJrZW1ERmZlcStVRWlFQUFaUE1HVjdzd2tiVHpFME5leERzaGN6TTdLS3N6cnl6TlZpZmFlYzI2N1h2UDd2cUxEQmdjdmhyajExNSt1UlNWbEczM25pTkVRMFFNSkVzYyt6S1V5OHVsZFowR1VjQ0VEQmhMSERzMXRFZkxjWE9PZTVtemZnUmdJQ0pZYThQdTVZUmxkd3pwajZ4QitqeXZXdEgvMjcxcVplOTRRVEdqZWNZdCtILy9OR2IyNE9aYURzelo1eVZVcnF1VktWNTZNdGxkYTFFZFBOemYvbEhyamd3SnJRKzNJWXEyL3V2dmkvM2pMbk1qT2k2ck00dTFXdnIzZnhjV2RVQUFlUERNNHpiY09MRVAxKzU1NEVtQnRsMnd4NEwreTh6SXFKRVZUUkF3UGl3aEhGN252bnBTalU5YUQ2NEVzWGttUXdDRURCZUxGN2NudU9MRjlzcm05MVdKL2xNRmdFSUdCZVdMVzdic1JlWDZrRnB0dEwzRFNlT0FBVDBud1dMMjNiOEo4dk5ka1k2ekhSU0NVQkFuMW1xdUJNLysrV0YzeXh2bGs3Mm1XQTNCYUJMYXhHUjl3dEF3S2l6U0hFblhqNjk5dlZIN3p0NmNxbVlRaFB1d3dBVVdicEhCQ0NnQnl4UDNJbk1mT25sdGZQdlhNbldleThpTXFOVUVaMEFCSXcrQ3hOMzZPbkZ0Wnk3cnpxN1BPeUJNRElFSUtBUExFbmNvYWRlem54dnBkcllya3FWcWZqaFF3SVFNTm9zUnR5NS8vVENiN3U2bmQ2ZUdmWkFHRDBDRURDcW5PSEZuZXZxZHRCT0ZSODM1Sk5LaWNqSWlGS3FzMHRsZFQzdm55dXJhMC8vM0ZsZ3dKQjVhSEZYZnZiTGk3OVozaWh0bWtwOHFzd29WYWtpMit3ZStYSlpYWXZVQUFGRFkrbmhybHo3bGZ2enk2b2ZkcUVJUU1EUVdYUzRLNW41MDM4OGYrNWlkdG1aVHV4T2xxb1NnSUJoc2R4d3Q3Ny83QnN6N2RWTFV3dk9jdWQyQ0VEQWNOam16TjJhYWE5ZW1YMmdxZ2JESGdqOVVyTExLRmt2dlZNdTJRUU5IQngvWTdFSC92UGZ2bGRtNnViUzFXRVBoSjdTQUFFSHgrTENIamkrZUxGZDI4eW1VeU55RndRZzRDQllWdGdieDU1ZHJySzBVNTBUdmJnN0FoQ3d2L3lSenQ2b3NuUjFXd1FmN3BZOVFNRCs4cmNVZStibnYzai96TGtyV2VwaEQ0U3hvUUVDOXA1RmhEM3p5cTh2UGZhMStXUFBML21WTzN1b1JJWUFCT3dkeXdkN0pqTmZlbm50bmVXMTZLcnc1b3M5SlFBQmU4WEN3VjU2ZW5FMTUrYnFjOHNwK2JBUGJnaEFUb01IN29nbGc3MzAxTXNaNzYxVUc5dWxWQ24rc0Q5S1pFU1ZLUUFCZDhKaXdSNzdxeGQrMjlidDlQYk1zQWZDZUNzbE9nRUl1QU4rM000ZWErdDJhbnU2U05Yc3I4d29HVkZLMW1mZkthdnJlZi9jdlJmWG52dmIxY1ZGZFNQd1dUeWYySHMvLy84dW5qbTNtYVV6dnpnUTF4cWdxdXIrMWR4WExteXNsbElXWnViKytJL05QK0FXTEEzc3ZWZisrOXBqZjNEZnNlZVh6UzhPVUNrbHMrdnF1Z2hBd0dld0tMRDNNdk9uLzNoKzZZTm91OVljNDJBSlFNRG5zQnl3TC83TGM3K1picTVjbWw0d3h4Z0dBUWo0VkxZNXN5K21teXVYWisvUDlLUmhLREl6b3RSZGx0Yy9PSGRwZTMxaFp1N0N4cXBOMEVENGk1ejljK3duNzlhelUrMEhWK1VmaGtvREJOekF6YzkrT2I1NHNWbS9HazBYUmJuSTBOMFFnTjdmV0kxU2ZrY0Fnb25rdG1jZlBmMmp0ek95cWdaTzlHSTBYQXRBWFYxK1h3Q0NTZVhQY2ZaUlJsYWxEaWRhTUNxdTdRR3Fzcnord2JuM3Q5ZC9aMmJ1L1kzVkg5b0RCSlBFM3pyc3I1Ly80c0piUzF0dGRNTWVDTnlrUk1uNHNBRzZzTG1XRVJvZ21BUnVjdmJYcTc5ZU8vdzFuemRrWkpVb1dVVTBKUVVnbUJCdWIvWlhacDU2ZWYzZDVjdHRsMkhMRHlNcE0wb1ZBaEJNQ0RjMisrN280bG8zZDE5MWRzbDhZNVFKUURBaDNOTHN1NmRlem5odnBkNXM0OW91VXhoZEFoQ01QVGN6QitHdlhueTdyWnJwcmVrb3Bodzk4SWtBdEI1UnZqaHpyd0FFWThDUDJ6a0liZFZNYlU4Vjg0MmVLQ1VpbysyaXl2S2IxZVdMbTFlL09IUHZoYzMxWi85MjNjL2dvZS84QmNNQitidGZYSHhyYWJQSnpxU2pYeklqU3RRbE1nYi9ldjZRQmdqNnpxM0xBZm5WcjlmKzBLL2M2UzBCQ01hR201WURrcGsvL2Evdm5MM1FaaWttSGowbEFNRVljTHR5Y0w3L3c5ZG51bzFMMHdzbUhyMG1BRUd2MlhiS3dabnBOcTdNM2wvUzQ0RitLeVZLUk50Rmw0MU4wTkE3SGtJY3FHZCs4bTQxTzlWYzJ2QmxaOGJESnhxZ3RZajRvdThBd1FoemMzS2dqaTllYk5jM3N1bDg0SWR4Y2wwQXluODkveFVCQ0VhWjI1S0RkdlQ1czZWa1JxMzNZY3pzZkt1OHJnUWdHR2x1U0E3YXNaTnZaMVFsSTAwL3hsU21BQVNqeTYzSUVQenNseGZPTEc5RjF3MTdJTENQQkNBWVRXNUNodUNWMDJ1UFBYcmZzWlBMd3g0STdEc0JDRWFOMjQ4aHlNeVhYbDQvLzg2VmJEcy85V0lTQ0VBd090eDRETWZUaStzNWQyOTUrMXdwUGk3RnBCQ0FZQlM0NVJpT3AxN09lRytsM213aklsUHh3d1M1UGdCZDNMcGNTand3NVV2UWNIRGNiQXpOWDczNGRsczEwOXN6d3g0SURFRm1WSFZkMStXclh6Z2tBTUZCOHE2Qm9XbXJadEFNeEc4bVV5bVJYZHRzTjIrc3ZYdXB1ZkxBMUwwWHR5Ny82UDl4RkFic080OGRodWxudjN6L3pOS1Y2R296a1FsWEtnMFFIQkMzRnNQMHl1bExqejA2NzFmdXNFTUFnZ1BncG1LWU12T24vM2grNlVLMDBacU5zRU1BZ24zbGRtTEkvc3V6djVsdXIzd3d2VkRNUnJqT3h3Rm9jNzFVUlFDQ3ZlSkdZc2hPblBqbnkvZmMzOFFnV3JzNzRXWWxvcDRhZlBVTGh5NXVySlhJQjJibkJTQzRTMjRoaHUrWm42NVUwNFBtZzZ2bUk5eFNpYWl6KytvRER3bEFjUGZjUEF6ZjhjV0w3ZHBXMXpTbE1pSGgxa29wa1NrQXdkMXoyekFTamoyN1hHZmRESnBoRHdSR21nQUVkODhOdzBnNC9zTjMyN3JOWXJzUGZENEJDTzZHVzRWUjhUZW5MbDdaM21xak1TMWhOd1FndUROdUVrYkZjejlaWDVpOTkvVVB6b1d6M0dIWEJDQzRYVzRQUnNYaVlwNWJmLzlxdTVGWkZSTVRib2NBQkx2bnhtQ0VISHQrdVpSQm05dm1KZHlCNndQUWhZMjFqUHdkQVFnK3dTM0JDSG5tNUVyWGJaZU05TW9MN3RST0FPcXkremNDRU55S200SFJjdlRaY3hFWnRld0RkeWVqbEJDQTRKTThZQmcxV1NyN25PR3VsY2lJRXRVYmw1YmYzMWo5bmRuNTl6ZldmdmlUUzR1TFBpSEJwUE1YQUNQbjczN3gvbHZucm02WDRrQlQyQnNaVVZmWk52L21nWWZlMzFnTERSQ1R6ZFJuNVB6cTE1Zis4R3Z6eDU1ZkNqLzBnajJTRVVVQWdvZ1FmUmhCbVhucTcxZVdMalVsU29SeUh2YU1BQVFoK2pDYWp2M2d0L1ZHMjN4eE5sTDBnVDEyVXdDNnNMRmVzaXpjYzY4QXhJU3duWlJSVkcrMHpmeTB2VDZ3SDBwRWxNaXVLMUc5dm5iK2c2dFhGdTY1OThMRytuTS9YcmNKbWtuZzBjS0lldnFGNVN4Wk9kRUw5bE5HVkJGWlZWVlQvcGVGMzlVQU1RbTBQb3lvTEZteVJHWDloWDIwczU4dXV5NnJWZ1BFaFBCY1lYUTkvZUw1cUtxeXZUM3NnY0JFMEFBeElVeG9SdGZUcDFiS2R1TkhYbkNRQkNER25xbk1TUHZCU3hldWJHMTBWWnFyY0pBRUlNYVlTY3hJZSs3SHF3djN6TDErYVhuWUE0RkpkRk1BT3IrMnRyMlZNOTM4dDc3bDJVR1BtYjZNdE1YRlBIZjV3a1o3dGVzcTMzYUdvYmd1QURWenpVT2IxVnFFQUVTUG1iaU11bU1ubDBzTTJ0dzJXV0dJZGdKUUtSRnRKd0RSYTZZc28rNlpreXRkdDExVjBkbnVETU1tQURFR1RGWjY0TmlQem1XWFVSY3pGa2FCQUVTdm1hYjB3TkZuejBaVlNsV2xJNzFnWkFoQTlKUUpTai84L0pjWHppeGQ3VEljN0FValJRQ2lkMHhOK3VHVjA2dVBQVHAzN0lXbFNKTVdSbzRBUkkrWWxQUkRadjc0SDFhV0x6V1p4ZmVkWVRUZEhJRHE5WXd5Mjk0ckFERlNURWQ2NDVtLytXMTF0VzBYWmdRZkdHVWZCYUF1NnZzM2YxY0FZdFE0dVozZXFLNjI3ZnhVcVV4YUdHazd4V3liRWRtdXpTeHZESzdNdHZkdTF1dC8vZXo2aVJQK2NtSDRaSEQ2NU9nTHkxM0pxaDMyT0lEZDJUbCtyOUlBTVVwTVB2cmtxUmVYcWk3dGRJWitFWUFZS2FZZFBYUHMrWE9sUkNmOVFOL2NGSUEyNnZVUWdCZ0dFNDZlZWVia3VTNTNGbEd6Ri9wbkp3Q1ZxTElVQVlpaE1OWG9ueCs4ZEdHOTJmaHdDUVg2NnJvQXRCYVJzNjN2QUhFUVRETDY1OW1mckg1eGR1NzFENWJOWHhnREphb3MyL2R2UGl3QWNUQk1ML3BuY1RIUHJWKzQwbXhGcExkZU1CNEVJQTZNaVVVdkhYMytmRldxcnRzMmhXR2NDRUFjQUZPS1hucm01RXJYTlJFUnhSZlNZTndJUU93cms0bStPdnJjdWNqTXF2TE9DOGFTQU1RK2NTWUF2WlVaVlZVRUh4aFRHVjFrdlRwOWZuTndhYmFkMzZqWC92clpTNDdDNE81NWJOQmpQL3ZGQjI4dWIzVzVYY3hrR0dzYUlQYVFxVU9QdlhKNi9iRkg3ejM2d3JJTlB6QUpCQ0QyaEVsRGoyWG1xWDlZV1ZwdFN4Y1I0ZzlNaE9zQzBHcEVDRURjTHRPRmZqdjJOMi9YVjV0bVlXYllBd0VPVGlrbHNzdlNDVURjQWR1YzZiZjZhdFBNVDVWSzVRTVRKSFBuR0wvQjZ2VFM1bUIxdHAzZnFGZHRnbWFYWkdSNjcra1h6bVVwcFRXYlllS1VpTkFBY1p0TURucnZxUmVYb3N2U1pTbGFUSmhFQWhDM3hiUmdIRHgxOGx4VXBXcUhQUTVnZUFRZ2RzbUVZQnc4OWVKUzZhS0VuM25CcFB0RUFGckxLUGUwOXdsQWZNUlVZRXo4NE5TRnk4M0d6dWJIWVk4RkdMS1BBbEFiOWNMV2x6YnE5WXdRZ05oaEVqQW1udjNiMVMvT3pMMXhhVm52QSt3b0VWbEtWVXJUaFFERVIxeCt4c1RpWXA2N2ZQRnFzNVhaT2RjTCtJZ0F4RTFjZU1iSHNlZlBsMUsxdWVWSUwrQW1BaEFmY2NrWkg4K2NYT202N1ZKSzJ1ME0zTW9uQXBCTjBKUEl4V2FzSEgzdVhHUkdYZnV0Ri9CcGRnSlFsSzdyYWdGb0F2a0VIT01sTStyS1hoL2dNMlJFWkVZWFZjbExzMHRYNnl2M3RQZHQxS3YvbDZNd0pvTkhCT1BtWnk5Zk9QUE9SalpweHcrd0N4bWxpdEoxWGJldzlmQkd2Wm9SOS9nUTRsaHphUmszcjd5Mit0anZ6eDA3dVR6c2dRQTlrcEVSZFFoQWs4QkZaZHhrNWsvK2Z1WDhwYmFKc09NSHVCMEMwRVJ3T1JsRHgzL3dkbXcwelFNekpqaHcrd1NnTVdlYk0rTm9vMm5tcG9ZOUNLQ25TcFFTWFZSWlhacGR1bHF2M3RQTzJ3UTlUbVJZeHRQVEo1ZXlpcnIxeGd1NEd4cWdNZVRpTVo2ZWVuR3B0T1kzc0NjRW9MSGlzakcyanY1b0tkSkxYV0N2M0JpQUJtdWxsSmx0SDBMc0g0OEZ4bGRHS1ZHODhnTDJ4ZzE3Z0xhbXI4eHMzN2N4V1B2K2o5YnNBZW9YV1pWeDluK2Z1bmkxMmQ3T2JWTWQyRk1aVVVYVmxhcWV2L0lsRFZDL2FIMFlaOVAxMUwrY1B5VDNBSHV0UkdSMEpadjhxQUdLUThNZUZMc2orakRPSHBpNTk5MnJsNXhvQWV5YnpEYWl5ZmpmSWphSFBSWjJSL1JobkYzWXZQeTc5OXlmMFExN0lNRFlxcW9TSmVPL1I4d01leWpzanVqRE9OdHF0OTlZWGZIQ0M5Z1BwVVFwTWIvNTVabm12czE2TFZhR1BTQjJ4eU9Cc1hYczFGSTI1ZHJ2VVFIMlRpa1JFZk9iWDk2czF5SmlwcDJ6d2JsSEJzTWVBT3lYYkxNTUlyZUhQUTVnTE9ST3pSTVJINGFlelhwTjZPa2pGNHp4OU9STGI5VmRYYnBpanpOd2wzWkNUMlFWZys3K0s1cWUzdFA2TUo2cXJOdXFIWFFPTVFYdTNMV21KNnVvdS91dmZHbWpXOStZV3B2ZEZucjZ6Y1ZqREIwL2ZxYVpIOFQwVkxSKzJ3WGNpWnVhbm8zQmVwUVVlc2FEMW9jeDFNM1dnOVdtWFJqWTN3emNMazNQMkJOOUdEZEhqdVRHNXNyMFFoUFpYZnNaQnNBdUNEMFRRdlJoM013L2VHWGx6VU1QSFY3MlBoZllKYUZub29nK2pKdkI3UFlqaDkvcklrVWY0SE5sUkdTVUl2Uk1FSmVXc1hMMDVQbklEQ2RYQUovbjQ5QVQzZjFiTmpKUEVLMFBZeVd6SzZYeStXYmdNM3djZWtwMy85YVhOdXIxalhwdHRoRjZKb1hMelBoNDRzUzdnMEViVmRhbFpJby93TTF1Ym5ycTlZaWM5WEhDQ2FQMVlYd01CdEUwOWZSVTQ5UXU0Qk5LWnQ3YzlBZzlFOGtsWjB3c0x1Ylp0WXRiMFhSZE0reXhBQ05sSi9SRVJHaDZDSzBQWStQQzV1V0g1eFpldjdRazBBTWYyZ2s5V2NwTzZGblQ5QkNpRDJOanE5MStZM1ZGN2dFaVltY3BLRkdpcE5ERFRVd0N4c0d4VTB2WmxBaWJmSUJyb2FkMDNWenovMjdVWDQ4NEpQUndQYTBQNHlEYkxJUEk3V0dQQXhpbTYwUFBQMjVXdjdkWi9kNXMrOHEzdnZXdFlRK00wU0lGMDN0UHZ2UlczZFdsSzhWOGhnbDFROU96V2YxZVJNeDB2eFY2dUNXdEQ3MVhaZDFXN2FDYkd2WkFnSU4zaTZaSDZPR3orU3VaZmp0Ky9Fd3pQNGpwcVdnZFhnRVRSZFBESGRMNjBHL2RiRDFZYmRxRmdmM05NREUwUGR3VnJRODlkdVJJSHZycXl2UURUV1JHTVpsaElwU29ORDNjRGEwUFBUYi80SldWTnc4OWRIaFppSWNKVVVvOXYva1BtaDd1aHVoRGp3MW10eDg1L0Y0WEtmckEyTnNKUFJ2MTcyM1cvM0ttZlV2bzRZNTVZTkJYUjArZWo4d0l1NXRoekgwVWVrb1VvWWU3cC9XaHJ6SzdVaXFmYjRZeGRuM1RNeXYwc0VlMFB2VFNFeWZlSFF6YXFMSXVKVlA4Z1hHajZXSC9hSDNvcGNFZ21xYWVubXFjMmdWalJ0UERmdFA2MEQrTGkzbDI3ZUpXTkYzWERIc3N3QjRvcFdTbXBvZURvZldoZnk1c1huNTRidUgxUzB1eU8vUmR1ZmJPdXJ0LzY1ODBQUndNMFlmKzJXcTMzMWhka1h1ZzEyNE1QWTlzMW8vTXRyN1R3MEh3OEtCbmpwMWF5cVpFMk9RRGZmWGg2NjJjMy95bmpmcVJFakhUdmkzMGNHQzBQdlJNdGxrR2tkdkRIZ2R3KzBvcEVUYzFQVUlQQjAzclE1ODgrZEpiZFZlWHJoUlRGM3JsdzlDVDg1di90RmsvRXBvZWhrZnJRNTlVV2JkVk8raW1oajBRWUxjK2FucDJRczltL1lqUXczRDUwNW5lT0g3OFRETS9pT21wYUIxZUFUMVFydjFMMDhObzBmclFHOTFzUFZodDJvV0IvYzB3NG5aQ1Q1VjVuNmFIMGFQMW9SK09ITWxEWDEyWmZxQ0p6Q2ptTFl5b2owUFAxajl0MW8rVWlHbWhoeEdqOWFFZjVoKzhzdkxtb1ljT0w4dnJNSnB1YW5xMk5EMk1LdEdIZmhqTWJqOXkrTDB1VXZTQlVTUDAwQytlSXZUQTBaUG5JelBDN21ZWUxWNXYwVWRhSDNvZ3N5dWw4dmxtR0JIbHcvK2g2YUdQdEQ2TXVpZE92RHNZdEZGbGZlM0VIMkJvU2tRWFVXVlVSZE5EWDJsOUdIV0RRVFJOUFQzVk9MVUxobWduOUVTSnlKemYvcWZOU3RORFgybDlHR21MaTNsMjdlSldORjNYREhzc01LRjJRazhwa1psTDMvaktsLzd4Ti9ldXZPdnNMZnBMOUdHa1BmdTM2MStjdWZmMVMwdm1LaHk4bTBMUDNPbTFpRmo3MnR3UjM5YWl6N3p3WXFSdHRkdHZySzdJUFhEQXJuKzlkZTd4cjh5ZFhwczd2U2IwTUI1TVlrYlhzVk5MMlpRSW0zemc0R2g2R0h0YUgwWlh0bGtHa2R2REhnZE1CazBQRThLRVprUTkrZEpiZFZlWHJoU3pGUFpaaWNoU0lsTFR3eVRRK2pDaXFxemJxaDEwVThNZUNJeXpuZENUa1ZWVnZmMG52NnZwWVJLWTNJeWk0OGZQTlBPRG1KNksxdUVWc0M4eW9wUVNrVlZWdi8wbnZ6di8ybnFVc3ZyNzl3bzlqRDJ0RDZPb202MEhxMDI3TUxDL0dmYmNUdWdwSHpZOTg2K3R6LytQeTZ1UDNpZjBNQ0ZNZEViT2tTTjU2S3NyMHc4MGtSbldZbmJ4c3lvQUFCU0ZTVVJCVk5nN21oNElyUThqYVA3Qkt5dHZIbnJvOExKb0RudEYwd01mRVgwWU9ZUFo3VWNPdjlkRmlqNXc5NFFldUltcHoyZzVldko4Wk81OFhnUzRHMTV2d1MxcGZSZ3RtVjBwbGM4M3c5M0lpSktsVkpvZXVBVzNBU1BraVJQdkRnWnRWRm1Ya2luK3dHM2JDVDFSWmR0MjcvejdoelE5OEVsYUgwYklZQkJOVTA5UE5VN3RndHYxVWRQVGR1MDdqejkwMyttMSszNjl1dm9IODBJUDNNUXR3YWhZWE15emF4ZTNvdW02WnRoamdUNjVxZW01Ny9SYVpLNExQZkFwdEQ2TWlndWJseCtlVzNqOTBwSkVEcnRXSXVPbXBrZm9nYzhtK2pBcXR0cnROMVpYNUI3WW5SSVpwZTZhSm9VZXVDMXVFa2JDc1ZOTDJaUUltM3pnYzEwWGV2NzlRM09uVnpORDZJSGQwL293RXJMTk1vamNIdlk0WUtTVkVoRlYxelQ1enA4K05IZDY5YjVmcjY0SlBYQ2IzREFNMzVNdnZWVjNkZWxLTVNIaDFxNkZudHl1ei8zWmx6UTljRGUwUGd4ZmxYVmJ0WU51YXRnRGdSRjBYZWo1eGxmbVRxL04vWHBkMHdOM3c4M0RrQjAvZnFhWkg4VDBWTFFPcjREcjNkVDByRVdXdFQvd1JXYTRXMW9maHF5YnJRZXJUYnN3c0w4WlBuVExwbWRPNklFOTRVWmltSTRjeVVOZlhabCtvSW5Nc0t5RHBnZjJuOWFIWVpwLzhNckttNGNlT3J3c2hVT0pvdW1CQXlENk1FeUQyZTFIRHIvWFJZbytUTFlTcGN1bUVucmdBTGkxR0pxako4OUhab1RkelV5eUVxV3JzLzcyTjc3MDNPbTFONzNlZ3YybjlXRm9NcnRTS3A5dlpsTHRoSjdxMjQ5LzVkWFRhNzg2dmY1blg1c3JRZy9zUDdjWncvSEVpWGNIZ3phcXJFdkpGSCtZS0I4M1BhK2VYaXRSRG4vdFBxRUhEb3pXaCtFWURLSnA2dW1weHFsZFRKS2JtNTdITkQxdzROeHlETUhpWXA1ZHU3Z1ZUZGMxd3g0TEhBeE5ENHdLclE5RGNHSHo4c056QzY5ZldoSyttUUNhSGhndG9nOURzTlZ1djdHNkl2Y3c3akpLQ0Qwd2F0eUVITFJqcDVheUtSRTIrVERHTWtwMFdmK0YxMXN3ZXJRK0hMUnNzd3dpdDRjOUR0aHJtVkhLaDZIbjhTKzljbnJ0bGRQclg5ZjB3SWh4UTNLZ25uenByYnFyUzFlS3VjY1kyUWs5VmFtYUxIL3hqUys5Y25vdG9ueGQwd01qU2V2RGdhcXlicXQyMEUwTmV5Q3dOM1pDVDExVlRWYmZlL3hMcjU1ZTEvVEFpSE56Y25DT0h6L1R6QTlpZWlwYWgxZlFlemMxUGErZVhzOElUUStNUHEwUEI2ZWJyUWVyVGJzd3NMK1pYdnVVcGtmb2dYNXdvM0pBamh6SlExOWRtWDZnMlhsdURIczRjQ2QySm05VmlxWUgra3Zyd3dHWmYvREt5cHVISGpxOExIRFRSenVocDY1S2R2R2RienlvNllIK0VuMDRJSVBaN1VjT3Y5ZEZpajcweXlkRHo2dW4xeDhUZXFDMzNMb2NoS01uejBkbWhOM045TWxIcjdleWkrOSs4OEZYVDY5SGhOQURmYWYxNFNCa2RxVlVQdDlNZjJSRTBmVEFXSElicysrZU9QSHVZTkJHbFhVcG1lSVBJeTRqU2xVeXUwclRBMk5KNjhPK0d3eWlhZXJwcWNhcFhZeTJuZEFUMlpYdmZPUExyNTVlMC9UQVdISkxzNzhXRi9QczJzV3RhTHF1R2ZaWTROTmtSRlFsUG14NjFpS0swQVBqU3V2RC9ycXdlZm5odVlYWEx5M0oyWXlrajBKUDk1MXZQUHhoMCtNWUNoaG5vZy83YTZ2ZGZtTjFSZTVoOU53VWVsWmZQYjM2Mk5mbWhSNFllMjV5OXRHeFUwdlpsQWliZkJncEg0ZWU3Mzd6NFZkUHIwYUUwQU9UUSt2RFBzbzJ5eUJ5ZTlqamdHczBQWURXaDMzejVFdHYxVjFkdWxKTU00WlAwd05jby9WaHYxUlp0MVU3NkthR1BSQW1uS1lIdUlHYm4zMXgvUGlaWm40UTAxUFJPcnlDWWNsU1NtU0piRFE5d0VlMFB1eUxiclllckRidHdzRCtab1poSi9SVWRZbi84UGlEcjU1ZTAvUUFIN0VRc1BlT0hNbERYMTJaZnFDNWR2d2pISnhyVFU5ZHhYLzQwd2QvOWRwNmlmakRSMzJjRVBpWTFvZTlOLy9nbFpVM0R6MTBlRm0yNWdEZDBQVDg2clgxLy9iYSttR2hCL2dFMFllOU41amRmdVR3ZTEyazZNT0JFSHFBMjJCcFlJOGRQWGsrTWlQc2J1WUFlTDBGM0RhdEQzc3NzeXVsOHZsbTlwbW1CN2hEbGduMjBoTW4zaDBNMnFpeUxpVlQvR0UvWkdRcFJkTUQzQ0d0RDN0cE1JaW1xYWVuR3FkMnNTOHlTcWxLbGQvUjlBQjN5cExCbmxsY3pMTnJGN2VpNmJwbTJHTmg3R1NVVWtySjd6eis1VmRQcjVVU2h4K2RFM3FBTzZEMVljOWMyTHo4OE56QzY1ZVdSR3IyMGs3b3FmSTdqei80NnVtMVg3MjI5dGpYaEI3Z3pvays3Sm10ZHZ1TjFSVzVoejBqOUFEN3dDTEMzamgyYWltYkVtR1REM3ZCNnkxZzMyaDkyQnZaWmhsRWJnOTdIUFNkcGdmWVp4WVU5c0NUTDcxVmQzWHBTakdqdUdPYUh1QkFhSDNZQTFYV2JkVU91cWxoRDRSZUtoRVJtaDdnZ0ZoY3VGdkhqNTlwNWdjeFBSV3R3eXU0UFR1aHB5bjVsNW9lNEtCb2ZiaGIzV3c5V0czYWhZSDl6ZXplZGFIbndWZE9yNzM4MnRvZmFYcUFBMkdoNGE0Y09aS0h2cm95L1VBVG1lRzV4UzZVaUN5bGpmekx4Ny84eXVtMUxQRkhtaDdnQUdsOXVDdnpEMTVaZWZQUVE0ZVh4V2crMTA3b2FTTC84dkVIWDNsTjB3TU1oK2pEWFJuTWJqOXkrTDB1VXZUaE05d2k5R2g2Z0NHeDlIRG5qcDQ4SDVrUmRqZnpxVzU0dmZYYVdvYlhXOENRYVgyNGM1bGRLWlhQTjNOTG1oNWdORm1HdUVOUG5IaDNNR2lqeXJxVVRQR0hqKzJFbnFnSDMvdDMvMExUQTR3YXJROTNhRENJcHFtbnB4cW5kdkdSbmRDVDllQjcvKzVmdlByYTVWZi94NVd2Q3ozQWlMRWtjU2NXRi9QczJzV3RhTHF1R2ZaWUdBblhOejJ2dm5ZNVNubnM5NzhnOUFBalNPdkRuYml3ZWZuaHVZWFhMeTFKejN5eTZYbnMwWHVGSG1Ca2lUN2NpYTEyKzQzVkZibG53cFdJekM2blpvUWVvRWNzVXR5Mlk2ZVdzaWtSTnZsTXJwM1FFOWRDejNxVXl1c3RvQyswUHR5MmJMTU1JcmVIUFE2R0lUT2lpcWluZGtMUHEvL2p5bU9QM2lmMEFEMWl3ZUwyUFBuU1czVlhsNjRVazJmQzdJU2Uwc1gzdnZubFYxNWJMNW9lb0orMFB0eWVLdXUyYWdmZDFMQUh3c0c1Rm5veXZ2ZjRsMTg1dmZicTZiV3ZPM3NMNkMyTEY3ZmgrUEV6emZ3Z3BxZWlkWGpGUkxpaDZUbTlWaUllRTNxQW50UDZjQnU2MlhxdzJyUUxBL3VieDU2bUJ4aFhGakoyNjhpUlBQVFZsZWtIbXNnTWo4RHhwZWtCeHB2V2g5MmFmL0RLeXB1SEhqcThMREdQcDUyUEZXaDZnSEVuK3JCYmc5bnRSdzYvMTBXS1B1TW1JMHBrZENVcW9RY1llNVkyZHVYb3lmT1JHV0YzODNqWkNUM1pEZXJ5N1QvOWl0ZGJ3Q1RRK3JBcm1WMHBsYzgzajQ4UG01NUJWYjc5cHcrOWVucjFWNjlwZW9DSllKbmo4ejF4NHQzQm9JMHE2MUl5eForZXU3SHBlZlgwYWlubDhLTkNEekFwdEQ1OHZzRWdtcWFlbm1xYzJ0VnZ0MnA2SHZ2YXZOQURUQlJMSHA5amNUSFBybDNjaXFicm1tR1BoVHVsNlFINGtOYUh6M0ZoOC9MRGN3dXZYMW9TbEh0SjB3TndJOUdIejdIVmJyK3h1aUwzOUU5bWxDTDBBTnpFSXNobk9YWnFLWnZ5NGRmdTZJa1BQN2ZkdGZrWGYrYjFGc0FOdEQ1OGxteXpEQ0szaHowT2Rta245SlN5RTNwZStmWGFLNzllKy9vZmFIb0FQbVpCNUZNOStkSmJkVmVYcmhUelpQVGQyUFM4OHV1MWlQajZIMmg2QUc2bTllRlRWVm0zVlR2b3BvWTlFRDdUclpzZW9RZmcxaXlPM05yeDQyZWErVUZNVDBYcjhJcFJwZWtCdUgxYUgyNnRtNjBIcTAyN01MQy9lUlJwZWdEdWxJV1NXemh5SkE5OWRXWDZnZWFqWG9GUmtSbFZpZFQwQU53aHJRKzNNUC9nbFpVM0R6MTBlRms0SGlFN29TZEtpZnp1TnpROUFIZEk5T0VXQnJQYmp4eCtyOXY1RWpERFZpS3l4RWVoNTlYVGE2KytKdlFBM0NGTEp6Yzdldko4WkViWTNUeDhPNkduS3BHWjMzMzhLNitlWG9zU2ovazRJY0JkMFBwd3M4eXVsTXJubTRkckovU1VFcEg1blQvOXlxdXZyYjM2MnRwalh4TjZBTzZXWlpRYlBISGkzY0dnalNyclVqTEZueUc0dWVsNWJTMUMwd093WjdRKzNHQXdpS2FwcDZjYXAzWWR2RnMzUFVJUHdKNnlwUEt4eGNVOHUzWnhLNXF1YTRZOWxzbWk2UUU0TUZvZlBuWmg4L0xEY3d1dlgxcVNpUS9NVHVqSmpNRmc4Qi8rN1NGTkQ4QitFMzM0MkZhNy9jYnFpdHh6TUs0UFBWM2IvZDZYcHY3Yi83d3M5QURzTjlHSGE0NmRXbHB2TnNJV240T1FVY3BIb2FkcnU2cXUvdmMvV2hqMnFBQW1ndWpETmRsbUdVUnVEM3NjWXk2amxCS2x2aTcwZlB2Zi9lNndSd1V3UVZUclJFUTgrZEpiZFZlWHJoUlRZci9zaEo2b0I0T3U2eUtpcW9RZWdDSFEraEFSVVdYZFZ1MmdteHIyUU1iU2RVMVAxM1ZkSi9RQURKSG9ReHcvZnFiWnlucDZ4dUVWZXkwalNpbENEOEFJRVgySWJyWWVyRGJ0d3NBTzU3MXpMZlIwWFZkS0pmUUFqQTdSWjlJZE9aSWJteXZUQzAxa0YzNVd2UWMrRGoyWjEvNlh2L2pHVjRZOUtnQ3VFWDBtM2Z5RFYxYmVQUFRRNFdWNzN1L2F6YUVuTS8vOG13OFBlMVFBM0VEMG1YU0QyZTFIRHIvWFJZbytkMEhvQWVnTlQ3dUpkdlRrK2NpMHUva3VsUkpkMTBXVVVpSXovK0xmQ3owQW8wdnJNOUV5dTFJcUgzQytZNWtSb2VrQjZCUFJaM0k5Y2VMZDdOcXMycnFVVFBIbk5wUVNYUmNSWFVUWk9ZeEw2QUhvQzlGbmNnMEcwVFQxOUZTVGFwOWQyd2s5VlYyWGJETkxoTmRiQUQxanI4K0VXbHpNczJzWHQ2THB1bWJZWSttSG5kQlREK3JzdW95b3F1cTdmL3FsWVE4S2dOdW05WmxRRnpZdlB6eTM4UHFsSmZIM2MzM1U5RlJ4N1l2TTN4TjZBSHBMOUpsUVcrMzJHNnNyY3M5bkUzb0F4bzhuM3lRNmRtb3BteEpoazgrbjhub0xZRnhwZlNaUnRsa0drZHZESHNkSTB2UUFqRGV0ejhSNThxVzM2cTR1WFNtdS9vMUtpY3lvYWswUHdEalQra3ljS3V1MmFnZmQxTEFITWtKS1JwWW9WUjFkbDExWE5EMEE0MHYwbVN6SGo1OXB0cktlbm5GNHhZNXJvU2U3S05WTzZOSDBBSXczMFdleWRMUDFZTFZwRndiMk4zOGNlckprS2FYcnZ2dG5QazRJTVA1RW53bHk1RWh1Yks1TUx6U1JYWlRKM2VoemMrakovSzR2TWdOTURORm5nc3cvZUdYbHpVTVBIVjZlMk8zdFFnOEFvczhFR2N4dVAzTDR2UzV5QXFPUDBBUEFqb2w3QkU2c295ZlBSK2JFN1c0dXBYU1pKYXF1eXloUm9tVGEwd013eWJRK2t5S3pLNldhb004MzczeWxKMVBUQThEMXRENFQ0WWtUN3c0R2JWUlpsNUk1N3ZGbkovUkVSR21qS3lXS3BnZUFqMmg5SnNKZ0VFMVRUMDgxWTM1cTE0ZE5UNVEyc2tTV3FQSjczeEI2QVBpWTFtZjhMUzdtMmJXTFc5RjBYVFBzc2V5YjY1dWVMQkVSSmYvOEc0OE1kMUFBakNDdHovaTdzSG41NGJtRjF5OHRqV2ZTL1dUVEkvUUE4T2xFbi9HMzFXNi9zYm95aHJsSDZBSGc5bzNkNDVBYkhUdTFsRTJKR0s5TlBsNXZBWENudEQ1akx0c3NnOGp0WVk5anIreDhqbEhUQThDZDB2cU1zeWRmZXF2dTZ0S1ZNZ1lYT2lOS2xNZzY2amJhakJSNkFMZ0RXcDl4Vm1YZFZ1MmdteHIyUU83T1R1Z3BXVWZkUmRkRlYwZjk3VzgrT094aEFkQkxvcy9ZT243OFRMT1Y5ZlJNancrditFVG9xYUlTZWdDNEc2TFAyT3BtNjhGcTB5NE1lcm0vV2VnQllIK0lQdVBweUpIYzJGeVpYbWdpdXlpOTJ1Z2o5QUN3bjBTZjhUVC80SldWTnc4OWRIaTVUenZaaFI0QTlwL29NNTRHczl1UEhINnZ1L1piOEpHWFVVcUowZ2s5QU95M1Bqd1h1VTFIVDU2UHpIN3NidDRKUGRHMVVkZVJKVkxvQVdCZmFYM0dVR1pYU2pYcW4yL09LS1YwcGV1aUtsR1Y2TnFvL3ZLYlh4NzJzQUFZYzFxZmNmUEVpWGNIZ3phcXJFdkpITW40c3hONm9zdW9kMDdoaXFqK1V0TUR3SUhRK295YndTQ2FwcDZlYWtieDFLNGJtNTZJTGpVOUFCd3NyYzlZV1Z6TXMyc1h0NkxwdW1iWVk3bVJwZ2VBMGFEMUdTc1hOaTgvUExmdytxV2xFUXExbWg0QVJvbm9NMWEyMnUwM1ZsZEdKZmNJUFFDTW50RjRScklYanAxYXlxWkVqTUFtbnc5ZmIxV0R1bXN6MCtzdEFFYUYxbWQ4Wkp0bEVMazk1R0dVS0YzcHlxQXFYWlZkVjlYVjkvNUUwd1BBcU5ENmpJa25YM3FyN3VyU2xUSzhhMXFpdE5uVlUzVjJHWkdscXI3M0o1b2VBRWFMMW1kTVZGbTNWVHZvcG9ieVQvOHc5RlJWVzNXdHBnZUEwU1g2aklQang4ODBXMWxQenh6ODRSV2ZERDEvTHZRQU1NSkVuM0hRemRhRDFhWmRHQnprL21haEI0QStFbjE2NzhpUjNOaGNtVjVvSXJzb0I3SFJKeU15VStnQm9JOUVuOTZiZi9ES3lwdUhIanE4ZkFDYjFxK0ZucXk3cWhONkFPZ2owYWYzQnJQYmp4eCtyNHZjMStqemNlaUpyb3V1NnFydi9abGZid0hRUDM3YzNtOUhUNTZQekgzZDNYeDk2SW1JS29RZUFIcE02OU52bVYwcDFUNTl2amtqU2lsVlc2NDFQVUlQQVAybjllbXhKMDY4T3hpMFVXVmRTdVpleHArZDBGUGFraVVqb21RUmVnQVlEMXFmSGhzTW9tbnE2YWxtRDAvdCtxanB5WkpaVXVnQllNeG9mZnBxY1RIUHJsM2NpcWJybXIzNXYxaEtSR2g2QUJodldwKyt1ckI1K2VHNWhkY3ZMZTFCZmkwbElySkU2VUxUQThCNEUzMzZhcXZkZm1OMTVXNXp6NGVoSnpJaUk2djRpOGQ5cHdlQWNlYUZWeThkTzdXVVRZbTRpMDArMTRlZWlDaENEd0FUUWV2VFM5bG1HVVJ1My81L3MxejcxMGROajlBRHdFUVJmZnJueVpmZTZyb3MyMUZ1cTdTN0ZucTZMRVhvQVdCaWlUNzlVMlhkVnUyZ205cnRmK0dHMEZNaU0wb1JlZ0NZVEtKUHp4dy9mcWJaeW5wNlpsZUhWNVRZMmNzajlBREFEdEduWjdyWmVyRGF0QXVEejluZi9ISG9xU0pUNkFHQUhhSlBueHc1a2h1Yks5TUxUV1MzOHhPdFd4QjZBT0RUaVQ1OU12L2dsWlUzRHoxMGVQbldYeVVRZWdEZzg0ZytmVEtZM1g3azhIdmR6cSt6cmlmMEFNRHUrS1JoYnh3OWVUNHliN0c3dVZ3WGVpS0VIZ0Q0REZxZjNzanNTcWx1K0h4enlaSlZWNHFtQndCMlNmVHBoeWRPdkp2WlpyUjFLWm01Y3c1RlYwcGVPMjlVNkFHQVhSRjkrbUY2WnJDMUdkTXoyNW1sUktraTJvaVNrYVg4dWRBREFMc20rdlREVk5mTTNIL1AxdFdtaXVnaU1xS08rTTQzaEI0QXVEMmlUejlNVjJWdzZZT2NubXFpcTZKODU1dENEd0RjQ2RHbkh3YWJHeEZ4ejliMnQ3NzF5TERIQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIzNmY4SHVHQ01rVWdYY000QUFBQUFTVVZPUks1Q1lJST0iIGhlaWdodD0iNzY2IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCBtZWV0Ii8+PC9nPjwvZz48L2c+PC9nPjwvcGF0dGVybj48Y2xpcFBhdGggaWQ9ImI4MDRiZjUzZDEiPjxwYXRoIGQ9Ik0gMCA2NTUuNjQ4NDM4IEwgODg4LjYxMzI4MSA2NTUuNjQ4NDM4IEwgODg4LjYxMzI4MSA4NDQuMzQ3NjU2IEwgMCA4NDQuMzQ3NjU2IFogTSAwIDY1NS42NDg0MzggIiBjbGlwLXJ1bGU9Im5vbnplcm8iLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0iODljMmIzMTA1YSI+PHBhdGggZD0iTSAwIDAuNjQ4NDM4IEwgODg4LjYxMzI4MSAwLjY0ODQzOCBMIDg4OC42MTMyODEgMTg5LjM0NzY1NiBMIDAgMTg5LjM0NzY1NiBaIE0gMCAwLjY0ODQzOCAiIGNsaXAtcnVsZT0ibm9uemVybyIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSJmN2RiYjdmNGYyIj48cmVjdCB4PSIwIiB3aWR0aD0iODg5IiB5PSIwIiBoZWlnaHQ9IjE5MCIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSJjZjUxMmZiNDI1Ij48cGF0aCBkPSJNIDY4MSA5NzYgTCAxNTAwIDk3NiBMIDE1MDAgMTUwMCBMIDY4MSAxNTAwIFogTSA2ODEgOTc2ICIgY2xpcC1ydWxlPSJub256ZXJvIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9IjAyZjhjZjdiM2MiPjxwYXRoIGQ9Ik0gNjgxLjYzNjcxOSAxMzMxLjMwODU5NCBMIDEzODcuMjU3ODEyIDk3Ni4wMjczNDQgTCAxNTAwIDExOTkuOTM3NSBMIDc5NC4zNzg5MDYgMTU1NS4yMjI2NTYgWiBNIDY4MS42MzY3MTkgMTMzMS4zMDg1OTQgIiBjbGlwLXJ1bGU9Im5vbnplcm8iLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0iOGQ0Njk3NGJmOSI+PHBhdGggZD0iTSAwLjYwMTU2MiAwIEwgODE5IDAgTCA4MTkgNTI0IEwgMC42MDE1NjIgNTI0IFogTSAwLjYwMTU2MiAwICIgY2xpcC1ydWxlPSJub256ZXJvIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9IjkwNWMwZjdkNWEiPjxwYXRoIGQ9Ik0gMC42MzY3MTkgMzU1LjMwODU5NCBMIDcwNi4yNTc4MTIgMC4wMjczNDM4IEwgODE5IDIyMy45Mzc1IEwgMTEzLjM3ODkwNiA1NzkuMjIyNjU2IFogTSAwLjYzNjcxOSAzNTUuMzA4NTk0ICIgY2xpcC1ydWxlPSJub256ZXJvIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9IjhhOWM3ZWE5YzEiPjxyZWN0IHg9IjAiIHdpZHRoPSI4MTkiIHk9IjAiIGhlaWdodD0iNTI0Ii8+PC9jbGlwUGF0aD48L2RlZnM+PHJlY3QgeD0iLTE1MCIgd2lkdGg9IjE4MDAiIGZpbGw9IiNmZmZmZmYiIHk9Ii0xNDkuOTk5OTkzIiBoZWlnaHQ9IjE3OTkuOTk5OTIiIGZpbGwtb3BhY2l0eT0iMSIvPjxyZWN0IHg9Ii0xNTAiIHdpZHRoPSIxODAwIiBmaWxsPSIjZmZmZmZmIiB5PSItMTQ5Ljk5OTk5MyIgaGVpZ2h0PSIxNzk5Ljk5OTkyIiBmaWxsLW9wYWNpdHk9IjEiLz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwLjAwMDAwMDAwMDAwMDExMjg2MSkiPjxnIGNsaXAtcGF0aD0idXJsKCNhMzQ1NGJhZWU5KSI+PGcgY2xpcC1wYXRoPSJ1cmwoI2Q0ZGMxYjdjNGUpIj48cmVjdCB4PSItMzMwIiB3aWR0aD0iMjE2MCIgZmlsbD0iIzliYjBlNiIgaGVpZ2h0PSIyMTU5Ljk5OTkwNCIgeT0iLTMyOS45OTk5ODUiIGZpbGwtb3BhY2l0eT0iMSIvPjwvZz48L2c+PC9nPjxnIGNsaXAtcGF0aD0idXJsKCMwMWRlZmRjZGMyKSI+PGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMSwgMjM0LCAyMzQpIj48ZyBjbGlwLXBhdGg9InVybCgjMGUzMWZjMDUyYSkiPjxnIGNsaXAtcGF0aD0idXJsKCM2MjgyNTY1YTg1KSI+PHBhdGggZmlsbD0iIzE3MWUzMSIgZD0iTSAwLjM3MTA5NCAwLjM3MTA5NCBMIDEwMzEuNjI4OTA2IDAuMzcxMDk0IEwgMTAzMS42Mjg5MDYgMTAzMS42Mjg5MDYgTCAwLjM3MTA5NCAxMDMxLjYyODkwNiBaIE0gMC4zNzEwOTQgMC4zNzEwOTQgIiBmaWxsLW9wYWNpdHk9IjEiIGZpbGwtcnVsZT0ibm9uemVybyIvPjwvZz48L2c+PC9nPjwvZz48ZyBjbGlwLXBhdGg9InVybCgjODQzYzVhMzE4MikiPjxwYXRoIGZpbGw9InVybCgjYmVlMTM2YWRjMykiIGQ9Ik0gNTU3LjAwMzkwNiAzNjcuNSBMIDEzMjIuMDAzOTA2IDM2Ny41IEwgMTMyMi4wMDM5MDYgMTEzMi41IEwgNTU3LjAwMzkwNiAxMTMyLjUgWiBNIDU1Ny4wMDM5MDYgMzY3LjUgIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PGcgY2xpcC1wYXRoPSJ1cmwoI2I4MDRiZjUzZDEpIj48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCA2NTUpIj48ZyBjbGlwLXBhdGg9InVybCgjZjdkYmI3ZjRmMikiPjxnIGNsaXAtcGF0aD0idXJsKCM4OWMyYjMxMDVhKSI+PHBhdGggZmlsbD0iIzliYjBlNiIgZD0iTSAwIDAuNjQ4NDM4IEwgODg4Ljk0OTIxOSAwLjY0ODQzOCBMIDg4OC45NDkyMTkgMTg5LjM0NzY1NiBMIDAgMTg5LjM0NzY1NiBaIE0gMCAwLjY0ODQzOCAiIGZpbGwtb3BhY2l0eT0iMSIgZmlsbC1ydWxlPSJub256ZXJvIi8+PC9nPjwvZz48L2c+PC9nPjxnIGNsaXAtcGF0aD0idXJsKCNjZjUxMmZiNDI1KSI+PGcgY2xpcC1wYXRoPSJ1cmwoIzAyZjhjZjdiM2MpIj48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCA2ODEsIDk3NikiPjxnIGNsaXAtcGF0aD0idXJsKCM4YTljN2VhOWMxKSI+PGcgY2xpcC1wYXRoPSJ1cmwoIzhkNDY5NzRiZjkpIj48ZyBjbGlwLXBhdGg9InVybCgjOTA1YzBmN2Q1YSkiPjxwYXRoIGZpbGw9IiM5YmIwZTYiIGQ9Ik0gMC42MzY3MTkgMzU1LjMwODU5NCBMIDcwNi40OTIxODggLTAuMDg5ODQzOCBMIDgxOS4yMzA0NjkgMjIzLjgyNDIxOSBMIDExMy4zNzg5MDYgNTc5LjIyMjY1NiBaIE0gMC42MzY3MTkgMzU1LjMwODU5NCAiIGZpbGwtb3BhY2l0eT0iMSIgZmlsbC1ydWxlPSJub256ZXJvIi8+PC9nPjwvZz48L2c+PC9nPjwvZz48L2c+PC9zdmc+"/>
<link rel="icon" type="image/png" href="data:image/png;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCAfQB9ADASIAAhEBAxEB/8QAHAABAQEBAQEBAQEAAAAAAAAAAAgHBQYCBAMB/8QAQhABAAAFAQIKCQQBAwMEAwEAAAECAwQGBRGUFiExNlZhcXWz0QcSExQXQVFUgRUyQoIiCGKRIyRSJXKSojNDRGT/xAAaAQEBAQEBAQEAAAAAAAAAAAAABAMFAQIG/8QAJREBAAIBBAIDAQEBAQEAAAAAAAECAxMUMVEEESEyYRIiQVJx/9oADAMBAAIRAxEAPwDTQH7JxwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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VUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUf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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/9k="/>
<style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,.045);
      --panel2: rgba(0,0,0,.14);
      --text: #e8eefc;
      --muted: #9bb0e6;
      --border: rgba(255,255,255,.10);

      --active-bg: rgba(255, 208, 92, 0.26);
      --active-br: rgba(255, 208, 92, 0.78);

      --hl-bg: rgba(59, 130, 246, 0.22);
      --hl-br: rgba(59, 130, 246, 0.88);

      --dim: 0.22;

      --line: rgba(255,255,255,.15);
      --line-hl: rgba(59,130,246,.92);
      --line-active: rgba(255,208,92,.95);

      --radius: 12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    /* Bright mode overrides */
    body.brightMode{
      --bg: #e8eaef;
      --panel: rgba(0,0,0,.05);
      --panel2: rgba(0,0,0,.08);
      --text: #111827;
      --muted: #475569;
      --border: rgba(0,0,0,.18);
      --active-bg: rgba(234,179,8,0.18);
      --active-br: rgba(160,110,0,0.85);
      --hl-bg: rgba(59,130,246,0.14);
      --hl-br: rgba(30,80,200,0.85);
      --dim: 0.40;
      --line: rgba(0,0,0,.18);
      --line-hl: rgba(30,80,200,.88);
      --line-active: rgba(160,110,0,.90);
    }
    body.brightMode{
      background: radial-gradient(1200px 600px at 10% 0%, rgba(59,130,246,.07), transparent 60%),
        radial-gradient(900px 500px at 90% 20%, rgba(255,208,92,.06), transparent 60%),
        var(--bg);
    }
    body.brightMode header{
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(225,228,235,.96), rgba(225,228,235,.82));
      border-bottom-color: rgba(0,0,0,.12);
    }
    body.brightMode .panel{
      background: linear-gradient(to bottom, rgba(255,255,255,.92), rgba(255,255,255,.78));
      border-color: rgba(0,0,0,.14);
    }
    body.brightMode .columnsWrap{
      background: linear-gradient(to bottom, rgba(255,255,255,.55), rgba(245,247,250,.4));
      border-color: rgba(0,0,0,.14);
    }
    body.brightMode .columnsHeader{ background: rgba(0,0,0,.05); }
    body.brightMode .tbBtn{ color: #64748b; }
    body.brightMode .tbBtn:hover{ background: rgba(0,0,0,.06); border-color: rgba(0,0,0,.14); color: #1e293b; }
    body.brightMode .tbBtn.active{ background: rgba(59,130,246,.1); border-color: rgba(59,130,246,.3); color: #1e293b; }
    body.brightMode .tbPop{ background: rgba(255,255,255,.98); border-color: rgba(0,0,0,.14); box-shadow: 0 8px 32px rgba(0,0,0,.15); }
    body.brightMode .tbRow1{ background: rgba(255,255,255,.6); border-color: rgba(0,0,0,.12); }
    body.brightMode .tbSep{ background: rgba(0,0,0,.15); }
    body.brightMode .filterChip:hover{ filter:brightness(0.82); box-shadow:0 0 0 1.5px rgba(0,0,0,.2); }
    body.brightMode .popItem.dragOver{ border-color: rgba(59,130,246,.5); }
    body.brightMode .feEmojiOption:hover{ background:rgba(0,0,0,.08) !important; }
    body.brightMode .feStyleBar{ background:rgba(0,0,0,.03); border-color:rgba(0,0,0,.12); }
    body.brightMode .feStyleItem:hover{ background:rgba(0,0,0,.06); border-color:rgba(0,0,0,.12); }
    body.brightMode .feStyleItem.feSwatchDragOver{ background:rgba(59,130,246,.1); border-color:rgba(59,130,246,.5); }
    body.brightMode .feColorSwatch{ border-color:rgba(0,0,0,.18); }
    body.brightMode .btn{
      background: rgba(255,255,255,.7);
      border-color: rgba(0,0,0,.16);
      color: #1e293b;
    }
    body.brightMode .btn:hover{ background: rgba(255,255,255,.95); }
    body.brightMode .btn.btnSave{ opacity: .35; pointer-events: none; }
    body.brightMode .btn.btnDirty{ border-color: rgba(180,130,10,.50); background: rgba(255,208,92,.22); color: var(--text); opacity: 1; pointer-events: auto; }
    body.brightMode .btn.btnDirty:hover{ background: rgba(255,208,92,.35); }
    body.brightMode .toggle{
      background: rgba(255,255,255,.7);
      border-color: rgba(0,0,0,.16);
      color: #1e293b;
    }
    body.brightMode .toggle:hover{ background: rgba(0,0,0,.08); border-color: rgba(0,0,0,.25); }
    body.brightMode .modeToggle.prominent{
      border-color: rgba(160,110,0,.50);
      background: rgba(255,208,92,.16);
    }
    body.brightMode .modeToggle.prominent:hover{ background: rgba(255,208,92,.26); }
    body.brightMode .popover{
      background: rgba(255,255,255,.98);
      border-color: rgba(0,0,0,.14);
      box-shadow: 0 24px 80px rgba(0,0,0,.22);
    }
    /* Panels */
    body.brightMode .panelHeader{ background: rgba(0,0,0,.05); }
    body.brightMode .panelHeader.colored{ background: var(--col-bg); border-bottom: 2px solid var(--col-color); }    body.brightMode .panelHeader.colored:hover{ background: var(--col-bg-hover); }
    body.brightMode .panelHeader.selected, body.brightMode .panelHeader.selected:hover{ background: rgba(234,179,8,0.22); border-bottom-color: var(--active-br); }
    body.brightMode .detailsHeader{ background: rgba(0,0,0,.05); }
    body.brightMode .details{ background: linear-gradient(to bottom, rgba(255,255,255,.90), rgba(255,255,255,.75)); }
    body.brightMode .foot{ background: rgba(0,0,0,.04); }
    /* Items / nodes */
    body.brightMode .item{ background: rgba(0,0,0,.06); }
    body.brightMode .item:hover{ background: rgba(0,0,0,.09); border-color: rgba(0,0,0,.14); }
    body.brightMode .item.connected{ background: rgba(59,130,246,.12); border-color: rgba(30,80,200,.35); }
    body.brightMode .item.active{ background: rgba(234,179,8,.15); border-color: rgba(160,110,0,.45); }
    body.brightMode .item.dimmed{ opacity: var(--dim); }
    /* Pills / tags */
    body.brightMode .pill{ background: rgba(0,0,0,.06); color: #475569; }
    body.brightMode .tag{ background: rgba(0,0,0,.06); color: #1e293b; }
    body.brightMode .tagChip{ color: #1e293b; border-color: color-mix(in srgb, var(--c,#3b82f6) 50%, rgba(0,0,0,.18)); background: color-mix(in srgb, var(--c,#3b82f6) 18%, rgba(0,0,0,.04)); }
    body.brightMode .box{ background: rgba(0,0,0,.03); }
    body.brightMode .k{ color: #475569; }
    /* Edges */
    body.brightMode .edgeMarker{ fill: rgba(0,0,0,.30); }
    body.brightMode .edgeMarker.hl{ fill: rgba(30,80,200,.85); }
    body.brightMode .edgeMarker.active{ fill: rgba(160,110,0,.90); }
    body.brightMode .edge{ stroke: rgba(0,0,0,.18); }
    body.brightMode .edge.hl{ stroke: rgba(30,80,200,.85); }
    body.brightMode .edge.active{ stroke: rgba(160,110,0,.90); }
    /* Search */
    body.brightMode .search{
      background: rgba(255,255,255,.75);
      border-color: rgba(0,0,0,.16);
    }
    body.brightMode .search input{ color: var(--text); }
    body.brightMode .search .hint{ background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.12); color: #475569; }
    /* Docs */
    /* Kbd */
    body.brightMode kbd{
      background: rgba(0,0,0,.06);
      border-color: rgba(0,0,0,.16);
      color: var(--text);
    }
    /* Slider labels */
    body.brightMode .sliderGroup{ color: #475569; }
    body.brightMode .sliderGroup .sliderVal{ color: #1e293b; }
    /* Tree carets */
    body.brightMode .caret{ border-left-color: rgba(0,0,0,.50); }
    body.brightMode .caret:hover{ background: rgba(0,0,0,.06); }
    /* Popover title */
    body.brightMode .popTitle{ color: #1e293b; }
    /* Map notes */
    body.brightMode .mapNote{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.10); color: #374151; }
    /* Mini buttons */
    body.brightMode .miniBtn{ background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.14); color: #1e293b; }
    /* Map card */
    body.brightMode .mapCard summary{ color: #374151; }
    /* Route/mono text */
    body.brightMode .route{ color: #475569; }
    body.brightMode code{ color: #1e293b; }
    /* Docs header name */
    /* Docs body text */
    body.brightMode .docsBody h2{ color: #111827; }
    body.brightMode .docsBody h3{ color: #1e293b; }
    body.brightMode .docsBody p, body.brightMode .docsBody li{ color: #374151; }
    body.brightMode .docsBody code{ background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.12); color: #1e293b; }
    body.brightMode .docsBody pre{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.10); }
    body.brightMode .docsBody pre code{ color: #1e293b; }
    body.brightMode .docsBody b, body.brightMode .docsBody strong{ color: #111827; }
    body.brightMode .docsBody a{ color: #2563eb; }
    /* Group icon (expand indicator) */
    body.brightMode .groupIcon{ border-left-color: rgba(0,0,0,.50); }
    body.brightMode .children{ border-left-color: rgba(0,0,0,.18); }
    /* Dirty save button */
    .btn.dirty{
      background: rgba(255,208,92,0.16);
      border-color: rgba(255,208,92,0.55);
      color: var(--text);
      font-weight: 700;
    }
    /* Bright mode: dirty save */
    body.brightMode .btn.dirty{
      background: rgba(255,208,92,0.22);
      border-color: rgba(180,130,10,0.50);
      color: var(--text);
    }
    /* Panel mode button in bright mode */
    body.brightMode .resizeHandle::after{ background: rgba(0,0,0,.08); }
    body.brightMode .resizeHandleH::after{ background: rgba(0,0,0,.08); }
    /* Project title input */
    body.brightMode #projectTitle{ background: rgba(0,0,0,.05) !important; border-color: rgba(0,0,0,.14) !important; }
    body.brightMode #projectTitle:focus{ background: rgba(255,255,255,.9) !important; border-color: rgba(59,130,246,.45) !important; }
    body.brightMode #projectTitle::placeholder{ color: rgba(0,0,0,.35); }
    /* Sub info bar */
    body.brightMode .sub{ color: #475569; }
    body.brightMode .sub span{ color: #475569; }
    /* Context menus */
    body.brightMode .ctxMenu{
      background: rgba(255,255,255,.97);
      border-color: rgba(0,0,0,.14);
      box-shadow: 0 18px 55px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
    }
    body.brightMode .ctxItem{
      background: rgba(0,0,0,.03);
      color: #1e293b;
    }
    body.brightMode .ctxItem:hover{ background: rgba(0,0,0,.07); border-color: rgba(0,0,0,.12); }
    body.brightMode .ctxItem:disabled{ opacity: .40; }
    body.brightMode .ctxItem.danger{ background: rgba(220,38,38,.06); border-color: rgba(220,38,38,.18); color: #b91c1c; }
    body.brightMode .ctxItem.danger:hover{ background: rgba(220,38,38,.12); border-color: rgba(220,38,38,.30); }
    body.brightMode .ctxSep{ background: rgba(0,0,0,.10); }
    body.brightMode .swatch{ border-color: rgba(0,0,0,.18); }
    body.brightMode .swatch.sel{ outline-color: rgba(0,0,0,.50); }
    /* Modal / Help dialog */
    body.brightMode .modal{
      background: rgba(255,255,255,.98);
      border-color: rgba(0,0,0,.14);
      box-shadow: 0 24px 80px rgba(0,0,0,.18);
      color: #1e293b;
    }
    body.brightMode .modalHeader{
      background: rgba(0,0,0,.03);
      border-bottom-color: rgba(0,0,0,.12);
    }
    body.brightMode .modalHeader .title{ color: #111827; }
    body.brightMode .modalBody{ color: #374151; }
    body.brightMode .modalBody h2, body.brightMode .modalBody h3, body.brightMode .modalBody h4{ color: #111827; }
    body.brightMode .modalBody code{ background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.12); color: #1e293b; }
    body.brightMode .modalBody a{ color: #2563eb; }
    body.brightMode .modalBody li{ color: #374151; }
    body.brightMode .modalBody strong{ color: #111827; }
    body.brightMode .modalBody kbd{ background: rgba(0,0,0,.06); border-color: rgba(0,0,0,.14); color: #1e293b; }
    /* Form inputs in modals */
    body.brightMode .inp{ background: rgba(0,0,0,.04); color: #1e293b; }
    body.brightMode .inp:focus{ border-color: rgba(59,130,246,.55); }
    body.brightMode select.inp{ background: rgba(0,0,0,.04); color: #1e293b; }
    body.brightMode select.inp option{ background: #fff; color: #1e293b; }
    body.brightMode select.inp option:checked{ background: #e0ecff; }
    body.brightMode select.inp option:disabled{ color: #94a3b8; }
    /* Map notes, link buttons */
    body.brightMode .mapNote{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.10); color: #374151; }
    body.brightMode .linkBtn{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.12); color: #1e293b; }
    body.brightMode .linkBtn:hover{ background: rgba(0,0,0,.08); }
    /* Map card */
    body.brightMode .mapCard{ border-color: rgba(0,0,0,.10); }
    body.brightMode .mapCard summary{ color: #374151; }
    /* Modal mask */
    body.brightMode .modalMask{ background: rgba(0,0,0,.30); }
    /* Status line */
    body.brightMode .statusLine{ color: #475569; }
    body.brightMode .viewerStatus{ color: #475569; }
    /* Create modal */
    body.brightMode .modalBody code#createIdPreview{ background: rgba(0,0,0,.08); border-color: rgba(0,0,0,.18); color: #1e293b; }
    /* Disabled / readonly inputs in bright mode */
    body.brightMode .inp:disabled, body.brightMode .inp[readonly],
    body.brightMode input:disabled, body.brightMode input[readonly],
    body.brightMode textarea:disabled, body.brightMode textarea[readonly]{
      background: rgba(0,0,0,.03); color: #6b7280; border-color: rgba(0,0,0,.08); -webkit-text-fill-color: #6b7280; opacity: 1;
      border-style: dashed;
    }
    /* Dimmed items - ensure text remains readable */
    body.brightMode .dimmed > .row{ opacity: var(--dim); }
    body.brightMode .node:not(.dimmed):not(.active):not(.connected) > .row .item{ background: rgba(0,0,0,.04); }
    /* Scrollbars - ensure visibility */
    
    *{ box-sizing: border-box; }

    /* Custom scrollbars  wider for easy grabbing */
    ::-webkit-scrollbar{ width: 10px; height: 10px; }
    ::-webkit-scrollbar-track{ background: rgba(255,255,255,.04); border-radius: 6px; }
    ::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.16); border-radius: 6px; min-height: 40px; }
    ::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.28); }
    ::-webkit-scrollbar-corner{ background: transparent; }
    /* Firefox */
    *{ scrollbar-width: auto; scrollbar-color: rgba(255,255,255,.16) rgba(255,255,255,.04); }
    /* Bright mode scrollbar overrides */
    body.brightMode ::-webkit-scrollbar{ width: 10px; height: 10px; }
    body.brightMode ::-webkit-scrollbar-track{ background: rgba(0,0,0,.06); border-radius: 6px; }
    body.brightMode ::-webkit-scrollbar-thumb{ background: rgba(0,0,0,.22); border-radius: 6px; min-height: 40px; }
    body.brightMode ::-webkit-scrollbar-thumb:hover{ background: rgba(0,0,0,.38); }
    body.brightMode, body.brightMode *{ scrollbar-color: rgba(0,0,0,.22) rgba(0,0,0,.06); scrollbar-width: auto; }

    /* === Viewport-locked layout === */
    html{ height: 100%; overflow: hidden; }
    body{
      margin: 0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(59,130,246,.10), transparent 60%),
        radial-gradient(900px 500px at 90% 20%, rgba(255,208,92,.08), transparent 60%),
        var(--bg);
      color: var(--text);
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header{
      position: relative;
      z-index: 50;
      flex-shrink: 0;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,16,32,.92), rgba(11,16,32,.70));
      border-bottom: 1px solid var(--border);
      padding: 12px 14px;
    }

    .top{
      display:grid;
      grid-template-columns: auto 1fr auto;
      align-items:center;
      gap: 12px;
    }
    @media(max-width:900px){ .top{ grid-template-columns:1fr; justify-items:center; } }
    .topCenter{display:flex;align-items:center;gap:6px;justify-content:center;}
    .topCenter input{
      font-size:14px;font-weight:600;text-align:center;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);
      border-radius:8px;padding:6px 14px;color:var(--text);
      max-width:600px;width:100%;transition:all .2s ease;
    }
    .topRight{display:flex;align-items:center;gap:8px;justify-content:flex-end;flex-wrap:wrap;}

    h1{
      font-size: 17px;
      margin: 0;
      font-weight: 800;
      letter-spacing: 1.0px;
      text-transform: uppercase;
    }


    .sub{
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items: center;
    }
    kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      color: var(--text);
    }

    /* shared buttons / controls */
    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap: wrap;
    }
    .btn{
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      transition: transform .05s ease, background .2s ease;
      user-select: none;
      white-space: nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn:active{ transform: translateY(1px); }
    .btn.btnSave{ opacity: .35; pointer-events: none; font-weight: 600; }
    .btn.btnDirty{ border-color: rgba(255,208,92,.55); background: rgba(255,208,92,.16); color: var(--text); font-weight: 700; opacity: 1; pointer-events: auto; }
    .btn.btnDirty:hover{ background: rgba(255,208,92,.26); }
    .btn.btnDanger{ border-color: rgba(239,68,68,.5); color: #ef4444; }
    .btn.btnDanger:hover{ background: rgba(239,68,68,.15); }
    .autoTag{ display:inline-block; font-size:9px; padding:1px 5px; border-radius:6px; background:rgba(59,130,246,.15); color:rgba(130,180,255,.8); vertical-align:middle; margin-left:6px; pointer-events:none; letter-spacing:.3px; user-select:none; transition: opacity .15s; white-space:nowrap; flex-shrink:0; }
    .k .autoTag{ margin-left:4px; font-size:8px; padding:1px 4px; vertical-align:baseline; }
    body.brightMode .autoTag{ background:rgba(59,130,246,.1); color:rgba(37,99,235,.6); }
    .miniCard:hover{ background: rgba(255,255,255,.06); }
    body.brightMode .miniCard:hover{ background: rgba(0,0,0,.05); }
    body.brightMode .btn.btnDanger{ border-color: rgba(220,38,38,.4); color: #dc2626; }
    body.brightMode .btn.btnDanger:hover{ background: rgba(220,38,38,.08); }

    /* === Multi-selection action panel === */
    .msBulk{
      display:flex; flex-direction:column; gap:10px; padding-bottom:12px; margin-bottom:6px;
      border-bottom:1px solid var(--border);
    }
    .msCard{
      border:1px solid rgba(255,255,255,.10); border-radius:14px;
      background: linear-gradient(135deg, rgba(255,255,255,.04) 0%, rgba(255,255,255,.015) 100%);
      padding:10px; display:flex; flex-direction:column; gap:4px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18);
    }
    .msCard.danger{ border-color: rgba(255,154,168,.14); background: linear-gradient(135deg, rgba(239,68,68,.06) 0%, rgba(239,68,68,.02) 100%); }
    .msCardHead{
      display:flex; align-items:center; gap:7px; padding:2px 4px 6px;
      font-size:10px; text-transform:uppercase; letter-spacing:.7px;
      color:rgba(130,180,255,.55); font-weight:600;
    }
    .msCardHead .msCount{
      font-size:9px; padding:1px 6px; border-radius:8px;
      background:rgba(59,130,246,.14); color:rgba(130,180,255,.7);
      font-weight:700; letter-spacing:0; text-transform:none;
    }
    .msCard.danger .msCardHead{ color:rgba(255,154,168,.55); }
    .msCard.danger .msCardHead .msCount{ background:rgba(239,68,68,.14); color:rgba(255,154,168,.7); }
    .msActBtn{
      display:flex; align-items:center; gap:9px; width:100%;
      border:1px solid transparent; background: rgba(255,255,255,.03);
      color: rgba(232,238,252,.88); padding:8px 10px; border-radius:11px;
      cursor:pointer; font-size:11.5px; text-align:left; transition: all .12s ease;
      user-select:none;
    }
    .msActBtn:hover{ background: rgba(255,255,255,.07); border-color: rgba(255,255,255,.10); }
    .msActBtn:active{ transform:translateY(1px); }
    .msActBtn .msIco{ width:18px; text-align:center; opacity:.75; flex:0 0 auto; font-size:13px; }
    .msActBtn.danger{ color: rgba(255,154,168,.90); }
    .msActBtn.danger:hover{ background: rgba(255,154,168,.10); border-color: rgba(255,154,168,.20); }
    .msActBtn .msArrow{ margin-left:auto; opacity:.25; font-size:10px; }
    .msStatGrid{
      display:grid; grid-template-columns:1fr 1fr; gap:6px;
    }
    .msStat{
      border:1px solid rgba(255,255,255,.07); border-radius:10px;
      background: rgba(255,255,255,.025); padding:8px 10px;
      display:flex; flex-direction:column; gap:2px;
    }
    .msStat .msStatLabel{
      font-size:9px; text-transform:uppercase; letter-spacing:.5px;
      opacity:.35; font-weight:500;
    }
    .msStat .msStatVal{
      font-size:15px; font-weight:700; letter-spacing:-.3px;
      color:rgba(232,238,252,.9);
    }
    .msStat .msStatSub{
      font-size:10px; opacity:.4; margin-top:1px;
    }
    .msStat.wide{ grid-column: 1 / -1; flex-direction:row; align-items:center; gap:10px; }
    .msStat.wide .msStatVal{ font-size:13px; }
    .msColChip{
      display:inline-flex; align-items:center; gap:5px;
      padding:4px 9px; border-radius:8px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      font-size:11px; white-space:nowrap;
      transition: background .12s;
    }
    .msColChip:hover{ background: rgba(255,255,255,.07); }
    .msColDot{
      width:7px; height:7px; border-radius:50%; flex-shrink:0;
      box-shadow: 0 0 6px currentColor;
    }
    .msColCount{ font-weight:600; opacity:.8; }
    /* bright mode overrides */
    body.brightMode .msCard{
      border-color: rgba(0,0,0,.10);
      background: linear-gradient(135deg, rgba(255,255,255,.5) 0%, rgba(245,247,250,.3) 100%);
      box-shadow: 0 2px 10px rgba(0,0,0,.06);
    }
    body.brightMode .msCard.danger{ border-color: rgba(220,38,38,.15); background: linear-gradient(135deg, rgba(220,38,38,.05) 0%, rgba(220,38,38,.02) 100%); }
    body.brightMode .msCardHead{ color:rgba(37,99,235,.55); }
    body.brightMode .msCardHead .msCount{ background:rgba(59,130,246,.10); color:rgba(37,99,235,.6); }
    body.brightMode .msCard.danger .msCardHead{ color:rgba(220,38,38,.50); }
    body.brightMode .msCard.danger .msCardHead .msCount{ background:rgba(220,38,38,.08); color:rgba(220,38,38,.6); }
    body.brightMode .msActBtn{ background: rgba(0,0,0,.025); color: rgba(30,41,59,.85); }
    body.brightMode .msActBtn:hover{ background: rgba(0,0,0,.06); border-color: rgba(0,0,0,.12); }
    body.brightMode .msActBtn.danger{ color: rgba(220,38,38,.80); }
    body.brightMode .msActBtn.danger:hover{ background: rgba(220,38,38,.07); border-color: rgba(220,38,38,.18); }
    body.brightMode .msStat{ border-color: rgba(0,0,0,.06); background: rgba(0,0,0,.02); }
    body.brightMode .msStat .msStatVal{ color: rgba(30,41,59,.85); }
    body.brightMode .msColChip{ border-color: rgba(0,0,0,.08); background: rgba(0,0,0,.03); }
    body.brightMode .msColChip:hover{ background: rgba(0,0,0,.06); }

    /* === Detail panel hero & metadata === */
    .dtHero{
      display:flex; align-items:flex-start; justify-content:space-between; gap:8px;
      padding:2px 2px 10px; margin-bottom:2px;
    }
    .dtEditorHead{
      display:flex; align-items:center; gap:8px;
      padding:0 0 8px; margin-bottom:4px;
      border-bottom:1px solid rgba(255,255,255,.05);
    }
    .dtEditorHead .dtEditorLabel{
      font-size:10px; opacity:.35; font-weight:500; letter-spacing:.3px;
    }
    .dtName{
      font-size:17px; font-weight:700; letter-spacing:-.2px;
      color:var(--text); line-height:1.25; word-break:break-word;
    }
    .dtType{
      font-size:9px; font-weight:700; text-transform:uppercase; letter-spacing:.8px;
      padding:3px 8px; border-radius:7px; flex-shrink:0; margin-top:3px;
      background:rgba(59,130,246,.12); color:rgba(130,180,255,.75);
      border:1px solid rgba(59,130,246,.15);
    }
    .dtType.group{ background:rgba(168,85,247,.12); color:rgba(192,148,255,.8); border-color:rgba(168,85,247,.18); }
    .dtType.column{ background:rgba(34,197,94,.10); color:rgba(100,220,150,.8); border-color:rgba(34,197,94,.15); }
    .dtType.mapping{ background:rgba(251,146,60,.10); color:rgba(251,176,100,.8); border-color:rgba(251,146,60,.15); }
    .dtRow{
      display:flex; align-items:baseline; gap:8px; padding:5px 2px;
      border-bottom:1px solid rgba(255,255,255,.04); font-size:12px;
    }
    .dtRow:last-child{ border-bottom:none; }
    .dtRowK{
      font-family:var(--mono); font-size:10px; color:rgba(155,176,230,.65);
      text-transform:uppercase; letter-spacing:.4px; flex:0 0 auto; min-width:54px;
    }
    .dtRowV{ flex:1; word-break:break-word; color:var(--text); }
    .dtId{
      font-family:var(--mono); font-size:11px; opacity:.7;
      display:inline-flex; align-items:center; gap:4px;
    }
    .dtNote{
      font-size:11.5px; opacity:.7; line-height:1.45; padding:6px 10px;
      border-radius:8px; background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.05); margin:2px 0;
    }
    .dtChipWrap{
      display:flex; flex-wrap:wrap; gap:5px; padding:4px 0;
    }
    .dtStatRow{
      display:flex; gap:6px; flex-wrap:wrap; padding:4px 0 2px;
    }
    .dtStatChip{
      font-size:11px; padding:4px 9px; border-radius:8px;
      border:1px solid rgba(255,255,255,.07); background:rgba(255,255,255,.03);
      display:inline-flex; align-items:center; gap:5px;
    }
    .dtStatChip .dtStatN{ font-weight:700; font-size:13px; letter-spacing:-.2px; }
    .dtStatChip .dtStatL{ opacity:.45; font-size:10px; }
    .dtColorSwatch{
      width:14px; height:14px; border-radius:5px; flex-shrink:0;
      border:1px solid rgba(255,255,255,.18); display:inline-block; vertical-align:middle;
    }
    .dtAttrGroup{
      display:flex; align-items:center; gap:5px; flex-wrap:wrap;
      padding:3px 0;
    }
    .dtAttrLabel{
      font-size:10px; font-family:var(--mono); padding:2px 7px;
      border-radius:6px; background:rgba(59,130,246,.10); color:rgba(130,180,255,.7);
      border:1px solid rgba(59,130,246,.10); font-weight:600;
    }
    .dtAttrVal{
      font-size:10.5px; padding:2px 7px; border-radius:6px;
      background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.08);
    }
    .dtActions{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      padding:10px 0 2px; margin-top:6px; border-top:1px solid var(--border);
    }
    .dtActions .spacer{ flex:1; }
    .dtHint{
      font-size:11px; opacity:.4; padding:6px 0 2px; line-height:1.4;
    }
    /* bright mode */
    body.brightMode .dtType{ background:rgba(59,130,246,.08); color:rgba(37,99,235,.6); border-color:rgba(59,130,246,.12); }
    body.brightMode .dtType.group{ background:rgba(168,85,247,.08); color:rgba(126,58,194,.6); border-color:rgba(168,85,247,.12); }
    body.brightMode .dtType.column{ background:rgba(34,197,94,.08); color:rgba(22,163,74,.6); border-color:rgba(34,197,94,.12); }
    body.brightMode .dtType.mapping{ background:rgba(251,146,60,.08); color:rgba(194,96,16,.6); border-color:rgba(251,146,60,.12); }
    body.brightMode .dtRow{ border-bottom-color:rgba(0,0,0,.04); }
    body.brightMode .dtEditorHead{ border-bottom-color:rgba(0,0,0,.06); }
    body.brightMode .dtRowK{ color:rgba(71,85,105,.6); }
    body.brightMode .dtNote{ background:rgba(0,0,0,.02); border-color:rgba(0,0,0,.06); }
    body.brightMode .dtStatChip{ border-color:rgba(0,0,0,.06); background:rgba(0,0,0,.02); }
    body.brightMode .dtStatChip .dtStatN{ color:rgba(30,41,59,.85); }
    body.brightMode .dtAttrLabel{ background:rgba(59,130,246,.07); color:rgba(37,99,235,.6); border-color:rgba(59,130,246,.08); }
    body.brightMode .dtAttrVal{ background:rgba(0,0,0,.03); border-color:rgba(0,0,0,.07); }
    body.brightMode .dtColorSwatch{ border-color:rgba(0,0,0,.15); }

    .toggle{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      cursor: pointer;
      user-select: none;
      font-size: 12px;
      white-space: nowrap;
      transition: background .15s, border-color .15s;
    }
    .toggle:hover{ background: rgba(255,255,255,.12); border-color: rgba(255,255,255,.2); }
    .toggle input{ accent-color: #3b82f6; width: 14px; height: 14px; margin: 0; }

    .search{
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      border-radius: 12px;
      padding: 6px 10px;
      min-width: min(520px, 92vw);
      flex: 1 1 auto;
    }
    .search input{
      width: 100%;
      border: none;
      outline: none;
      background: transparent;
      color: var(--text);
      font-size: 12px;
      padding: 4px 0;
    }
    .search .hint{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(155,176,230,.9);
      border: 1px solid var(--border);
      padding: 2px 6px;
      border-radius: 8px;
      background: rgba(255,255,255,.04);
      white-space: nowrap;
    }

    /* main content areas */
    main{
      padding: 14px;
      flex: 1 1 0;
      min-height: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* App footer */
    .appFooter{
      display: flex; align-items: center; justify-content: space-between;
      padding: 6px 14px;
      border-top: 1px solid var(--border);
      font-size: 10px; color: var(--muted); opacity: .5;
      flex-shrink: 0; user-select: none;
      letter-spacing: .2px;
    }
    .appFooter a{ color: var(--muted); text-decoration: none; }
    .appFooter a:hover{ text-decoration: underline; }
    .aboutLicenseLink{ color: inherit; text-decoration: none; cursor: pointer; }
    .aboutLicenseLink:hover{ text-decoration: underline; }
    .view{
      display:none;
    }
    .view.active{
      display: flex;
      flex-direction: column;
      flex: 1 1 0;
      min-height: 0;
    }

    /* Viewer layout  panel modes controlled by [data-panel] */
    .viewerGrid{
      display: grid;
      grid-template-columns: 1fr 440px;
      gap: 14px;
      flex: 1 1 0;
      min-height: 0;
      overflow: hidden;
      position: relative;
    }
    /* Side mode  RIGHT (default) */
    .viewerGrid[data-panel="right"]{ grid-template-columns: 1fr 440px; grid-template-rows: 1fr; }
    .viewerGrid[data-panel="right"] .details{ max-height: none; }
    /* Side mode  LEFT */
    .viewerGrid[data-panel="left"]{ grid-template-columns: 440px 1fr; grid-template-rows: 1fr; }
    .viewerGrid[data-panel="left"] .details{ max-height: none; order: -1; }
    .viewerGrid[data-panel="left"] .columnsWrap{ order: 1; }
    .viewerGrid[data-panel="left"] .resizeHandle{ order: 0; }
    /* Bottom mode */
    .viewerGrid[data-panel="bottom"]{ grid-template-columns: 1fr; grid-template-rows: 1fr calc(30vh - 28px); }
    .viewerGrid[data-panel="bottom"] .details{ max-height: 65vh; min-height: 120px; }
    .viewerGrid[data-panel="bottom"] .detailsBody{ max-height: none; }
    /* Floating mode */
    .viewerGrid[data-panel="float"]{ grid-template-columns: 1fr; grid-template-rows: 1fr; }
    .viewerGrid[data-panel="float"] .details{
      position: fixed;
      z-index: 180;
      top: auto; left: auto; right: auto; bottom: auto;
      width: 444px; max-width: calc(100vw - 32px);
      height: 380px; min-height: 160px; min-width: 300px;
      border-radius: var(--radius);
      box-shadow: 0 20px 60px rgba(0,0,0,.55), 0 0 0 1px rgba(255,255,255,.10);
      backdrop-filter: blur(24px);
      background: rgba(11,16,32,.97);
      overflow: visible;
    }
    body.brightMode .viewerGrid[data-panel="float"] .details{
      box-shadow: 0 20px 60px rgba(0,0,0,.25), 0 0 0 1px rgba(0,0,0,.14);
      background: rgba(245,247,250,.97);
      backdrop-filter: blur(24px);
    }
    /* Floating mode: entire header is the drag handle */
    .viewerGrid[data-panel="float"] .detailsHeader{
      cursor: move; user-select: none;
      border-radius: var(--radius) var(--radius) 0 0;
    }
    /* Float resize: custom corner handle */
    .floatResizeHandle{
      display: none; position: absolute; bottom: 0; right: 0;
      width: 18px; height: 18px; cursor: nwse-resize; z-index: 5;
    }
    .floatResizeHandle::after{
      content: ''; position: absolute; bottom: 3px; right: 3px;
      width: 8px; height: 8px;
      border-right: 2px solid rgba(255,255,255,.25);
      border-bottom: 2px solid rgba(255,255,255,.25);
    }
    .floatResizeHandle:hover::after{
      border-color: rgba(59,130,246,.7);
    }
    body.brightMode .floatResizeHandle::after{
      border-color: rgba(0,0,0,.2);
    }
    body.brightMode .floatResizeHandle:hover::after{
      border-color: rgba(59,130,246,.6);
    }
    .viewerGrid[data-panel="float"] .floatResizeHandle{ display: block; }
    .viewerGrid[data-panel="float"] .floatOnly{ display: inline-flex !important; }
    .viewerGrid[data-panel="float"] .details{ transition: opacity .25s ease; }
    .viewerGrid[data-panel="float"] .detailsBody{ border-radius: 0 0 var(--radius) var(--radius); }
    .viewerGrid[data-panel="float"] .details.minimized .detailsBody,
    .viewerGrid[data-panel="float"] .details.minimized .floatResizeHandle{ display: none; }
    .viewerGrid[data-panel="float"] .details.minimized{ height: auto !important; min-height: 0 !important; }
    body.brightMode #opacityPopover{ background: rgba(245,247,250,.97); box-shadow: 0 8px 24px rgba(0,0,0,.15); }
    /* Hidden mode */
    .viewerGrid[data-panel="hidden"]{ grid-template-columns: 1fr; grid-template-rows: 1fr; }
    .viewerGrid[data-panel="hidden"] .details{ display: none; }

    /* Details drag grip icon (float mode only) */
    .detailsDragHandle{ display: none; }
    .detailsGrip{
      display: none; width: 12px; height: 18px; cursor: move;
      flex-shrink: 0; opacity: .3; transition: opacity .15s;
      background-image: radial-gradient(circle, currentColor 1.2px, transparent 1.2px);
      background-size: 6px 6px;
      background-position: 0 0;
      background-repeat: repeat;
    }
    .detailsGrip:hover{ opacity: .6; }
    .viewerGrid[data-panel="float"] .detailsGrip{ display: block; }

    /* Close button for details panel */
    .detailsClose{
      display: inline-flex; width: 22px; height: 22px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06);
      color: var(--muted); font-size: 13px; line-height: 1;
      cursor: pointer; align-items: center; justify-content: center;
      transition: all .15s; flex-shrink: 0;
    }
    .detailsClose:hover{ background: rgba(255,255,255,.12); color: var(--text); }
    body.brightMode .detailsClose{ border-color: rgba(0,0,0,.12); background: rgba(0,0,0,.04); }
    body.brightMode .detailsClose:hover{ background: rgba(0,0,0,.08); }

    /* Resize handle for side mode  absolutely positioned over the gap */
    .resizeHandle{
      position: absolute; top: 0; bottom: 0; width: 14px; cursor: col-resize;
      z-index: 15; user-select: none; display: none;
    }
    .resizeHandle::before{
      content: ''; position: absolute; top: 12px; bottom: 12px; left: 50%; width: 1px;
      background: var(--border); transform: translateX(-50%);
    }
    .resizeHandle::after{
      content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
      width: 4px; height: 48px; border-radius: 4px;
      background: rgba(255,255,255,.14);
      transition: background .15s, height .15s, box-shadow .15s;
    }
    .resizeHandle:hover::after, .resizeHandle.active::after{
      background: rgba(59,130,246,.65); height: 64px;
      box-shadow: 0 0 8px rgba(59,130,246,.25);
    }
    body.brightMode .resizeHandle::before{ background: rgba(0,0,0,.1); }
    body.brightMode .resizeHandle::after{ background: rgba(0,0,0,.12); }
    body.brightMode .resizeHandle:hover::after, body.brightMode .resizeHandle.active::after{
      background: rgba(59,130,246,.55); box-shadow: 0 0 8px rgba(59,130,246,.15);
    }
    .viewerGrid[data-panel="right"] .resizeHandle{ display: block; }
    .viewerGrid[data-panel="left"] .resizeHandle{ display: block; }
    /* Bottom mode resize handle */
    .resizeHandleH{
      position: absolute; left: 0; right: 0; height: 14px; cursor: row-resize;
      z-index: 15; user-select: none; display: none;
    }
    .resizeHandleH::before{
      content: ''; position: absolute; left: 12px; right: 12px; top: 50%; height: 1px;
      background: var(--border); transform: translateY(-50%);
    }
    .resizeHandleH::after{
      content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
      width: 48px; height: 4px; border-radius: 4px;
      background: rgba(255,255,255,.14);
      transition: background .15s, width .15s, box-shadow .15s;
    }
    .resizeHandleH:hover::after, .resizeHandleH.active::after{
      background: rgba(59,130,246,.65); width: 64px;
      box-shadow: 0 0 8px rgba(59,130,246,.25);
    }
    body.brightMode .resizeHandleH::before{ background: rgba(0,0,0,.1); }
    body.brightMode .resizeHandleH::after{ background: rgba(0,0,0,.12); }
    body.brightMode .resizeHandleH:hover::after, body.brightMode .resizeHandleH.active::after{
      background: rgba(59,130,246,.55); box-shadow: 0 0 8px rgba(59,130,246,.15);
    }
    .viewerGrid[data-panel="bottom"] .resizeHandleH{ display: block; }

    /* Pan mode (P key toggle) */
    .columnsScroller.panReady{ cursor: all-scroll !important; }
    .columnsScroller.panReady *{ cursor: all-scroll !important; pointer-events: none !important; }
    .columnsScroller.panning{ cursor: all-scroll !important; }
    .columnsScroller.panning *{ cursor: all-scroll !important; pointer-events: none !important; }

    /* Layout popover sections */
    .layoutSection{ padding: 8px 0; }
    .layoutSection + .layoutSection{ border-top: 1px solid var(--border); }
    .layoutSectionTitle{
      font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: .6px;
      color: var(--muted); opacity: .7; margin-bottom: 6px;
    }
    .layoutSliderRow{
      display: grid; grid-template-columns: 44px 1fr 36px 16px; gap: 6px;
      align-items: center; margin: 6px 0;
    }
    .layoutSliderLabel{ font-size: 11px; color: var(--muted); }
    .layoutSliderVal{ font-family: var(--mono); font-size: 11px; color: var(--muted); text-align: right; }
    .layoutSliderRow input[type="range"]{ width: 100%; }
    .layoutReset{
      font-size: 12px; cursor: pointer; opacity: 0; transition: opacity .15s;
      color: var(--muted); text-align: center; line-height: 1;
    }
    .layoutSliderRow:hover .layoutReset{ opacity: .4; }
    .layoutReset:hover{ opacity: .8 !important; color: var(--accent); }
    .layoutHint{
      font-size: 10px; opacity: .35; margin-top: 8px;
    }
    .layoutHint kbd{
      font-family: var(--mono); font-size: 10px; padding: 1px 4px;
      border-radius: 4px; border: 1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
    }
    body.brightMode .layoutHint kbd{
      border-color: rgba(0,0,0,.15); background: rgba(0,0,0,.04);
    }

    /* Dock selector  icon+label buttons in a row */
    .dockSelector{
      display: flex; gap: 4px; flex-wrap: wrap;
    }
    .dockOpt{
      display: flex; flex-direction: column; align-items: center; gap: 3px;
      padding: 6px 8px 5px; border-radius: 8px; border: 1px solid var(--border);
      background: rgba(255,255,255,.04); color: var(--muted);
      font-size: 10px; cursor: pointer; user-select: none;
      transition: all .15s; flex: 1 1 0; min-width: 42px;
    }
    .dockOpt:hover{
      background: rgba(255,255,255,.08); color: var(--text); border-color: rgba(255,255,255,.18);
    }
    .dockOpt.active{
      background: rgba(59,130,246,.15); border-color: rgba(59,130,246,.5); color: var(--text);
    }
    .dockOpt svg{ flex-shrink: 0; }
    body.brightMode .dockOpt{
      background: rgba(0,0,0,.03); color: #64748b; border-color: rgba(0,0,0,.12);
    }
    body.brightMode .dockOpt:hover{
      background: rgba(0,0,0,.06); color: #1e293b; border-color: rgba(0,0,0,.2);
    }
    body.brightMode .dockOpt.active{
      background: rgba(59,130,246,.1); border-color: rgba(59,130,246,.4); color: #1e293b;
    }

    /* Details header dock actions  always visible */
    .detailsDockActions{
      display: flex; gap: 2px; align-items: center;
    }
    .dockAction{
      width: 22px; height: 22px; border-radius: 6px;
      border: 1px solid rgba(255,255,255,.10); background: transparent;
      color: var(--muted); cursor: pointer; display: inline-flex;
      align-items: center; justify-content: center; transition: all .12s;
      padding: 0;
    }
    .dockAction:hover{ background: rgba(255,255,255,.10); color: var(--text); }
    body.brightMode .dockAction{ border-color: rgba(0,0,0,.10); }
    body.brightMode .dockAction:hover{ background: rgba(0,0,0,.06); color: #1e293b; }

    /* Snap-to-edge indicator when dragging float panel */
    .snapIndicator{
      position: fixed; z-index: 175; display: none;
      background: rgba(59,130,246,.12); border: 2px dashed rgba(59,130,246,.5);
      border-radius: 8px; pointer-events: none;
      transition: all .15s ease;
    }
    body.brightMode .snapIndicator{
      background: rgba(59,130,246,.08); border-color: rgba(59,130,246,.4);
    }

    .columnsWrap{
      position: relative;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(to bottom, rgba(255,255,255,.045), rgba(255,255,255,.02));
      overflow: hidden;
      min-height: 0;
      min-width: 0;
      display:flex;
      flex-direction: column;
      flex: 1 1 0;
    }
    .columnsHeader{
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.10);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .statusLine{
      color: var(--muted);
      font-size: 12px;
      min-width: 220px;
      flex: 1 1 auto;
    }

    .columnsScroller{
      position: relative;
      overflow: auto;
      min-height: 0;
      padding: 12px;
      flex: 1 1 0;
    }

    .columnsRow{
      position: relative;
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(var(--col-width, 300px), 1fr);
      gap: var(--col-gap, 20px);
      align-items: stretch;
      min-width: 920px; /* allows horizontal scroll when many columns */
      padding-bottom: 6px;
      min-height: 100%;
    }

    #svgOverlay{
 position: absolute;
 inset: 0;
 pointer-events: none;
 z-index: 40;
 overflow: hidden;
 }

    .panel{
      position: relative;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: linear-gradient(to bottom, rgba(255,255,255,.05), rgba(255,255,255,.03));
      min-height: 0;
      display:flex;
      flex-direction: column;
      height: 100%;
    }

    .panelHeader{
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.10);
      user-select: none;
    }
    .panelHeader .name{
      font-weight: 900;
      font-size: 13px;
      letter-spacing: .2px;
    }
    .panelHeader .meta{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
    }
    
.panelHeader.clickable{cursor:pointer;}
.panelHeader.clickable:hover{background: rgba(59,130,246,.08);}
.panelHeader.clickable:active{transform: translateY(1px);}
.panelHeader.colored{ background: var(--col-bg); border-bottom: 2px solid var(--col-color); }
.panelHeader.colored:hover{ background: var(--col-bg-hover); }
.panelHeader.selected, .panelHeader.selected:hover{background: var(--active-bg); border-bottom-color: var(--active-br);}
.panelHeader.selected.colored, .panelHeader.selected.colored:hover{background: var(--active-bg); border-bottom-color: var(--active-br);}
.tree{
      padding: 8px;
      overflow: auto;
      min-height: 0;
      flex: 1 1 0;
    }
    .foot{
      padding: 10px 12px;
      border-top: 1px solid var(--border);
      background: rgba(0,0,0,.08);
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }

    .node{ margin: 2px 0; border-radius: 10px; }
    .row{
 position: relative;
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      border: 1px solid transparent;
      transition: background .15s ease, border-color .15s ease, opacity .15s ease, transform .05s ease;
    }
    .row:hover{ background: rgba(255,255,255,.05); }
    .row:active{ transform: translateY(1px); }
    .hasNodeColor:not(.active):not(.connected):not(.filterHighlight):not(.filterDimmed) > .row{ background: var(--node-color); border-color: var(--node-color-border); }

    .badge{
      font-family: var(--mono);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(255,255,255,.04);
      flex: 0 0 auto;
    }

    .caret{
      width: 0; height: 0;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 7px solid rgba(232,238,252,.72);
      transition: transform .12s ease;
      margin-right: 2px;
      flex: 0 0 auto;
      cursor: pointer;
      padding: 6px;
      border-radius: 8px;
    }
    .caret:hover{ background: rgba(255,255,255,.06); }
    .group.collapsed > .row .caret{ transform: rotate(-90deg); }

    .label{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width: 0;
 flex: 1 1 auto;
      font-size: 13px;
    }
    .label .text{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
 display:block;
 min-width:0;
 flex: 1 1 auto;
    }

    .id{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(155,176,230,.85);
      margin-left:auto;
      opacity: .75;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 48%;
    }
/* Hide node IDs in tree rows (IDs remain in Details/breadcrumbs) */
.row .id{display:none !important;}


    .children{
      margin-left: 16px;
      padding-left: 8px;
      border-left: 1px dashed rgba(255,255,255,.14);
    }

    .hidden{ display:none !important; }
    .filterDimmed > .row{ opacity: 0.25; }
    .filterDimmed.active > .row, .filterDimmed.connected > .row{ opacity: 1 !important; }
    .filterHighlight > .row{ background: var(--filter-bg, transparent) !important; border-radius: 4px; }
    .filterHighlight > .row{ border-left: 3px solid var(--filter-border, transparent); padding-left: 3px; }
    .filterBold > .row .label .text{ font-weight: 700 !important; }
    .filterFrame{ outline: 2px solid var(--filter-frame, #3b82f6); outline-offset: -1px; border-radius: 5px; }
    .filterEmoji{ font-style: normal; }
    .catItem.dragOver{ border-color: rgba(59,130,246,.6) !important; box-shadow: 0 -2px 0 0 rgba(59,130,246,.7) !important; }
    .condGroup{ border-left: 2px solid var(--accent); margin: 4px 0 4px 8px; padding: 2px 0 2px 10px; border-radius: 0 0 0 6px; }
    .condDragHandle{ cursor:grab; opacity:.35; font-size:11px; user-select:none; padding:0 2px; transition:opacity .15s; }
    .condDragHandle:hover{ opacity:.8; }
    .condRow.condDragOver-above, .condGroup.condDragOver-above{ box-shadow:0 -2px 0 0 var(--accent); background:rgba(59,130,246,.06); border-radius:4px; }
    .condRow.condDragOver-below, .condGroup.condDragOver-below{ box-shadow:0 2px 0 0 var(--accent); background:rgba(59,130,246,.06); border-radius:4px; }
    .condGroup.condDragOver-into{ background:rgba(59,130,246,.10); border-color:var(--accent); }
    .condRow.condDragging, .condGroup.condDragging{ opacity:.3; }
    .condRow{ position:relative; padding:3px 0; border-radius:4px; transition:background .1s, box-shadow .1s; }
    .condGroup{ position:relative; transition:background .1s, box-shadow .1s; }
    .condActions .btn{ opacity:.4; min-width:20px; text-align:center; }
    .condActions .btn:hover{ opacity:1; }
    .condActions .ruleDel{ opacity:.5; }
    .condActions .ruleDel:hover{ opacity:1; background:rgba(248,113,113,.12); }
    .feHighlightGrid, .feStyleBar{ display:flex; gap:0; align-items:center; flex-wrap:wrap; margin-bottom:6px; padding:8px 10px; border:1px solid var(--border); border-radius:10px; background:rgba(255,255,255,.03); justify-content:space-between; }
    .feStyleItem{ display:flex; align-items:center; gap:4px; font-size:11px; cursor:grab; padding:3px 6px; border-radius:8px; border:1px solid transparent; transition:all .15s; }
    .feStyleItem:hover{ background:rgba(255,255,255,.06); border-color:var(--border); }
    .feStyleItem.feSwatchDragOver{ border-color:rgba(59,130,246,.7); background:rgba(59,130,246,.15); box-shadow:0 0 8px rgba(59,130,246,.3); }
    .feStyleItem.feSwatchDragging{ opacity:.45; }
    .feStyleLabel{ font-size:10px; opacity:.65; letter-spacing:.3px; }
    .feColorSwatch{ width:26px; height:20px; border:1px solid rgba(255,255,255,.15); border-radius:5px; cursor:pointer; padding:0; }
    .feStyleSep{ width:1px; height:22px; background:var(--border); flex-shrink:0; }
    .feEmojiOption:hover{ background:rgba(255,255,255,.12) !important; border-color:var(--accent) !important; }
    .dimmed > .row{ opacity: var(--dim); }
    .active > .row{ background: var(--active-bg) !important; border-color: var(--active-br) !important; }
.active > .row{opacity:1 !important;}
.active.dimmed > .row{opacity:1 !important;}
    .connected > .row{ background: var(--hl-bg) !important; border-color: var(--hl-br) !important; }
    .connectedParent > .row{ background: rgba(59,130,246,.09) !important; border-color: rgba(59,130,246,.35) !important; }
    body.brightMode .connectedParent > .row{ background: rgba(59,130,246,.06) !important; border-color: rgba(30,80,200,.30) !important; }
    .active.connectedParent > .row{ background: var(--active-bg) !important; border-color: var(--active-br) !important; }
    .active.connected > .row{ background: linear-gradient(90deg, var(--active-bg), var(--hl-bg)) !important; }

    /* Details panel */
    .details{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: linear-gradient(to bottom, rgba(255,255,255,.05), rgba(255,255,255,.03));
      display:flex;
      flex-direction: column;
      min-height:0;
      min-width:0;
    }
    .detailsHeader{
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.10);
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
    }
    .detailsHeader .name{ font-weight: 900; font-size: 13px; }
    .detailsHeader .meta{ font-family: var(--mono); color: var(--muted); font-size: 11px; }
    .detailsBody{
      padding: 10px 12px 12px;
      overflow: auto;
      min-height: 0;
      flex: 1 1 0;
    }
    .box{
 border: 1px solid var(--border);

      border: 1px solid var(--border);
      background: rgba(255,255,255,.04);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
    }
    .box h3{
      margin: 0 0 6px 0;
      font-size: 12px;
      color: var(--muted);
      font-weight: 900;
      letter-spacing: .2px;
      text-transform: uppercase;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    /* Collapsible detail sections */
    .detailSectionHead{ cursor:pointer; user-select:none; }
    .detailSectionHead::before{ content:''; display:inline-block; width:12px; font-size:10px; opacity:.5; transition:transform .15s; }
    .detailSection.collapsed .detailSectionHead::before{ transform:rotate(-90deg); }
    .detailSection.collapsed .detailSectionBody{ display:none; }
    .detailSectionHead:hover{ color:var(--text); }
    .kv{
      display:grid;
      grid-template-columns: 96px 1fr;
      gap: 6px 10px;
      font-size: 12px;
      align-items: start;
    }
    .k{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(155,176,230,.95);
      padding-top: 2px;
    }
    .v{ word-break: break-word; }

    .list{
      list-style:none;
      padding:0;
      margin: 8px 0 0 0;
      display:flex;
      flex-direction: column;
      gap: 6px;
    }
    .item{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 8px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: rgba(0,0,0,.10);
      cursor: pointer;
      user-select: none;
    }
/* Mapping row action icons (Details pane) */
.item{position:relative;}
.item .itemActions{margin-left:auto; display:flex; gap:6px; align-items:center; opacity:0; transition: opacity .12s ease;}
.item:hover .itemActions{opacity:1;}
.mapNote{flex: 1 1 100%; margin-left: 0; font-family: var(--mono); font-size: 11px; opacity:.78; overflow-wrap:anywhere;}

    .item:hover{
      border-color: rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
    }
    .pill{
      font-family: var(--mono);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(255,255,255,.04);
      flex: 0 0 auto;
    }
    .tag{
      font-family: var(--mono);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: rgba(232,238,252,.85);
      background: rgba(255,255,255,.05);
      flex: 0 0 auto;
      max-width: 190px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .empty{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* SVG edges */
    .edge{
 transition: opacity .14s ease;
 stroke-linecap: round;
 stroke-linejoin: round;
      fill: none;
      stroke: var(--line);
      stroke-width: 1.3;
      opacity: .95;
    }
    .edge.hl{
      stroke: var(--line-hl);
      stroke-width: 2.0;
      opacity: 1;
    }
    .edge.dimmed{ opacity: var(--dim); }
    .edge.fadeOut{ opacity: 0 !important; }
 .edge.active{
      stroke: var(--line-active);
      stroke-width: 2.4;
      opacity: 1;
    }
    .edgeMarker{ fill: var(--line); opacity: .95; }
    .edgeMarker.hl{ fill: var(--line-hl); opacity: 1; }
    .edgeMarker.active{ fill: var(--line-active); opacity: 1; }

    /* Editor layout */
    textarea{
      width: 100%;
      height: 100%;
      min-height: 0;
      resize: none;
      border: none;
      outline: none;
      background: rgba(0,0,0,.10);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      padding: 12px;
      tab-size: 2;
    }

    .ok{ color: #9be6b0; }
    .warn{ color: #f5d27b; }
    .err{ color: #ff9aa8; }

    /* Docs */
    .docsBody{
      padding: 24px;
    }
    .docsBody h2{
      margin: 20px 0 8px 0;
      font-size: 14px;
      scroll-margin-top: 8px;
    }
    .docsBody h2:first-of-type{ margin-top: 10px; }
    .docsBody h3{
      margin: 14px 0 6px 0;
      font-size: 13px;
      color: rgba(232,238,252,.92);
      scroll-margin-top: 8px;
    }
    .docsToc{ margin-bottom: 20px; padding: 14px 18px 12px; background: rgba(255,255,255,.03); border: 1px solid var(--border); border-radius: var(--radius); }
    .docsToc .tocTitle{ font-weight: 700; font-size: 11px; margin-bottom: 10px; color: rgba(232,238,252,.45); text-transform: uppercase; letter-spacing: .8px; }
    .docsToc .tocGrid{ display: grid; grid-template-columns: 1fr 1fr; gap: 2px 32px; }
    .docsToc .tocSection{ break-inside: avoid; padding: 3px 0; }
    .docsToc .tocSection a.main{ display: block; font-size: 12.5px; font-weight: 600; color: rgba(200,218,255,.9); text-decoration: none; padding: 2px 0; line-height: 1.45; }
    .docsToc .tocSection a.main:hover{ text-decoration: underline; color: rgba(140,180,255,1); }
    .docsToc .tocSection .tocSubs{ padding-left: 10px; border-left: 1px solid rgba(255,255,255,.06); margin: 1px 0 4px 4px; }
    .docsToc .tocSection .tocSubs a{ display: block; font-size: 11.5px; color: rgba(160,185,240,.55); text-decoration: none; padding: 1px 0; line-height: 1.45; }
    .docsToc .tocSection .tocSubs a:hover{ text-decoration: underline; color: rgba(140,180,255,.9); }
    body.brightMode .docsToc{ background: rgba(0,0,0,.025); }
    body.brightMode .docsToc .tocTitle{ color: #9ca3af; }
    body.brightMode .docsToc .tocSection a.main{ color: #1e40af; }
    body.brightMode .docsToc .tocSection a.main:hover{ color: #1d4ed8; }
    body.brightMode .docsToc .tocSection .tocSubs{ border-left-color: rgba(0,0,0,.08); }
    body.brightMode .docsToc .tocSection .tocSubs a{ color: #6b7fad; }
    body.brightMode .docsToc .tocSection .tocSubs a:hover{ color: #1d4ed8; }
    .docsBody p, .docsBody li{
      color: rgba(232,238,252,.86);
      font-size: 12.5px;
      line-height: 1.55;
    }
    .docsBody code{
      font-family: var(--mono);
      font-size: 11.5px;
      background: rgba(255,255,255,.06);
      padding: 1px 5px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.10);
    }
    .docsBody pre{
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
      overflow: auto;
    }
    .docsBody pre code{
      background: transparent;
      border: none;
      padding: 0;
      border-radius: 0;
    }

    @media (max-width: 1180px){
      .viewerGrid[data-panel="right"]{ grid-template-columns: 1fr; grid-template-rows: 1fr auto; }
      .viewerGrid[data-panel="right"] .details{ max-height: 38vh; min-height: 120px; }
      .viewerGrid[data-panel="right"] .resizeHandle{ display: none; }
      .viewerGrid[data-panel="right"] .resizeHandleH{ display: block; }
      .viewerGrid[data-panel="left"]{ grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      .viewerGrid[data-panel="left"] .details{ max-height: 38vh; min-height: 120px; order: -1; }
      .viewerGrid[data-panel="left"] .resizeHandle{ display: none; }
      .viewerGrid[data-panel="left"] .resizeHandleH{ display: block; }
      .columnsRow{ grid-auto-columns: minmax(280px, 1fr); }
    }
    @media (max-width: 768px){
      header{ padding: 8px 10px; }
      main{ padding: 8px; }
      .viewerGrid{ gap: 8px; }
      .viewerGrid[data-panel="float"] .details{ width: calc(100vw - 20px); right: 10px; bottom: 10px; }
    }

    
    .inp{
      width: 100%;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.16);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      outline: none;
    }
    
/* Improved select dropdown readability */
select.inp{ color: var(--text); background: rgba(0,0,0,.18); }
select.inp option{ background: #16203a; color: #e8eefc; }
select.inp option:checked{ background: #2b3a5c; color: #ffffff; }
select.inp option:disabled{ color: rgba(155,176,230,.95); }
.inp:focus{ border-color: rgba(59,130,246,.55); box-shadow: 0 0 0 2px rgba(59,130,246,.12); }
    .mapCard{
      border: 1px solid var(--border);
      background: rgba(0,0,0,.10);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
    }
    .mapCard.catItem{ transition: border-color .15s, box-shadow .15s; }
    .mapCard.catItem:not(.catEditing):hover{ border-color: rgba(59,130,246,.35); box-shadow: 0 0 0 1px rgba(59,130,246,.12); }
    .mapCard.catEditing{ border-color: rgba(59,130,246,.5); box-shadow: 0 0 0 2px rgba(59,130,246,.12); }
    .catEditActive .catItem:not(.catEditing){ opacity: 0.3; pointer-events: none; filter: grayscale(.4); transition: opacity .2s, filter .2s; }
    .catEditActive .catItem.catEditing{ position:relative; z-index:1; }
    .mapCard .topRow{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .mapCard .topRow .mini{ font-family: var(--mono); font-size: 11px; color: var(--muted); }
    .mapCard details{ margin-top: 8px; }
    .mapCard summary{ cursor:pointer; color: rgba(232,238,252,.86); font-size:12px; }

  

/* --- Enhancements (2026-02): ports, overflow, column wrapping, popovers --- */
.row .port{position:absolute; top:50%; transform:translateY(-50%); width:10px; height:10px; border-radius:999px;
  background: rgba(59,130,246,.20); border:1px solid rgba(59,130,246,.55); opacity:0; pointer-events:none;}
.row .port.portL{left:-6px;}
.row .port.portR{right:-6px;}
.node.field .row .port{background: rgba(255,208,92,.14); border-color: rgba(255,208,92,.45);}
.row:hover .port{opacity:.35;}

/* Details panel: prevent ugly overflow */

/* --- Mapping list layout tweaks (v6_4): always break field name + prettier notes --- */
.item{flex-wrap:wrap; align-items:flex-start; gap:8px;}
.item .txt{flex:1 1 100%; min-width:0; margin-top:2px; font-weight:800;}
.item .route{flex:1 1 100%; margin-left:0; margin-top:6px; font-family:var(--mono); font-size:11px; opacity:.72; overflow-wrap:anywhere; word-break:break-word;}
.mapNote{flex:1 1 100%; margin-left:0; margin-top:6px; padding:6px 8px; border-radius:10px; border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.10); color:rgba(232,238,252,.82); font-size:11px; line-height:1.35; overflow-wrap:anywhere;}
.mapNote::before{content:'Note'; display:inline-block; margin-right:6px; font-weight:900; color:rgba(155,176,230,.95);}
.item{flex-wrap:wrap; align-items:flex-start; gap:8px;}
.item .txt{min-width: 160px; flex: 1 1 220px; overflow:hidden; text-overflow: ellipsis;}
.item .route{flex: 1 1 100%; margin-left: 0; font-family: var(--mono); font-size: 11px; opacity: .75;
  overflow-wrap:anywhere; word-break: break-word;}
.tag{max-width: 260px;}

/* Column wrap mode (stack columns under each other) */
.columnsRow.wrap{grid-auto-flow: row; grid-template-columns: repeat(auto-fit, minmax(var(--col-width, 300px), 1fr)); min-width: 0 !important;}
.panel.hiddenCol{display:none !important;}

/* Popover + modal */
.popover{position:absolute; top: 44px; right: 14px; z-index: 120; width: min(520px, 92vw);
  border:1px solid var(--border); border-radius: 14px; background: rgba(11,16,32,.92);
  box-shadow: 0 20px 60px rgba(0,0,0,.45); backdrop-filter: blur(10px); padding: 10px; display:none;}
.popover.active{display:block;}
.popover .popTitle{font-weight: 900; font-size: 12px; margin: 2px 0 10px 0; color: rgba(232,238,252,.92);} 
.popItem{display:flex; align-items:center; gap:8px; padding: 8px; border-radius: 12px; border:1px solid transparent; background: rgba(255,255,255,.03);} 
.popItem:hover{border-color: rgba(255,255,255,.10); background: rgba(255,255,255,.05);} 
.popItem.dragOver{border-color: rgba(59,130,246,.6); box-shadow: 0 -2px 0 0 rgba(59,130,246,.7);}
.popItem .grow{flex:1 1 auto; min-width: 0;} 
.popItem input[type='checkbox']{accent-color:#3b82f6;}

.modalMask{position:fixed; inset:0; background: rgba(0,0,0,.55); z-index: 200; display:none;}
.modalMask.active{display:block;}
.modalMask.elevated{z-index: 300;}
.modal{position:fixed; inset: 7vh 14px auto 14px; max-width: 980px; margin: 0 auto; z-index: 210;
  border:1px solid var(--border); border-radius: 16px; background: rgba(11,16,32,.96);
  box-shadow: 0 24px 80px rgba(0,0,0,.55); display:none; overflow:hidden;}
.modal.active{display:block;}
.modal.elevated{z-index: 310;}
.modalMask.elevated-2{z-index: 400;}
.modal.elevated-2{z-index: 410;}
.modalHeader{display:flex; justify-content:space-between; align-items:center; gap:10px; padding: 12px 14px;
  border-bottom:1px solid var(--border); background: rgba(255,255,255,.03);} 
.modalHeader .title{font-weight:900; font-size: 13px;}
.modalBody{padding: 12px 14px; max-height: 72vh; overflow:auto;}
.modalBody h4{font-size:13px; margin:0; color: rgba(232,238,252,.95);}
body.brightMode .modalBody h4{color:#111827;}



.modalBody code#createIdPreview{display:inline-block; padding:6px 8px; border-radius:10px; border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.12); color: rgba(232,238,252,.92); overflow-wrap:anywhere;}
/* --- Inline Editor Mode (2026-02) --- */
#editorOverlay{position:absolute; inset:0; z-index:30; pointer-events:none;}
/* Prevent editor overlay from affecting scrollable extents (avoids surprise scrollbars) */
#editorOverlay{overflow:hidden; contain: layout paint;}
/* Keep layout stable when scrollbars appear/disappear */
.columnsScroller{scrollbar-gutter: stable both-edges;}

body.editorMode #editorOverlay{pointer-events:none;}








/* Editor-mode: overlay row actions without changing row height */
body.editorMode .row{position:relative;}
body.editorMode .row .rowActions{position:absolute; right:8px; top:50%; transform:translateY(-50%);
  margin-left:0; opacity:0; pointer-events:none;}
body.editorMode .row:hover .rowActions{opacity:1; pointer-events:auto;}

/* Editor-mode: row action buttons must overlay (no layout shift, no premature ellipsis) */
body.editorMode .row{position:relative;}
body.editorMode .row .rowActions{
  position:absolute !important;
  right:6px; top:0; bottom:0;
  transform: translateY(1px);
  margin:0 !important; padding:0 !important;
  display:none !important; opacity:1 !important;
  gap:4px; align-items:center; justify-content:flex-end;
  pointer-events:none;
}
body.editorMode .row:hover .rowActions{display:flex !important; pointer-events:auto;}
body.editorMode .row.menuOpen .rowActions{display:flex !important; pointer-events:auto; opacity:1 !important;}
body.editorMode .active > .row .rowActions{display:flex !important; pointer-events:auto; opacity:1 !important;}

/* Row hover actions */
.row .rowActions{margin-left:8px; display:flex; gap:6px; align-items:center; opacity:0; transition: opacity .12s ease;}
body.editorMode .row:hover .rowActions{opacity:1;}
.miniBtn{border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.14); color: rgba(232,238,252,.92);
 width:18px; height:18px; border-radius:7px; cursor:pointer; font-weight:900; font-size:11px;
 line-height:18px; padding:0; text-align:center;
 display:flex; align-items:center; justify-content:center; flex:0 0 auto;}
body.editorMode .miniBtn{padding-top:1px;}
.miniBtn:hover{background: rgba(255,255,255,.08);}
.miniBtn.danger{border-color: rgba(255,154,168,.38); background: rgba(255,154,168,.10);}
.miniBtn.danger:hover{background: rgba(255,154,168,.18);}

/* Tag chips (replace field/group badges) */
.tagStrip{display:flex;gap:6px;align-items:center;flex:0 0 auto;}
.tagChip{font-family: var(--mono); font-size: 10px; padding:2px 6px; border-radius:999px; border:1px solid rgba(59,130,246,.55); background: rgba(59,130,246,.18); color: rgba(232,238,252,.95); line-height:1;}
.tagChip[data-color]{border-color: color-mix(in srgb, var(--c) 70%, rgba(255,255,255,.12)); background: color-mix(in srgb, var(--c) 22%, transparent);}
/* Inline action menu */
.miniMenu{position:absolute; right: 6px; top: 30px; z-index: 999; border:1px solid rgba(255,255,255,.14); border-radius: 12px; background: rgba(11,16,32,.95); box-shadow: 0 18px 50px rgba(0,0,0,.45); padding: 6px; display:none; gap:6px;}
.miniMenu.active{display:flex;}
.miniMenu .miniBtn{width:auto;padding:6px 8px;border-radius:10px;}

/* --- Context menu (vertical, viewport-anchored; avoids clipping in scroll containers) --- */
.ctxMenu{position:fixed; z-index: 2500; min-width: 176px; max-width: 280px;
  border:1px solid rgba(255,255,255,.14); border-radius: 14px;
  background: rgba(11,16,32,.96); backdrop-filter: blur(10px);
  box-shadow: 0 18px 55px rgba(0,0,0,.55);
  padding: 6px; display:flex; flex-direction: column; gap: 4px;
}
.ctxItem{display:flex; align-items:center; gap:10px; width:100%;
  border:1px solid transparent; background: rgba(255,255,255,.03);
  color: rgba(232,238,252,.95);
  padding: 9px 10px; border-radius: 12px; cursor:pointer;
  font-size: 12px; text-align:left;
}
.ctxItem:hover{background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.10);}
.ctxItem:disabled{opacity:.45; cursor: not-allowed;}
.ctxItem .ico{width:16px; text-align:center; opacity:.9; flex: 0 0 auto;}
.ctxItem.danger{background: rgba(255,154,168,.08); border-color: rgba(255,154,168,.20);}
.ctxItem.danger:hover{background: rgba(255,154,168,.16); border-color: rgba(255,154,168,.38);}
.ctxSep{height:1px; background: rgba(255,255,255,.10); margin: 4px 2px;}
/* Hover menus */

/* Tag create swatches */
.swatch{width:22px;height:22px;border-radius:8px;border:1px solid rgba(255,255,255,.18);cursor:pointer;box-shadow:0 10px 24px rgba(0,0,0,.25);}
.swatch:hover{transform: translateY(-1px);}
.swatch.sel{outline:2px solid rgba(255,255,255,.60); outline-offset:2px;}



/* Drag & drop */
body.editorMode .node.field .row{cursor: grab;}
body.editorMode .node.field .row:active{cursor: grabbing;}
.row.dropTarget{outline: 2px solid rgba(59,130,246,.80); background: rgba(59,130,246,.12);}
.row.illegal{cursor:not-allowed !important;}

/* Make SVG clickable in editor mode */
#svgOverlay{pointer-events:none;}
body.editorMode #svgOverlay{pointer-events:none;}
body.editorMode .edge{
 transition: opacity .14s ease;
 stroke-linecap: round;
 stroke-linejoin: round;pointer-events:none;}
body.editorMode .edge.selected{stroke: rgba(255,208,92,.98); stroke-width: 3.0;}


/* Multi-value custom attribute checklist */
.multiValsActions{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;}
.multiValsActions .linkBtn{background:transparent;border:1px solid rgba(255,255,255,.12);color:rgba(232,238,252,.9);padding:5px 8px;border-radius:10px;cursor:pointer;font-size:11px;}
.multiValsActions .linkBtn:hover{background:rgba(255,255,255,.06);}

.multiVals{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px;}
.multiVals label{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border:1px solid rgba(255,255,255,.10);border-radius:10px;background:rgba(0,0,0,.10);cursor:pointer;font-size:12px;}
.multiVals input[type=checkbox]{accent-color:#3b82f6;}


/* v6_5+ line-break spacer to force mapped field label onto a new row */
.itemBreak{flex:0 0 100% !important;width:100% !important;height:0 !important;display:block !important;margin:0 !important;padding:0 !important;}

/* HIT-TEST OVERRIDES v7_3 */
#svgOverlay{pointer-events:none !important;}
#edgesLayer{pointer-events:none;}
.edge{
 transition: opacity .14s ease;pointer-events:stroke;}
body.editorMode .edge{
 transition: opacity .14s ease;pointer-events:stroke;}

.box.clickable{cursor:pointer;}
.box.clickable:hover{background: rgba(255,255,255,.06);}
body.brightMode .box.clickable:hover{background: rgba(0,0,0,.05);}

/* --- Drag ghost (visual-only) --- */
#dragGhost{
  position:fixed; z-index:3000; pointer-events:none; display:none;
  background:rgba(11,16,32,.96);
  border:1px solid rgba(255,255,255,.14);
  border-radius:10px; padding:6px 8px; color:#e8eefc;
  font:12px var(--sans); box-shadow:0 12px 32px rgba(0,0,0,.45);
  max-width:480px; opacity:.98;
}
#dragGhost .top {display:flex; align-items:center; gap:8px; margin-bottom:6px;}
#dragGhost .chip {
  font-family: var(--mono, ui-monospace, Consolas, monospace);
  font-size:10px; padding:2px 6px; border-radius:999px;
  border:1px solid rgba(255,255,255,.22); line-height:1;
  background:rgba(255,255,255,.06);
}
#dragGhost .chip.move { border-color:#3b82f6; background:rgba(59,130,246,.20); color:#fff; }
#dragGhost .chip.copy { border-color:#22c55e; background:rgba(34,197,94,.18); color:#fff; }
#dragGhost .chip.copyPlus { border-color:#84cc16; background:rgba(132,204,22,.20); color:#fff; }
#dragGhost .chip.map  { border-color:#f59e0b; background:rgba(245,158,11,.18); color:#fff; }
#dragGhost .label { font-weight:900; letter-spacing:.2px; }
#dragGhost .body  { opacity:.92; }
#dragGhost .multiBadge {
  font-family: var(--mono, ui-monospace, Consolas, monospace);
  font-size:10px; font-weight:800; padding:2px 5px; border-radius:999px;
  background:rgba(255,255,255,.12); color:rgba(255,255,255,.85);
  line-height:1; display:none;
}


/* === Empty-column drop placeholder (v20.5) === */
body.editorMode .panel[data-empty="1"].dropOpen .emptyDrop { display: block; }
.emptyDrop { display: none;
  margin: 10px; border: 2px dashed rgba(59,130,246,.55); border-radius: 10px;
  padding: 12px 10px; color: rgba(232,238,252,.88); background: rgba(59,130,246,.08);
  font-size: 12px; text-align: center; user-select: none;
}
.emptyDrop.copy { border-color:#22c55e; background: rgba(34,197,94,.10); }
.emptyDrop.move { border-color:#3b82f6; background: rgba(59,130,246,.10); }


/* --- v23 header polish --- */
.brand .logo{filter:drop-shadow(0 2px 6px rgba(0,0,0,.25));}
.modeToggle.prominent{border-color: rgba(255,208,92,.55); background: rgba(255,208,92,.16);} 
.modeToggle.prominent:hover{background: rgba(255,208,92,.22);} 
.modeToggle.prominent input{accent-color:#f59e0b;}
#viewerControls{display:flex; flex-direction: column; gap:6px; margin-top:12px; padding-top:10px; border-top:1px solid var(--border);}

/* --- Toolbar Row 1: always-visible filter bar --- */
.tbRow1{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:6px 10px;border:1px solid var(--border);border-radius:12px;background:var(--panel);}
.tbRow1 .search{flex:0 1 260px;}
.tbFilterOpts{display:flex;gap:6px;align-items:center;flex-wrap:nowrap;padding:2px 8px;border-left:1px solid var(--border);margin-left:2px;}
.tbFilterOpts .toggle, .tbFilterOpts .btn{ font-size:11px; padding:5px 8px; }
.fbGroup{
  display:flex; align-items:center; gap:3px;
  padding:2px 3px; border-radius:9px;
  background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06);
}
.fbGroup .fbOpt{
  font-size:10px; padding:4px 8px; border-radius:7px; border:1px solid transparent;
  background:transparent; color:var(--muted); cursor:pointer; user-select:none;
  transition:all .12s; white-space:nowrap; font-weight:500; letter-spacing:.2px;
}
.fbGroup .fbOpt:hover{ color:var(--text); background:rgba(255,255,255,.06); }
.fbGroup .fbOpt.active{
  background:rgba(59,130,246,.15); border-color:rgba(59,130,246,.4);
  color:var(--text); font-weight:600;
}
.fbGroup .fbOpt.active.fbWarn{
  background:rgba(251,146,60,.12); border-color:rgba(251,146,60,.35);
}
.fbGroup .fbOpt.active.fbHide{
  background:rgba(239,68,68,.10); border-color:rgba(239,68,68,.30);
  color:rgba(255,180,180,.9);
}
.fbSep{ width:1px; align-self:stretch; background:var(--border); margin:0 2px; flex-shrink:0; }
.fbToggle{
  font-size:10.5px; padding:4px 9px; border-radius:8px; border:1px solid var(--border);
  background:rgba(255,255,255,.03); color:var(--muted); cursor:pointer; user-select:none;
  transition:all .12s; white-space:nowrap; display:inline-flex; align-items:center; gap:5px;
}
.fbToggle:hover{ background:rgba(255,255,255,.06); color:var(--text); }
.fbToggle.active{ background:rgba(59,130,246,.12); border-color:rgba(59,130,246,.35); color:var(--text); }
.fbToggle input{ display:none; }
.fbToggle .fbDot{
  width:6px; height:6px; border-radius:50%; background:var(--muted); transition:background .12s;
}
.fbToggle.active .fbDot{ background:rgba(59,130,246,.9); }
.fbClear{
  font-size:10px; padding:4px 10px; border-radius:7px; border:1px solid rgba(255,255,255,.08);
  background:rgba(255,255,255,.03); color:var(--muted); cursor:pointer; user-select:none;
  transition:all .12s; white-space:nowrap; font-weight:500; letter-spacing:.2px;
}
.fbClear:hover{ background:rgba(239,68,68,.10); border-color:rgba(239,68,68,.25); color:rgba(255,180,180,.9); }
body.brightMode .fbGroup{ background:rgba(0,0,0,.02); border-color:rgba(0,0,0,.06); }
body.brightMode .fbGroup .fbOpt:hover{ background:rgba(0,0,0,.04); color:#1e293b; }
body.brightMode .fbGroup .fbOpt.active{ background:rgba(59,130,246,.08); border-color:rgba(59,130,246,.3); color:#1e293b; }
body.brightMode .fbGroup .fbOpt.active.fbHide{ background:rgba(239,68,68,.08); border-color:rgba(239,68,68,.25); color:#b91c1c; }
body.brightMode .fbGroup .fbOpt.active.fbWarn{ background:rgba(251,146,60,.08); border-color:rgba(251,146,60,.25); color:#9a3412; }
body.brightMode .fbToggle{ background:rgba(0,0,0,.02); border-color:rgba(0,0,0,.08); color:#64748b; }
body.brightMode .fbToggle:hover{ background:rgba(0,0,0,.04); color:#1e293b; }
body.brightMode .fbToggle.active{ background:rgba(59,130,246,.06); border-color:rgba(59,130,246,.25); color:#1e293b; }
body.brightMode .fbToggle.active .fbDot{ background:rgba(37,99,235,.8); }
body.brightMode .fbClear{ background:rgba(0,0,0,.02); border-color:rgba(0,0,0,.06); color:#64748b; }
body.brightMode .fbClear:hover{ background:rgba(239,68,68,.06); border-color:rgba(239,68,68,.2); color:#b91c1c; }
.filterChip:hover{filter:brightness(1.3);box-shadow:0 0 0 1px rgba(255,255,255,.15);}

/* --- Toolbar Row 2: icon toolbar --- */
.tbRow2{display:flex;gap:4px;align-items:center;flex-wrap:wrap;}
.tbBtn{position:relative;display:inline-flex;align-items:center;gap:5px;padding:5px 10px;border-radius:8px;background:transparent;color:var(--muted);font-size:11px;font-weight:700;letter-spacing:.3px;border:1px solid transparent;cursor:pointer;transition:all .15s;white-space:nowrap;}
.tbBtn:hover{background:rgba(255,255,255,.06);border-color:var(--border);color:var(--text);}
.tbBtn.active{background:rgba(59,130,246,.12);border-color:rgba(59,130,246,.35);color:var(--text);}
.tbBtn .tbIcon{font-size:13px;line-height:1;opacity:.7;}
.tbBtn:hover .tbIcon{opacity:1;}
.tbSep{width:1px;height:20px;background:var(--border);margin:0 4px;flex-shrink:0;}

/* --- Toolbar popovers --- */
.tbPop{display:none;position:absolute;top:calc(100% + 6px);left:0;min-width:200px;padding:10px 14px;border-radius:12px;border:1px solid var(--border);background:rgba(16,20,34,.97);box-shadow:0 8px 32px rgba(0,0,0,.5);z-index:200;flex-direction:column;gap:8px;}
.tbPop.open{display:flex;}
.tbPop .tbPopTitle{font-size:10px;font-weight:900;letter-spacing:.5px;text-transform:uppercase;color:var(--muted);margin-bottom:2px;}
.tbPop .tbPopRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.selMenuActions{ display:flex; flex-direction:column; gap:4px; }
.selActionBtn{ display:flex; align-items:center; gap:7px; font-size:12px; }
.selActionBtn svg{ flex-shrink:0; opacity:.6; }


/* Brand */
.brand h1{display:block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:45vw; margin:0;}


/* v23.2.3b: ensure quick toolbar is visible and spaced */
#toolbarQuick{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 2px 0}
#toolbarQuick .btn{font-weight:700}

/* Range slider in toolbar */
.sliderGroup{display:flex;align-items:center;gap:8px;font-size:11px;color:var(--muted);white-space:nowrap;}
.sliderGroup input[type=range]{width:90px;accent-color:#3b82f6;cursor:pointer;}
.sliderGroup .sliderVal{font-family:var(--mono);font-size:10px;min-width:32px;text-align:right;color:var(--text);}


/* --- Cancel and Bin drop zones (v24.2) --- */
.dragDropZone {
  position: fixed;
  bottom: 20px;
  z-index: 9999;
  padding: 16px 24px;
  border-radius: 12px;
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.3px;
  user-select: none;
  pointer-events: auto;
  transition: all 0.2s ease;
  opacity: 0;
  transform: translateY(10px) scale(0.95);
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
}

.dragDropZone.visible {
  opacity: 1;
  transform: translateY(0) scale(1);
}

.dragDropZone.dragover {
  transform: translateY(0) scale(1.05);
  box-shadow: 0 12px 32px rgba(0,0,0,.5);
}

#cancelZone {
  left: 20px;
  background: linear-gradient(135deg, rgba(148, 163, 184, 0.32), rgba(100, 116, 139, 0.26));
  border: 2px solid rgba(148, 163, 184, 0.7);
  color: rgba(226, 232, 240, 0.95);
  backdrop-filter: blur(12px);
}

#cancelZone.dragover {
  background: linear-gradient(135deg, rgba(148, 163, 184, 0.45), rgba(100, 116, 139, 0.38));
  border-color: rgba(148, 163, 184, 0.90);
}

#binZone {
  right: 20px;
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.35), rgba(220, 38, 38, 0.28));
  border: 2px solid rgba(239, 68, 68, 0.75);
  color: rgba(254, 226, 226, 0.95);
  backdrop-filter: blur(12px);
}

#binZone.dragover {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.48), rgba(220, 38, 38, 0.40));
  border-color: rgba(239, 68, 68, 0.95);
}

/*  Command Palette  */
.cmdPaletteMask{ position:fixed;inset:0;background:rgba(0,0,0,.45);z-index:9999;display:none;align-items:flex-start;justify-content:center;padding-top:min(20vh,140px); }
.cmdPaletteMask.active{ display:flex; }
.cmdPalette{ background:rgba(11,16,32,.97);border:1px solid var(--border);border-radius:14px;width:min(520px,92vw);max-height:min(440px,60vh);display:flex;flex-direction:column;box-shadow:0 16px 64px rgba(0,0,0,.5),0 0 0 1px rgba(255,255,255,.05);overflow:hidden; }
body.brightMode .cmdPalette{ background:#fff;border-color:rgba(0,0,0,.15);box-shadow:0 16px 64px rgba(0,0,0,.18); }
.cmdPaletteInput{ background:transparent;border:none;border-bottom:1px solid var(--border);color:var(--text);font-size:14px;padding:14px 16px;outline:none;width:100%;font-family:inherit; }
.cmdPaletteInput::placeholder{ color:var(--muted);opacity:.5; }
.cmdPaletteResults{ overflow-y:auto;padding:6px;flex:1;min-height:0; }
.cmdPaletteResults:empty::after{ content:'No results';display:block;text-align:center;padding:20px;opacity:.35;font-size:13px; }
.cmdCat{ font-size:10px;text-transform:uppercase;letter-spacing:.08em;opacity:.4;padding:8px 10px 4px;font-weight:600; }
.cmdItem{ display:flex;align-items:center;gap:10px;padding:8px 12px;border-radius:8px;cursor:pointer;font-size:13px;transition:background .1s; }
.cmdItem:hover,.cmdItem.active{ background:rgba(59,130,246,.15); }
body.brightMode .cmdItem:hover, body.brightMode .cmdItem.active{ background:rgba(59,130,246,.1); }
.cmdItem .cmdIcon{ width:20px;text-align:center;font-size:14px;flex-shrink:0;opacity:.7; }
.cmdItem .cmdLabel{ flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap; }
.cmdItem .cmdLabel mark{ background:rgba(59,130,246,.35);color:inherit;border-radius:2px;padding:0 1px; }
body.brightMode .cmdItem .cmdLabel mark{ background:rgba(59,130,246,.2); }
.cmdItem .cmdHint{ font-size:10px;opacity:.4;flex-shrink:0;white-space:nowrap; }
.cmdItem .cmdKbd{ font-size:10px;opacity:.45;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.1);border-radius:4px;padding:1px 5px;font-family:var(--mono);flex-shrink:0; }
body.brightMode .cmdItem .cmdKbd{ background:rgba(0,0,0,.06);border-color:rgba(0,0,0,.12); }
.cmdPaletteFooter{ border-top:1px solid var(--border);padding:6px 14px;display:flex;gap:12px;font-size:10px;opacity:.4;align-items:center; }
.cmdPaletteFooter kbd{ font-family:var(--mono);background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.08);border-radius:3px;padding:0 4px;font-size:9px; }
body.brightMode .cmdPaletteFooter kbd{ background:rgba(0,0,0,.06);border-color:rgba(0,0,0,.1); }

/* Suppress all hover effects during marquee/lasso selection */
.lassoActive * { pointer-events: none !important; }


</style>
</head>
<body>
<header>
<div class="top">
<div class="brand">
<h1>Dunnode</h1>
</div>
<div class="topCenter">
<input id="projectTitle" type="text" placeholder="New Project" title="Project title (click to edit)"/>
<button class="btn" id="projectInfoBtn" title="Project properties" style="padding:4px 8px;font-size:13px;min-width:0;line-height:1;"></button>
</div>
<div class="topRight">
<button class="btn" id="newMappingBtn" title="Start a new blank project">New project</button>
<button class="btn" id="openProjectBtn" title="Upload and open a project JSON file">Open project</button>
<button class="btn" id="saveProjectBtn" title="Download the current project as JSON">Save project</button>
<label class="toggle modeToggle prominent" title="Toggle inline editing controls in the viewer">
<input id="editorModeToggle" type="checkbox"/>
<span>Editor mode</span>
</label>
<button class="btn" id="brightModeBtn" title="Toggle bright/dark mode" style="width:34px;height:34px;padding:0;display:inline-flex;align-items:center;justify-content:center;"></button>
<button class="btn" id="cmdPaletteBtn" title="Command palette (Ctrl+K)" style="width:34px;height:34px;padding:0;display:inline-flex;align-items:center;justify-content:center;font-size:15px;"></button>
</div>
</div>
<!-- Viewer controls: two-row toolbar -->
<div id="viewerControls">

<!-- Row 1: Icon toolbar with popovers -->
<div class="tbRow2">

<!-- Filter bar toggle -->
<div class="tbBtn" id="tbFilterToggle" title="Show/hide filter bar">
<span class="tbIcon"></span>Filter<span id="filterBadge" style="display:none;background:#3b82f6;color:#fff;font-size:9px;padding:1px 5px;border-radius:8px;font-weight:700;"></span>
</div>

<div class="tbSep"></div>

<!-- Graph -->
<div class="tbBtn" id="tbGraph" title="Arrow & graph display options">
<span class="tbIcon"></span>Graph
<div class="tbPop" id="tbPopGraph" style="min-width:260px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Show arrows</div>
<div class="dockSelector" id="arrowModeSelector">
<button class="dockOpt active" data-amode="selected" title="Only arrows for selected/hovered nodes">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="currentColor" stroke-width="1.5"/><polygon points="10,2.5 14,5 10,7.5" fill="currentColor"/><circle cx="2" cy="5" r="1.5" fill="currentColor" opacity=".5"/></svg>
<span>Selected</span>
</button>
<button class="dockOpt" data-amode="all" title="Show all arrows at once">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="3" x2="11" y2="3" stroke="currentColor" stroke-width="1.2"/><polygon points="10,.5 14,3 10,5.5" fill="currentColor"/><line x1="1" y1="7" x2="11" y2="7" stroke="currentColor" stroke-width="1.2" opacity=".5"/><polygon points="10,4.5 14,7 10,9.5" fill="currentColor" opacity=".5"/></svg>
<span>All</span>
</button>
<button class="dockOpt" data-amode="off" title="Hide all arrows">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="currentColor" stroke-width="1.5" opacity=".2"/><polygon points="10,2.5 14,5 10,7.5" fill="currentColor" opacity=".2"/><line x1="2" y1="2" x2="13" y2="8" stroke="currentColor" stroke-width="1.5" opacity=".6"/></svg>
<span>Off</span>
</button>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0 4px;"></div>
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Arrow scope</div>
<div style="display:flex;gap:6px;flex-wrap:wrap;">
<label class="toggle" style="flex:1;" title="Show arrows within the same column"><input id="showSameColToggle" type="checkbox" checked/>Same-column</label>
<label class="toggle" style="flex:1;" title="Show arrows across non-adjacent columns"><input id="showDistantToggle" type="checkbox" checked/>Distant</label>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0 4px;"></div>
<div style="font-size:10px;opacity:.5;margin-bottom:4px;">Color mappings by</div>
<div class="dockSelector" id="edgeColorSelector">
<button class="dockOpt active" data-scheme="" title="No auto-coloring (manual / filter only)">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="13" y2="5" stroke="currentColor" stroke-width="1.5" opacity=".4"/><polygon points="12,2 16,5 12,8" fill="currentColor" opacity=".4"/></svg>
<span>Off</span>
</button>
<button class="dockOpt" data-scheme="cardinality" title="Color by cardinality (1:1, 1:N, N:1, N:M)">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="13" y2="5" stroke="#f59e0b" stroke-width="1.5"/><polygon points="12,2 16,5 12,8" fill="#f59e0b"/></svg>
<span>Card.</span>
</button>
<button class="dockOpt" data-scheme="transform" title="Color by first transform">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="13" y2="5" stroke="#8b5cf6" stroke-width="1.5"/><polygon points="12,2 16,5 12,8" fill="#8b5cf6"/></svg>
<span>Xform</span>
</button>
<button class="dockOpt" data-scheme="srcTag" title="Color by source tag (highest priority)">
<svg width="16" height="10" viewBox="0 0 16 10"><circle cx="2.5" cy="5" r="2.5" fill="#22c55e"/><line x1="5" y1="5" x2="13" y2="5" stroke="#22c55e" stroke-width="1.5"/><polygon points="12,2 16,5 12,8" fill="#22c55e"/></svg>
<span>Src </span>
</button>
<button class="dockOpt" data-scheme="tgtTag" title="Color by target tag (highest priority)">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="#06b6d4" stroke-width="1.5"/><polygon points="10,2 14,5 10,8" fill="#06b6d4"/><circle cx="2.5" cy="5" r="2.5" fill="none" stroke="#06b6d4" stroke-width="1"/></svg>
<span>Tgt </span>
</button>
</div>
<div id="edgeColorLegend" style="display:none;margin-top:6px;font-size:10px;"></div>
</div>
</div>
</div>

<!-- Layout -->
<div class="tbBtn" id="tbLayout" title="Column layout & details panel position">
<span class="tbIcon"></span>Layout
<div class="tbPop" id="tbPopLayout" style="min-width:260px;">
<div class="layoutSection">
<div class="layoutSectionTitle">Columns</div>
<label class="toggle" title="Wrap columns into rows"><input id="wrapToggle" type="checkbox"/>Wrap columns</label>
<div class="layoutSliderRow">
<span class="layoutSliderLabel">Width</span>
<input id="colWidthSlider" type="range" min="200" max="600" step="10" value="300"/>
<span class="layoutSliderVal" id="colWidthVal">300</span>
<span class="layoutReset" id="colWidthReset" title="Reset to default (300)"></span>
</div>
<div class="layoutSliderRow">
<span class="layoutSliderLabel">Gap</span>
<input id="colGapSlider" type="range" min="0" max="60" step="2" value="20"/>
<span class="layoutSliderVal" id="colGapVal">20</span>
<span class="layoutReset" id="colGapReset" title="Reset to default (20)"></span>
</div>
<div class="layoutSliderRow">
<span class="layoutSliderLabel">Zoom</span>
<input id="colZoomSlider" type="range" min="50" max="150" step="5" value="100"/>
<span class="layoutSliderVal" id="colZoomVal">100%</span>
<span class="layoutReset" id="colZoomReset" title="Reset to default (100%)"></span>
</div>
</div>
<div class="layoutSection">
<div class="layoutSectionTitle">Node labels</div>
<label class="toggle" title="Show tag pills on nodes"><input id="showTagPillsToggle" type="checkbox" checked/>Display tags</label>
<label class="toggle" title="Show custom attribute value pills on nodes"><input id="showAttrPillsToggle" type="checkbox" checked/>Display attributes</label>
</div>
<div class="layoutSection">
<div class="layoutSectionTitle">Node colors</div>
<div style="font-size:10px;opacity:.5;margin-bottom:4px;">Background tint inheritance</div>
<div class="dockSelector" id="nodeColorModeSelector">
<button class="dockOpt active" data-ncm="all" title="All levels: node  group  column">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="14" height="3" rx="1" fill="currentColor" opacity=".25"/><rect x="2" y="5" width="12" height="3" rx="1" fill="currentColor" opacity=".45"/><rect x="3" y="9" width="10" height="3.5" rx="1" fill="currentColor" opacity=".75"/></svg>
<span>All</span>
</button>
<button class="dockOpt" data-ncm="groups" title="Column + group colors only (no field override)">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="14" height="3" rx="1" fill="currentColor" opacity=".25"/><rect x="2" y="5" width="12" height="3" rx="1" fill="currentColor" opacity=".45"/><rect x="3" y="9" width="10" height="3.5" rx="1" fill="none" stroke="currentColor" stroke-width=".5" stroke-dasharray="1.5 1" opacity=".3"/></svg>
<span>Groups</span>
</button>
<button class="dockOpt" data-ncm="column" title="Column color only (no group/field override)">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="14" height="3" rx="1" fill="currentColor" opacity=".25"/><rect x="2" y="5" width="12" height="3" rx="1" fill="none" stroke="currentColor" stroke-width=".5" stroke-dasharray="1.5 1" opacity=".3"/><rect x="3" y="9" width="10" height="3.5" rx="1" fill="none" stroke="currentColor" stroke-width=".5" stroke-dasharray="1.5 1" opacity=".3"/></svg>
<span>Column</span>
</button>
<button class="dockOpt" data-ncm="off" title="No background tinting">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><line x1="3" y1="3" x2="13" y2="11" stroke="currentColor" stroke-width="1.5" opacity=".4"/><line x1="13" y1="3" x2="3" y2="11" stroke="currentColor" stroke-width="1.5" opacity=".4"/></svg>
<span>Off</span>
</button>
</div>
</div>
<div class="layoutSection">
<div class="layoutSectionTitle">Details panel</div>
<div class="dockSelector" id="panelModeSelector">
<button class="dockOpt" data-mode="left" title="Dock details to left side">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="5" height="12" rx="1" fill="currentColor" opacity=".45"/></svg>
<span>Left</span>
</button>
<button class="dockOpt" data-mode="bottom" title="Dock details to bottom">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="9" width="14" height="4" rx="1" fill="currentColor" opacity=".45"/></svg>
<span>Bottom</span>
</button>
<button class="dockOpt" data-mode="right" title="Dock details to right side">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="10" y="1" width="5" height="12" rx="1" fill="currentColor" opacity=".45"/></svg>
<span>Right</span>
</button>
<button class="dockOpt" data-mode="float" title="Floating panel  drag to reposition">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1" stroke-dasharray="2,2"/><rect x="6" y="4" width="8" height="7" rx="1.5" fill="currentColor" opacity=".45" stroke="currentColor" stroke-width=".5"/></svg>
<span>Float</span>
</button>
<button class="dockOpt" data-mode="hidden" title="Hide details panel">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><line x1="4" y1="3" x2="12" y2="11" stroke="currentColor" stroke-width="1" opacity=".4"/><line x1="12" y1="3" x2="4" y2="11" stroke="currentColor" stroke-width="1" opacity=".4"/></svg>
<span>Hidden</span>
</button>
</div>
<div class="layoutHint">Press <kbd>D</kbd> to toggle details  <kbd>P</kbd> to pan viewer<br/>Drag float panel to edge to dock</div>
</div>
</div>
</div>

<div class="tbSep"></div>

<!-- Selection -->
<div class="tbBtn" id="tbSelection" title="Expand, collapse & clear selection">
<span class="tbIcon"></span>Selection
<div class="tbPop" id="tbPopSelection" style="min-width:210px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Dim unselected</div>
<div class="dockSelector" id="dimModeSelector">
<button class="dockOpt active" data-dim="all" title="Dim all unselected nodes">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="2" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="9" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".2"/><rect x="2" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".2"/><rect x="9" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".2"/></svg>
<span>All</span>
</button>
<button class="dockOpt" data-dim="keepParents" title="Dim unselected but keep parent groups visible">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="2" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="9" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".5"/><rect x="2" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".2"/><rect x="9" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".5"/></svg>
<span>Parents</span>
</button>
<button class="dockOpt" data-dim="off" title="No dimming  all nodes stay at full opacity">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="2" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="9" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="2" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="9" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/></svg>
<span>Off</span>
</button>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0;"></div>
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Highlight mode</div>
<div class="dockSelector" id="multiArrowModeSelector">
<button class="dockOpt active" data-mode="chain" title="Highlight the full mapping chain across all columns">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="6" y2="5" stroke="currentColor" stroke-width="1.5"/><line x1="6" y1="5" x2="11" y2="5" stroke="currentColor" stroke-width="1.5" stroke-dasharray="1 1.5"/><polygon points="10,2.5 14,5 10,7.5" fill="currentColor"/></svg>
<span>Chain</span>
</button>
<button class="dockOpt" data-mode="direct" title="Highlight only direct (adjacent) mappings">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="currentColor" stroke-width="1.5"/><polygon points="10,2.5 14,5 10,7.5" fill="currentColor"/></svg>
<span>Direct</span>
</button>
<button class="dockOpt" data-mode="selected" title="Highlight only the selected node(s), no connected fields">
<svg width="16" height="10" viewBox="0 0 16 10"><circle cx="4" cy="5" r="3" fill="currentColor"/><line x1="8" y1="5" x2="14" y2="5" stroke="currentColor" stroke-width="1" opacity=".25"/></svg>
<span>Selected</span>
</button>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0;"></div>
<div class="selMenuActions">
<button class="btn selActionBtn" id="selectAllBtn" title="Select all visible nodes (Ctrl+A)">
<svg width="14" height="14" viewBox="0 0 14 14"><rect x="1" y="1" width="5" height="5" rx="1" fill="currentColor"/><rect x="8" y="1" width="5" height="5" rx="1" fill="currentColor"/><rect x="1" y="8" width="5" height="5" rx="1" fill="currentColor"/><rect x="8" y="8" width="5" height="5" rx="1" fill="currentColor"/></svg>
Select all
</button>
<button class="btn selActionBtn" id="invertSelectionBtn" title="Invert current selection (Ctrl+Shift+I)">
<svg width="14" height="14" viewBox="0 0 14 14"><rect x="1" y="1" width="5" height="5" rx="1" fill="currentColor"/><rect x="8" y="1" width="5" height="5" rx="1" fill="none" stroke="currentColor" stroke-width="1.2"/><rect x="1" y="8" width="5" height="5" rx="1" fill="none" stroke="currentColor" stroke-width="1.2"/><rect x="8" y="8" width="5" height="5" rx="1" fill="currentColor"/></svg>
Invert selection
</button>
<button class="btn selActionBtn" id="clearSelectionBtn" title="Clear selection (Esc)">
<svg width="14" height="14" viewBox="0 0 14 14"><rect x="1" y="1" width="12" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="1.2"/><line x1="4" y1="4" x2="10" y2="10" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/><line x1="10" y1="4" x2="4" y2="10" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>
Clear selection
</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="expandAllBtn" title="Expand all groups">
<svg width="14" height="14" viewBox="0 0 14 14"><rect x="1" y="1" width="12" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="1.2"/><line x1="7" y1="4" x2="7" y2="10" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/><line x1="4" y1="7" x2="10" y2="7" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>
Expand all
</button>
<button class="btn selActionBtn" id="collapseAllBtn" title="Collapse all groups">
<svg width="14" height="14" viewBox="0 0 14 14"><rect x="1" y="1" width="12" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="1.2"/><line x1="4" y1="7" x2="10" y2="7" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>
Collapse all
</button>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0;"></div>
<button class="btn selActionBtn" id="hlColorsBtn" title="Customize highlight colors">
<svg width="14" height="14" viewBox="0 0 14 14"><circle cx="7" cy="7" r="5.5" fill="none" stroke="currentColor" stroke-width="1.2"/><circle cx="5.5" cy="5.5" r="2" fill="currentColor" opacity=".6"/><circle cx="8.5" cy="5.5" r="2" fill="currentColor" opacity=".4"/><circle cx="7" cy="8.5" r="2" fill="currentColor" opacity=".5"/></svg>
Highlight colors
</button>
</div>
</div>
</div>

<!-- Catalogs -->
<div class="tbBtn" id="tbCatalogs" title="Tags, transforms, attributes & filters">
<span class="tbIcon"></span>Catalogs
<div class="tbPop" id="tbPopCatalogs" style="min-width:160px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<button class="btn" id="tagsBtn" title="Manage tags">Tags</button>
<button class="btn" id="transformsBtn" title="Manage transformations">Transforms</button>
<button class="btn" id="customAttrsBtn" title="Manage attributes">Attributes</button>
<button class="btn" id="filtersBtn" title="Manage saved filters and conditional formatting">Filters</button>
</div>
</div>
</div>

<div class="tbSep"></div>

<!-- Export -->
<div class="tbBtn" id="tbExport" title="Export data">
<span class="tbIcon"></span>Export
<div class="tbPop" id="tbPopExport" style="min-width:140px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<button class="btn" id="exportCsvBtn" title="Export mappings as CSV">Export CSV</button>
<button class="btn" id="exportReportBtn" title="Export HTML report">Export report</button>
</div>
</div>
</div>

<!-- Help -->
<div class="tbBtn" id="tbHelp" title="Help, docs & examples">
<span class="tbIcon">?</span>Help
<div class="tbPop" id="tbPopHelp" style="min-width:160px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<button class="btn" id="helpBtn" title="Help / shortcuts (press ?)">Quick start</button>
<button class="btn" id="goDocsBtn" title="Open documentation">Documentation</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn" id="loadExampleBtn" title="Load the built-in example project">Load example</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn" id="releaseNotesBtn" title="View release notes">Release notes</button>
<button class="btn" id="aboutBtn" title="About Dunnode">About</button>
</div>
</div>
</div>

</div>

<!-- Row 2: Filter bar (toggleable, below icons) -->
<div class="tbRow1" id="tbFilterBar" style="display:none;">
<div class="search" style="flex:1 1 200px;" title="Search labels &amp; IDs across all columns">
<span style="opacity:.85"></span>
<input id="searchInput" placeholder="Search" style="min-width:100px;"/>
<span class="hint">Esc</span>
</div>
<div class="tbFilterOpts">
<label class="fbToggle" id="onlyMappedWrap" title="Hide fields without any mappings"><input id="onlyMappedToggle" type="checkbox"/><span class="fbDot"></span>Only mapped</label>
<span class="fbSep"></span>
<div class="fbGroup" id="filterModeGroup">
<button class="fbOpt fbHide active" data-fmode="hide" title="Hide non-matching fields">Hide</button>
<button class="fbOpt fbWarn" data-fmode="dim" title="Dim non-matching fields">Dim</button>
<button class="fbOpt" data-fmode="highlight" title="Highlight matching fields only">Highlight</button>
</div>
<span class="fbSep"></span>
<div class="fbGroup" id="filterLogicGroup">
<button class="fbOpt" data-flogic="and" title="Node must match ALL active filters">AND</button>
<button class="fbOpt active" data-flogic="or" title="Node must match ANY active filter">OR</button>
</div>
<span class="fbSep"></span>
<button class="fbClear" id="clearFilterBtn" title="Clear search and all active filters">Clear all</button>
</div>
<div id="filterChips" style="display:flex;gap:5px;align-items:center;flex-wrap:wrap;flex:1 1 100%;min-height:0;"></div>
</div>

</div>
<div class="sub">
<span id="globalStatus">Hover a field/group to preview. Click to lock. Click again to unlock.</span>
<span></span>
<span>Tips: <kbd>Click</kbd> lock  <kbd>Esc</kbd> clear search + selection  caret collapses groups  non-adjacent mappings supported  toggle Editor mode to edit</span>
</div>
</header>
<main>
<!-- VIEWER -->
<section class="view active" id="view-viewer">
<div class="viewerGrid" data-panel="right">
<div class="columnsWrap">
<div class="columnsHeader">
<div class="statusLine" id="viewerStatus">Ready.</div>
<div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
<!-- View controls -->
<button class="btn" id="showAllColumnsBtn" title="Show/hide and reorder columns">Columns</button>
<button class="btn" id="panToggleBtn" title="Toggle pan mode (P)" style="width:30px;height:30px;padding:0;display:inline-flex;align-items:center;justify-content:center;font-size:16px;opacity:.6;transition:opacity .15s,background .15s;"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="1" x2="8" y2="15"/><line x1="1" y1="8" x2="15" y2="8"/><polyline points="5.5,3.5 8,1 10.5,3.5"/><polyline points="5.5,12.5 8,15 10.5,12.5"/><polyline points="3.5,5.5 1,8 3.5,10.5"/><polyline points="12.5,5.5 15,8 12.5,10.5"/></svg></button>
<button class="btn" id="clearSelBtn" title="Clear selection (Esc)" style="width:30px;height:30px;padding:0;display:inline-flex;align-items:center;justify-content:center;font-size:14px;opacity:.6;transition:opacity .15s;"></button>
<!-- Editor mode only -->
<button class="btn" id="undoBtn" title="Undo (Ctrl+Z)" disabled style="display:none;"></button>
<button class="btn" id="redoBtn" title="Redo (Ctrl+Y)" disabled style="display:none;"></button>
</div>
</div>
<div class="columnsScroller" id="columnsScroller">
<div id="lassoRect" style="display:none;position:absolute;border:1.5px dashed rgba(59,130,246,.7);background:rgba(59,130,246,.08);border-radius:2px;pointer-events:none;z-index:9999;"></div>
<svg id="lassoSvg" style="display:none;position:absolute;top:0;left:0;pointer-events:none;z-index:9999;overflow:visible;"><polygon id="lassoPolygon" fill="rgba(59,130,246,.08)" stroke="rgba(59,130,246,.7)" stroke-width="1.5" stroke-dasharray="4,3"/></svg>
<svg aria-hidden="true" id="svgOverlay">
<defs>
<marker id="arrowDefault" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto" refx="0" refy="7" viewbox="0 0 14 14">
<!-- Slightly bigger; refX=0 so the path ends exactly at arrow base (flat side) -->
<path class="edgeMarker" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<marker id="arrowHL" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker hl" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<marker id="arrowActive" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker active" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<!-- Bidirectional markers - for start of line, use same shape but reversed orientation -->
<marker id="arrowStartDefault" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto-start-reverse" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<marker id="arrowStartHL" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto-start-reverse" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker hl" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<marker id="arrowStartActive" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto-start-reverse" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker active" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
</defs>
<g id="edgesLayer"></g>
</svg>
<div class="columnsRow" id="columnsRow"></div>
</div>
</div>
<div class="resizeHandle" id="resizeHandle"></div>
<div class="resizeHandleH" id="resizeHandleH"></div>
<aside class="details" id="detailsPanel">
<div class="detailsHeader" id="detailsHeader">
<div style="display:flex;align-items:center;gap:10px;">
<div class="detailsGrip" title="Drag to reposition"></div>
<div class="name">Details</div>
</div>
<div style="display:flex;align-items:center;gap:6px;">
<div class="meta" id="detailsMeta"></div>
<div class="detailsDockActions" id="detailsDockActions"></div>
<button class="detailsClose floatOnly" id="detailsOpacityBtn" title="Inactive opacity" style="font-size:11px;display:none;position:relative;overflow:visible;"><div id="opacityPopover" style="display:none;position:absolute;bottom:100%;right:0;margin-bottom:6px;padding:8px 12px;background:rgba(11,16,32,.95);border:1px solid var(--border);border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.4);z-index:200;white-space:nowrap;min-width:140px;">
<div style="font-size:10px;opacity:.5;margin-bottom:6px;letter-spacing:.3px;">INACTIVE OPACITY</div>
<div style="display:flex;align-items:center;gap:8px;">
<input type="range" id="opacitySlider" min="10" max="100" value="30" style="flex:1;accent-color:#3b82f6;cursor:pointer;"/>
<span id="opacityVal" style="font-size:11px;font-family:var(--mono);min-width:28px;text-align:right;">30%</span>
</div>
</div></button>
<button class="detailsClose" id="detailsDefaultBtn" title="Reset to default size" style="font-size:11px;"></button>
<button class="detailsClose floatOnly" id="detailsMinBtn" title="Minimize panel" style="font-size:11px;display:none;"></button>
<button class="detailsClose" id="detailsCloseBtn" title="Hide details panel"></button>
</div>
</div>
<div class="detailsBody" id="detailsBody">
<div class="empty">
Hover a field/group to preview details. Click to lock selection.
<br/><br/>
Use the Details pane to see <b>Outbound</b> and <b>Inbound</b> mappings for the selection.
</div>
</div>
<div class="floatResizeHandle" id="floatResizeHandle"></div>
</aside>
<div class="snapIndicator" id="snapIndicator"></div>
</div>
</section>
<!-- Hidden: file input for Open project, jsonArea for internal state sync, fieldDatalist for autocomplete -->
<input accept=".json,application/json" id="fileInput" style="display:none" type="file"/>
<datalist id="fieldDatalist"></datalist>
<textarea id="jsonArea" spellcheck="false" style="display:none"></textarea>
<div id="logArea" style="display:none"></div>
<!-- Docs modal -->
<div class="modalMask" id="docsMask"></div>
<div aria-label="Documentation" class="modal" id="docsModal" role="dialog" style="max-width:880px;">
<div class="modalHeader">
<div class="title">Documentation</div>
<div class="controls">
<button class="btn" id="closeDocsBtn">Close</button>
</div>
</div>
<div class="modalBody docsBody" id="docsBody">
<!-- populated by JS -->
</div>
</div>
</main>
<footer class="appFooter">
<span> 2026 Olivr Bn  <a href="#" id="footerLicenseLink">MIT License</a></span>
<span id="appVersionLabel">v1.3.7</span>
</footer>
<!-- Permanent DnD overlay  all drag visuals live here to avoid body flex reflow -->
<div id="dndOverlay" style="position:fixed;inset:0;z-index:9998;pointer-events:none;">
  <div id="cancelZone" class="dragDropZone"> Cancel</div>
  <div id="binZone" class="dragDropZone"> Delete</div>
</div>
<!-- Columns popover -->
<div aria-label="Columns" class="popover" id="columnsPopover" role="dialog">
<div class="popTitle">Columns</div>
<div id="columnsList"></div>
<div style="display:flex;gap:8px;align-items:center;margin-top:10px;padding-top:8px;border-top:1px solid var(--border);flex-wrap:wrap;">
<span id="colPopAddBtns" style="display:none;gap:8px;">
<button class="btn" id="addColumnLeftBtn" title="Add a new column at the far left">+ Add left</button>
<button class="btn" id="addColumnRightBtn" title="Add a new column at the far right">+ Add right</button>
</span>
<span style="flex:1;"></span>
<button class="btn" id="showAllColsBtn">Show all</button>
<button class="btn" id="hideUnmappedColsBtn" title="Hide columns that currently contain no mapped fields (based on the loaded JSON)">Hide unmapped</button>
<button class="btn" id="closeColumnsBtn">Close</button>
</div>
</div>
<!-- Tags modal -->
<div class="modalMask" id="tagsMask"></div>
<div aria-label="Tags" class="modal" id="tagsModal" role="dialog">
<div class="modalHeader">
<div class="title">Tag manager</div>
<div class="controls">
<button class="btn" id="addTagBtn">Add tag</button>
<button class="btn" id="closeTagsBtn">Close</button>
</div>
</div>
<div class="modalBody" id="tagsBody"></div>
</div>
<!-- Transforms modal -->
<div class="modalMask" id="transformsMask"></div>
<div aria-label="Transforms" class="modal" id="transformsModal" role="dialog">
<div class="modalHeader">
<div class="title">Transformation library</div>
<div class="controls">
<button class="btn" id="addTransformBtn">Add transform</button>
<button class="btn" id="closeTransformsBtn">Close</button>
</div>
</div>
<div class="modalBody" id="transformsBody"></div>
</div>
<!-- Attributes modal -->
<div class="modalMask" id="customAttrsMask"></div>
<div aria-label="Attributes" class="modal" id="customAttrsModal" role="dialog">
<div class="modalHeader">
<div class="title">Attributes catalog</div>
<div class="controls">
<button class="btn" id="addCustomAttrBtn">Add attribute</button>
<button class="btn" id="closeCustomAttrsBtn">Close</button>
</div>
</div>
<div class="modalBody" id="customAttrsBody"></div>
</div>
<!-- Filters modal -->
<div class="modalMask" id="filtersMask"></div>
<div aria-label="Filters" class="modal" id="filtersModal" role="dialog" style="max-width:720px;">
<div class="modalHeader">
<div class="title">Filter catalog</div>
<div class="controls">
<button class="btn" id="addFilterBtn">Add filter</button>
<button class="btn" id="closeFiltersBtn">Close</button>
</div>
</div>
<div class="modalBody" id="filtersBody"></div>
</div>
<!-- Custom alert/confirm modal -->
<div class="modalMask" id="customDialogMask" style="z-index:10000;"></div>
<div aria-label="Dialog" class="modal" id="customDialog" role="dialog" style="z-index:10001;max-width:500px;">
<div class="modalHeader">
<div class="title">Dialog</div>
<div class="controls"><button class="modalClose" title="Close">&times;</button></div>
</div>
<div class="modalBody" style="padding:24px;">
<div id="customDialogMessage" style="font-size:15px;line-height:1.6;margin-bottom:24px;white-space:pre-wrap;"></div>
<div id="customDialogButtons" style="display:flex;gap:8px;justify-content:flex-end;"></div>
</div>
</div>
<!-- Unified create modal (columns, nodes, tags, transforms, attributes, values) -->
<div class="modalMask" id="createMask"></div>
<div aria-label="Create" class="modal" id="createModal" role="dialog">
<div class="modalHeader">
<div class="title" id="createTitle">Create</div>
<div class="controls">
<button class="btn" id="createCloseBtn">Close</button>
</div>
</div>
<div class="modalBody">
<div class="kv" style="grid-template-columns: 110px 1fr;">
<div class="k">Label</div>
<div class="v"><input class="inp" id="createLabel" placeholder=""/></div>
<div class="k">ID <span class="autoTag" id="createIdAuto">auto</span></div>
<div class="v" style="display:flex;align-items:center;gap:0;">
<span id="createIdPrefix" style="font-family:var(--mono);font-size:11px;opacity:.55;white-space:nowrap;"></span>
<input class="inp" id="createIdInput" value="" style="font-family:var(--mono);font-size:11px;flex:1 1 auto;"/>
</div>
<div class="k crOpt" id="crAbbrK" style="display:none">Abbr <span class="autoTag" id="createAbbrAuto">auto</span></div>
<div class="v crOpt" id="crAbbrV" data-flex="1" style="display:none;align-items:center;"><input class="inp" id="createAbbr" placeholder="e.g. S" style="flex:1;"/></div>
<div class="k crOpt" id="crColorK" style="display:none">Color</div>
<div class="v crOpt" id="crColorV" style="display:none">
<div id="createColors" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
<div style="display:flex;align-items:center;gap:6px;margin-top:8px;">
<input type="color" id="createColorPicker" value="#3b82f6" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;"/>
<input class="inp" id="createColorHex" placeholder="#3b82f6" style="flex:1;"/>
<span class="layoutReset" id="createColorReset" title="Reset color" style="opacity:.35;cursor:pointer;font-size:13px;color:var(--muted);transition:opacity .15s;"></span>
</div>
</div>
<div class="k crOpt" id="crMultiK" style="display:none">Mode</div>
<div class="v crOpt" id="crMultiV" style="display:none">
<label class="toggle" style="padding:6px 10px; display:inline-flex;">
<input type="checkbox" id="createMulti"/>
Multi-value
</label>
<div class="empty" style="margin-top:6px;">If OFF, selecting a value replaces the previous one.</div>
</div>
<div class="k" id="crNoteK">Note</div>
<div class="v" id="crNoteV"><input class="inp" id="createNote" placeholder="optional"/></div>
<div class="k crOpt" id="crParamsK" style="display:none">Params</div>
<div class="v crOpt" id="crParamsV" style="display:none">
<div id="createParamsRows"></div>
<button class="btn" id="createAddParamBtn" type="button" style="margin-top:4px;font-size:11px;padding:2px 8px;">+ Add param</button>
</div>
<div class="k crOpt" id="crTagsK" style="display:none">Tags</div>
<div class="v crOpt" id="crTagsV" style="display:none">
<div id="createTagChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;">
<select class="inp" id="createTagSel" style="max-width:280px;flex:0 0 auto;"><option value="">Add tag</option></select>
<button class="btn" id="createTagMgr" type="button">Tags</button>
</div>
</div>
<div class="k crOpt" id="crAttrsK" style="display:none">Custom</div>
<div class="v crOpt" id="crAttrsV" style="display:none">
<div id="createAttrChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;">
<select class="inp" id="createAttrSel" style="max-width:240px;"><option value="">Attribute</option></select>
<select class="inp" id="createAttrValSel" style="max-width:240px;"><option value="">Value</option></select>
<button class="btn" id="createAttrMgr" type="button">Attributes</button>
</div>
</div>
</div>
<div class="empty" id="createHint" style="margin-top:8px;"></div>
<div style="display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap; margin-top:12px;">
<button class="btn" id="createCancelBtn">Cancel</button>
<button class="btn btnSave" id="createOkBtn">Save</button>
</div>
</div>
</div>
<!-- Help modal -->
<div class="modalMask" id="helpMask"></div>
<div aria-label="Help" class="modal" id="helpModal" role="dialog" style="max-width:660px;">
<div class="modalHeader">
<div class="title">Quick Start Guide</div>
<div class="controls">
<button class="btn" id="closeHelpBtn">Close</button>
</div>
</div>
<div class="modalBody" id="helpBody"></div>
</div>
<!-- Release notes modal -->
<div class="modalMask" id="releaseNotesMask"></div>
<div aria-label="Release Notes" class="modal" id="releaseNotesModal" role="dialog" style="max-width:640px;">
<div class="modalHeader">
<div class="title">Release Notes</div>
<div class="controls">
<button class="btn" id="closeReleaseNotesBtn">Close</button>
</div>
</div>
<div class="modalBody" id="releaseNotesBody" style="max-height:70vh;overflow-y:auto;"></div>
</div>
<div class="modalMask" id="projPropsMask"></div>
<div aria-label="Project Properties" class="modal" id="projectPropsModal" role="dialog">
<div class="modalHeader">
<div class="title">Project Properties</div>
<div class="controls">
<button class="btn btnSave" id="projPropsSave">Save</button>
<button class="btn" id="projPropsCancel">Cancel</button>
</div>
</div>
<div class="modalBody" id="projPropsBody" style="max-height:65vh;overflow-y:auto;"></div>
</div>

<div class="modalMask" id="aboutMask"></div>
<div aria-label="About" class="modal" id="aboutModal" role="dialog" style="max-width:380px;">
<div class="modalHeader">
<div class="title">About</div>
<div class="controls"><button class="btn" id="aboutClose">Close</button></div>
</div>
<div class="modalBody" style="text-align:center;padding:28px 24px;">
<div style="font-size:22px;font-weight:800;letter-spacing:1.2px;margin-bottom:2px;text-transform:uppercase;">Dunnode</div>
<div style="font-size:13px;font-weight:600;opacity:.55;letter-spacing:.4px;margin-bottom:14px;">Done. Now.</div>
<div style="font-size:12px;opacity:.6;line-height:1.6;margin-bottom:18px;">A lightweight mapping studio for complex flows.</div>
<div style="font-size:11px;opacity:.5;line-height:1.8;">
Created by Olivr Bn<br/>
<span id="dunnodeContact" style="color:var(--accent);cursor:pointer;text-decoration:none;"></span><br/>
<a href="https://dunnode.com" target="_blank" rel="noopener" style="color:var(--accent);text-decoration:none;">dunnode.com</a>
</div>
<div style="margin-top:14px;font-size:10.5px;opacity:.4;line-height:1.6;">
<a href="#" id="aboutLicenseLink" class="aboutLicenseLink">MIT Licensed</a>  Runs entirely in your browser
</div>
<div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border);font-size:10px;opacity:.35;" id="aboutVersion">v</div>
</div>
</div>

<div class="modalMask" id="hlColorsMask"></div>
<div aria-label="Highlight colors" class="modal" id="hlColorsModal" role="dialog" style="max-width:380px;">
<div class="modalHeader">
<div class="title">Highlight colors</div>
<div class="controls"><button class="btn" id="hlColorsClose">Close</button></div>
</div>
<div class="modalBody" id="hlColorsBody" style="padding:18px 22px;">
<div style="margin-bottom:16px;">
<div style="font-size:12px;font-weight:600;margin-bottom:8px;">Selected / Hovered</div>
<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
<input type="color" id="hlActivePicker" value="#ffd05c" style="width:30px;height:24px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;"/>
<div id="hlActiveSwatches" style="display:flex;gap:5px;flex-wrap:nowrap;"></div>
<span class="layoutReset hlEditOnly" id="hlActiveReset" title="Reset to default (#ffd05c)" style="opacity:.35;cursor:pointer;font-size:13px;color:var(--muted);transition:opacity .15s,color .15s;"></span>
</div>
</div>
<div style="margin-bottom:4px;">
<div style="font-size:12px;font-weight:600;margin-bottom:8px;">Connected</div>
<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
<input type="color" id="hlConnectedPicker" value="#3b82f6" style="width:30px;height:24px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;"/>
<div id="hlConnectedSwatches" style="display:flex;gap:5px;flex-wrap:nowrap;"></div>
<span class="layoutReset hlEditOnly" id="hlConnectedReset" title="Reset to default (#3b82f6)" style="opacity:.35;cursor:pointer;font-size:13px;color:var(--muted);transition:opacity .15s,color .15s;"></span>
</div>
</div>
<div style="border-top:1px solid var(--border);margin-top:16px;padding-top:14px;">
<div style="font-size:11px;opacity:.4;margin-bottom:10px;text-align:center;">Preview  hover or click to test</div>
<div id="hlTester" style="display:flex;align-items:center;justify-content:center;gap:0;user-select:none;padding:10px 4px;">
<div id="hlTesterSource" class="hlTesterNode" style="padding:8px 20px;border-radius:8px;border:1.5px solid var(--border);background:var(--panel);font-size:12.5px;font-weight:600;cursor:pointer;transition:background .15s, border-color .15s;position:relative;z-index:1;">source_id</div>
<svg id="hlTesterArrow" width="70" height="24" viewBox="0 0 70 24" style="flex-shrink:0;overflow:visible;cursor:pointer;margin-right:-6px;">
<line x1="2" y1="12" x2="58" y2="12" stroke="var(--line)" stroke-width="1.5" id="hlTesterLine" style="transition:stroke .15s;"/>
<polygon points="56,7 66,12 56,17" fill="var(--line)" id="hlTesterHead" style="transition:fill .15s;"/>
</svg>
<div id="hlTesterTarget" class="hlTesterNode" style="padding:8px 20px;border-radius:8px;border:1.5px solid var(--border);background:var(--panel);font-size:12.5px;font-weight:600;cursor:pointer;transition:background .15s, border-color .15s;position:relative;z-index:1;">target_id</div>
</div>
</div>
<div id="hlColorsEditorActions" style="display:none;margin-top:14px;padding-top:10px;border-top:1px solid var(--border);">
<div style="display:flex;gap:8px;flex-wrap:wrap;">
<button class="btn" id="hlColorsDelete" style="border-color:rgba(255,154,168,.45);">Delete</button>
<span style="flex:1;"></span>
<button class="btn" id="hlColorsCancel">Cancel</button>
<button class="btn btnSave" id="hlColorsSave">Save</button>
</div>
</div>
<div id="hlViewerHint" style="display:none;margin-top:12px;font-size:11px;opacity:.4;text-align:center;">Switch to Editor mode to change highlight colors.</div>
</div>
</div>

<!-- Command Palette -->
<div class="cmdPaletteMask" id="cmdPaletteMask">
<div class="cmdPalette" id="cmdPalette">
<input class="cmdPaletteInput" id="cmdPaletteInput" placeholder="Type a command, search nodes or docs" autocomplete="off" spellcheck="false"/>
<div class="cmdPaletteResults" id="cmdPaletteResults"></div>
<div class="cmdPaletteFooter"><kbd></kbd> navigate <kbd></kbd> run <kbd>esc</kbd> close</div>
</div>
</div>

<script>
/* =========================================================
   Dunnode  One page app (Vanilla JS)
   - Multi-column schema viewer with nested trees
   - Hover highlight + click lock
   - Arrows across adjacent or non-adjacent columns
   - Documentation embedded
  Mapping model:
  - One mapping per (fromto) pair
  - One-to-many is expressed as multiple edges
  - 'default' may be provided as an attribute

========================================================= */

/* ----------------------- Example JSON (v3) -----------------------
   New format supports ANY number of columns:
   {
     columns: [
       { id, label, schema: (tree root group node) },
       ...
     ],
     mappings: [
       { from, to, cardinality, transforms: [{ref, params?}], note, default }
     ],
     transformCatalog: [{ id, label, abbr, note, color?, params?: [{id, label, type, default?}] }],
     customAttributeCatalog: [{ id, label, abbr, note, multi, displayOnNode?, priority?,
       color?, colorEnabled?,
       values: [{ id, label, abbr?, note?, color?, colorEnabled?, priority? }] }],
     columns: [{ id, label, note?, color?, schema: { ... } }]
   }

   Field IDs MUST start with "<columnId>." so we can infer the column.
------------------------------------------------------------------- */
const APP_VERSION = '1.3.7';

const EXAMPLE_JSON = {
  "title": "Mars Mission Data Integration",
  "subtitle": "Spacecraft telemetry and research pipeline",
  "description": "Maps mission data across five systems: Mission Control, Spacecraft Telemetry, the Lab analysis pipeline, an Archive database, and the Obs ground-tracking dashboard.\n\nDemonstrates nested schemas, bidirectional mappings, tags for workflow stages, ordered transforms, custom attributes for data classification, multi-column chains, and color inheritance  every column has a color, groups override their column (e.g. Crew  red, Personnel  pink, dim_crew  indigo), and individual fields can override their group (e.g. CommanderName  amber).",
  "author": "Mars Systems Integration Team",
  "organization": "Ares Space Agency",
  "contact": "hello@dunnode.com",
  "url": "https://dunnode.com",
  "projectVersion": "1.0",
  "date": "2026-02-22",
  "_app": { "name": "Dunnode", "version": "1.3.7", "schema": 1 },
  "_savedAt": "",
  "columns": [
    {
      "id": "mc",
      "_autoId": false,
      "label": "Mission Control",
      "note": "Primary command center. Source of truth for crew assignments and mission parameters.",
      "color": "#3b82f6",
      "schema": {
        "id": "mc",
        "_autoId": false,
        "label": "Mission Control",
        "type": "group",
        "children": [
          {
            "id": "mc.mission",
            "label": "Mission",
            "type": "group",
            "tags": ["active"],
            "note": "Core mission parameters group.",
            "children": [
              {
                "id": "mc.mission.missionId",
                "label": "MissionId",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "no",
                  "domain": ["telemetry","navigation"]
                },
                "note": "Unique mission identifier (e.g. ARES-2026-07)."
              },
              {
                "id": "mc.mission.missionName",
                "label": "MissionName",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "no"
                }
              },
              {
                "id": "mc.mission.objectiveCode",
                "label": "ObjectiveCode",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "mc.mission.launchMass",
                "label": "LaunchMassKg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                }
              },
              {
                "id": "mc.mission.fuelBudget",
                "label": "FuelBudgetKg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                }
              },
              {
                "id": "mc.mission.targetOrbit",
                "label": "TargetOrbit",
                "type": "field",
                "tags": [
                  "active",
                   "pending"
                ],
                "customAttributes": {
                  "format": "string",
                  "domain": ["navigation"]
                }
              },
              {
                "id": "mc.mission.legacyCallsign",
                "label": "LegacyCallsign",
                "type": "field",
                "tags": [
                  "retired",
                   "pending"
                ],
                "note": "Deprecated  old radio callsign format, replaced in 2025."
              }
            ]
          },
          {
            "id": "mc.crew",
            "label": "Crew",
            "type": "group",
            "tags": ["active","pending"],
            "customAttributes": { "classified": "yes" },
            "note": "Crew manifest  restricted access group.",
            "color": "#ef4444",
            "children": [
              {
                "id": "mc.crew.crewId",
                "label": "CrewId",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string",
                  "domain": ["personnel","navigation"]
                }
              },
              {
                "id": "mc.crew.commanderName",
                "label": "CommanderName",
                "type": "field",
                "tags": [
                  "active",
                   "pending"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "yes",
                  "domain": ["personnel"]
                },
                "note": "Commander identity  restricted access.",
                "color": "#f59e0b"
              },
              {
                "id": "mc.crew.headcount",
                "label": "Headcount",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "integer"
                }
              }
            ]
          },
          {
            "id": "mc.forecast",
            "label": "Forecast",
            "type": "group",
            "tags": ["pending"],
            "note": "Experimental forecast models  subject to change.",
            "children": [
              {
                "id": "mc.forecast.arrivalWindow",
                "label": "ArrivalWindow",
                "type": "field",
                "tags": [
                  "pending"
                ],
                "customAttributes": {
                  "format": "string"
                },
                "note": "Under review  orbital mechanics model being recalibrated."
              }
            ]
          }
        ]
      }
    },
    {
      "id": "sat",
      "label": "Spacecraft Telemetry",
      "note": "Live telemetry feed from the spacecraft. Nested subsystem sensors.",
      "color": "#8b5cf6",
      "schema": {
        "id": "sat",
        "label": "Spacecraft Telemetry",
        "type": "group",
        "children": [
          {
            "id": "sat.vehicle",
            "label": "Vehicle",
            "type": "group",
            "children": [
              {
                "id": "sat.vehicle.vehicleCode",
                "label": "VehicleCode",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "no",
                  "domain": ["telemetry","navigation"]
                },
                "note": "Spacecraft identifier (maps to Mission Control ID)."
              },
              {
                "id": "sat.vehicle.missionLabel",
                "label": "MissionLabel",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "sat.vehicle.objectiveTag",
                "label": "ObjectiveTag",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "sat.vehicle.massKg",
                "label": "MassKg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal",
                  "domain": ["telemetry","science"]
                }
              },
              {
                "id": "sat.vehicle.fuelKg",
                "label": "FuelKg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal",
                  "domain": ["telemetry","navigation"]
                }
              },
              {
                "id": "sat.vehicle.nav",
                "label": "Navigation",
                "type": "group",
                "tags": ["active"],
                "customAttributes": { "classified": "yes" },
                "note": "Navigation subsystem  contains crew identity data.",
                "color": "#f97316",
                "children": [
                  {
                    "id": "sat.vehicle.nav.crewRef",
                    "label": "CrewRef",
                    "type": "field",
                    "tags": [
                      "active"
                    ],
                    "customAttributes": {
                      "format": "string"
                    }
                  },
                  {
                    "id": "sat.vehicle.nav.pilotCallsign",
                    "label": "PilotCallsign",
                    "type": "field",
                    "tags": [
                      "active"
                    ],
                    "customAttributes": {
                      "format": "string"
                    }
                  },
                  {
                    "id": "sat.vehicle.nav.pilotName",
                    "label": "PilotName",
                    "type": "field",
                    "tags": [
                      "active",
                   "pending"
                    ],
                    "customAttributes": {
                      "format": "string",
                      "classified": "yes",
                      "domain": ["personnel","navigation"]
                    }
                  }
                ]
              },
              {
                "id": "sat.vehicle.heartbeatTs",
                "label": "HeartbeatTs",
                "type": "field",
                "customAttributes": {
                  "format": "datetime"
                },
                "note": "Telemetry heartbeat timestamp  not mapped."
              }
            ]
          }
        ]
      }
    },
    {
      "id": "lab",
      "_autoId": true,
      "label": "Lab",
      "note": "Research analysis pipeline. Processes raw telemetry into normalized experiment data.",
      "color": "#10b981",
      "schema": {
        "id": "lab",
        "_autoId": true,
        "label": "Lab",
        "type": "group",
        "children": [
          {
            "id": "lab.experiment",
            "label": "EXPERIMENT",
            "type": "group",
            "tags": ["active"],
            "note": "Primary experiment data from telemetry.",
            "children": [
              {
                "id": "lab.experiment.experiment_ref",
                "_autoId": true,
                "label": "experiment_ref",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.experiment.experiment_name",
                "_autoId": true,
                "label": "experiment_name",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.experiment.objective_slug",
                "label": "objective_slug",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.experiment.payload_mass",
                "_autoId": true,
                "label": "payload_mass",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal",
                  "domain": ["science","telemetry"]
                }
              },
              {
                "id": "lab.experiment.payload_mass_norm",
                "label": "payload_mass_norm",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                },
                "note": "Mass normalized to standard gravity units."
              },
              {
                "id": "lab.experiment.fuel_reserve",
                "_autoId": true,
                "label": "fuel_reserve",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal",
                  "domain": ["science","navigation"]
                }
              },
              {
                "id": "lab.experiment.sample_analysis",
                "label": "SAMPLE_ANALYSIS",
                "type": "group",
                "note": "Nested group: laboratory sample breakdown.",
                "children": [
                  {
                    "id": "lab.experiment.sample_analysis.sample_id",
                "_autoId": true,
                    "label": "sample_id",
                    "type": "field",
                    "tags": ["active"],
                    "customAttributes": { "format": "string" }
                  },
                  {
                    "id": "lab.experiment.sample_analysis.composition",
                    "label": "composition",
                    "type": "field",
                    "tags": ["active"],
                    "customAttributes": { "format": "string", "domain": ["science"] }
                  },
                  {
                    "id": "lab.experiment.sample_analysis.mass_mg",
                    "label": "mass_mg",
                    "type": "field",
                    "tags": ["active"],
                    "customAttributes": { "format": "decimal" }
                  }
                ]
              }
            ]
          },
          {
            "id": "lab.personnel",
            "label": "PERSONNEL",
            "type": "group",
            "color": "#ec4899",
            "children": [
              {
                "id": "lab.personnel.team_code",
                "_autoId": true,
                "label": "team_code",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.personnel.lead_callsign",
                "label": "lead_callsign",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.personnel.lead_name",
                "_autoId": true,
                "label": "lead_name",
                "type": "field",
                "tags": [
                  "active",
                   "pending"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "yes"
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "arch",
      "label": "Archive DB",
      "note": "Long-term storage. Star schema with dim_ and fact_ tables for historical analysis.",
      "color": "#64748b",
      "schema": {
        "id": "arch",
        "label": "Archive DB",
        "type": "group",
        "children": [
          {
            "id": "arch.dim_mission",
                "_autoId": true,
            "label": "dim_mission",
            "type": "group",
            "children": [
              {
                "id": "arch.dim_mission.mission_id",
                "_autoId": true,
                "label": "mission_id",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.dim_mission.mission_name",
                "_autoId": true,
                "label": "mission_name",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.dim_mission.objective_cd",
                "label": "objective_cd",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.dim_mission.mass_kg",
                "_autoId": true,
                "label": "mass_kg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                },
                "note": "Launch mass, rounded to 2 decimals."
              },
              {
                "id": "arch.dim_mission.mass_kg_norm",
                "label": "mass_kg_norm",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                }
              },
              {
                "id": "arch.dim_mission.fuel_kg",
                "label": "fuel_kg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                }
              }
            ]
          },
          {
            "id": "arch.dim_crew",
                "_autoId": true,
            "label": "dim_crew",
            "type": "group",
            "tags": ["active"],
            "customAttributes": { "classified": "yes" },
            "note": "Crew dimension  contains restricted personnel data.",
            "color": "#6366f1",
            "children": [
              {
                "id": "arch.dim_crew.crew_id",
                "_autoId": true,
                "label": "crew_id",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.dim_crew.crew_name",
                "_autoId": true,
                "label": "crew_name",
                "type": "field",
                "tags": [
                  "active",
                   "pending"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "yes"
                }
              },
              {
                "id": "arch.dim_crew.crew_callsign",
                "label": "crew_callsign",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              }
            ]
          },
          {
            "id": "arch.fact_telemetry",
                "_autoId": true,
            "label": "fact_telemetry",
            "type": "group",
            "color": "#0ea5e9",
            "children": [
              {
                "id": "arch.fact_telemetry.mission_id",
                "_autoId": true,
                "label": "mission_id",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.fact_telemetry.orbit_cd",
                "label": "orbit_cd",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.fact_telemetry.recorded_ts",
                "_autoId": true,
                "label": "recorded_ts",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "datetime"
                },
                "note": "Archive ingestion timestamp  generated, not mapped."
              }
            ]
          }
        ]
      }
    },
    {
      "id": "obs",
      "_autoId": true,
      "label": "Obs",
      "note": "Ground-based tracking and analysis. Feeds enrichment data back to the archive.",
      "color": "#f59e0b",
      "schema": {
        "id": "obs",
        "_autoId": true,
        "label": "Obs",
        "type": "group",
        "children": [
          {
            "id": "obs.tracking",
            "label": "Tracking",
            "type": "group",
            "children": [
              {
                "id": "obs.tracking.missionKey",
                "label": "MissionKey",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "obs.tracking.orbitBucket",
                "label": "OrbitBucket",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              }
            ]
          },
          {
            "id": "obs.validation",
            "label": "Validation",
            "type": "group",
            "tags": ["pending"],
            "note": "Validation rules still being calibrated.",
            "color": "#eab308",
            "children": [
              {
                "id": "obs.validation.isNominal",
                "label": "IsNominal",
                "type": "field",
                "tags": [
                  "pending",
                   "active"
                ],
                "customAttributes": {
                  "format": "boolean"
                },
                "note": "Trajectory nominal flag  validation thresholds still being tuned."
              },
              {
                "id": "obs.validation.anomalyCodes",
                "label": "AnomalyCodes",
                "type": "field",
                "tags": [
                  "pending"
                ],
                "customAttributes": {
                  "format": "string"
                },
                "note": "Pipe-separated anomaly codes from ground tracking."
              }
            ]
          }
        ]
      }
    }
  ],
  "tagCatalog": [
    {
      "id": "active",
      "_autoId": true,
      "label": "Active",
      "abbr": "A",
      "color": "#22c55e",
      "note": "Field is active in production.",
      "priority": 1
    },
    {
      "id": "pending",
      "_autoId": true,
      "label": "Pending",
      "abbr": "?",
      "color": "#f59e0b",
      "note": "Mapping or field is still being defined  may change.",
      "priority": 2
    },
    {
      "id": "retired",
      "_autoId": true,
      "label": "Retired",
      "abbr": "R",
      "color": "#ef4444",
      "note": "No longer in use. Kept for historical reference.",
      "priority": 3
    }
  ],
  "transformCatalog": [
    {
      "id": "trim",
      "label": "Trim whitespace",
      "abbr": "TR",
      "note": "Remove leading/trailing whitespace.",
      "color": "#22c55e"
    },
    {
      "id": "upper",
      "label": "Uppercase",
      "abbr": "UP",
      "note": "Convert to uppercase."
    },
    {
      "id": "norm_ws",
      "label": "Normalize whitespace",
      "abbr": "NW",
      "note": "Collapse multiple spaces and trim."
    },
    {
      "id": "cast_dec",
      "label": "Cast to decimal",
      "abbr": "CD",
      "note": "Parse string to decimal with configurable precision.",
      "params": [
        {"id": "precision", "label": "Precision", "type": "number", "default": 2}
      ]
    },
    {
      "id": "normalize_g",
      "label": "Normalize to std gravity",
      "abbr": "NG",
      "note": "Convert mass to standard gravity units ( 9.80665)."
    },
    {
      "id": "round2",
      "label": "Round to N decimals",
      "abbr": "RN",
      "note": "Standard rounding before archival.",
      "params": [
        {"id": "decimals", "label": "Decimals", "type": "number", "default": 2}
      ]
    },
    {
      "id": "slugify",
      "label": "Slugify code",
      "abbr": "SL",
      "note": "Convert objective to lowercase slug (e.g. Geology/Core  geology-core)."
    },
    {
      "id": "fallback",
      "label": "Fallback to default",
      "abbr": "FB",
      "note": "Use default value when source is null or empty.",
      "params": [
        {"id": "value", "label": "Fallback value", "type": "text", "default": ""}
      ]
    },
    {
      "id": "lookup",
      "label": "Reference lookup",
      "abbr": "LK",
      "note": "Resolve foreign key to a descriptive value via lookup table.",
      "params": [
        {"id": "table", "label": "Lookup table", "type": "text", "default": ""},
        {"id": "key", "label": "Key column", "type": "text", "default": "id"}
      ]
    }
  ],
  "customAttributeCatalog": [
    {
      "id": "format",
      "_autoId": true,
      "label": "Format",
      "abbr": "FM",
      "note": "Logical data format of the field.",
      "priority": 1,
      "displayOnNode": true,
      "values": [
        {
          "id": "string",
          "_autoId": true,
          "label": "String",
          "abbr": "STR",
          "note": "Variable-length text",
          "color": "#22c55e",
          "colorEnabled": true,
          "priority": 1
        },
        {
          "id": "integer",
          "_autoId": true,
          "label": "Integer",
          "abbr": "INT",
          "note": "Whole number",
          "color": "#3b82f6",
          "colorEnabled": true,
          "priority": 2
        },
        {
          "id": "decimal",
          "_autoId": true,
          "label": "Decimal",
          "abbr": "DEC",
          "note": "Fixed-point number",
          "color": "#8b5cf6",
          "colorEnabled": true,
          "priority": 3
        },
        {
          "id": "boolean",
          "_autoId": true,
          "label": "Boolean",
          "abbr": "BOL",
          "note": "True/false flag",
          "color": "#f97316",
          "colorEnabled": true,
          "priority": 4
        },
        {
          "id": "datetime",
          "_autoId": true,
          "label": "DateTime",
          "abbr": "DT",
          "note": "ISO 8601 timestamp",
          "color": "#06b6d4",
          "colorEnabled": true,
          "priority": 5
        }
      ],
      "multi": false
    },
    {
      "id": "classified",
      "_autoId": true,
      "label": "Classified",
      "abbr": "CL",
      "note": "Whether the field contains restricted personnel information.",
      "priority": 2,
      "displayOnNode": true,
      "color": "#f59e0b",
      "colorEnabled": true,
      "values": [
        {
          "id": "yes",
          "_autoId": true,
          "label": "Yes",
          "abbr": "Y",
          "note": "Restricted  need-to-know access only",
          "color": "#ef4444",
          "colorEnabled": true,
          "priority": 1
        },
        {
          "id": "no",
          "_autoId": true,
          "label": "No",
          "abbr": "N",
          "color": "#22c55e",
          "colorEnabled": false,
          "priority": 2
        }
      ],
      "multi": false
    },
    {
      "id": "domain",
      "_autoId": true,
      "label": "Domain",
      "abbr": "DM",
      "note": "Which mission domains this field participates in. Multi-select.",
      "priority": 3,
      "displayOnNode": false,
      "values": [
        { "id": "telemetry", "label": "Telemetry", "abbr": "TM", "note": "Spacecraft sensor and flight data", "color": "#0ea5e9", "colorEnabled": true, "priority": 1 },
        { "id": "navigation", "label": "Navigation", "abbr": "NV", "note": "Orbit and trajectory data", "color": "#eab308", "colorEnabled": true, "priority": 2 },
        { "id": "personnel", "label": "Personnel", "abbr": "PR", "note": "Crew and team member data", "color": "#ec4899", "colorEnabled": true, "priority": 3 },
        { "id": "science", "label": "Science", "abbr": "SC", "note": "Experiment and research data", "color": "#10b981", "colorEnabled": true, "priority": 4 }
      ],
      "multi": true
    }
  ],
  "mappings": [
    {
      "from": "mc.mission.missionId",
      "to": "sat.vehicle.vehicleCode",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ],
      "note": "Mission Control ID becomes spacecraft vehicle code."
    },
    {
      "from": "mc.mission.missionName",
      "to": "sat.vehicle.missionLabel",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"},
        {"ref": "norm_ws"}
      ],
      "note": "Mission name flows to telemetry label."
    },
    {
      "from": "mc.mission.objectiveCode",
      "to": "sat.vehicle.objectiveTag",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "mc.mission.launchMass",
      "to": "sat.vehicle.massKg",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec", "params": {"precision": 4}}
      ]
    },
    {
      "from": "mc.mission.fuelBudget",
      "to": "sat.vehicle.fuelKg",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec"}
      ]
    },
    {
      "from": "mc.crew.crewId",
      "to": "sat.vehicle.nav.crewRef",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ]
    },
    {
      "from": "mc.crew.commanderName",
      "to": "sat.vehicle.nav.pilotName",
      "cardinality": "1:1",
      "color": "#eab308",
      "transforms": [
        {"ref": "trim"},
        {"ref": "norm_ws"}
      ]
    },
    {
      "from": "mc.crew.headcount",
      "to": "sat.vehicle.nav.pilotCallsign",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ],
      "note": "Crew headcount used to derive callsign pattern."
    },
    {
      "from": "sat.vehicle.vehicleCode",
      "to": "lab.experiment.experiment_ref",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ],
      "note": "Rename VehicleCode  experiment_ref."
    },
    {
      "from": "sat.vehicle.missionLabel",
      "to": "lab.experiment.experiment_name",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "norm_ws"}
      ]
    },
    {
      "from": "sat.vehicle.objectiveTag",
      "to": "lab.experiment.objective_slug",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "slugify"}
      ],
      "note": "Slugify objective for internal catalog."
    },
    {
      "from": "sat.vehicle.massKg",
      "to": "lab.experiment.payload_mass",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec"}
      ],
      "note": "Original mass reading."
    },
    {
      "from": "sat.vehicle.massKg",
      "to": "lab.experiment.payload_mass_norm",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec"},
        {"ref": "normalize_g"}
      ],
      "note": "Normalized mass (two transforms in sequence)."
    },
    {
      "from": "sat.vehicle.fuelKg",
      "to": "lab.experiment.fuel_reserve",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec"}
      ]
    },
    {
      "from": "sat.vehicle.nav.crewRef",
      "to": "lab.personnel.team_code",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"},
        {"ref": "upper"}
      ]
    },
    {
      "from": "sat.vehicle.nav.pilotName",
      "to": "lab.personnel.lead_name",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "norm_ws"},
        {"ref": "fallback", "params": {"value": "UNASSIGNED"}}
      ],
      "default": "UNASSIGNED",
      "note": "Default to UNASSIGNED when pilot name is pending."
    },
    {
      "from": "sat.vehicle.nav.pilotCallsign",
      "to": "lab.personnel.lead_callsign",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "upper"}
      ]
    },
    {
      "from": "lab.experiment.experiment_ref",
      "to": "arch.dim_mission.mission_id",
      "cardinality": "1:1",
      "transforms": [],
      "note": "Direct passthrough to archive."
    },
    {
      "from": "lab.experiment.experiment_name",
      "to": "arch.dim_mission.mission_name",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "lab.experiment.objective_slug",
      "to": "arch.dim_mission.objective_cd",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "upper"}
      ]
    },
    {
      "from": "lab.experiment.payload_mass",
      "to": "arch.dim_mission.mass_kg",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "round2"}
      ],
      "note": "Round before archival."
    },
    {
      "from": "lab.experiment.payload_mass_norm",
      "to": "arch.dim_mission.mass_kg_norm",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "round2", "params": {"decimals": 4}}
      ]
    },
    {
      "from": "lab.experiment.fuel_reserve",
      "to": "arch.dim_mission.fuel_kg",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "lab.personnel.team_code",
      "to": "arch.dim_crew.crew_id",
      "cardinality": "n:1",
      "transforms": [],
      "note": "Multiple missions may share a crew."
    },
    {
      "from": "lab.personnel.lead_name",
      "to": "arch.dim_crew.crew_name",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "lab.personnel.lead_callsign",
      "to": "arch.dim_crew.crew_callsign",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "arch.dim_mission.mission_id",
      "to": "obs.tracking.missionKey",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ],
      "note": "Archive feeds observatory tracking."
    },
    {
      "from": "obs.tracking.missionKey",
      "to": "arch.fact_telemetry.mission_id",
      "cardinality": "1:1",
      "color": "#3b82f6",
      "transforms": [],
      "note": "Observatory writes back to archive fact table."
    },
    {
      "from": "obs.tracking.orbitBucket",
      "to": "arch.fact_telemetry.orbit_cd",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "upper"}
      ]
    },
    {
      "from": "mc.forecast.arrivalWindow",
      "to": "obs.tracking.orbitBucket",
      "cardinality": "1:1",
      "color": "#f43f5e",
      "transforms": [
        {"ref": "upper"},
        {"ref": "trim"}
      ],
      "note": "Non-adjacent: Mission Control forecast feeds observatory directly."
    },
    {
      "from": "arch.dim_mission.mission_id",
      "to": "lab.experiment.experiment_ref",
      "cardinality": "1:1",
      "color": "#a855f7",
      "transforms": [],
      "note": "Bidirectional: archive can reconcile back to science lab."
    },
    {
      "from": "lab.experiment.sample_analysis.sample_id",
      "to": "arch.dim_mission.mission_id",
      "cardinality": "N:1",
      "color": "#f97316",
      "transforms": [
        {"ref": "trim"}
      ],
      "tags": ["active"],
      "note": "Links sample records back to the parent mission in archive."
    },
    {
      "from": "obs.tracking.missionKey",
      "to": "obs.validation.isNominal",
      "cardinality": "1:1",
      "color": "#06b6d4",
      "transforms": [],
      "note": "Same-column: tracking key determines nominal validation flag."
    },
    {
      "from": "lab.experiment.experiment_ref",
      "to": "lab.personnel.lead_name",
      "cardinality": "N:1",
      "color": "#22c55e",
      "transforms": [
        {"ref": "lookup", "params": {"table": "personnel_roster", "key": "experiment_id"}}
      ],
      "note": "Same-column: experiment reference resolves to the lead researcher."
    }
  ],
  "filterCatalog": [
    {
      "id": "critical_unmapped",
      "label": "Critical & Unmapped",
      "note": "Fields tagged Critical that have no mappings yet  likely gaps.",
      "priority": 1,
      "rules": [
        { "field": "tag", "op": "has", "value": "critical" },
        { "join": "and", "field": "mapped", "op": "no", "value": "" }
      ],
      "highlight": { "bg": "#ef4444", "border": "#ef4444", "edgeColor": "#ef4444", "frameColor": "#ef4444", "bgEnabled": true, "borderEnabled": true, "edgeEnabled": false, "bold": true, "frame": true, "emoji": "" }
    },
    {
      "id": "string_fields",
      "label": "String format",
      "note": "All fields with Format = String",
      "priority": 2,
      "rules": [
        { "field": "attr:format", "op": "is", "value": "string" }
      ],
      "highlight": { "bg": "#22c55e", "border": "#22c55e", "edgeColor": "#22c55e", "frameColor": "#22c55e", "bgEnabled": true, "borderEnabled": true, "edgeEnabled": true, "bold": false, "frame": false, "emoji": "" }
    },
    {
      "id": "trimmed_fields",
      "label": "Trimmed mappings",
      "note": "Nodes connected by edges using the Trim transform",
      "priority": 3,
      "rules": [
        { "field": "transform", "op": "has", "value": "trim" }
      ],
      "highlight": { "bg": "#a855f7", "border": "#a855f7", "edgeColor": "#a855f7", "frameColor": "#a855f7", "bgEnabled": true, "borderEnabled": false, "edgeEnabled": true, "bold": false, "frame": false, "emoji": "" }
    }
  ]
};/* =========================
   App state
========================= */
const state = {
  tab: "viewer",

  // viewer state
  lockedId: null,
  hoverId: null,
  search: "",
  onlyMapped: false,
  activeFilterIds: [],   // IDs from filterCatalog currently applied
  filterLogic: 'or',     // 'and' | 'or'  how multiple active filters combine
  filterMode: 'hide',    // 'hide' | 'dim' | 'highlight'
  arrowsOn: true,
  allArrows: false,
  showSameColumn: true,
  showDistant: true,
  selectionDim: 'all',  // 'all' | 'keepParents' | 'off'
  panMode: false,
  multiSelection: new Set(),       // multi-select: set of node IDs
  _multiCollapsed: { nodes: true, mappings: false, mapInternal: false, mapOutbound: false, mapInbound: false }, // collapse state for multi-select panel sections
  multiSelectArrowMode: 'chain',   // 'chain' | 'direct' | 'selected'  highlight mode for selections
  edgeColorScheme: '',  // '' | 'cardinality' | 'transform' | 'srcTag' | 'tgtTag' | 'srcAttr:id' | 'tgtAttr:id'
  hiddenColumns: new Set(),
  wrapColumns: false,
  showTagPills: true,      // display tag pills on nodes
  showAttrPills: true,     // display custom attribute pills on nodes
  nodeColorMode: 'all',    // 'all' | 'groups' | 'column' | 'off'
  
  // project state
  isDirty: false,
  
  // undo/redo
  undoStack: [],
  redoStack: [],
  maxUndoSteps: 50,

  // inline editor
  editorMode: false,
  selectedEdgeId: null,
  selectedColumnId: null,
  hoverEdgeId: null,
  // node editor UI state
  nodeEditorAttrFocus: '',
  // panel layout
  panelMode: 'right',  // 'left' | 'right' | 'bottom' | 'float' | 'hidden'
  panelWidth: 444,    // side mode width
  panelHeight: null,   // bottom mode height (null = auto)
  // data
  data: null
};

/* =========================
   DOM refs
========================= */
const viewerControls = document.getElementById("viewerControls");
const views = {
  viewer: document.getElementById("view-viewer")
};

const globalStatus = document.getElementById("globalStatus");
const viewerStatus = document.getElementById("viewerStatus");

const columnsScroller = document.getElementById("columnsScroller");
const columnsRow = document.getElementById("columnsRow");
const svgOverlay = document.getElementById("svgOverlay");
const edgesLayer = document.getElementById("edgesLayer");

const detailsMeta = document.getElementById("detailsMeta");
const detailsBody = document.getElementById("detailsBody");

const jsonArea = document.getElementById("jsonArea");
const logArea = document.getElementById("logArea");
const fileInput = document.getElementById("fileInput");


const fieldDatalist = document.getElementById("fieldDatalist");

/* Viewer controls */
const searchInput = document.getElementById("searchInput");
const clearFilterBtn = document.getElementById("clearFilterBtn");
const expandAllBtn = document.getElementById("expandAllBtn");
const collapseAllBtn = document.getElementById("collapseAllBtn");
const clearSelectionBtn = document.getElementById("clearSelectionBtn");
const onlyMappedToggle = document.getElementById("onlyMappedToggle");
const showSameColToggle = document.getElementById("showSameColToggle");
const showDistantToggle = document.getElementById("showDistantToggle");
const wrapToggle = document.getElementById("wrapToggle");
const editorModeToggle = document.getElementById("editorModeToggle");
const editorOverlay = document.getElementById("editorOverlay");
const columnsBtn = document.getElementById("columnsBtn");
const columnsPopover = document.getElementById("columnsPopover");
const columnsList = document.getElementById("columnsList");
const showAllColsBtn = document.getElementById("showAllColsBtn");
const hideUnmappedColsBtn = document.getElementById("hideUnmappedColsBtn");
const closeColumnsBtn = document.getElementById("closeColumnsBtn");
const exportCsvBtn = document.getElementById("exportCsvBtn");
const exportReportBtn = document.getElementById("exportReportBtn");
const helpBtn = document.getElementById("helpBtn");
const helpMask = document.getElementById("helpMask");
const helpModal = document.getElementById("helpModal");
const helpBody = document.getElementById("helpBody");
const closeHelpBtn = document.getElementById("closeHelpBtn");
const tagsBtn = document.getElementById("tagsBtn");
const tagsMask = document.getElementById("tagsMask");
const tagsModal = document.getElementById("tagsModal");
const tagsBody = document.getElementById("tagsBody");
const closeTagsBtn = document.getElementById("closeTagsBtn");
const addTagBtn = document.getElementById("addTagBtn");
const addTransformBtn = document.getElementById("addTransformBtn");
const addCustomAttrBtn = document.getElementById("addCustomAttrBtn");
const closeCustomAttrsBtn = document.getElementById("closeCustomAttrsBtn");
const customAttrsMask = document.getElementById("customAttrsMask");

const loadExampleBtn = document.getElementById("loadExampleBtn");
const newMappingBtn = document.getElementById("newMappingBtn");
const openProjectBtn = document.getElementById("openProjectBtn");
const saveProjectBtn = document.getElementById("saveProjectBtn");
const showAllColumnsBtn = document.getElementById("showAllColumnsBtn");
const undoBtn = document.getElementById("undoBtn");
const redoBtn = document.getElementById("redoBtn");
const addColumnLeftBtn = document.getElementById("addColumnLeftBtn");
const addColumnRightBtn = document.getElementById("addColumnRightBtn");

/* Docs */
const docsBody = document.getElementById("docsBody");

/* =========================
   In-memory indexes rebuilt on render
========================= */
let IDX = null;

function resetIndexes(){
  IDX = {
    // column order and meta
    columns: [],                 // [{id,label,schema}]
    columnIndex: new Map(),      // id -> index

    // nodes
    nodeById: new Map(),         // nodeId -> node
    parentById: new Map(),       // nodeId -> parentId
    elementById: new Map(),      // nodeId -> .node element
    rowById: new Map(),          // nodeId -> .row element
    nodeColumnById: new Map(),   // nodeId -> columnId
    fieldIds: new Set(),         // all field IDs

    // descendants
    nodeFieldDescendants: new Map(), // nodeId -> [fieldIds]

    // edges
    edges: [],                   // expanded edges {id, from, to, ...meta}
    edgesByField: new Map(),     // fieldId -> [edge]
    adjacency: new Map(),        // fieldId -> Set(connected fieldId)
    mappedFields: new Set(),     // field ids present in any edge

    // for geometry / rendering
    panelByColumnId: new Map(),  // colId -> panel element
    treeByColumnId: new Map(),   // colId -> tree element
  };
}

/* =========================
   Utilities
========================= */
const norm = s => (s ?? "").toString().toLowerCase();

function columnOf(id){
  // expects "<colId>." prefix
  const i = id.indexOf(".");
  return i > 0 ? id.slice(0, i) : null;
}
function isField(id){ return IDX.fieldIds.has(id); }

function ensureArr(map, key){ if(!map.has(key)) map.set(key, []); return map.get(key); }
function ensureSet(map, key){ if(!map.has(key)) map.set(key, new Set()); return map.get(key); }

function short(s, max=52){
  if(s === undefined || s === null) return "";
  s = String(s);
  return s.length > max ? s.slice(0, max-1) + "" : s;
}

// --- ID generation helpers (rename updates) ---
function idPartFromLabel(label, {lower=false}={}){
  let s = String(label||'').trim();
  // Replace spaces with underscore, keep existing underscores and alphanumerics.
  s = s.replace(/\s+/g,'_').replace(/[^A-Za-z0-9_]/g,'').replace(/_+/g,'_');
  if(lower) s = s.toLowerCase();
  if(!s) s = 'node';
  // Avoid starting with a digit
  if(/^[0-9]/.test(s)) s = 'n_' + s;
  return s;
}
// Check if an object's ID is auto-derived from its label.
function isLikelyAutoId(obj){
  return !!(obj && obj._autoId);
}
function ensureUniqueId(baseId, taken){
  let id = baseId;
  let i = 2;
  while(taken.has(id)){
    id = baseId + '_' + i;
    i += 1;
    }
    return id;
}

// --- v20.1: always compute a unique ID within target parent/group (sibling scope)
function uniqueSiblingId(parentId, label, siblings) {
  const taken = new Set((siblings || []).map(n => n && n.id).filter(Boolean));
  const base = parentId + '.' + idPartFromLabel(label, { lower:false });
  return ensureUniqueId(base, taken);
}

function findColumnByIdIn(data, colId){
  return (data?.columns||[]).find(c=>c && c.id===colId);
}
function replaceIdsInMappings(data, idMap){
  if(!data || !Array.isArray(data.mappings)) return;
  data.mappings.forEach(m=>{
    if(!m || typeof m!=='object') return;
    if(typeof m.from==='string' && idMap[m.from]) m.from = idMap[m.from];
    if(Array.isArray(m.to)){
      m.to = m.to.map(t => (typeof t==='string' && idMap[t]) ? idMap[t] : t);
    } else if(typeof m.to==='string' && idMap[m.to]){
      m.to = idMap[m.to];
    }
  });
}
function buildSubtreeIdMap(node, oldPrefix, newPrefix, out){
  if(!node || typeof node!=='object') return;
  const oldId = node.id;
  // Replace only the prefix for subtree
  const newId = (oldId === oldPrefix) ? newPrefix : (newPrefix + oldId.slice(oldPrefix.length));
  out[oldId] = newId;
  node.id = newId;
  (node.children||[]).forEach(ch => buildSubtreeIdMap(ch, oldPrefix, newPrefix, out));
}

// v20.1 safety net: ensure sibling IDs are unique per group (fixes any duplicate copies)
function normalizeSiblingIds(data){
  if(!data || !Array.isArray(data.columns)) return;
  const idMap = {};
  function walk(node){
    if(!node || typeof node!== 'object' || !Array.isArray(node.children)) return;
    const seen = new Map();
    for(let i=0;i<node.children.length;i++){
      const ch = node.children[i];
      if(!ch || !ch.id) continue;
      const key = ch.id;
      if(!seen.has(key)){
        seen.set(key, 1);
      } else {
        // duplicate under same parent: compute unique id and rewrite subtree
        const siblings = node.children;
        const newId = uniqueSiblingId(node.id, ch.label || ch.id, siblings);
        const oldId = ch.id;
        if(newId !== oldId){
          buildSubtreeIdMap(ch, oldId, newId, idMap);
        }
      }
    }
    // recurse after potential rewrites
    for(const ch of (node.children||[])){ walk(ch); }
  }
  for(const col of (data.columns||[])){ if(col && col.schema) walk(col.schema); }
  if(Object.keys(idMap).length){ replaceIdsInMappings(data, idMap); }
}

function renameNodeInData(data, nodeId, newLabel, explicitColId=null){
  if(!data) return nodeId;
  const colId = explicitColId || columnOf(nodeId) || nodeId;
  const col = findColumnByIdIn(data, colId);
  if(!col || !col.schema) return nodeId;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.node) return nodeId;

  // Update label only  ID is independent and stays unchanged
  loc.node.label = newLabel;
  return nodeId;
}
function renameColumnInData(data, oldColId, newLabel){
  if(!data) return oldColId;
  const col = findColumnByIdIn(data, oldColId);
  if(!col) return oldColId;

  // Update column label only  ID is independent and stays unchanged
  col.label = newLabel;
  return oldColId;
}

/* ---- ID refactoring functions ---- */

// Collect ALL node IDs across the entire project
function collectAllNodeIds(data){
  const ids = new Set();
  for(const col of (data?.columns||[])){
    if(!col || !col.schema) continue;
    (function walk(n){ if(!n) return; if(n.id) ids.add(n.id); (n.children||[]).forEach(walk); })(col.schema);
  }
  return ids;
}

// Walk all nodes in all columns, calling fn(node) for each
function walkAllNodes(data, fn){
  for(const col of (data?.columns||[])){
    if(!col || !col.schema) continue;
    (function walk(n){ if(!n) return; fn(n); (n.children||[]).forEach(walk); })(col.schema);
  }
}

// Sanitize a manually-entered ID: trim, replace spaces with underscores
function sanitizeManualId(raw){
  return (raw||'').trim().replace(/\s+/g,'_');
}

// Extract the last segment of a dotted node ID (the "local" part)
function localIdSegment(nodeId){
  if(!nodeId) return '';
  const lastDot = nodeId.lastIndexOf('.');
  return lastDot >= 0 ? nodeId.slice(lastDot + 1) : nodeId;
}

// Extract the path prefix of a dotted node ID (everything before the last dot, inclusive)
function idPathPrefix(nodeId){
  if(!nodeId) return '';
  const lastDot = nodeId.lastIndexOf('.');
  return lastDot >= 0 ? nodeId.slice(0, lastDot + 1) : '';
}

// Rename a column's ID independently from its label
function reIdColumnInData(data, oldColId, newColId){
  if(!data || !newColId || oldColId === newColId) return oldColId;
  const col = findColumnByIdIn(data, oldColId);
  if(!col) return oldColId;
  const taken = new Set((data.columns||[]).filter(c=>c && c.id!==oldColId).map(c=>c.id));
  if(taken.has(newColId)) return oldColId;

  const idMap = {};
  const root = col.schema;
  root.id = oldColId;
  buildSubtreeIdMap(root, oldColId, newColId, idMap);
  col.id = newColId;
  if(col.schema) col.schema.id = newColId;
  replaceIdsInMappings(data, idMap);

  if(data === state.data && state.hiddenColumns && state.hiddenColumns.has(oldColId)){
    state.hiddenColumns.delete(oldColId);
    state.hiddenColumns.add(newColId);
  }
  return newColId;
}

// Rename a node's ID independently from its label
function reIdNodeInData(data, oldNodeId, newNodeId, explicitColId){
  if(!data || !newNodeId || oldNodeId === newNodeId) return oldNodeId;
  // Check global uniqueness (excluding the node's own subtree)
  const allIds = collectAllNodeIds(data);
  // Remove the old subtree IDs (they'll be rewritten)
  const colId = explicitColId || columnOf(oldNodeId) || oldNodeId;
  const col = findColumnByIdIn(data, colId);
  if(!col || !col.schema) return oldNodeId;
  const loc = locateNode(col.schema, oldNodeId);
  if(!loc || !loc.node) return oldNodeId;
  // Remove old subtree from taken set
  (function removeOld(n){ if(!n) return; allIds.delete(n.id); (n.children||[]).forEach(removeOld); })(loc.node);
  // Check if new id or any projected descendant collides
  if(allIds.has(newNodeId)) return oldNodeId;

  const idMap = {};
  buildSubtreeIdMap(loc.node, oldNodeId, newNodeId, idMap);
  // Verify no collisions with projected new ids
  for(const nid of Object.values(idMap)){
    if(allIds.has(nid)) {
      // Collision  revert by rebuilding with old ids
      buildSubtreeIdMap(loc.node, newNodeId, oldNodeId, {});
      return oldNodeId;
    }
  }
  replaceIdsInMappings(data, idMap);
  return newNodeId;
}

// Rename a tag's ID and update all node.tags references
function reIdTagInData(data, oldTagId, newTagId){
  if(!data || !newTagId || oldTagId === newTagId) return oldTagId;
  const cat = data.tagCatalog || [];
  const tag = cat.find(t => t && t.id === oldTagId);
  if(!tag) return oldTagId;
  if(cat.some(t => t && t.id === newTagId && t !== tag)) return oldTagId;
  tag.id = newTagId;
  walkAllNodes(data, n => {
    if(Array.isArray(n.tags)) n.tags = n.tags.map(t => t === oldTagId ? newTagId : t);
  });
  return newTagId;
}

// Rename a custom attribute's ID and update all node.customAttributes keys
function reIdCustomAttrInData(data, oldAttrId, newAttrId){
  if(!data || !newAttrId || oldAttrId === newAttrId) return oldAttrId;
  const cat = data.customAttributeCatalog || [];
  const attr = cat.find(a => a && a.id === oldAttrId);
  if(!attr) return oldAttrId;
  if(cat.some(a => a && a.id === newAttrId && a !== attr)) return oldAttrId;
  attr.id = newAttrId;
  walkAllNodes(data, n => {
    if(n.customAttributes && typeof n.customAttributes === 'object' && !Array.isArray(n.customAttributes)){
      if(oldAttrId in n.customAttributes){
        n.customAttributes[newAttrId] = n.customAttributes[oldAttrId];
        delete n.customAttributes[oldAttrId];
      }
    }
  });
  return newAttrId;
}

// Rename a transform's ID and update all mapping.transforms references
function reIdTransformInData(data, oldTrId, newTrId){
  if(!data || !newTrId || oldTrId === newTrId) return oldTrId;
  const cat = data.transformCatalog || [];
  const tr = cat.find(t => t && t.id === oldTrId);
  if(!tr) return oldTrId;
  if(cat.some(t => t && t.id === newTrId && t !== tr)) return oldTrId;
  tr.id = newTrId;
  if(Array.isArray(data.mappings)){
    data.mappings.forEach(m => {
      if(m && Array.isArray(m.transforms)){
        m.transforms = m.transforms.map(t => {
          if(typeof t === 'string') return t === oldTrId ? newTrId : t;
          if(typeof t === 'object' && t && t.ref === oldTrId) return { ...t, ref: newTrId };
          return t;
        });
      }
    });
  }
  return newTrId;
}

// Rename a custom attribute value's ID and update all node.customAttributes values
function reIdCustomAttrValueInData(data, attrId, oldValId, newValId){
  if(!data || !newValId || oldValId === newValId) return oldValId;
  const cat = data.customAttributeCatalog || [];
  const attr = cat.find(a => a && a.id === attrId);
  if(!attr || !Array.isArray(attr.values)) return oldValId;
  const val = attr.values.find(v => v && v.id === oldValId);
  if(!val) return oldValId;
  if(attr.values.some(v => v && v.id === newValId && v !== val)) return oldValId;
  val.id = newValId;
  walkAllNodes(data, n => {
    if(n.customAttributes && typeof n.customAttributes === 'object' && !Array.isArray(n.customAttributes)){
      const cur = n.customAttributes[attrId];
      if(Array.isArray(cur)){
        n.customAttributes[attrId] = cur.map(v => String(v) === String(oldValId) ? newValId : v);
      } else if(cur !== undefined && String(cur) === String(oldValId)){
        n.customAttributes[attrId] = newValId;
      }
    }
  });
  return newValId;
}


function formatTransform(t){
  if(!t) return "";
  if(typeof t === "string") return t;
  if(Array.isArray(t)) return t.map(formatTransform).filter(Boolean).join("  ");
  if(typeof t === "object"){
    const params = t.params ? JSON.stringify(t.params) : "";
    return params ? `${t.type} ${params}` : `${t.type}`;
  }
  return String(t);
}

function edgeSortKey(e){ return `${e.from}${e.to}`; }
function compareEdgesSimple(a,b){ return edgeSortKey(a).localeCompare(edgeSortKey(b)); }




function isCompute(edge){
  if(edge.computeGroup) return true;
  const t = edge.transform;
  const check = o => o && typeof o === "object" && !Array.isArray(o) && o.type === "compute";
  if(check(t)) return true;
  if(Array.isArray(t)) return t.some(check);
  return false;
}

function isFallback(edge){
  if(edge.default !== undefined && edge.default !== null && String(edge.default) !== "") return true;
  const t = edge.transform;
  const check = o => o && typeof o === "object" && !Array.isArray(o)
    && ["defaultIfNull","defaultIfEmpty","defaultIfNullOrEmpty","coalesce"].includes(o.type);
  if(check(t)) return true;
  if(Array.isArray(t)) return t.some(check);
  return false;
}

function setGlobalStatus(text){ globalStatus.textContent = text; }
function setViewerStatus(text){ viewerStatus.textContent = text; }

// Custom alert/confirm dialogs (replaces browser prompts)
// Ensure the standard dialog body structure exists (bulk modals may replace innerHTML)
function _ensureDialogBody(){
  const dialog = document.getElementById('customDialog');
  const body = dialog?.querySelector('.modalBody');
  if(!body) return;
  if(!document.getElementById('customDialogMessage')){
    body.innerHTML = `<div id="customDialogMessage" style="font-size:15px;line-height:1.6;margin-bottom:24px;white-space:pre-wrap;"></div>
      <div id="customDialogButtons" style="display:flex;gap:8px;justify-content:flex-end;"></div>`;
  }
}
function customAlert(message){
  return new Promise((resolve) => {
    _ensureDialogBody();
    const mask = document.getElementById('customDialogMask');
    const dialog = document.getElementById('customDialog');
    const messageEl = document.getElementById('customDialogMessage');
    const buttonsEl = document.getElementById('customDialogButtons');
    
    messageEl.textContent = message;
    buttonsEl.innerHTML = '';
    const hdr = dialog.querySelector('.modalHeader');
    if(hdr) hdr.style.display = 'none';
    
    const okBtn = document.createElement('button');
    okBtn.className = 'btn';
    okBtn.textContent = 'OK';
    okBtn.style.minWidth = '80px';
    okBtn.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      resolve();
    });
    buttonsEl.appendChild(okBtn);
    
    mask.classList.add('active');
    dialog.classList.add('active');
    okBtn.focus();
    
    // Close on Escape or mask click
    const onEscape = (e) => {
      if(e.key === 'Escape'){ 
        mask.classList.remove('active');
        dialog.classList.remove('active');
        document.removeEventListener('keydown', onEscape);
        resolve();
      }
    };
    document.addEventListener('keydown', onEscape);
    
    mask.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      document.removeEventListener('keydown', onEscape);
      resolve();
    }, {once: true});
  });
}

function customConfirm(message){
  return new Promise((resolve) => {
    _ensureDialogBody();
    const mask = document.getElementById('customDialogMask');
    const dialog = document.getElementById('customDialog');
    const messageEl = document.getElementById('customDialogMessage');
    const buttonsEl = document.getElementById('customDialogButtons');
    
    messageEl.textContent = message;
    buttonsEl.innerHTML = '';
    const hdr = dialog.querySelector('.modalHeader');
    if(hdr) hdr.style.display = 'none';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.minWidth = '80px';
    cancelBtn.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      resolve(false);
    });
    
    const okBtn = document.createElement('button');
    okBtn.className = 'btn';
    okBtn.textContent = 'OK';
    okBtn.style.minWidth = '80px';
    okBtn.style.background = 'rgba(59,130,246,0.15)';
    okBtn.style.borderColor = 'rgba(59,130,246,0.4)';
    okBtn.style.color = 'rgba(96,165,250,1)';
    okBtn.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      resolve(true);
    });
    
    buttonsEl.appendChild(cancelBtn);
    buttonsEl.appendChild(okBtn);
    
    mask.classList.add('active');
    dialog.classList.add('active');
    okBtn.focus();
    
    // Close on Escape
    const onEscape = (e) => {
      if(e.key === 'Escape'){ 
        mask.classList.remove('active');
        dialog.classList.remove('active');
        document.removeEventListener('keydown', onEscape);
        resolve(false);
      }
    };
    document.addEventListener('keydown', onEscape);
    
    mask.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      document.removeEventListener('keydown', onEscape);
      resolve(false);
    }, {once: true});
  });
}




// --- Transforms (mapping-level) ---
function ensureTransformCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.transformCatalog)) state.data.transformCatalog = [];
  return state.data.transformCatalog;
}
function transformById(id){
  const cat = ensureTransformCatalog();
  return cat.find(t=>t && t.id===id) || null;
}
function transformAbbr(t){
  if(!t) return '';
  const a = (t.abbr||'').trim();
  if(a) return a;
  const lbl = (t.label||t.id||'').trim();
  return lbl ? lbl.slice(0,2).toUpperCase() : '';
}
function formatTransformRef(ref){
  if(!ref) return '';
  // Legacy string format
  if(typeof ref==='string'){
    const t = transformById(ref);
    return t ? (t.label||t.id) : ref;
  }
  // Array = chain
  if(Array.isArray(ref)) return ref.map(formatTransformRef).filter(Boolean).join('  ');
  // New {ref, params} instance format
  if(typeof ref==='object' && ref.ref){
    const t = transformById(ref.ref);
    const label = t ? (t.label||t.id) : ref.ref;
    const p = ref.params;
    if(p && typeof p==='object' && Object.keys(p).length > 0){
      const pStr = Object.entries(p).map(([k,v])=>`${k}=${v}`).join(', ');
      return `${label}(${pStr})`;
    }
    return label;
  }
  // Legacy object with .type
  if(typeof ref==='object' && ref.type){
    const params = ref.params ? JSON.stringify(ref.params) : '';
    return params ? `${ref.type} ${params}` : `${ref.type}`;
  }
  return String(ref);
}

// Get the catalog ref ID from a transform instance (handles both old string and new object format)
function transformRefId(inst){
  if(!inst) return '';
  if(typeof inst === 'string') return inst;
  if(typeof inst === 'object' && inst.ref) return inst.ref;
  return '';
}

// Get abbreviated label for a transform instance
function formatTransformAbbr(inst){
  const rid = transformRefId(inst);
  const t = transformById(rid);
  if(!t) return rid;
  const abbr = transformAbbr(t);
  const p = (typeof inst === 'object' && inst.params && Object.keys(inst.params).length > 0);
  return p ? abbr + '()' : abbr;
}

// Normalize a transforms array: convert legacy strings to {ref} objects
function normalizeTransforms(arr){
  if(!Array.isArray(arr)) return [];
  return arr.map(t => {
    if(typeof t === 'string') return { ref: t };
    if(typeof t === 'object' && t && t.ref) return t;
    return null;
  }).filter(Boolean);
}
// --- Tags (node-level) ---
const DEFAULT_TAG_COLOR = '#3b82f6';
function ensureTagCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.tagCatalog)) state.data.tagCatalog = [];
  return state.data.tagCatalog;
}
function tagById(id){
  const cat = ensureTagCatalog();
  return cat.find(t=>t && t.id===id) || null;
}
function normalizeNodeTags(node){
  if(!node) return [];
  if(!Array.isArray(node.tags)) node.tags = [];
  node.tags = node.tags.filter(x=>typeof x==='string' && x.trim());
  return node.tags;
}
function tagColor(tag){
  return (tag && tag.color) ? tag.color : DEFAULT_TAG_COLOR;
}
function tagAbbr(tag){
  if(!tag) return '';
  const a = (tag.abbr||'').trim();
  if(a) return a;
  const lbl = (tag.label||tag.id||'').trim();
  return lbl ? lbl.slice(0,1).toUpperCase() : '';
}
function sortTagIdsByPriority(tagIds){
  if(!tagIds || !tagIds.length) return tagIds;
  const cat = ensureTagCatalog();
  return [...tagIds].sort((a,b)=>{
    const ta = cat.find(t=>t.id===a);
    const tb = cat.find(t=>t.id===b);
    const pa = ta && typeof ta.priority==='number' ? ta.priority : 9999;
    const pb = tb && typeof tb.priority==='number' ? tb.priority : 9999;
    return pa - pb;
  });
}
function nextTagPriority(){
  const cat = ensureTagCatalog();
  let max = 0;
  cat.forEach(t=>{ if(typeof t.priority==='number' && t.priority > max) max = t.priority; });
  return max + 1;
}

// --- Tag creation modal (auto id + preset colors) ---


// --- Transform creation modal (catalog-based; no browser prompts) ---

function slugifyTagLabel(label){
  return String(label||'')
    .trim()
    .toLowerCase()
    .replace(/\s+/g,'_')
    .replace(/[^a-z0-9_\-]/g,'')
    .replace(/_+/g,'_')
    .replace(/^_+|_+$/g,'');
}

function slugifyTransformLabel(label){
  return String(label||'').trim().toLowerCase()
    .replace(/\s+/g,'_')
    .replace(/[^a-z0-9_\-]/g,'')
    .replace(/_+/g,'_')
    .replace(/^_+|_+$/g,'');
}
function generateTransformIdFromLabel(label){
  const base0 = slugifyTransformLabel(label) || 'transform';
  const cat = ensureTransformCatalog();
  const taken = new Set((cat||[]).map(t=>t && t.id).filter(Boolean));
  let id = base0, i = 2;
  while(taken.has(id)) { id = base0 + '_' + i; i += 1; }
  return id;
}
function openTransformCreateModal(opts={}){
  const afterCreate = opts.afterCreate || null;
  const cat = ensureTransformCatalog();
  const taken = new Set((cat||[]).map(t=>t && t.id).filter(Boolean));
  openCreateModal({
    kind: 'transform',
    title: 'Create transform',
    placeholder: 'e.g. Trim whitespace',
    hint: 'ID is generated from the label. You can override it.',
    taken,
    onCommit: ({label, id, abbr, note, _autoId, _autoAbbr})=>{
      const finalAbbr = (abbr||'').trim() || label.replace(/\s+/g,'').slice(0,2).toUpperCase();
      const finalNote = (note||'').trim();
      // Read params from create modal
      const paramsContainer = document.getElementById('createParamsRows');
      const newParams = [];
      if(paramsContainer){
        paramsContainer.querySelectorAll('.trParamRow').forEach(row => {
          let pid = (row.querySelector('[data-pf="id"]')?.value||'').trim();
          const plabel = (row.querySelector('[data-pf="label"]')?.value||'').trim();
          const ptype = row.querySelector('[data-pf="type"]')?.value || 'text';
          const pdef = (row.querySelector('[data-pf="default"]')?.value||'').trim();
          if(!pid && plabel) pid = plabel.toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
          if(pid){
            const p = { id: pid, label: plabel || pid, type: ptype };
            if(pdef !== '') p.default = ptype === 'number' ? Number(pdef) : pdef;
            newParams.push(p);
          }
        });
      }
      const cat2 = ensureTransformCatalog();
      recordChange();
      const entry = { id, label, abbr: finalAbbr, note: finalNote, _autoId, _autoAbbr };
      if(newParams.length) entry.params = newParams;
      cat2.push(entry);
      renderAll();
      renderTransformsManager();
      if(typeof afterCreate === 'function'){
        try { afterCreate(id); } catch(e){ console.error(e); }
      }
      setGlobalStatus('Created transform ' + id);
    }
  });
}


// --- Custom Attributes (node-level; catalogized keys & values) ---
function ensureCustomAttributeCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.customAttributeCatalog)) state.data.customAttributeCatalog = [];
  return state.data.customAttributeCatalog;
}
function customAttrById(id){
  const cat = ensureCustomAttributeCatalog();
  return cat.find(a=>a && a.id===id) || null;
}
function customValueById(attrId, valId){
  const a = customAttrById(attrId);
  const vals = (a && Array.isArray(a.values)) ? a.values : [];
  return vals.find(v=>v && v.id===valId) || null;
}
function customAttrLabel(id){
  const a = customAttrById(id);
  return a ? (a.label||a.id) : id;
}
function customValueLabel(attrId, valId){
  const v = customValueById(attrId, valId);
  return v ? (v.label||v.id) : valId;
}
function customAttrAbbr(a){
  if(!a) return '';
  const ab = (a.abbr||'').trim();
  if(ab) return ab;
  const lbl = (a.label||a.id||'').trim();
  return lbl ? lbl.slice(0,2).toUpperCase() : '';
}

// Per-attribute multiplicity (single vs multi)
function customAttrIsMulti(aid){
  const a = customAttrById(aid);
  // default is single-select unless explicitly marked multi
  return !!(a && a.multi);
}
function normalizeCatalogMultiFlag(){
  const cat = ensureCustomAttributeCatalog();
  (cat||[]).forEach(a=>{ if(a && typeof a==='object' && a.multi===undefined) a.multi = false; });
}
function normalizeCustomAttributes(node){
  if(!node || typeof node!=='object') return {};
  if(!node.customAttributes || typeof node.customAttributes!=='object' || Array.isArray(node.customAttributes)) node.customAttributes = {};
  for(const k of Object.keys(node.customAttributes)){
    let v = node.customAttributes[k];
    if(v===null || v===undefined){ delete node.customAttributes[k]; continue; }
    const isMulti = customAttrIsMulti(k);
    if(Array.isArray(v)){
      const arr = v.map(x=>String(x||'').trim()).filter(Boolean);
      const uniq = Array.from(new Set(arr));
      if(!uniq.length){ delete node.customAttributes[k]; continue; }
      node.customAttributes[k] = isMulti ? uniq : uniq[0];
    } else {
      const s = String(v).trim();
      if(!s) delete node.customAttributes[k];
      else node.customAttributes[k] = s;
    }
  }
  return node.customAttributes;
}


function normalizeNodeNote(node){
  if(!node || typeof node!=='object') return '';
  if(node.note===undefined || node.note===null) node.note='';
  if(typeof node.note!=='string') node.note = String(node.note);
  return node.note;
}
const TAG_COLOR_PRESETS = [
  {name:'Blue', value:'#3b82f6'},
  {name:'Cyan', value:'#06b6d4'},
  {name:'Green', value:'#22c55e'},
  {name:'Lime', value:'#84cc16'},
  {name:'Amber', value:'#f59e0b'},
  {name:'Orange', value:'#f97316'},
  {name:'Rose', value:'#f43f5e'},
  {name:'Purple', value:'#a855f7'},
  {name:'Slate', value:'#64748b'},
  {name:'Teal', value:'#14b8a6'},
];

// Build preset swatch row that syncs with a color input
function buildColorSwatches(container, targetInput){
  if(!container) return;
  container.innerHTML = '';
  TAG_COLOR_PRESETS.forEach(p=>{
    const s = document.createElement('div');
    s.className = 'swatch';
    s.style.cssText = 'width:14px;height:14px;border-radius:5px;box-shadow:none;flex-shrink:0;';
    s.style.background = p.value;
    s.title = p.name;
    s.addEventListener('click', ()=>{
      if(targetInput){
        targetInput.value = p.value;
        targetInput.style.opacity = '1';
        targetInput.dispatchEvent(new Event('input', {bubbles:true}));
      }
      container.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
      s.classList.add('sel');
    });
    container.appendChild(s);
  });
}

let __tagCreateCtx = { attachNodeId: null, afterCreate: null };

function openTagCreateModal(opts={}){
  __tagCreateCtx.attachNodeId = opts.attachNodeId || null;
  __tagCreateCtx.afterCreate = opts.afterCreate || null;
  const cat = ensureTagCatalog();
  const taken = new Set((cat||[]).map(t=>t && t.id).filter(Boolean));
  openCreateModal({
    kind: 'tag',
    title: 'Create tag',
    placeholder: 'e.g. Screening',
    hint: 'ID is generated from the label. You can override it.',
    taken,
    onCommit: ({label, id, abbr, note, color, _autoId, _autoAbbr})=>{
      const finalAbbr = (abbr||'').trim() || label.slice(0,1).toUpperCase();
      const finalColor = color || DEFAULT_TAG_COLOR;
      const finalNote = (note||'').trim();
      const cat2 = ensureTagCatalog();
      recordChange();
      cat2.push({ id, label, abbr: finalAbbr, color: finalColor, note: finalNote, priority: nextTagPriority(), _autoId, _autoAbbr });
      // Attach to node if requested
      if(__tagCreateCtx.attachNodeId){
        const node = IDX?.nodeById?.get(__tagCreateCtx.attachNodeId);
        if(node){
          normalizeNodeTags(node);
          if(!node.tags.includes(id)) node.tags.push(id);
          state.lockedId = __tagCreateCtx.attachNodeId;
          state.hoverId = null;
        }
      }
      if(__tagCreateCtx.afterCreate === 'tagsManager'){
        renderTagsManager();
      }
      renderAll();
      applyHighlight();
      setGlobalStatus('Created tag ' + id);
    }
  });
}

function currentEffectiveId(){
  return state.hoverId ?? state.lockedId ?? null;
}

/* =========================
   Validation (Editor)
========================= */

// =========================
// New blank mapping (two empty columns)
// =========================
function createBlankMappingData(){
  return {
    title: 'New Project',
    subtitle: '',
    description: '',
    author: '',
    organization: '',
    contact: '',
    url: '',
    projectVersion: '',
    date: '',
    _app: { name: 'Dunnode', version: APP_VERSION, schema: 1 },
    _savedAt: '',
    columns: [
      { id:'a', label:'A', _autoId: true, schema:{ id:'a', label:'A', _autoId: true, type:'group', children: [] } },
      { id:'b', label:'B', _autoId: true, schema:{ id:'b', label:'B', _autoId: true, type:'group', children: [] } },
    ],
    mappings: [],
    tagCatalog: [],
  transformCatalog: [],
    customAttributeCatalog: [],
    filterCatalog: []
  };
}
async function startNewMapping(){
  const ok = await customConfirm(`Start a new project?\n\nAny unsaved changes to the current project will be lost.\nMake sure you\u2019ve saved your work first.`);
  if(!ok) return;
  state.data = createBlankMappingData();
  // Reset selection + filters
  state.lockedId = null; state.hoverId = null; state.selectedColumnId = null; state.selectedEdgeId = null; state.multiSelection.clear();
  // Clear any in-flight edit sessions (prevents stale abandon guards)
  __editSnapshot = null;
  __edgeEditSession = null;
  state.search = ''; if(searchInput) searchInput.value='';
  state.hiddenColumns = new Set();
  state.onlyMapped = false; if(onlyMappedToggle) onlyMappedToggle.checked=false;
  const _omWrap2 = document.getElementById('onlyMappedWrap'); if(_omWrap2) _omWrap2.classList.remove('active');
  state.activeFilterIds = [];
  state.filterMode = 'hide';
  state.filterLogic = 'or';
  if(typeof updateFilterModeUI==='function') updateFilterModeUI();
  if(typeof updateFilterLogicUI==='function') updateFilterLogicUI();
  renderActiveFilterChips(); updateFilterBadge();
  state.allArrows = false; state.arrowsOn = true; state.showSameColumn = true; state.showDistant = true;
  if(showSameColToggle) showSameColToggle.checked = true;
  if(showDistantToggle) showDistantToggle.checked = true;
  if(typeof updateArrowModeUI==='function') updateArrowModeUI();
  // Tag manager should show empty state
  // Sync editor JSON + structured list
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  validateEditor();
  clearUndoHistory(); // Clear undo on new project
  renderAll();
  markClean(); // Fresh project, not dirty (after renderAll normalizes data)
  applyHighlight();
  setGlobalStatus('Started a new blank mapping.');
}

function validateData(data){
  const errors = [];
  const warnings = [];
  if(!data || typeof data !== 'object'){
    errors.push('Root must be an object.');
    return { errors, warnings };
  }
  if(!Array.isArray(data.columns)){
    errors.push('columns must be an array.');
  }

  const colIds = new Set();
  const nodeIds = new Set();
  const fieldIds = new Set();
  // customAttributeCatalog validation (must be ready before schema walk)
  const customAttrIds = new Set();
  const customValIdsByAttr = new Map();
  if(data.customAttributeCatalog !== undefined){
    if(!Array.isArray(data.customAttributeCatalog)) errors.push('customAttributeCatalog must be an array when present.');
    else {
      for(const a of data.customAttributeCatalog){
        if(!a || typeof a!=='object'){ warnings.push('customAttributeCatalog contains a non-object entry.'); continue; }
        if(!a.id || typeof a.id!=='string'){ errors.push('customAttributeCatalog entry missing string id.'); continue; }
        if(customAttrIds.has(a.id)) errors.push('Duplicate customAttributeCatalog id: ' + a.id);
        customAttrIds.add(a.id);
        const vset = new Set();
        const vals = Array.isArray(a.values) ? a.values : [];
        for(const v of vals){
          if(!v || typeof v!=='object'){ warnings.push('customAttributeCatalog['+a.id+'] has a non-object value.'); continue; }
          if(!v.id || typeof v.id!=='string'){ errors.push('customAttributeCatalog['+a.id+'] value missing string id.'); continue; }
          if(vset.has(v.id)) errors.push('Duplicate value id in customAttributeCatalog['+a.id+']: ' + v.id);
          vset.add(v.id);
        }
        customValIdsByAttr.set(a.id, vset);
      }
    }
  }


  function walk(node, parentId, colId){
    if(!node || typeof node !== 'object') return;
    if(!node.id || typeof node.id !== 'string'){
      errors.push(`Node missing string id in column '${colId}'.`);
      return;
    }
    if(nodeIds.has(node.id)) errors.push(`Duplicate node id: ${node.id}`);
    nodeIds.add(node.id);
    if(node.id !== colId && !node.id.startsWith(colId + '.')){
      warnings.push(`Node id '${node.id}' does not start with column prefix '${colId}.' (recommended). Root can be exactly '${colId}'.`);
    }
    if(node.type === 'field') fieldIds.add(node.id);
    else if(node.type !== 'group') warnings.push(`Node '${node.id}' has unknown type '${node.type}'. Expected 'group' or 'field'.`);
    if(node.note !== undefined && node.note !== null && typeof node.note !== 'string') warnings.push(`Node '${node.id}' note should be a string.`);
    if(node.customAttributes !== undefined){
      if(!node.customAttributes || typeof node.customAttributes !== 'object' || Array.isArray(node.customAttributes)) errors.push(`Node '${node.id}' customAttributes must be an object {aid: valueId or [valueId,...]}.`);
      else {
        for(const [aid, vid] of Object.entries(node.customAttributes||{})){
          if(customAttrIds.size && !customAttrIds.has(aid)) errors.push(`Node '${node.id}' references unknown custom attribute: ${aid}`);
          const vset = customValIdsByAttr.get(aid);
          if(vset){
            if(Array.isArray(vid)){
              for(const one of vid){
                if(one && !vset.has(String(one))) errors.push(`Node '${node.id}' references unknown custom attribute value: ${aid}.${one}`);
              }
            } else {
              if(vid && !vset.has(String(vid))) errors.push(`Node '${node.id}' references unknown custom attribute value: ${aid}.${vid}`);
            }
          // enforce catalog multiplicity (single vs multi)
          const def = (data.customAttributeCatalog||[]).find(x=>x && x.id===aid);
          const isMulti = !!(def && def.multi);
          if(!isMulti && Array.isArray(vid) && vid.length>1){
            errors.push(`Node '${node.id}' custom attribute '${aid}' is single-select but has multiple values.`);
          }
          }
        }
      }
    }
    if(Array.isArray(node.children)) node.children.forEach(ch=>walk(ch, node.id, colId));
  }

  if(Array.isArray(data.columns)){
    for(const c of data.columns){
      if(!c || typeof c !== 'object'){ errors.push('Each column must be an object.'); continue; }
      if(!c.id || typeof c.id !== 'string'){ errors.push('Each column requires a string id.'); continue; }
      if(colIds.has(c.id)) errors.push(`Duplicate column id: ${c.id}`);
      colIds.add(c.id);
      if(!c.label || typeof c.label !== 'string') warnings.push(`Column '${c.id}' has no label (string).`);
      if(!c.schema || typeof c.schema !== 'object'){ errors.push(`Column '${c.id}' is missing schema object.`); continue; }
      if(c.schema.id !== c.id) warnings.push(`Column '${c.id}' schema root id is '${c.schema.id}'. Recommended: schema.id == column.id.`);
      walk(c.schema, null, c.id);
    }
  }

  
  // transform catalog validation (catalog-only transforms)
  const transformIds = new Set();
  if(data.transformCatalog !== undefined){
    if(!Array.isArray(data.transformCatalog)) errors.push('transformCatalog must be an array when present.');
    else {
      for(const t of data.transformCatalog){
        if(!t || typeof t !== 'object') { warnings.push('transformCatalog contains a non-object entry.'); continue; }
        if(!t.id || typeof t.id !== 'string') { errors.push('transformCatalog entry missing string id.'); continue; }
        if(transformIds.has(t.id)) errors.push('Duplicate transformCatalog id: ' + t.id);
        transformIds.add(t.id);
      }
    }
  }
if(!Array.isArray(data.mappings)){
    errors.push('mappings must be an array.');
  } else {
    const seen = new Set();
    let idx = 0;
    for(const m of data.mappings){
      idx++;
      if(!m || typeof m !== 'object'){ errors.push(`mappings[${idx}] must be an object.`); continue; }
      if(!m.from || typeof m.from !== 'string'){ errors.push(`mappings[${idx}].from must be a string field id.`); continue; }
      if(!m.to || typeof m.to !== 'string'){ errors.push(`mappings[${idx}].to must be a string field id.`); continue; }
      if(!fieldIds.has(m.from)) errors.push(`mappings[${idx}].from references unknown/non-field id: ${m.from}`);
      if(!fieldIds.has(m.to)) errors.push(`mappings[${idx}].to references unknown/non-field id: ${m.to}`);
      const key = `${m.from}${m.to}`;
      if(seen.has(key)) errors.push(`Duplicate mapping pair not allowed: ${key}`);
      seen.add(key);
      // catalog-only transforms: reject legacy 'transform'
      if(m.transform !== undefined && m.transform !== null && String(m.transform).trim() !== ''){
        errors.push(`mappings[${idx}].transform is not allowed. Use transforms: [<catalogId>, ...].`);
      }
      // validate transforms ids
      if(m.transforms !== undefined){
        const arr = normalizeTransforms(m.transforms);
        if(arr.length && transformIds.size===0){
          errors.push(`mappings[${idx}].transforms provided but transformCatalog is missing or empty.`);
        }
        for(const inst of arr){
          const tid = inst.ref;
          if(!tid || (typeof tid !== 'string') || !tid.trim()) continue;
          if(transformIds.size && !transformIds.has(tid)){
            errors.push(`mappings[${idx}].transforms references unknown transform id: ${tid}`);
          }
        }
      }

                }
  }

  return { errors, warnings };
}


function renderValidationLog(result){
  const { errors, warnings } = result;

  const html = [];
  html.push(`<div class="msg"><h4 class="${errors.length ? 'err' : 'ok'}">Parse/Schema</h4>`);
  if(errors.length === 0){
    html.push(`<div class="ok"> No blocking errors.</div>`);
  } else {
    html.push(`<div class="err"> ${errors.length} error(s) found. Fix before applying.</div>`);
    html.push(`<ul>` + errors.map(e => `<li>${escapeHtml(e)}</li>`).join("\n") + `</ul>`);
  }
  html.push(`</div>`);

  html.push(`<div class="msg"><h4 class="${warnings.length ? 'warn' : 'ok'}">Warnings</h4>`);
  if(warnings.length === 0){
    html.push(`<div class="ok"> No warnings.</div>`);
  } else {
    html.push(`<div class="warn"> ${warnings.length} warning(s). You can still apply, but results may be surprising.</div>`);
    html.push(`<ul>` + warnings.map(w => `<li>${escapeHtml(w)}</li>`).join("\n") + `</ul>`);
  }
  html.push(`</div>`);

  html.push(`<div class="msg"><h4>Notes</h4>
    <ul>
      <li><b>Uniqueness:</b> only one mapping is allowed per <code>from</code>  <code>to</code> pair.</li>
      <li>To reduce arrow clutter, keep arrows on <b>Selected</b> mode and rely on hover/click highlighting.</li>
      <li>Non-adjacent mappings are supported; consider hiding same-column or distant arrows in the Graph menu if clutter increases.</li>
    </ul>
  </div>`);

  logArea.innerHTML = html.join("\n");
}


function escapeHtml(s){
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}





// =========================
// Generic create modal (label -> id) + edit cancel snapshots
// =========================
let __createCtx = null;
function closeCreateModal(){
  const cm = document.getElementById('createMask');
  const md = document.getElementById('createModal');
  cm?.classList.remove('active', 'elevated-2');
  md?.classList.remove('active', 'elevated-2');
  // Restore button label in case it was relabeled for nested flow
  const closeBtn = document.getElementById('createCloseBtn');
  if(closeBtn) closeBtn.textContent = 'Close';
  __createCtx = null;
}
function computeAutoIdFromLabel(label, ctx){
  const raw = String(label||'').trim();
  if(!raw) return '';
  if(ctx.kind==='column'){
    const base0 = idPartFromLabel(raw, {lower:false}).replace(/\./g,'');
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0 || 'col', taken);
  }
  if(ctx.kind==='tag'){
    const base0 = slugifyTagLabel(raw) || 'tag';
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0, taken);
  }
  if(ctx.kind==='transform'){
    const base0 = slugifyTransformLabel(raw) || 'transform';
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0, taken);
  }
  if(ctx.kind==='customAttr')
  {
    const base0 = idPartFromLabel(raw, {lower:true});
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0 || 'attr', taken);
  }
  if(ctx.kind==='customAttrValue')
  {
    const base0 = idPartFromLabel(raw, {lower:true});
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0 || 'val', taken);
  }

  if(ctx.kind==='node'){
    const base0 = (ctx.parentId || ctx.colId) + '.' + idPartFromLabel(raw, {lower:false});
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0 || ((ctx.parentId||ctx.colId)+'.node'), taken);
  }
  return '';
}

// Which optional fields to show per entity kind
const CREATE_FIELDS = {
  column:          { color: true, note: true },
  node:            { note: true, tags: true, customAttrs: true },
  tag:             { abbr: true, color: true, note: true },
  transform:       { abbr: true, note: true, params: true },
  customAttr:      { abbr: true, multi: true, note: true },
  customAttrValue: { abbr: true, color: true, note: true },
};

let __createSelectedColor = null;
let __createTags = [];
let __createCustomAttrs = {};
let __createModalAutoElevate = false;

function _renderCreateTagChips(){
  const wrap = document.getElementById('createTagChips'); if(!wrap) return;
  const cat = ensureTagCatalog();
  if(!__createTags.length){ wrap.innerHTML = '<span class="empty">No tags.</span>'; return; }
  wrap.innerHTML = __createTags.map(tid=>{
    const t = cat.find(x=>x.id===tid);
    const lbl = t ? (t.abbr || t.label) : tid;
    const col = t?.color || DEFAULT_TAG_COLOR;
    return `<span class="tagChip" style="background:${escapeHtml(col)};color:#fff;cursor:pointer;" data-tid="${escapeHtml(tid)}" title="Click to remove">${escapeHtml(lbl)}</span>`;
  }).join('');
  wrap.querySelectorAll('.tagChip').forEach(ch=>{
    ch.addEventListener('click', ()=>{
      __createTags = __createTags.filter(x=>x!==ch.dataset.tid);
      _renderCreateTagChips();
      _populateCreateTagSel();
    });
  });
}
function _populateCreateTagSel(){
  const sel = document.getElementById('createTagSel'); if(!sel) return;
  const cat = ensureTagCatalog();
  const sorted = [...cat].sort((a,b)=>{
    const pa = typeof a.priority==='number'?a.priority:9999;
    const pb = typeof b.priority==='number'?b.priority:9999;
    return pa-pb;
  });
  sel.innerHTML = '<option value="">Add tag</option>' + sorted.filter(t=>!__createTags.includes(t.id)).map(t=>
    `<option value="${escapeHtml(t.id)}">${escapeHtml(t.label)}</option>`
  ).join('') + '<option value="__new__">+ New tag</option>';
  sel.onchange = ()=>{
    const v = sel.value; if(!v) return;
    sel.value = '';
    if(v==='__new__'){
      _openCatalogFromCreateModal('tags');
      return;
    }
    __createTags.push(v);
    _renderCreateTagChips();
    _populateCreateTagSel();
  };
}
function _renderCreateAttrChips(){
  const wrap = document.getElementById('createAttrChips'); if(!wrap) return;
  const cat = ensureCustomAttributeCatalog();
  const entries = Object.entries(__createCustomAttrs).filter(([,v])=>v&&v.length);
  if(!entries.length){ wrap.innerHTML = '<span class="empty">No attributes.</span>'; return; }
  wrap.innerHTML = entries.map(([aid, vals])=>{
    const a = cat.find(x=>x.id===aid);
    const aLabel = a ? a.label : aid;
    return vals.map(vid=>{
      const v = (a?.values||[]).find(x=>x.id===vid);
      const vLabel = v ? v.label : vid;
      return `<span class="tagChip" style="cursor:pointer;" data-aid="${escapeHtml(aid)}" data-vid="${escapeHtml(vid)}" title="Click to remove">${escapeHtml(aLabel)}: ${escapeHtml(vLabel)}</span>`;
    }).join('');
  }).join('');
  wrap.querySelectorAll('.tagChip').forEach(ch=>{
    ch.addEventListener('click', ()=>{
      const aid = ch.dataset.aid, vid = ch.dataset.vid;
      if(__createCustomAttrs[aid]) __createCustomAttrs[aid] = __createCustomAttrs[aid].filter(x=>x!==vid);
      if(!__createCustomAttrs[aid]?.length) delete __createCustomAttrs[aid];
      _renderCreateAttrChips();
    });
  });
}
function _populateCreateAttrSel(){
  const attrSel = document.getElementById('createAttrSel');
  const valSel = document.getElementById('createAttrValSel');
  if(!attrSel || !valSel) return;
  const cat = ensureCustomAttributeCatalog();
  attrSel.innerHTML = '<option value="">Attribute</option>' + cat.map(a=>
    `<option value="${escapeHtml(a.id)}">${escapeHtml(a.label)}</option>`
  ).join('') + '<option value="__new__">+ New attribute</option>';
  valSel.innerHTML = '<option value="">Value</option>';
  attrSel.onchange = ()=>{
    const aid = attrSel.value;
    if(aid==='__new__'){
      attrSel.value = '';
      _openCatalogFromCreateModal('attrs');
      return;
    }
    const a = cat.find(x=>x.id===aid);
    const vals = a?.values || [];
    valSel.innerHTML = '<option value="">Value</option>' + vals.map(v=>
      `<option value="${escapeHtml(v.id)}">${escapeHtml(v.label||v.id)}</option>`
    ).join('') + (aid ? '<option value="__new__">+ New value</option>' : '');
  };
  valSel.onchange = ()=>{
    const aid = attrSel.value, vid = valSel.value;
    if(!aid || aid==='__new__') return;
    if(vid==='__new__'){
      valSel.value = '';
      _openCatalogFromCreateModal('attrs');
      return;
    }
    if(!vid) return;
    const a = cat.find(x=>x.id===aid);
    if(!__createCustomAttrs[aid]) __createCustomAttrs[aid] = [];
    if(a?.multi){
      if(!__createCustomAttrs[aid].includes(vid)) __createCustomAttrs[aid].push(vid);
    } else {
      __createCustomAttrs[aid] = [vid];
    }
    valSel.value = '';
    _renderCreateAttrChips();
  };
}

// Watch for a modal to lose '.active' class and fire callback once
function _watchModalClose(modalEl, cb){
  if(!modalEl) return;
  const obs = new MutationObserver(()=>{
    if(!modalEl.classList.contains('active')){
      obs.disconnect();
      cb();
    }
  });
  obs.observe(modalEl, { attributes: true, attributeFilter: ['class'] });
}

// Open a catalog modal elevated above the create modal, refresh on close
let __savedCreateState = null; // saved create-node-modal state during catalog visit

function _openCatalogFromCreateModal(which){
  let modal, mask, openFn, closeBtnId;
  if(which==='tags'){
    modal = document.getElementById('tagsModal');
    mask = document.getElementById('tagsMask');
    openFn = openTags;
    closeBtnId = 'closeTagsBtn';
  } else {
    modal = document.getElementById('customAttrsModal');
    mask = document.getElementById('customAttrsMask');
    openFn = openCustomAttrs;
    closeBtnId = 'closeCustomAttrsBtn';
  }

  // --- Save full create-modal state ---
  const createModal = document.getElementById('createModal');
  const createMask = document.getElementById('createMask');
  __savedCreateState = {
    ctx: __createCtx,
    tags: [...__createTags],
    customAttrs: JSON.parse(JSON.stringify(__createCustomAttrs)),
    label: document.getElementById('createLabel')?.value || '',
    idInput: document.getElementById('createIdInput')?.value || '',
    note: document.getElementById('createNote')?.value || '',
  };

  // Hide create modal (catalog takes over)
  createModal?.classList.remove('active');
  createMask?.classList.remove('active');

  // Elevate catalog above where create modal was
  if(modal) modal.classList.add('elevated');
  if(mask) mask.classList.add('elevated');

  // Relabel Close   Back
  const closeBtn = document.getElementById(closeBtnId);
  if(closeBtn) closeBtn.textContent = ' Back';

  // Flag: any openCreateModal() called while catalog is elevated should auto-elevate
  __createModalAutoElevate = true;

  openFn();

  _watchModalClose(modal, ()=>{
    __createModalAutoElevate = false;
    // Remove elevation and restore button label
    if(modal) modal.classList.remove('elevated');
    if(mask) mask.classList.remove('elevated');
    if(closeBtn) closeBtn.textContent = 'Close';

    // --- Restore create-node-modal ---
    const saved = __savedCreateState;
    __savedCreateState = null;
    if(!saved || !saved.ctx) return;

    // Re-open with saved context
    openCreateModal(saved.ctx);

    // Restore form values  but first clean up entries deleted during catalog visit
    const tagCat = ensureTagCatalog();
    const tagCatIds = new Set(tagCat.map(t=>t.id));
    __createTags = saved.tags.filter(tid=>tagCatIds.has(tid));

    const attrCat = ensureCustomAttributeCatalog();
    const attrCatIds = new Set(attrCat.map(a=>a.id));
    const cleanedAttrs = saved.customAttrs;
    for(const aid of Object.keys(cleanedAttrs)){
      if(!attrCatIds.has(aid)){ delete cleanedAttrs[aid]; continue; }
      const a = attrCat.find(x=>x.id===aid);
      const valIds = new Set((a?.values||[]).map(v=>v.id));
      cleanedAttrs[aid] = (cleanedAttrs[aid]||[]).filter(vid=>valIds.has(vid));
      if(!cleanedAttrs[aid].length) delete cleanedAttrs[aid];
    }
    __createCustomAttrs = cleanedAttrs;
    const lEl = document.getElementById('createLabel');
    const iEl = document.getElementById('createIdInput');
    const nEl = document.getElementById('createNote');
    if(lEl) lEl.value = saved.label;
    if(iEl) iEl.value = saved.idInput;
    if(nEl) nEl.value = saved.note;

    // Refresh chips and dropdowns to reflect catalog changes
    _renderCreateTagChips();
    _populateCreateTagSel();
    _renderCreateAttrChips();
    _populateCreateAttrSel();
  });
}

function openCreateModal(ctx){
  __createCtx = ctx;
  __createSelectedColor = TAG_COLOR_PRESETS[0].value;
  const mask = document.getElementById('createMask');
  const modal = document.getElementById('createModal');
  const title = document.getElementById('createTitle');
  const labelEl = document.getElementById('createLabel');
  const idPrefix = document.getElementById('createIdPrefix');
  const idInput = document.getElementById('createIdInput');
  const abbrEl = document.getElementById('createAbbr');
  const colorHex = document.getElementById('createColorHex');
  const colorsEl = document.getElementById('createColors');
  const multiEl = document.getElementById('createMulti');
  const noteEl = document.getElementById('createNote');
  const hint = document.getElementById('createHint');
  const ok = document.getElementById('createOkBtn');

  if(title) title.textContent = ctx.title || 'New item';
  if(labelEl){
    labelEl.value = ctx.defaultLabel || '';
    labelEl.placeholder = ctx.placeholder || 'Label';
  }
  if(hint) hint.textContent = ctx.hint || '';
  if(ok) ok.textContent = ctx.okText || 'Save';
  if(abbrEl) abbrEl.value = '';
  if(noteEl) noteEl.value = '';
  if(multiEl) multiEl.checked = false;
  if(idInput) idInput.value = '';

  // Node prefix
  if(ctx.kind==='node'){
    const prefix = (ctx.parentId || ctx.colId || '') + '.';
    if(idPrefix) { idPrefix.textContent = prefix; idPrefix.style.display = ''; }
  } else {
    if(idPrefix) { idPrefix.textContent = ''; idPrefix.style.display = 'none'; }
  }

  // Show/hide optional fields
  const fields = CREATE_FIELDS[ctx.kind] || {};
  const show = (k, v) => {
    const kEl = document.getElementById('cr'+k.charAt(0).toUpperCase()+k.slice(1)+'K');
    const vEl = document.getElementById('cr'+k.charAt(0).toUpperCase()+k.slice(1)+'V');
    if(kEl) kEl.style.display = v ? '' : 'none';
    if(vEl) vEl.style.display = v ? (vEl.dataset.flex ? 'flex' : '') : 'none';
  };
  show('abbr', fields.abbr);
  show('color', fields.color);
  show('multi', fields.multi);
  show('note', true); // always show note
  show('params', fields.params);
  show('tags', fields.tags);
  show('attrs', fields.customAttrs);

  // Transform params in create modal
  if(fields.params){
    const paramsContainer = document.getElementById('createParamsRows');
    if(paramsContainer) paramsContainer.innerHTML = '';
    const addParamBtn = document.getElementById('createAddParamBtn');
    if(addParamBtn) addParamBtn.onclick = ()=>{
      if(!paramsContainer) return;
      const row = document.createElement('div');
      row.className = 'trParamRow';
      row.style.cssText = 'display:flex;gap:4px;align-items:center;margin-bottom:4px;';
      row.innerHTML = `
        <input class="inp" data-pf="label" value="" placeholder="label" style="flex:2;"/>
        <input class="inp" data-pf="id" value="" placeholder="id (auto)" style="flex:1;font-family:var(--mono);font-size:10px;"/>
        <select class="inp" data-pf="type" style="flex:0 0 70px;font-size:11px;">
          <option value="text">text</option>
          <option value="number">number</option>
        </select>
        <input class="inp" data-pf="default" value="" placeholder="default" style="flex:1;font-size:11px;"/>
        <button class="btn" style="padding:2px 6px;font-size:11px;" title="Remove"></button>
      `;
      row.querySelector('button').addEventListener('click', ()=> row.remove());
      // Auto-generate id from label whenever id is empty
      const lblInp = row.querySelector('[data-pf="label"]');
      const idInp = row.querySelector('[data-pf="id"]');
      const slugParam = (s)=> s.trim().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
      if(lblInp && idInp){
        let _lastAuto = '';
        lblInp.addEventListener('input', ()=>{
          const cur = idInp.value.trim();
          if(!cur || cur === _lastAuto){ const a = slugParam(lblInp.value); idInp.value = a; _lastAuto = a; }
        });
        idInp.addEventListener('input', ()=>{
          if(!idInp.value.trim()){ const a = slugParam(lblInp.value); idInp.value = a; _lastAuto = a; }
          else _lastAuto = '';
        });
      }
      paramsContainer.appendChild(row);
    };
  }

  // Node tags and custom attrs in create modal
  __createTags = [];
  __createCustomAttrs = {};
  if(fields.tags){
    _renderCreateTagChips();
    _populateCreateTagSel();
    const tagMgrBtn = document.getElementById('createTagMgr');
    if(tagMgrBtn) tagMgrBtn.onclick = ()=> _openCatalogFromCreateModal('tags');
  }
  if(fields.customAttrs){
    _renderCreateAttrChips();
    _populateCreateAttrSel();
    const attrMgrBtn = document.getElementById('createAttrMgr');
    if(attrMgrBtn) attrMgrBtn.onclick = ()=> _openCatalogFromCreateModal('attrs');
  }

  // Build color swatches for tags
  if(fields.color && colorsEl){
    colorsEl.innerHTML = '';
    TAG_COLOR_PRESETS.forEach(p=>{
      const s = document.createElement('div');
      s.className = 'swatch' + (p.value===__createSelectedColor ? ' sel' : '');
      s.style.background = p.value;
      s.title = p.name + ' ' + p.value;
      s.addEventListener('click', (e)=>{
        e.stopPropagation();
        __createSelectedColor = p.value;
        if(colorHex) colorHex.value = p.value;
        if(colorPicker) colorPicker.value = p.value;
        colorsEl.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        s.classList.add('sel');
      });
      colorsEl.appendChild(s);
    });
    const colorPicker = document.getElementById('createColorPicker');
    if(colorPicker){
      colorPicker.value = __createSelectedColor || DEFAULT_TAG_COLOR;
      colorPicker.addEventListener('input', ()=>{
        __createSelectedColor = colorPicker.value;
        if(colorHex) colorHex.value = colorPicker.value;
        colorsEl.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
      });
    }
    if(colorHex){
      colorHex.value = __createSelectedColor || DEFAULT_TAG_COLOR;
      colorHex.oninput = ()=>{
        const v = (colorHex.value||'').trim();
        if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
          __createSelectedColor = v;
          if(colorPicker) colorPicker.value = v;
          colorsEl.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        }
      };
    }
    const colorResetBtn = document.getElementById('createColorReset');
    if(colorResetBtn){
      colorResetBtn.onclick = ()=>{
        __createSelectedColor = DEFAULT_TAG_COLOR;
        if(colorPicker) colorPicker.value = DEFAULT_TAG_COLOR;
        if(colorHex) colorHex.value = DEFAULT_TAG_COLOR;
        colorsEl.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        const first = colorsEl.querySelector('.swatch');
        if(first) first.classList.add('sel');
      };
    }
  }

  // ID auto-fill from label: keep updating as long as user hasn't manually edited
  __lastAutoId = '';
  const idAutoTag = document.getElementById('createIdAuto');
  const abbrAutoTag = document.getElementById('createAbbrAuto');
  const refreshId = ()=>{
    const cur = idInput ? idInput.value.trim() : '';
    if(cur && cur !== __lastAutoId) return; // user typed custom value  don't touch
    const autoId = computeAutoIdFromLabel(labelEl?.value||'', ctx);
    if(ctx.kind==='node'){
      const prefix = (ctx.parentId || ctx.colId || '') + '.';
      const seg = autoId ? autoId.slice(prefix.length) : '';
      if(idInput) idInput.value = seg;
      __lastAutoId = seg;
    } else {
      if(idInput) idInput.value = autoId || '';
      __lastAutoId = autoId || '';
    }
  };
  __lastAutoAbbr = '';
  const computeAutoAbbr = (lbl)=>{
    if(!lbl) return '';
    if(ctx.kind==='tag') return lbl.slice(0,1).toUpperCase();
    if(ctx.kind==='customAttrValue') return lbl.replace(/\s+/g,'').slice(0,3).toUpperCase();
    return lbl.replace(/\s+/g,'').slice(0,2).toUpperCase();
  };
  const refreshAbbr = ()=>{
    if(!fields.abbr || !abbrEl) return;
    const curAbbr = abbrEl.value.trim();
    if(!curAbbr || curAbbr === __lastAutoAbbr){
      const a = computeAutoAbbr((labelEl?.value||'').trim());
      abbrEl.value = a;
      __lastAutoAbbr = a;
    }
  };
  const refreshAutoTags = ()=>{
    if(idAutoTag) idAutoTag.style.display = __lastAutoId !== '' ? '' : 'none';
    if(abbrAutoTag) abbrAutoTag.style.display = __lastAutoAbbr !== '' ? '' : 'none';
  };
  if(labelEl){
    labelEl.oninput = ()=>{
      refreshId();
      refreshAbbr();
      refreshAutoTags();
    };
  }
  if(idInput){
    idInput.oninput = ()=>{
      if(!idInput.value.trim()){
        refreshId();
      } else {
        __lastAutoId = '';
      }
      refreshAutoTags();
    };
  }
  if(abbrEl){
    abbrEl.oninput = ()=>{
      if(!abbrEl.value.trim()){
        const a = computeAutoAbbr((labelEl?.value||'').trim());
        abbrEl.value = a;
        __lastAutoAbbr = a;
      } else {
        __lastAutoAbbr = '';
      }
      refreshAutoTags();
    };
  }
  refreshId();
  refreshAutoTags();

  mask?.classList.add('active');
  modal?.classList.add('active');
  // Wire dirty highlight: Save button is disabled until form has content
  if(ok){
    const modalBody = modal?.querySelector('.modalBody');
    if(modalBody){
      const updateDirty = ()=>{ ok.classList.toggle('btnDirty', createModalIsDirty()); };
      // Remove old listeners by cloning approach: just add fresh ones (they stack but it's harmless for short-lived modals)
      modalBody.addEventListener('input', updateDirty);
      modalBody.addEventListener('change', updateDirty);
      modalBody.addEventListener('click', ()=> setTimeout(updateDirty, 50));
      ok.__dirtyUpdate = updateDirty;
      updateDirty(); // initial state: not dirty
    }
  }
  // Auto-elevate if opened from within an elevated catalog (e.g. "Add tag" in catalog)
  if(__createModalAutoElevate){
    mask?.classList.add('elevated-2');
    modal?.classList.add('elevated-2');
    // Relabel top Close   Back since there's a parent modal underneath
    const closeBtn = document.getElementById('createCloseBtn');
    if(closeBtn) closeBtn.textContent = ' Back';
  } else {
    const closeBtn = document.getElementById('createCloseBtn');
    if(closeBtn) closeBtn.textContent = 'Close';
  }
  setTimeout(()=> labelEl?.focus(), 0);
}
function commitCreateModal(){
  if(!__createCtx) return;
  const ctx = __createCtx;
  const labelEl = document.getElementById('createLabel');
  const idInput = document.getElementById('createIdInput');
  const abbrEl = document.getElementById('createAbbr');
  const noteEl = document.getElementById('createNote');
  const multiEl = document.getElementById('createMulti');
  const colorHex = document.getElementById('createColorHex');

  const raw = String(labelEl?.value||'').trim();
  if(!raw){
    customAlert('Please enter a label.');
    labelEl?.focus();
    return;
  }

  // Compute ID: use field value if non-empty, otherwise auto from label
  let id;
  const manualSeg = sanitizeManualId(idInput?.value || '');
  if(manualSeg){
    if(ctx.kind==='node'){
      id = (ctx.parentId || ctx.colId || '') + '.' + manualSeg;
    } else {
      id = manualSeg;
    }
    // Check uniqueness
    if(ctx.taken && ctx.taken.has(id)){
      customAlert('ID already exists. Please choose a unique ID.');
      idInput?.focus();
      return;
    }
  } else {
    id = computeAutoIdFromLabel(raw, ctx);
  }

  // Gather optional fields
  const fields = CREATE_FIELDS[ctx.kind] || {};
  const result = { label: raw, id, _autoId: __lastAutoId !== '' };
  if(fields.abbr) { result.abbr = (abbrEl?.value||'').trim(); result._autoAbbr = __lastAutoAbbr !== ''; }
  if(fields.note || true) result.note = (noteEl?.value||'').trim(); // always pass note
  if(fields.color) result.color = __createSelectedColor || (colorHex?.value||'').trim() || DEFAULT_TAG_COLOR;
  if(fields.multi) result.multi = !!multiEl?.checked;
  if(fields.tags && __createTags.length) result.tags = [...__createTags];
  if(fields.customAttrs && Object.keys(__createCustomAttrs).length){
    result.customAttributes = {};
    for(const [k,v] of Object.entries(__createCustomAttrs)){
      if(v && v.length) result.customAttributes[k] = [...v];
    }
  }

  const cb = ctx.onCommit;
  closeCreateModal();
  try{ cb && cb(result); }catch(err){ console.error(err); }
}
function createModalIsDirty(){
  if(!__createCtx) return false;
  const label = (document.getElementById('createLabel')?.value||'').trim();
  const note = (document.getElementById('createNote')?.value||'').trim();
  const abbr = (document.getElementById('createAbbr')?.value||'').trim();
  // Check params rows for transforms
  const paramsContainer = document.getElementById('createParamsRows');
  const hasParams = paramsContainer && paramsContainer.querySelectorAll('.trParamRow').length > 0;
  return !!(label || note || abbr || hasParams || (__createTags && __createTags.length) || (__createCustomAttrs && Object.keys(__createCustomAttrs).length));
}
async function guardedCloseCreateModal(){
  if(createModalIsDirty()){
    const ok = await customConfirm('Discard new ' + (__createCtx?.kind || 'item') + '?');
    if(!ok) return;
  }
  closeCreateModal();
}
// wire create modal
document.getElementById('createCloseBtn')?.addEventListener('click', guardedCloseCreateModal);
document.getElementById('createCancelBtn')?.addEventListener('click', guardedCloseCreateModal);
document.getElementById('createMask')?.addEventListener('click', guardedCloseCreateModal);
document.getElementById('createOkBtn')?.addEventListener('click', commitCreateModal);
document.getElementById('createLabel')?.addEventListener('keydown', (e)=>{
  if(e.key==='Enter'){ e.preventDefault(); commitCreateModal(); }
  if(e.key==='Escape'){ e.preventDefault(); guardedCloseCreateModal(); }
});

// --- Edit snapshots for Cancel button in Details pane ---
let __editSnapshot = null;
let __editorAutoId = false;   // true while current editor's ID is auto-linked to label
let __editorAutoAbbr = false; // true while current editor's abbr is auto-linked to label
let __lastAutoId = '';        // create modal: tracks last auto-generated ID value
let __lastAutoAbbr = '';      // create modal: tracks last auto-generated abbr value
function beginEditSnapshot(kind, id){
  if(__editSnapshot && __editSnapshot.kind===kind && __editSnapshot.id===id) return;
  // Auto-revert any existing unsaved edit session (user navigated away without Save)
  if(__editSnapshot && __editSnapshot.data){
    revertEditSnapshot();
    __editSnapshot = null;
    checkDirtyState();
    // Schedule re-render to clear stale viewer state (e.g. tag pills from reverted edits).
    // Use queueMicrotask to avoid recursion since we may be called from inside renderAll.
    queueMicrotask(()=>{ renderAll(); });
  }
  __editSnapshot = { kind, id, data: null };
  if(kind==='column'){
    const col = findColumnById(id);
    __editSnapshot.data = col ? { label: col.label, id: col.id, note: (col.note||''), color: (col.color||''), _pendingColor: (col._pendingColor||''), _autoId: !!col._autoId } : null;
  } else if(kind==='node'){
    const node = IDX?.nodeById?.get(id);
    __editSnapshot.data = node ? { id: node.id, label: node.label, tags: Array.isArray(node.tags)? [...node.tags] : [], note: (node.note||''), color: (node.color||''), _pendingColor: (node._pendingColor||''), _autoId: !!node._autoId, customAttributes: node.customAttributes? JSON.parse(JSON.stringify(node.customAttributes)) : {} } : null;
  }
}
function revertEditSnapshot(){
  if(!__editSnapshot || !__editSnapshot.data) return;
  const { kind, id, data } = __editSnapshot;
  if(kind==='column'){
    const col = findColumnById(id);
    if(col){ col.label = data.label; col.note = (data.note||''); col._autoId = !!data._autoId; if(col.schema) col.schema._autoId = !!data._autoId; if(data.color) col.color = data.color; else delete col.color; if(data._pendingColor) col._pendingColor = data._pendingColor; else delete col._pendingColor; }
  } else if(kind==='node'){
    const colId = columnOf(id);
    const col = colId ? findColumnById(colId) : null;
    if(col){
      const loc = locateNode(col.schema, id);
      if(loc && loc.node){
        loc.node.label = data.label;
        loc.node.tags = Array.isArray(data.tags)? [...data.tags] : [];
        loc.node.note = (data.note||'');
        loc.node._autoId = !!data._autoId;
        if(data.color) loc.node.color = data.color; else delete loc.node.color;
        if(data._pendingColor) loc.node._pendingColor = data._pendingColor; else delete loc.node._pendingColor;
        loc.node.customAttributes = data.customAttributes ? JSON.parse(JSON.stringify(data.customAttributes)) : {};
      }
    }
  }
}
function cancelEditAndDeselect(){
  revertEditSnapshot();
  __editSnapshot = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.lockedId = null;
  state.hoverId = null;
  state.multiSelection.clear();
  state.__hoverCooldownUntil = Date.now() + 400;
  checkDirtyState();
  renderAll();
  setGlobalStatus('Cancelled changes.');
}

// --- Edge (mapping) edit session ---
// Ensures mapping edits (including transforms) are only persisted on explicit Save.
let __edgeEditSession = null; // { edgeId, from, to, ruleRef, draft }
function deepClone(obj){
  try{ return JSON.parse(JSON.stringify(obj)); }catch{ return obj; }
}
function edgeEditIsDirty(){
  if(!__edgeEditSession || !__edgeEditSession.ruleRef || !__edgeEditSession.draft) return false;
  if(JSON.stringify(__edgeEditSession.ruleRef) !== JSON.stringify(__edgeEditSession.draft)) return true;
  // Detect picker change OR checkbox toggle independently
  const edColorEl = document.getElementById('edColor');
  const edColorOnEl = document.getElementById('edColorOn');
  if(edColorEl && edColorOnEl){
    const origColor = __edgeEditSession.ruleRef.color || '';
    const origPickerVal = origColor || __edgeEditSession.ruleRef._pendingColor || '#3b82f6';
    if(edColorOnEl.checked !== !!origColor) return true;
    if(edColorEl.value !== origPickerVal) return true;
  }
  return false;
}
function clearEdgeEditSession(opts={}){
  __edgeEditSession = null;
  if(opts && opts.clearSelection){
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    state._selectedEdgeEndpoints = null;
    state.lockedId = null;
    state.hoverId = null;
  }
}

async function deleteMappingByEdgeId(edgeId){
  if(!state || !state.data || !Array.isArray(state.data.mappings)) return;
  const edge = (IDX && Array.isArray(IDX.edges)) ? IDX.edges.find(e=>e && e.id===edgeId) : null;
  if(!edge) return;
  const msg = `Delete mapping?
${edge.from}  ${edge.to}`;
  if(!await customConfirm(msg)) return;
  state.data.mappings = state.data.mappings.filter(m=>{
    if(!m || typeof m!=='object') return false;
    if(m.from!==edge.from) return true;
    const to = m.to;
    if(Array.isArray(to)) return !to.includes(edge.to);
    return String(to)!==String(edge.to);
  });
  __edgeEditSession = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.lockedId = null;
  state.hoverId = null;
  renderAll();
  applyHighlight();
  setGlobalStatus('Deleted mapping.');
}


/* =========================
   Index building and rendering
========================= */
function buildIndexes(data){
  try{ normalizeSiblingIds(data); }catch(e){}

  // Normalize project-level fields for stable JSON shape
  if(data.subtitle===undefined || data.subtitle===null) data.subtitle = '';
  if(data.description===undefined || data.description===null) data.description = '';
  if(data.author===undefined || data.author===null) data.author = '';
  if(data.organization===undefined || data.organization===null) data.organization = '';
  if(data.projectVersion===undefined || data.projectVersion===null) data.projectVersion = '';
  if(data.date===undefined || data.date===null) data.date = '';
  if(data.contact===undefined || data.contact===null) data.contact = '';
  if(data.url===undefined || data.url===null) data.url = '';
  if(data._appVersion===undefined || data._appVersion===null) data._appVersion = '';
  if(data._savedAt===undefined || data._savedAt===null) data._savedAt = '';
  if(data._app===undefined || data._app===null) data._app = '';

  // Normalize tag priorities (auto-assign sequential if missing)
  if(Array.isArray(data.tagCatalog)){
    let maxP = 0;
    data.tagCatalog.forEach(t=>{ if(t && typeof t.priority==='number') maxP = Math.max(maxP, t.priority); });
    data.tagCatalog.forEach(t=>{
      if(t && (t.priority===undefined || t.priority===null || typeof t.priority!=='number')){
        t.priority = ++maxP;
      }
    });
  }

  // Normalize custom attribute priorities and value priorities
  if(Array.isArray(data.customAttributeCatalog)){
    let maxAP = 0;
    data.customAttributeCatalog.forEach(a=>{ if(a && typeof a.priority==='number') maxAP = Math.max(maxAP, a.priority); });
    data.customAttributeCatalog.forEach(a=>{
      if(a && (a.priority===undefined || a.priority===null || typeof a.priority!=='number')){
        a.priority = ++maxAP;
      }
      // Normalize value priorities within each attribute
      if(a && Array.isArray(a.values)){
        let maxVP = 0;
        a.values.forEach(v=>{ if(v && typeof v.priority==='number') maxVP = Math.max(maxVP, v.priority); });
        a.values.forEach(v=>{
          if(v && (v.priority===undefined || v.priority===null || typeof v.priority!=='number')){
            v.priority = ++maxVP;
          }
        });
      }
    });
  }

  resetIndexes();
  IDX.columns = data.columns.map(c => {
    // Normalize note field for stable JSON shape
    if(c.note===undefined || c.note===null) c.note = '';
    return { id: c.id, label: c.label ?? c.id, schema: c.schema, note: c.note, color: c.color, _pendingColor: c._pendingColor };
  });
  IDX.columns.forEach((c, i) => IDX.columnIndex.set(c.id, i));

  // walk nodes per column
  for(const col of IDX.columns){
    walkAndIndex(col.schema, null, col.id);
  }

  // build edges
  expandEdges(data.mappings || []);
}

function walkAndIndex(node, parentId, columnId){
  IDX.nodeById.set(node.id, node);
  IDX.nodeColumnById.set(node.id, columnId);
  if(parentId) IDX.parentById.set(node.id, parentId);

  // Eagerly normalize node fields so the JSON shape is stable
  // (prevents dirty-flag false positives when editors touch nodes later)
  if(!Array.isArray(node.tags)) node.tags = [];
  node.tags = node.tags.filter(x=>typeof x==='string' && x.trim());
  if(!node.customAttributes || typeof node.customAttributes!=='object' || Array.isArray(node.customAttributes)) node.customAttributes = {};
  if(node.note===undefined || node.note===null) node.note='';

  if(node.type === "field"){
    IDX.fieldIds.add(node.id);
    IDX.nodeFieldDescendants.set(node.id, [node.id]);
    return [node.id];
  }

  const all = [];
  for(const child of (node.children || [])){
    all.push(...walkAndIndex(child, node.id, columnId));
  }
  IDX.nodeFieldDescendants.set(node.id, all);
  return all;
}

function expandEdges(mappings){
  // Migrate raw mapping data: normalize transforms from legacy string[] to {ref}[] format
  for(const m of (mappings||[])){
    if(m && Array.isArray(m.transforms)){
      m.transforms = normalizeTransforms(m.transforms);
    }
  }
  for(const fid of IDX.fieldIds){
    IDX.adjacency.set(fid, new Set());
    IDX.edgesByField.set(fid, []);
  }
  let counter = 0;
  const seenPair = new Set();
  for(const m of (mappings||[])){
    if(!m || typeof m !== 'object') continue;
    const from = m.from;
    const tos = Array.isArray(m.to) ? m.to : (typeof m.to === 'string' ? [m.to] : []);
    for(const to of tos){
      if(!from || !to) continue;
      const key = `${from}${to}`;
      if(seenPair.has(key)) continue;
      seenPair.add(key);
      counter++;
      const edge = { id: `e${counter}:${key}`, from, to,
        cardinality: m.cardinality ?? '',
        transform: m.transform ?? '',
        transforms: normalizeTransforms(m.transforms),
        note: m.note ?? '',
        default: m.default ?? '',
        color: m.color || '',
        };
      IDX.edges.push(edge);
      IDX.mappedFields.add(from); IDX.mappedFields.add(to);
      if(IDX.adjacency.has(from)) IDX.adjacency.get(from).add(to);
      if(IDX.adjacency.has(to)) IDX.adjacency.get(to).add(from);
      if(IDX.edgesByField.has(from)) IDX.edgesByField.get(from).push(edge);
      if(IDX.edgesByField.has(to)) IDX.edgesByField.get(to).push(edge);
    }
  }
}

// Mark bidirectional and consolidated edges in the index
function markConsolidatedEdges(){
  // Clear any previous markings
  for(const edge of IDX.edges){
    delete edge.__consolidated;
    delete edge.__isBidirectional;
    delete edge.__fromId;
    delete edge.__toId;
  }
  
  // Find bidirectional field pairs
  const bidirectionalPairs = new Map();
  for(const edge of IDX.edges){
    const pairKey = `${edge.from}${edge.to}`;
    const reversePairKey = `${edge.to}${edge.from}`;
    
    // Check if reverse mapping exists
    const reverseEdge = IDX.edges.find(e => e.from === edge.to && e.to === edge.from);
    if(reverseEdge){
      if(!bidirectionalPairs.has(pairKey)){
        bidirectionalPairs.set(pairKey, []);
      }
      bidirectionalPairs.get(pairKey).push(edge);
    }
  }
  
  // Mark edges as consolidated/bidirectional
  for(const [pairKey, edges] of bidirectionalPairs.entries()){
    if(edges.length === 0) continue;
    
    const [fromId, toId] = pairKey.split('');
    const reversePairKey = `${toId}${fromId}`;
    const isBidirectional = bidirectionalPairs.has(reversePairKey);
    
    // Only process each pair once
    if(isBidirectional && fromId > toId) continue;
    
    const representativeEdge = edges[0];
    
    // Combine edges from both directions
    let allEdges = [...edges];
    if(isBidirectional){
      const reverseEdges = bidirectionalPairs.get(reversePairKey) || [];
      allEdges = [...edges, ...reverseEdges];
    }
    
    // Mark the representative edge
    representativeEdge.__consolidated = allEdges;
    representativeEdge.__isBidirectional = isBidirectional;
    representativeEdge.__fromId = fromId;
    representativeEdge.__toId = toId;
  }
}


function clearViewerDOM(){
  columnsRow.innerHTML = "";
  edgesLayer.innerHTML = "";
  IDX.elementById.clear();
  IDX.rowById.clear();
  IDX.panelByColumnId.clear();
  IDX.treeByColumnId.clear();
}

/* Render panels for all columns */
function renderColumns(){
  clearViewerDOM();

  // wrap mode: columns can stack under each other (no forced horizontal min-width)
  columnsRow.classList.toggle('wrap', !!state.wrapColumns);
  const visibleCols = IDX.columns.filter(c => !state.hiddenColumns.has(c.id));
  const colW = parseInt(getComputedStyle(columnsRow).getPropertyValue('--col-width')) || 300;
  const minWidth = state.wrapColumns ? 0 : Math.max(920, visibleCols.length * (colW + 20));
  columnsRow.style.minWidth = (minWidth || 0) + 'px';

  for(const col of visibleCols){
    const panel = document.createElement("section");
    panel.className = "panel";
    panel.dataset.columnId = col.id;

    const header = document.createElement("div");
    header.className = "panelHeader";
    const name = document.createElement("div");
    name.className = "name";
    name.textContent = col.label;
    const meta = document.createElement("div");
    meta.className = "meta";

    const fieldsCount = (IDX.nodeFieldDescendants.get(col.id) || []).length;
    meta.textContent = `${fieldsCount} fields`;

    header.appendChild(name);
    header.appendChild(meta);

    // Apply column color to header (respects nodeColorMode)
    const ncm = state.nodeColorMode || 'all';
    if(col.color && ncm !== 'off'){
      const r = parseInt(col.color.slice(1,3),16), g = parseInt(col.color.slice(3,5),16), b = parseInt(col.color.slice(5,7),16);
      header.style.setProperty('--col-color', col.color);
      header.style.setProperty('--col-bg', `rgba(${r},${g},${b},.18)`);
      header.style.setProperty('--col-bg-hover', `rgba(${r},${g},${b},.28)`);
      header.classList.add('colored');
    }

    const tree = document.createElement("div");
    tree.className = "tree";
    tree.dataset.columnId = col.id;

    const foot = document.createElement("div");
    foot.className = "foot";
    foot.innerHTML = `Hover/click nodes to highlight. Column: <code>${col.id}</code>`;

    panel.appendChild(header);
    panel.appendChild(tree);
    panel.appendChild(foot);

    columnsRow.appendChild(panel);

    IDX.panelByColumnId.set(col.id, panel);
    IDX.treeByColumnId.set(col.id, tree);

    // render tree nodes
    // render tree nodes (skip redundant root; render its children)
 if(col.schema && Array.isArray(col.schema.children) && col.schema.children.length){
   for(const child of col.schema.children){
     tree.appendChild(createNodeElement(child, col.id));
   }
 }

    // interactions
    attachTreeInteractions(tree);
  }

  // overlay SVG must match scroller content box
  
 attachColumnHeaderActions();
 updateColumnHeaderSelectionStyles();
 
attachSvgEdgeInteractions();
scheduleArrowsUpdate();
}

/* DOM node creation */

// Build a unified pill strip for a node: Tags (sorted by priority) then Attribute values
// (sorted by attribute priority, then value priority within attribute).
// Respects state.showTagPills, state.showAttrPills, and per-attribute displayOnNode flag.
function buildNodePillStrip(node){
  const strip = document.createElement('div');
  strip.className = 'tagStrip';
  let count = 0;
  const MAX_PILLS = 5; // cap to avoid row overflow

  // 1) Tag pills
  if(state.showTagPills){
    const tags = sortTagIdsByPriority(normalizeNodeTags(node));
    for(let i = 0; i < tags.length && count < MAX_PILLS; i++){
      const tid = tags[i];
      const td = tagById(tid) || {id: tid, label: tid, abbr: tid.slice(0,1).toUpperCase(), color: DEFAULT_TAG_COLOR};
      const chip = document.createElement('span');
      chip.className = 'tagChip';
      chip.style.setProperty('--c', tagColor(td));
      chip.setAttribute('data-color','1');
      chip.title = (td.label||td.id||'') + (td.note?('  '+td.note):'');
      chip.textContent = tagAbbr(td);
      strip.appendChild(chip);
      count++;
    }
  }

  // 2) Custom attribute value pills
  if(state.showAttrPills){
    const ca = normalizeCustomAttributes(node);
    // Get attributes sorted by priority, filtered to displayOnNode
    const attrCat = ensureCustomAttributeCatalog()
      .filter(a => a && a.displayOnNode)
      .sort((a,b) => {
        const pa = typeof a.priority==='number' ? a.priority : 9999;
        const pb = typeof b.priority==='number' ? b.priority : 9999;
        return pa - pb;
      });
    for(const attr of attrCat){
      if(count >= MAX_PILLS) break;
      const raw = ca[attr.id];
      if(!raw) continue;
      const valIds = Array.isArray(raw) ? raw : [raw];
      // Sort value IDs by their priority in the attribute's values array
      const valsDef = Array.isArray(attr.values) ? attr.values : [];
      const sortedValIds = [...valIds].sort((a,b) => {
        const va = valsDef.find(v=>v.id===a);
        const vb = valsDef.find(v=>v.id===b);
        const pa = va && typeof va.priority==='number' ? va.priority : 9999;
        const pb = vb && typeof vb.priority==='number' ? vb.priority : 9999;
        return pa - pb;
      });
      for(const vid of sortedValIds){
        if(count >= MAX_PILLS) break;
        const vDef = valsDef.find(v=>v.id===vid);
        const vLabel = vDef ? (vDef.abbr || vDef.label || vid) : vid;
        // Color inheritance: value color (if enabled)  attribute color (if enabled)  none
        const vColorEnabled = vDef?.color && vDef?.colorEnabled !== false;
        const attrColorEnabled = attr.color && attr.colorEnabled !== false;
        const vColor = vColorEnabled ? vDef.color : (attrColorEnabled ? attr.color : '');
        const chip = document.createElement('span');
        chip.className = 'tagChip';
        if(vColor){
          chip.style.setProperty('--c', vColor);
          chip.setAttribute('data-color','1');
        }
        chip.title = (attr.label||attr.id) + ': ' + (vDef?.label||vid) + (vDef?.note ? ('  '+vDef.note) : '');
        chip.textContent = vLabel;
        strip.appendChild(chip);
        count++;
      }
    }
  }

  return count > 0 ? strip : null;
}

function createNodeElement(node, columnId){
  const container = document.createElement("div");
  container.className = `node ${node.type}`;
  container.dataset.nodeId = node.id;
  container.dataset.columnId = columnId;

  const row = document.createElement("div");
  row.className = "row";
  row.dataset.nodeId = node.id;
  row.dataset.columnId = columnId;
 // Tooltip: show node ID
 row.title = `${node.type||'node'}: ${node.id}`;
  // connection ports (used as arrow anchor points; avoids arrowheads overlapping text)
  const portL = document.createElement('span');
  portL.className = 'port portL';
  const portR = document.createElement('span');
  portR.className = 'port portR';
  row.appendChild(portL);
  row.appendChild(portR);

  if(node.type === "group"){
    const caret = document.createElement("div");
    caret.className = "caret";
    caret.dataset.caretFor = node.id;
    row.appendChild(caret);
  const pillStrip = buildNodePillStrip(node);
  if(pillStrip) row.appendChild(pillStrip);
  } else {
    const spacer = document.createElement("div");
    spacer.style.width = "21px";
    spacer.style.flex = "0 0 auto";
    row.appendChild(spacer);
  const pillStrip = buildNodePillStrip(node);
  if(pillStrip) row.appendChild(pillStrip);
  }

  const label = document.createElement("div");
  label.className = "label";
  const text = document.createElement("span");
  text.className = "text";
  text.textContent = node.label ?? node.id;
  label.appendChild(text);
  // ID is intentionally hidden in the tree row to save horizontal space.
  // Full ID is still available in Details and status/breadcrumbs.
  row.appendChild(label);
  container.appendChild(row);

  if(node.type === "group"){
    const childrenWrap = document.createElement("div");
    childrenWrap.className = "children";
    for(const child of (node.children || [])){
      childrenWrap.appendChild(createNodeElement(child, columnId));
    }
    container.appendChild(childrenWrap);
  }

  IDX.elementById.set(node.id, container);
  IDX.rowById.set(node.id, row);

  // Apply custom node color as subtle background tint
  // Hierarchy: node.color (applied)  nearest ancestor color (applied)  column color  none
  // Respects state.nodeColorMode: 'all' | 'groups' | 'column' | 'off'
  const ncm = state.nodeColorMode || 'all';
  const effectiveColor = ncm === 'off' ? '' : (function(){
    // 'all': use node's own color for any type
    // 'groups': use node's own color only if it's a group (not field)
    // 'column': skip all node/group colors
    const useOwnColor = ncm === 'all' || (ncm === 'groups' && node.type === 'group');
    if(useOwnColor && node.color) return node.color;
    // Walk parent chain for group colors
    if(ncm !== 'column'){
      let pid = IDX.parentById.get(node.id);
      while(pid){
        const pNode = IDX.nodeById.get(pid);
        if(pNode && pNode.color) return pNode.color;
        pid = IDX.parentById.get(pid);
      }
    }
    // Fall back to column color
    const cid = columnId || columnOf(node.id);
    const colObj = cid ? findColumnByIdIn(state.data, cid) : null;
    return colObj?.color || '';
  })();
  if(effectiveColor){
    const cr = parseInt(effectiveColor.slice(1,3),16), cg = parseInt(effectiveColor.slice(3,5),16), cb = parseInt(effectiveColor.slice(5,7),16);
    const isGroup = node.type === 'group';
    row.style.setProperty('--node-color', `rgba(${cr},${cg},${cb},${isGroup ? .08 : .14})`);
    row.style.setProperty('--node-color-border', `rgba(${cr},${cg},${cb},${isGroup ? .22 : .38})`);
    container.classList.add('hasNodeColor');
  }

  return container;
}

function toggleCollapse(nodeId, force=null, skipHighlight=false){
  const el = IDX.elementById.get(nodeId);
  if(!el || !el.classList.contains("group")) return;
  const children = el.querySelector(":scope > .children");
  if(!children) return;

  const collapsed = el.classList.contains("collapsed");
  const next = (force === null) ? !collapsed : !!force;

  el.classList.toggle("collapsed", next);
  children.style.display = next ? "none" : "block";

  if(!skipHighlight) applyHighlight();
  scheduleArrowsUpdate();
}

function setAllGroupsCollapsed(collapsed){
  for(const [id, node] of IDX.nodeById.entries()){
    if(node.type === "group"){
      toggleCollapse(id, collapsed, true);
    }
  }
  applyHighlight();
  scheduleArrowsUpdate();
}

/* =========================
   Filter Catalog Engine
========================= */
function ensureFilterCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.filterCatalog)) state.data.filterCatalog = [];
  return state.data.filterCatalog;
}

// Condition field options
const FILTER_FIELDS = [
  { id:'tag', label:'Tag', valueType:'tagSelect' },
  { id:'mapped', label:'Has mappings', valueType:'boolean' },
  { id:'transform', label:'Has transform', valueType:'transformSelect' },
  { id:'type', label:'Node type', valueType:'typeSelect' },
  { id:'label', label:'Label', valueType:'text' },
  { id:'id', label:'ID', valueType:'text' },
  { id:'note', label:'Note', valueType:'text' },
];
function getFilterFieldOptions(){
  const base = [...FILTER_FIELDS];
  // Add one entry per custom attribute
  const attrCat = ensureCustomAttributeCatalog();
  attrCat.forEach(a=>{
    base.push({ id:'attr:'+a.id, label:'Attr: '+(a.abbr||a.label), valueType:'attrSelect', attrId:a.id });
  });
  // Add saved filters as possible conditions (for composition)
  const fCat = ensureFilterCatalog();
  fCat.forEach(f=>{
    base.push({ id:'filter:'+f.id, label:'Filter: '+f.label, valueType:'boolean' });
  });
  return base;
}

// Operators per value type
function getOperators(valueType){
  switch(valueType){
    case 'tagSelect': return [{id:'has',label:'has'},{id:'not_has',label:'does not have'}];
    case 'attrSelect': return [{id:'is',label:'is'},{id:'is_not',label:'is not'},{id:'is_set',label:'is set'},{id:'is_not_set',label:'is not set'}];
    case 'text': return [{id:'contains',label:'contains'},{id:'not_contains',label:'does not contain'},{id:'eq',label:'equals'},{id:'starts_with',label:'starts with'}];
    case 'boolean': return [{id:'yes',label:'yes'},{id:'no',label:'no'}];
    case 'typeSelect': return [{id:'is_field',label:'is field'},{id:'is_group',label:'is group'}];
    case 'transformSelect': return [{id:'has',label:'has'},{id:'not_has',label:'does not have'}];
    default: return [{id:'eq',label:'equals'}];
  }
}

// Evaluate a single condition against a node
function evaluateCondition(node, cond, visited){
  if(!cond || !cond.field) return true;
  const f = cond.field, op = cond.op || '', val = cond.value || '';

  if(f === 'tag'){
    const tags = Array.isArray(node.tags) ? node.tags : [];
    return op === 'not_has' ? !tags.includes(val) : tags.includes(val);
  }
  if(f === 'mapped'){
    const isMapped = IDX && IDX.mappedFields && IDX.mappedFields.has(node.id);
    return op === 'no' ? !isMapped : !!isMapped;
  }
  if(f === 'transform'){
    // Check edges connected to this node for the specified transform
    const edges = IDX?.edgesByField?.get(node.id) || [];
    const hasTransform = edges.some(e => Array.isArray(e.transforms) && e.transforms.some(inst => transformRefId(inst) === val));
    return op === 'not_has' ? !hasTransform : hasTransform;
  }
  if(f === 'type'){
    return op === 'is_group' ? node.type === 'group' : node.type === 'field';
  }
  if(f === 'label' || f === 'id' || f === 'note'){
    const hay = norm(f === 'label' ? (node.label||'') : f === 'id' ? (node.id||'') : (node.note||''));
    const needle = norm(val);
    if(!needle && (op==='contains'||op==='eq'||op==='starts_with')) return !needle;
    if(op === 'contains') return hay.includes(needle);
    if(op === 'not_contains') return !hay.includes(needle);
    if(op === 'eq') return hay === needle;
    if(op === 'starts_with') return hay.startsWith(needle);
    return hay.includes(needle);
  }
  if(f.startsWith('attr:')){
    const attrId = f.slice(5);
    const ca = node.customAttributes || {};
    const nodeVal = ca[attrId];
    const nodeVals = nodeVal ? (Array.isArray(nodeVal) ? nodeVal : [nodeVal]) : [];
    if(op === 'is_set') return nodeVals.length > 0;
    if(op === 'is_not_set') return nodeVals.length === 0;
    if(op === 'is') return nodeVals.includes(val);
    if(op === 'is_not') return !nodeVals.includes(val);
    return nodeVals.includes(val);
  }
  if(f.startsWith('filter:')){
    const refId = f.slice(7);
    const match = evaluateFilter(node, refId, visited);
    return op === 'no' ? !match : match;
  }
  return true;
}

// Evaluate all conditions of a filter against a node (with cycle detection)
// Supports recursive groups: rule = { field, op, value } or { type:'group', rules:[...] }
function evaluateRules(node, rules, visited){
  if(!rules || !rules.length) return true;
  let result = evaluateRule(node, rules[0], visited);
  for(let i = 1; i < rules.length; i++){
    const join = rules[i].join || 'and';
    const val = evaluateRule(node, rules[i], visited);
    result = join === 'or' ? (result || val) : (result && val);
  }
  return result;
}

function evaluateRule(node, rule, visited){
  if(!rule) return true;
  if(rule.type === 'group') return evaluateRules(node, rule.rules || [], visited);
  return evaluateCondition(node, rule, visited);
}

function evaluateFilter(node, filterId, visited){
  if(!visited) visited = new Set();
  if(visited.has(filterId)) return false;
  visited.add(filterId);
  const cat = ensureFilterCatalog();
  const filter = cat.find(f=>f.id === filterId);
  if(!filter) return true;
  return evaluateRules(node, filter.rules || [], new Set(visited));
}

// Get all nodes matching a filter
function getFilterMatchSet(filterId){
  const matches = new Set();
  if(!IDX) return matches;
  for(const [id, node] of IDX.nodeById.entries()){
    if(evaluateFilter(node, filterId)) matches.add(id);
  }
  return matches;
}

// Default highlight
const DEFAULT_HIGHLIGHT = { bg:'#3b82f6', border:'#3b82f6', bold:false, emoji:'', frame:false, edgeColor:'#3b82f6', bgEnabled:true, borderEnabled:true, edgeEnabled:false };

// ---- Filter catalog manager ----
let __filterEditId = null;
let __filterIsNew = false;

function renderFiltersManager(){
  const body = document.getElementById('filtersBody');
  if(!body) return;
  const cat = ensureFilterCatalog();
  const editable = state.editorMode;
  if(cat.length === 0){
    body.innerHTML = `<div class="empty" style="padding:18px;">No saved filters yet.${editable?' Click <b>Add filter</b> to create one.':''}</div>`;
    return;
  }

  // Build sorted index array by priority
  const sortedIdxs = cat.map((_,i)=>i).sort((a,b)=>{
    const pa = typeof cat[a].priority==='number' ? cat[a].priority : 9999;
    const pb = typeof cat[b].priority==='number' ? cat[b].priority : 9999;
    return pa - pb;
  });

  body.innerHTML = sortedIdxs.map((idx, sortPos)=>{
    const f = cat[idx];
    const hl = f.highlight || {};
    const isEditing = (__filterEditId === f.id);
    const isFirst = sortPos === 0;
    const isLast = sortPos === sortedIdxs.length - 1;

    // Rules summary
    const rulesSummary = summarizeRules(f.rules || []) || '<i style="opacity:.5">No conditions</i>';
    
    const swatch = hl.bg || hl.border || '';
    const swatchHtml = swatch ? `<span style="display:inline-block;width:14px;height:14px;border-radius:3px;background:${escapeHtml(hl.bgEnabled!==false?(hl.bg||'transparent'):'transparent')};border:2px solid ${escapeHtml(hl.borderEnabled!==false?(hl.border||hl.bg||'var(--border)'):'var(--border)')};vertical-align:middle;margin-right:6px;"></span>` : '';

    const isActive = state.activeFilterIds.includes(f.id);

    if(isEditing && editable){
      return renderFilterEditCard(f, idx);
    }

    return `<div class="catCard catItem filterCard" data-fid="${escapeHtml(f.id)}" data-fidx="${idx}" data-sort-pos="${sortPos}" ${editable?'draggable="true"':''} style="margin-bottom:8px;padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:var(--panel);display:flex;align-items:center;gap:10px;${editable?'cursor:pointer;':''}${hl.frame?'box-shadow:0 0 0 2px '+escapeHtml(hl.frameColor||hl.border||'#3b82f6')+';':''}" ${editable?'title="Click to edit  Drag to reorder"':''}>
      <div style="flex:1;min-width:0;">
        <div style="display:flex;align-items:center;gap:8px;">
          ${swatchHtml}
          <b style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${hl.emoji?escapeHtml(hl.emoji)+' ':''}${escapeHtml(f.label||f.id)}</b>
          <span style="font-family:var(--mono);font-size:10px;opacity:.35;flex-shrink:0;">${escapeHtml(f.id)}</span>${isLikelyAutoId(f) ? '<span class="autoTag" style="font-size:8px;padding:0 4px;">auto</span>' : ''}
        </div>
        <div style="font-size:11px;line-height:1.5;opacity:.8;margin-top:4px;">${rulesSummary}</div>
        ${f.note?`<div style="font-size:11px;opacity:.6;margin-top:2px;">${escapeHtml(f.note)}</div>`:''}
      </div>
      <div style="display:flex;align-items:center;gap:6px;flex-shrink:0;">
        <label class="toggle" style="font-size:11px;display:inline-flex;align-items:center;" title="Toggle this filter on/off"><input type="checkbox" class="fToggle" data-fid="${escapeHtml(f.id)}" ${isActive?'checked':''}/>Active</label>
        ${editable?`<span style="width:8px;"></span><button class="btn catMoveBtn" data-act="moveUp" data-fidx="${idx}" title="Move up" style="padding:2px 6px;font-size:12px;${isFirst?'visibility:hidden;':''}"></button>
        <button class="btn catMoveBtn" data-act="moveDown" data-fidx="${idx}" title="Move down" style="padding:2px 6px;font-size:12px;${isLast?'visibility:hidden;':''}"></button>`:''}
      </div>
    </div>`;
  }).join('');
  body.classList.toggle('catEditActive', !!__filterEditId);

  // Wire events
  body.querySelectorAll('.fToggle').forEach(cb=>{
    cb.addEventListener('change', (e)=>{
      e.stopPropagation();
      const fid = cb.dataset.fid;
      if(cb.checked){ if(!state.activeFilterIds.includes(fid)) state.activeFilterIds.push(fid); }
      else { state.activeFilterIds = state.activeFilterIds.filter(x=>x!==fid); }
      renderActiveFilterChips();
      updateFilterBadge();
      refreshViewer();
    });
  });

  //  move buttons
  body.querySelectorAll('.catMoveBtn').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(!state.editorMode) return;
      const fidx = Number(btn.dataset.fidx);
      const dir = btn.dataset.act === 'moveUp' ? -1 : 1;
      const pos = sortedIdxs.indexOf(fidx);
      const swapPos = pos + dir;
      if(swapPos < 0 || swapPos >= sortedIdxs.length) return;
      const otherIdx = sortedIdxs[swapPos];
      pushUndo();
      const tmp = cat[fidx].priority;
      cat[fidx].priority = cat[otherIdx].priority;
      cat[otherIdx].priority = tmp;
      checkDirtyState();
      renderFiltersManager();
      renderActiveFilterChips();
    });
  });

  // Drag-and-drop reorder (tag-style)
  let __fDragSortPos = null;
  let __fDragTime = 0;
  body.querySelectorAll('.filterCard[draggable]').forEach(card=>{
    card.addEventListener('dragstart', (e)=>{
      __fDragSortPos = Number(card.dataset.sortPos);
      __fDragTime = Date.now();
      card.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    });
    card.addEventListener('dragend', ()=>{
      card.style.opacity = '';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      __fDragSortPos = null;
    });
    card.addEventListener('dragover', (e)=>{
      e.preventDefault(); e.dataTransfer.dropEffect = 'move';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      card.classList.add('dragOver');
    });
    card.addEventListener('dragleave', ()=>{ card.classList.remove('dragOver'); });
    card.addEventListener('drop', (e)=>{
      e.preventDefault(); card.classList.remove('dragOver');
      const fromPos = __fDragSortPos;
      const toPos = Number(card.dataset.sortPos);
      if(fromPos === null || fromPos === toPos) return;
      const reordered = [...sortedIdxs];
      const [moved] = reordered.splice(fromPos, 1);
      reordered.splice(toPos, 0, moved);
      pushUndo();
      reordered.forEach((catIdx, newPos) => { cat[catIdx].priority = newPos + 1; });
      checkDirtyState();
      renderFiltersManager();
      renderActiveFilterChips();
    });
  });

  // Click-to-edit
  body.querySelectorAll('.filterCard').forEach(card=>{
    if(!card.draggable) return; // not editable
    card.addEventListener('click', async (e)=>{
      if(!state.editorMode) return;
      if(e.target.closest('.catMoveBtn') || e.target.closest('.fToggle') || e.target.closest('label')) return;
      if(Date.now() - __fDragTime < 300) return;
      if(!await guardFilterAbandon()) return;
      __filterEditId = card.dataset.fid;
      __filterIsNew = false;
      // Store snapshot for dirty checking
      const f = cat.find(x => x.id === __filterEditId);
      __filterEditSnapshot = f ? JSON.stringify(f) : null;
      renderFiltersManager();
    });
  });

  wireFilterEditCard(body);
}

function summarizeRules(rules, depth){
  if(!rules || !rules.length) return '';
  return rules.map((r, i)=>{
    const joinHtml = i > 0 ? ` <span style="color:var(--accent);font-weight:700;">${(r.join||'and').toUpperCase()}</span> ` : '';
    if(r.type === 'group'){
      return `${joinHtml}( ${summarizeRules(r.rules||[])} )`;
    }
    const fd = getFilterFieldOptions().find(x=>x.id===r.field);
    return `${joinHtml}<span style="opacity:.8">${escapeHtml(fd?fd.label:r.field||'?')}</span> ${escapeHtml(r.op||'')} <b>${escapeHtml(r.value||'')}</b>`;
  }).join('');
}

function renderFilterEditCard(f, idx){
  const hl = f.highlight || {};
  const rules = f.rules || [];
  const fieldOpts = getFilterFieldOptions().filter(x=>!x.id.startsWith('filter:'+f.id));

  const rulesHtml = renderRulesEditor(rules, fieldOpts, '');

  const EMOJI_PICKS = ['','','','','','','','','','','','','','','','','',''];

  return `<div class="catCard filterEditCard" data-fid="${escapeHtml(f.id)}" style="margin-bottom:8px;padding:12px 14px;border-radius:10px;border:2px solid var(--accent);background:var(--panel);">
    <div class="kv" style="grid-template-columns:50px 1fr;margin-bottom:8px;">
      <div class="k">Label</div><div class="v"><input class="inp feLabel" value="${escapeHtml(f.label||'')}" placeholder="Filter name" style="font-size:13px;font-weight:700;"/></div>
      <div class="k">Id <span class="autoTag" data-auto="id">auto</span></div><div class="v" style="display:flex;align-items:center;"><input class="inp feId" value="${__filterIsNew ? '' : escapeHtml(f.id||'')}" placeholder="auto" style="font-family:var(--mono);font-size:11px;flex:1;"/></div>
    </div>
    <div class="feRules">${rulesHtml}</div>
    <div style="display:flex;gap:6px;margin:6px 0 10px;">
      <button class="btn feAddCond" style="font-size:11px;">+ Condition</button>
      <button class="btn feAddGroup" style="font-size:11px;">+ Group ( )</button>
    </div>
    <div style="font-size:11px;opacity:.6;margin-bottom:6px;">Highlight style <span style="opacity:.6;font-size:10px;"> drag a swatch onto another to copy its color</span></div>
    <div class="feStyleBar">
      <div class="feStyleItem" data-color-cls="feBg" draggable="true" title="Background tint  Drag to copy color">
        <input type="checkbox" class="feBgOn" ${(hl.bgEnabled!==false)?'checked':''}/>
        <input type="color" class="feBg feColor feColorSwatch" value="${hl.bg||'#3b82f6'}"/>
        <span class="feStyleLabel">Background</span>
      </div>
      <div class="feStyleItem" data-color-cls="feBorder" draggable="true" title="Left border stripe  Drag to copy color">
        <input type="checkbox" class="feBorderOn" ${(hl.borderEnabled!==false)?'checked':''}/>
        <input type="color" class="feBorder feColor feColorSwatch" value="${hl.border||'#3b82f6'}"/>
        <span class="feStyleLabel">Stripe</span>
      </div>
      <div class="feStyleItem" data-color-cls="feEdge" draggable="true" title="Arrow color  Drag to copy color">
        <input type="checkbox" class="feEdgeOn" ${hl.edgeEnabled?'checked':''}/>
        <input type="color" class="feEdge feColor feColorSwatch" value="${hl.edgeColor||'#3b82f6'}"/>
        <span class="feStyleLabel">Arrow</span>
      </div>
      <div class="feStyleItem" data-color-cls="feFrameColor" draggable="true" title="Frame outline  Drag to copy color">
        <input type="checkbox" class="feFrame" ${hl.frame?'checked':''}/>
        <input type="color" class="feFrameColor feColor feColorSwatch" value="${hl.frameColor||hl.border||'#3b82f6'}"/>
        <span class="feStyleLabel">Frame</span>
      </div>
      <div class="feStyleSep"></div>
      <label class="toggle" style="font-size:11px;"><input type="checkbox" class="feBold" ${hl.bold?'checked':''}/>Bold</label>
      <div class="feStyleSep"></div>
      <div style="display:flex;align-items:center;gap:3px;font-size:11px;">
        <input class="inp feEmoji" value="${escapeHtml(hl.emoji||'')}" style="width:32px;font-size:13px;text-align:center;padding:2px;" maxlength="4" placeholder=""/>
        <button class="btn feEmojiPick" style="font-size:11px;padding:2px 5px;" title="Pick emoji"></button>
      </div>
      <div class="feStyleSep"></div>
      <button class="btn feColorPalette" style="font-size:11px;padding:2px 5px;" title="Show color presets"></button>
    </div>
    <div class="feColorPalettePanel" style="display:none;margin:6px 0 8px;padding:6px 8px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);">
      <div style="display:flex;align-items:center;gap:6px;">
        ${TAG_COLOR_PRESETS.map(p=>`<div class="fePresetSwatch" draggable="true" data-color="${p.value}" title="${p.name}  drag onto swatch or click to apply" style="width:22px;height:22px;border-radius:6px;background:${p.value};cursor:grab;border:1px solid rgba(255,255,255,.15);transition:transform .1s;flex-shrink:0;"></div>`).join('')}
        <div style="font-size:9px;opacity:.35;white-space:nowrap;line-height:1.4;flex-shrink:0;margin-left:4px;">click = all active channels<br/>drag = single swatch</div>
      </div>
    </div>
    <div class="feEmojiPicker" style="display:none;flex-wrap:wrap;gap:2px;margin:6px 0 8px;justify-content:space-between;">
      ${EMOJI_PICKS.map(e=>`<button class="feEmojiOption" data-emoji="${e}" style="font-size:16px;padding:3px 5px;border:1px solid transparent;border-radius:6px;background:transparent;cursor:pointer;transition:all .1s;" title="${e}">${e}</button>`).join('')}
      <button class="feEmojiOption" data-emoji="" style="font-size:11px;padding:3px 6px;border:1px solid var(--border);border-radius:6px;background:transparent;cursor:pointer;color:var(--muted);" title="Clear emoji"></button>
    </div>
    <input class="inp feNote" value="${escapeHtml(f.note||'')}" placeholder="Note (optional)" style="width:100%;font-size:11px;margin-bottom:8px;"/>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap;">
      ${__filterIsNew ? '' : '<button class="btn feDel" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
      <span style="flex:1;"></span>
      <button class="btn feCancel">Cancel</button>
      <button class="btn btnSave feSave">Save</button>
    </div>
  </div>`;
}

// Render rules editor recursively (conditions + groups)
function renderRulesEditor(rules, fieldOpts, pathPrefix){
  if(!rules || !rules.length) return '<div style="opacity:.5;font-size:11px;padding:4px 0;">No conditions  matches everything.</div>';
  return rules.map((r, ri)=>{
    const path = pathPrefix ? pathPrefix+'.'+ri : ''+ri;
    const joinHtml = ri > 0 ? `<div style="display:flex;align-items:center;margin:2px 0 4px ${pathPrefix?'4':'12'}px;">
      <select class="inp ruleJoin" data-path="${path}" style="width:60px;font-size:10px;font-weight:700;color:var(--accent);background:transparent;border:1px dashed var(--accent);border-radius:4px;padding:1px 4px;cursor:pointer;">
        <option value="and" ${(r.join||'and')==='and'?'selected':''}>AND</option><option value="or" ${r.join==='or'?'selected':''}>OR</option>
      </select>
    </div>` : '';

    if(r.type === 'group'){
      const innerHtml = renderRulesEditor(r.rules || [], fieldOpts, path);
      return `${joinHtml}<div class="condGroup" data-path="${path}">
        <div class="condGroupHead" style="display:flex;align-items:center;gap:4px;margin-bottom:4px;">
          <span class="condDragHandle" draggable="true" data-path="${path}" title="Drag to reorder"></span>
          <span style="font-size:10px;opacity:.5;font-weight:700;">GROUP</span>
          <span style="flex:1;"></span>
          <button class="btn ruleAddCond" data-path="${path}" style="font-size:10px;">+ Cond</button>
          <button class="btn ruleAddGroup" data-path="${path}" style="font-size:10px;">+ Group</button>
          <span class="condActions" style="display:flex;gap:1px;align-items:center;">
            <button class="btn ruleUp" data-path="${path}" title="Move up" style="font-size:10px;padding:2px 4px;"></button>
            <button class="btn ruleDown" data-path="${path}" title="Move down" style="font-size:10px;padding:2px 4px;"></button>
            <button class="btn ruleIndent" data-path="${path}" title="Indent into previous group" style="font-size:10px;padding:2px 4px;"></button>
            <button class="btn ruleOutdent" data-path="${path}" title="Outdent from group" style="font-size:10px;padding:2px 4px;"></button>
            <button class="btn ruleDel" data-path="${path}" style="font-size:10px;padding:2px 4px;border-color:rgba(255,100,100,.5);color:#f87171;" title="Delete group"></button>
          </span>
        </div>
        ${innerHtml}
      </div>`;
    }

    const fd = fieldOpts.find(x=>x.id===r.field) || fieldOpts[0] || {};
    const ops = getOperators(fd.valueType||'text');
    const needsValue = !['boolean','typeSelect'].includes(fd.valueType) && !['is_set','is_not_set','yes','no','is_field','is_group'].includes(r.op);
    return `${joinHtml}<div class="condRow" data-path="${path}" style="display:flex;gap:4px;align-items:center;margin-bottom:2px;">
      <span class="condDragHandle" draggable="true" data-path="${path}" title="Drag to reorder"></span>
      <select class="inp ruleField" data-path="${path}" style="flex:1;font-size:11px;">
        ${fieldOpts.map(o=>`<option value="${escapeHtml(o.id)}" ${o.id===r.field?'selected':''}>${escapeHtml(o.label)}</option>`).join('')}
      </select>
      <select class="inp ruleOp" data-path="${path}" style="flex:0 0 120px;font-size:11px;">
        ${ops.map(o=>`<option value="${escapeHtml(o.id)}" ${o.id===r.op?'selected':''}>${escapeHtml(o.label)}</option>`).join('')}
      </select>
      ${needsValue ? renderRuleValueInput(fd, r, path) : '<span style="flex:1;"></span>'}
      <span class="condActions" style="display:flex;gap:1px;align-items:center;flex-shrink:0;">
        <button class="btn ruleUp" data-path="${path}" title="Move up" style="font-size:10px;padding:2px 4px;"></button>
        <button class="btn ruleDown" data-path="${path}" title="Move down" style="font-size:10px;padding:2px 4px;"></button>
        <button class="btn ruleIndent" data-path="${path}" title="Indent into previous group" style="font-size:10px;padding:2px 4px;"></button>
        <button class="btn ruleOutdent" data-path="${path}" title="Outdent from group" style="font-size:10px;padding:2px 4px;"></button>
        <button class="btn ruleDel" data-path="${path}" style="font-size:10px;padding:2px 4px;border-color:rgba(255,100,100,.5);color:#f87171;" title="Remove"></button>
      </span>
    </div>`;
  }).join('');
}

function renderRuleValueInput(fd, rule, path){
  if(fd.valueType === 'tagSelect'){
    const tags = ensureTagCatalog();
    return `<select class="inp ruleVal" data-path="${path}" style="flex:1;font-size:11px;"><option value=""></option>
      ${tags.map(t=>`<option value="${escapeHtml(t.id)}" ${t.id===rule.value?'selected':''}>${escapeHtml((t.abbr||'')+'  '+t.label)}</option>`).join('')}</select>`;
  }
  if(fd.valueType === 'transformSelect'){
    const transforms = ensureTransformCatalog();
    return `<select class="inp ruleVal" data-path="${path}" style="flex:1;font-size:11px;"><option value=""></option>
      ${transforms.map(t=>`<option value="${escapeHtml(t.id)}" ${t.id===rule.value?'selected':''}>${escapeHtml((t.abbr||t.id)+'  '+t.label)}</option>`).join('')}</select>`;
  }
  if(fd.valueType === 'attrSelect'){
    const attrCat = ensureCustomAttributeCatalog();
    const a = attrCat.find(x=>x.id===fd.attrId);
    const vals = a?.values || [];
    return `<select class="inp ruleVal" data-path="${path}" style="flex:1;font-size:11px;"><option value=""></option>
      ${vals.map(v=>`<option value="${escapeHtml(v.id)}" ${v.id===rule.value?'selected':''}>${escapeHtml(v.label||v.id)}</option>`).join('')}</select>`;
  }
  return `<input class="inp ruleVal" data-path="${path}" value="${escapeHtml(rule.value||'')}" placeholder="Value" style="flex:1;font-size:11px;"/>`;
}

function wireFilterEditCard(container){
  const card = container.querySelector('.filterEditCard');
  if(!card) return;
  const fid = card.dataset.fid;
  const cat = ensureFilterCatalog();
  const filter = cat.find(x=>x.id===fid);
  if(!filter) return;
  if(!filter.rules) filter.rules = [];

  // Resolve dot-path "0.2.1"  { arr, idx } into the rules tree
  function resolvePath(path){
    const parts = path.split('.').map(Number);
    let arr = filter.rules;
    for(let i = 0; i < parts.length - 1; i++){
      const r = arr[parts[i]];
      if(r && r.type === 'group') arr = r.rules || (r.rules = []);
      else return null;
    }
    return { arr, idx: parts[parts.length - 1] };
  }

  // Add condition at root
  card.querySelector('.feAddCond')?.addEventListener('click', ()=>{
    const fields = getFilterFieldOptions();
    const nr = { field: fields[0]?.id||'tag', op: getOperators(fields[0]?.valueType||'text')[0]?.id||'has', value:'' };
    if(filter.rules.length > 0) nr.join = 'and';
    filter.rules.push(nr);
    renderFiltersManager();
  });

  // Add group at root
  card.querySelector('.feAddGroup')?.addEventListener('click', ()=>{
    const ng = { type: 'group', rules: [] };
    if(filter.rules.length > 0) ng.join = 'and';
    filter.rules.push(ng);
    renderFiltersManager();
  });

  // Add condition inside a group
  card.querySelectorAll('.ruleAddCond').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref) return;
      const group = ref.arr[ref.idx];
      if(!group || group.type !== 'group') return;
      if(!group.rules) group.rules = [];
      const fields = getFilterFieldOptions();
      const nr = { field: fields[0]?.id||'tag', op: getOperators(fields[0]?.valueType||'text')[0]?.id||'has', value:'' };
      if(group.rules.length > 0) nr.join = 'and';
      group.rules.push(nr);
      renderFiltersManager();
    });
  });

  // Add group inside a group
  card.querySelectorAll('.ruleAddGroup').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref) return;
      const group = ref.arr[ref.idx];
      if(!group || group.type !== 'group') return;
      if(!group.rules) group.rules = [];
      const ng = { type: 'group', rules: [] };
      if(group.rules.length > 0) ng.join = 'and';
      group.rules.push(ng);
      renderFiltersManager();
    });
  });

  // Delete rule (condition or group)
  card.querySelectorAll('.ruleDel').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref) return;
      ref.arr.splice(ref.idx, 1);
      if(ref.arr.length > 0 && ref.arr[0].join) delete ref.arr[0].join;
      renderFiltersManager();
    });
  });

  // Helper: fix join connectors after mutations (first item has no join, rest get 'and' if missing)
  function fixJoins(arr){
    arr.forEach((r,i)=>{
      if(i===0) delete r.join;
      else if(!r.join) r.join = 'and';
    });
  }

  // Move up
  card.querySelectorAll('.ruleUp').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref || ref.idx <= 0) return;
      const [item] = ref.arr.splice(ref.idx, 1);
      ref.arr.splice(ref.idx - 1, 0, item);
      fixJoins(ref.arr);
      renderFiltersManager();
    });
  });

  // Move down
  card.querySelectorAll('.ruleDown').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref || ref.idx >= ref.arr.length - 1) return;
      const [item] = ref.arr.splice(ref.idx, 1);
      ref.arr.splice(ref.idx + 1, 0, item);
      fixJoins(ref.arr);
      renderFiltersManager();
    });
  });

  // Indent (move into previous sibling group)
  card.querySelectorAll('.ruleIndent').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref || ref.idx <= 0) return;
      const prev = ref.arr[ref.idx - 1];
      if(!prev || prev.type !== 'group') return; // can only indent into a group
      const [item] = ref.arr.splice(ref.idx, 1);
      if(!prev.rules) prev.rules = [];
      if(prev.rules.length > 0) item.join = item.join || 'and';
      else delete item.join;
      prev.rules.push(item);
      fixJoins(ref.arr);
      renderFiltersManager();
    });
  });

  // Outdent (move out of parent group to grandparent level)
  card.querySelectorAll('.ruleOutdent').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const path = btn.dataset.path;
      const dotIdx = path.lastIndexOf('.');
      if(dotIdx < 0) return; // already at root, can't outdent
      const parentPath = path.substring(0, dotIdx);
      const parentRef = resolvePath(parentPath);
      if(!parentRef) return;
      const group = parentRef.arr[parentRef.idx];
      if(!group || group.type !== 'group') return;
      const localIdx = parseInt(path.substring(dotIdx + 1), 10);
      if(isNaN(localIdx) || localIdx < 0 || localIdx >= (group.rules||[]).length) return;
      const [item] = group.rules.splice(localIdx, 1);
      fixJoins(group.rules);
      // Insert after the parent group in grandparent array
      item.join = 'and'; // always join with AND when outdenting
      parentRef.arr.splice(parentRef.idx + 1, 0, item);
      fixJoins(parentRef.arr);
      renderFiltersManager();
    });
  });

  // Join change
  card.querySelectorAll('.ruleJoin').forEach(sel=>{
    sel.addEventListener('change', ()=>{
      const ref = resolvePath(sel.dataset.path);
      if(ref) ref.arr[ref.idx].join = sel.value;
    });
  });

  // Field change
  card.querySelectorAll('.ruleField').forEach(sel=>{
    sel.addEventListener('change', ()=>{
      const ref = resolvePath(sel.dataset.path);
      if(!ref) return;
      const fields = getFilterFieldOptions();
      const fd = fields.find(x=>x.id===sel.value) || fields[0];
      ref.arr[ref.idx].field = sel.value;
      ref.arr[ref.idx].op = getOperators(fd.valueType)[0]?.id || '';
      ref.arr[ref.idx].value = '';
      renderFiltersManager();
    });
  });

  // Op change
  card.querySelectorAll('.ruleOp').forEach(sel=>{
    sel.addEventListener('change', ()=>{
      const ref = resolvePath(sel.dataset.path);
      if(ref) ref.arr[ref.idx].op = sel.value;
      renderFiltersManager();
    });
  });

  // Value change
  card.querySelectorAll('.ruleVal').forEach(el=>{
    const evt = el.tagName === 'SELECT' ? 'change' : 'input';
    el.addEventListener(evt, ()=>{
      const ref = resolvePath(el.dataset.path);
      if(ref) ref.arr[ref.idx].value = el.value;
    });
  });

  // --- Condition DnD reorder / indent ---
  {
    let __condDragPath = null;

    function isDescendant(parentPath, childPath){
      return childPath.startsWith(parentPath + '.');
    }

    function clearCondDragClasses(){
      card.querySelectorAll('.condDragOver-above,.condDragOver-below,.condDragOver-into,.condDragging').forEach(el=>{
        el.classList.remove('condDragOver-above','condDragOver-below','condDragOver-into','condDragging');
      });
    }

    card.querySelectorAll('.condDragHandle').forEach(handle=>{
      handle.addEventListener('dragstart', (e)=>{
        __condDragPath = handle.dataset.path;
        const row = handle.closest('.condRow, .condGroup');
        if(row){
          // Use entire row as drag ghost (captured before opacity change)
          try{
            const rect = row.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            e.dataTransfer.setDragImage(row, x, y);
          }catch(ex){}
          // Delay dim so browser captures ghost at full opacity
          setTimeout(()=> row.classList.add('condDragging'), 0);
        }
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/x-cond-path', __condDragPath);
      });
      handle.addEventListener('dragend', ()=>{
        __condDragPath = null;
        clearCondDragClasses();
      });
    });

    card.querySelectorAll('.condRow, .condGroup').forEach(el=>{
      el.addEventListener('dragover', (e)=>{
        if(!__condDragPath) return;
        const targetPath = el.dataset.path;
        if(!targetPath || targetPath === __condDragPath) return;
        if(isDescendant(__condDragPath, targetPath)) return;
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'move';
        clearCondDragClasses();

        const rect = el.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const isGroup = el.classList.contains('condGroup');

        if(isGroup){
          // Top 25% = above, bottom 25% = below, middle = into
          if(y < rect.height * 0.25) el.classList.add('condDragOver-above');
          else if(y > rect.height * 0.75) el.classList.add('condDragOver-below');
          else el.classList.add('condDragOver-into');
        } else {
          if(y < rect.height * 0.5) el.classList.add('condDragOver-above');
          else el.classList.add('condDragOver-below');
        }
      });

      el.addEventListener('dragleave', (e)=>{
        // Only clear if leaving the element entirely (not entering a child)
        if(!el.contains(e.relatedTarget)){
          el.classList.remove('condDragOver-above','condDragOver-below','condDragOver-into');
        }
      });

      el.addEventListener('drop', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        const targetPath = el.dataset.path;
        if(!__condDragPath || !targetPath || targetPath === __condDragPath) return;
        if(isDescendant(__condDragPath, targetPath)) return;

        // Determine position from CSS classes
        let position = 'after';
        if(el.classList.contains('condDragOver-above')) position = 'before';
        else if(el.classList.contains('condDragOver-into')) position = 'into';

        // Resolve both paths BEFORE any mutation
        const srcRef = resolvePath(__condDragPath);
        const tgtRef = resolvePath(targetPath);
        if(!srcRef || !tgtRef){ clearCondDragClasses(); return; }
        const srcItem = srcRef.arr[srcRef.idx];
        if(!srcItem){ clearCondDragClasses(); return; }

        // Remove from source
        srcRef.arr.splice(srcRef.idx, 1);
        if(srcRef.arr.length > 0 && srcRef.arr[0].join) delete srcRef.arr[0].join;

        // Adjust target index if same array and source was before target
        let adjIdx = tgtRef.idx;
        if(srcRef.arr === tgtRef.arr && srcRef.idx < tgtRef.idx) adjIdx--;

        if(position === 'into'){
          const group = tgtRef.arr[adjIdx];
          if(group && group.type === 'group'){
            if(!group.rules) group.rules = [];
            if(group.rules.length > 0) srcItem.join = srcItem.join || 'and';
            else delete srcItem.join;
            group.rules.push(srcItem);
          }
        } else {
          const insertIdx = position === 'after' ? adjIdx + 1 : adjIdx;
          if(insertIdx > 0) srcItem.join = srcItem.join || 'and';
          else delete srcItem.join;
          tgtRef.arr.splice(insertIdx, 0, srcItem);
          if(tgtRef.arr.length > 0 && tgtRef.arr[0].join) delete tgtRef.arr[0].join;
          if(tgtRef.arr.length > 1 && !tgtRef.arr[1].join) tgtRef.arr[1].join = 'and';
        }
        __condDragPath = null;
        clearCondDragClasses();
        renderFiltersManager();
      });
    });
  }

  // Color swatch DnD copy
  {
    let __swatchDragCls = null;
    card.querySelectorAll('.feStyleItem[draggable]').forEach(item => {
      item.addEventListener('dragstart', (e) => {
        __swatchDragCls = item.dataset.colorCls;
        item.classList.add('feSwatchDragging');
        e.dataTransfer.effectAllowed = 'copy';
        e.dataTransfer.setData('text/plain', '');
      });
      item.addEventListener('dragend', () => {
        item.classList.remove('feSwatchDragging');
        card.querySelectorAll('.feStyleItem').forEach(i => i.classList.remove('feSwatchDragOver'));
        __swatchDragCls = null;
      });
      item.addEventListener('dragover', (e) => {
        if(!__swatchDragCls || __swatchDragCls === item.dataset.colorCls) return;
        e.preventDefault(); e.dataTransfer.dropEffect = 'copy';
        card.querySelectorAll('.feStyleItem').forEach(i => i.classList.remove('feSwatchDragOver'));
        item.classList.add('feSwatchDragOver');
      });
      item.addEventListener('dragleave', () => { item.classList.remove('feSwatchDragOver'); });
      item.addEventListener('drop', (e) => {
        e.preventDefault(); item.classList.remove('feSwatchDragOver');
        if(!__swatchDragCls || __swatchDragCls === item.dataset.colorCls) return;
        const src = card.querySelector('.' + __swatchDragCls);
        const tgt = card.querySelector('.' + item.dataset.colorCls);
        if(src && tgt){ tgt.value = src.value; tgt.dispatchEvent(new Event('input',{bubbles:true})); }
      });
    });
  }

  // Emoji picker toggle
  card.querySelector('.feEmojiPick')?.addEventListener('click', (e)=>{
    e.preventDefault();
    const picker = card.querySelector('.feEmojiPicker');
    if(picker) picker.style.display = picker.style.display === 'none' ? 'flex' : 'none';
  });

  // Emoji picker options
  card.querySelectorAll('.feEmojiOption').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.preventDefault();
      const emoji = btn.dataset.emoji || '';
      const inp = card.querySelector('.feEmoji');
      if(inp) inp.value = emoji;
      const picker = card.querySelector('.feEmojiPicker');
      if(picker) picker.style.display = 'none';
    });
  });

  // Color palette toggle
  card.querySelector('.feColorPalette')?.addEventListener('click', (e)=>{
    e.preventDefault();
    const panel = card.querySelector('.feColorPalettePanel');
    if(panel) panel.style.display = panel.style.display === 'none' ? 'flex' : 'none';
  });

  // Color palette presets  drag onto any feStyleItem to set its color
  card.querySelectorAll('.fePresetSwatch').forEach(swatch=>{
    swatch.addEventListener('dragstart', (e)=>{
      e.dataTransfer.setData('text/plain', swatch.dataset.color);
      e.dataTransfer.effectAllowed = 'copy';
      swatch.style.transform = 'scale(1.15)';
    });
    swatch.addEventListener('dragend', ()=>{
      swatch.style.transform = '';
    });
    // Also allow click to apply to all enabled channels
    swatch.addEventListener('click', ()=>{
      const color = swatch.dataset.color;
      card.querySelectorAll('.feStyleItem').forEach(item=>{
        const cb = item.querySelector('input[type="checkbox"]');
        const inp = item.querySelector('.feColorSwatch');
        if(inp && cb && cb.checked){ inp.value = color; inp.dispatchEvent(new Event('input',{bubbles:true})); }
      });
    });
  });

  // feStyleItems accept drops from preset swatches
  card.querySelectorAll('.feStyleItem').forEach(item=>{
    item.addEventListener('dragover', (e)=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      item.classList.add('feSwatchDragOver');
    });
    item.addEventListener('dragleave', ()=>{
      item.classList.remove('feSwatchDragOver');
    });
    item.addEventListener('drop', (e)=>{
      e.preventDefault();
      item.classList.remove('feSwatchDragOver');
      const color = e.dataTransfer.getData('text/plain');
      if(color && /^#[0-9a-fA-F]{6}$/.test(color)){
        const inp = item.querySelector('.feColorSwatch');
        if(inp){ inp.value = color; inp.dispatchEvent(new Event('input',{bubbles:true})); }
      }
    });
  });

  // Save
  card.querySelector('.feSave')?.addEventListener('click', ()=>{
    const newLabel = card.querySelector('.feLabel').value.trim();
    if(!newLabel){ customAlert('Please enter a label.'); card.querySelector('.feLabel')?.focus(); return; }
    if(__filterIsNew) recordChange(); else pushUndo();
    filter.label = newLabel;
    filter.note = card.querySelector('.feNote').value.trim();
    filter._autoId = card.__filterAutoId ? card.__filterAutoId() : false;
    // Handle ID change
    let newId = sanitizeManualId(card.querySelector('.feId')?.value||'');
    if(!newId) newId = newLabel.toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'') || filter.id;
    if(newId !== filter.id){
      const cat = ensureFilterCatalog();
      const conflict = cat.some(x => x.id === newId && x !== filter);
      if(conflict){
        setGlobalStatus('Filter ID conflict  not changed.');
      } else {
        const oldId = filter.id;
        // Update activeFilterIds reference
        const afi = state.activeFilterIds.indexOf(oldId);
        if(afi >= 0) state.activeFilterIds[afi] = newId;
        filter.id = newId;
      }
    }
    delete filter.conditions; delete filter.logic; // clean legacy
    filter.highlight = {
      bg: card.querySelector('.feBg').value,
      border: card.querySelector('.feBorder').value,
      edgeColor: card.querySelector('.feEdge').value,
      frameColor: card.querySelector('.feFrameColor').value,
      bgEnabled: card.querySelector('.feBgOn').checked,
      borderEnabled: card.querySelector('.feBorderOn').checked,
      edgeEnabled: card.querySelector('.feEdgeOn').checked,
      bold: card.querySelector('.feBold').checked,
      frame: card.querySelector('.feFrame').checked,
      emoji: card.querySelector('.feEmoji').value.trim(),
    };
    __filterEditId = null;
    __filterEditSnapshot = null;
    __filterIsNew = false;
    checkDirtyState();
    renderFiltersManager();
    renderActiveFilterChips();
    refreshViewer();
  });

  // Cancel
  card.querySelector('.feCancel')?.addEventListener('click', ()=>{
    if(__filterIsNew){
      // Remove unsaved new filter
      const i = cat.findIndex(x=>x.id===fid);
      if(i>=0) cat.splice(i,1);
    } else if(__filterEditSnapshot){
      const snap = JSON.parse(__filterEditSnapshot);
      if(snap.rules) filter.rules = snap.rules;
    }
    __filterEditId = null;
    __filterEditSnapshot = null;
    __filterIsNew = false;
    renderFiltersManager();
  });

  // Delete
  card.querySelector('.feDel')?.addEventListener('click', async ()=>{
    if(!__filterIsNew){
      const ok = await customConfirm(`Delete filter "${filter.label||filter.id}"?`);
      if(!ok) return;
      pushUndo();
    }
    const i = cat.findIndex(x=>x.id===fid);
    if(i>=0) cat.splice(i,1);
    state.activeFilterIds = state.activeFilterIds.filter(x=>x!==fid);
    __filterEditId = null;
    __filterEditSnapshot = null;
    __filterIsNew = false;
    checkDirtyState();
    renderFiltersManager();
    renderActiveFilterChips();
    updateFilterBadge();
    refreshViewer();
  });
  wireDirtyHighlight(card, card.querySelector('.feSave'), filterFormIsDirty);

  // Auto-id from label: keep updating as long as user hasn't manually edited the ID
  {
    const labelInp = card.querySelector('.feLabel');
    const idInp = card.querySelector('.feId');
    const idAutoTag = card.querySelector('[data-auto="id"]');
    if(labelInp && idInp){
      const slugify = (s)=> s.trim().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
      const initAuto = slugify(labelInp.value);
      let lastAutoId = (filter && filter._autoId) ? initAuto : '';
      const refreshTag = ()=>{ if(idAutoTag) idAutoTag.style.display = lastAutoId !== '' ? '' : 'none'; };
      refreshTag();
      labelInp.addEventListener('input', ()=>{
        const cur = idInp.value.trim();
        if(!cur || cur === lastAutoId){
          const autoId = slugify(labelInp.value) || '';
          idInp.value = autoId;
          lastAutoId = autoId;
        }
        refreshTag();
      });
      idInp.addEventListener('input', ()=>{
        if(!idInp.value.trim()){
          const autoId = slugify(labelInp.value) || '';
          idInp.value = autoId;
          lastAutoId = autoId;
        } else {
          lastAutoId = '';
        }
        refreshTag();
      });
      // Expose auto state for save handler
      card.__filterAutoId = ()=> lastAutoId !== '';
      if(__filterIsNew) setTimeout(()=> labelInp.focus(), 50);
    }
  }
}

// ---- Toolbar active filter chips ----
function renderActiveFilterChips(){
  const wrap = document.getElementById('filterChips');
  if(!wrap) return;
  const cat = ensureFilterCatalog();
  if(cat.length === 0){
    wrap.innerHTML = '<span style="opacity:.4;font-size:11px;">No saved filters. Open <b>Catalogs  Filters</b> to create.</span>';
    return;
  }
  const sorted = [...cat].sort((a,b)=>{
    const pa = typeof a.priority==='number'?a.priority:9999;
    const pb = typeof b.priority==='number'?b.priority:9999;
    return pa-pb;
  });
  wrap.innerHTML = sorted.map(f=>{
    const hl = f.highlight || {};
    const active = state.activeFilterIds.includes(f.id);
    const swatch = hl.bg || hl.border || '#3b82f6';
    return `<span class="filterChip${active?' active':''}" data-fid="${escapeHtml(f.id)}" style="cursor:pointer;display:inline-flex;align-items:center;gap:4px;padding:2px 8px;border-radius:999px;font-size:11px;font-family:var(--mono);border:1.5px solid ${active?escapeHtml(swatch):'var(--border)'};background:${active?escapeHtml(swatch)+'28':'transparent'};color:var(--text);transition:all .15s;user-select:none;" title="Click to toggle filter: ${escapeHtml(f.label)}">${hl.emoji?escapeHtml(hl.emoji)+' ':''}${escapeHtml(f.label||f.id)}</span>`;
  }).join('');

  wrap.querySelectorAll('.filterChip').forEach(ch=>{
    ch.addEventListener('click', (e)=>{
      e.stopPropagation(); // Prevent group toggle (DOM rebuild detaches e.target)
      const fid = ch.dataset.fid;
      if(state.activeFilterIds.includes(fid)){
        state.activeFilterIds = state.activeFilterIds.filter(x=>x!==fid);
      } else {
        state.activeFilterIds.push(fid);
      }
      renderActiveFilterChips();
      updateFilterBadge();
      refreshViewer();
    });
  });
}

function updateFilterBadge(){
  const badge = document.getElementById('filterBadge');
  const toggleBtn = document.getElementById('tbFilterToggle');
  const count = state.activeFilterIds.length + (state.onlyMapped?1:0) + (state.search?1:0);
  if(badge){
    if(count > 0){ badge.textContent = count; badge.style.display = ''; }
    else { badge.style.display = 'none'; }
  }
  // Keep toggle button highlighted if filters are active even when bar is hidden
  if(toggleBtn){
    const bar = document.getElementById('tbFilterBar');
    const barVisible = bar && bar.style.display !== 'none';
    toggleBtn.classList.toggle('active', barVisible || count > 0);
  }
}

function hasActiveFilters(){
  return state.activeFilterIds.length > 0;
}

// Evaluate all active filters against a node
// Returns: { match: boolean, highlights: [{filterId, highlight}] }
function evaluateActiveFilters(node){
  if(!hasActiveFilters()) return { match: true, highlights: [] };
  const cat = ensureFilterCatalog();
  const highlights = [];
  let anyMatch = false, allMatch = true;
  // Iterate in catalog order (priority)  NOT activation order
  const sorted = [...cat].sort((a,b)=>{
    const pa = typeof a.priority==='number'?a.priority:9999;
    const pb = typeof b.priority==='number'?b.priority:9999;
    return pa-pb;
  });
  for(const f of sorted){
    if(!state.activeFilterIds.includes(f.id)) continue;
    if(evaluateFilter(node, f.id)){
      highlights.push({ filterId: f.id, highlight: f.highlight || {} });
      anyMatch = true;
    } else {
      allMatch = false;
    }
  }
  const match = state.filterLogic === 'and' ? allMatch : anyMatch;
  return { match, highlights };
}

// Get edge color if both endpoints match an active filter with edgeColor
// Dynamic SVG markers for filter edge coloring
const __filterMarkerCache = new Map();
function getOrCreateFilterMarker(color, isStart){
  const key = (isStart?'s:':'e:') + color;
  if(__filterMarkerCache.has(key)) return __filterMarkerCache.get(key);
  const svg = document.getElementById('svgOverlay');
  const defs = svg?.querySelector('defs');
  if(!defs) return '';
  const id = 'filterArrow_' + (isStart?'s_':'e_') + color.replace('#','');
  const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
  marker.setAttribute('id', id);
  marker.setAttribute('markerWidth', '14');
  marker.setAttribute('markerHeight', '14');
  marker.setAttribute('markerUnits', 'userSpaceOnUse');
  marker.setAttribute('orient', isStart ? 'auto-start-reverse' : 'auto');
  marker.setAttribute('refX', '0');
  marker.setAttribute('refY', '7');
  marker.setAttribute('viewBox', '0 0 14 14');
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M0,2.6 L0,11.4 L13,7 z');
  path.setAttribute('fill', color);
  marker.appendChild(path);
  defs.appendChild(marker);
  const url = `url(#${id})`;
  __filterMarkerCache.set(key, url);
  return url;
}

function getFilterEdgeColor(fromId, toId, consolidatedEdges){
  if(!hasActiveFilters()) return '';
  const cat = ensureFilterCatalog();
  const sorted = [...cat].sort((a,b)=>{
    const pa = typeof a.priority==='number'?a.priority:9999;
    const pb = typeof b.priority==='number'?b.priority:9999;
    return pa-pb;
  });
  // Direct check on the visible endpoints
  const fromNode = IDX?.nodeById?.get(fromId);
  const toNode = IDX?.nodeById?.get(toId);
  if(fromNode && toNode){
    for(const f of sorted){
      if(!state.activeFilterIds.includes(f.id)) continue;
      if(!f.highlight?.edgeEnabled || !f.highlight?.edgeColor) continue;
      if(evaluateFilter(fromNode, f.id) && evaluateFilter(toNode, f.id)) return f.highlight.edgeColor;
    }
  }
  // For consolidated arrows (collapsed groups), check if ANY constituent edge matches
  if(consolidatedEdges && consolidatedEdges.length > 0){
    for(const f of sorted){
      if(!state.activeFilterIds.includes(f.id)) continue;
      if(!f.highlight?.edgeEnabled || !f.highlight?.edgeColor) continue;
      for(const ce of consolidatedEdges){
        const fn = IDX?.nodeById?.get(ce.from);
        const tn = IDX?.nodeById?.get(ce.to);
        if(fn && tn && evaluateFilter(fn, f.id) && evaluateFilter(tn, f.id)){
          return f.highlight.edgeColor;
        }
      }
    }
  }
  return '';
}

/* =========================
   Edge color scheme (auto-coloring by property)
========================= */
const SCHEME_PALETTE = [
  ...TAG_COLOR_PRESETS.map(p=>p.value),
  '#ec4899', // Pink
  '#8b5cf6', // Violet
  '#0ea5e9', // Sky
  '#10b981', // Emerald
  '#eab308', // Yellow
  '#ef4444', // Red
  '#6366f1', // Indigo
  '#d946ef', // Fuchsia
  '#78716c', // Stone
  '#2dd4bf', // Teal light
];
let __edgeSchemeMap = new Map(); // value  color

function getEdgeSchemeColor(edge){
  const scheme = state.edgeColorScheme;
  if(!scheme) return '';
  let val = '';
  let customColor = ''; // from tag.color or value.color
  if(scheme === 'cardinality'){
    val = (edge.cardinality||'').trim() || '';
  } else if(scheme === 'transform'){
    const trs = Array.isArray(edge.transforms) ? edge.transforms : [];
    val = trs.length ? transformRefId(trs[0]) : '';
    if(val !== ''){
      const t = ensureTransformCatalog().find(x=>x.id===val);
      if(t && t.color) customColor = t.color;
    }
  } else if(scheme === 'srcTag'){
    const node = IDX?.nodeById?.get(edge.from);
    const tags = sortTagIdsByPriority(normalizeNodeTags(node||{}));
    val = tags.length ? tags[0] : '';
    if(val !== ''){
      const t = tagById(val);
      if(t && t.color) customColor = t.color;
    }
  } else if(scheme === 'tgtTag'){
    const node = IDX?.nodeById?.get(edge.to);
    const tags = sortTagIdsByPriority(normalizeNodeTags(node||{}));
    val = tags.length ? tags[0] : '';
    if(val !== ''){
      const t = tagById(val);
      if(t && t.color) customColor = t.color;
    }
  } else if(scheme.startsWith('srcAttr:')){
    const attrId = scheme.slice(8);
    const node = IDX?.nodeById?.get(edge.from);
    const raw = node?.customAttributes?.[attrId];
    val = Array.isArray(raw) ? raw[0]||'' : (raw||'');
    if(val !== ''){
      const v = customValueById(attrId, val);
      if(v && v.color && v.colorEnabled !== false) customColor = v.color;
    }
  } else if(scheme.startsWith('tgtAttr:')){
    const attrId = scheme.slice(8);
    const node = IDX?.nodeById?.get(edge.to);
    const raw = node?.customAttributes?.[attrId];
    val = Array.isArray(raw) ? raw[0]||'' : (raw||'');
    if(val !== ''){
      const v = customValueById(attrId, val);
      if(v && v.color && v.colorEnabled !== false) customColor = v.color;
    }
  }
  if(!val) return '';
  if(!__edgeSchemeMap.has(val)){
    __edgeSchemeMap.set(val, customColor || SCHEME_PALETTE[__edgeSchemeMap.size % SCHEME_PALETTE.length]);
  }
  return __edgeSchemeMap.get(val);
}

function buildEdgeSchemeLegend(){
  const legend = document.getElementById('edgeColorLegend');
  if(!legend) return;
  if(!state.edgeColorScheme || __edgeSchemeMap.size === 0){
    legend.style.display = 'none';
    legend.innerHTML = '';
    return;
  }
  legend.style.display = 'block';
  const scheme = state.edgeColorScheme;
  let html = '';
  for(const [val, color] of __edgeSchemeMap.entries()){
    let label = val;
    // Resolve IDs to human-readable labels
    if(scheme === 'transform'){
      const t = ensureTransformCatalog().find(x=>x.id===val);
      if(t) label = t.abbr ? `${t.abbr}  ${t.label}` : t.label;
    } else if(scheme === 'srcTag' || scheme === 'tgtTag'){
      const t = tagById(val);
      if(t) label = t.label || val;
    } else if(scheme.startsWith('srcAttr:') || scheme.startsWith('tgtAttr:')){
      const attrId = scheme.split(':')[1];
      const v = customValueById(attrId, val);
      if(v) label = v.label || val;
    }
    html += `<div style="display:flex;align-items:center;gap:6px;margin:2px 0;">
      <span style="width:12px;height:12px;border-radius:3px;background:${escapeHtml(color)};flex-shrink:0;border:1px solid rgba(255,255,255,.15);"></span>
      <span style="opacity:.8;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(label)}</span>
    </div>`;
  }
  legend.innerHTML = html;
}

function rebuildEdgeSchemeOptions(){
  const container = document.getElementById('edgeColorSelector');
  if(!container) return;
  // Remove old dynamic attribute buttons
  container.querySelectorAll('.dockOpt[data-dynamic]').forEach(o=>o.remove());
  container.querySelectorAll('.edgeSchemeAttrSep').forEach(o=>o.remove());
  // Add custom attribute options
  const cat = ensureCustomAttributeCatalog();
  if(cat.length){
    const sep = document.createElement('div');
    sep.className = 'edgeSchemeAttrSep';
    sep.style.cssText = 'width:100%;border-top:1px solid var(--border);margin:2px 0;';
    container.appendChild(sep);
    cat.forEach(a=>{
      const btn = document.createElement('button');
      btn.className = 'dockOpt';
      btn.dataset.scheme = 'srcAttr:'+a.id;
      btn.dataset.dynamic = '1';
      btn.title = 'Source ' + (a.label||a.id);
      btn.innerHTML = `<svg width="16" height="10" viewBox="0 0 16 10"><circle cx="2.5" cy="5" r="2.5" fill="#22c55e"/><line x1="5" y1="5" x2="13" y2="5" stroke="#22c55e" stroke-width="1.5"/><polygon points="12,2 16,5 12,8" fill="#22c55e"/></svg><span>${(a.abbr||a.label||a.id).slice(0,3)}</span>`;
      if(state.edgeColorScheme === 'srcAttr:'+a.id) btn.classList.add('active');
      container.appendChild(btn);
    });
    cat.forEach(a=>{
      const btn = document.createElement('button');
      btn.className = 'dockOpt';
      btn.dataset.scheme = 'tgtAttr:'+a.id;
      btn.dataset.dynamic = '1';
      btn.title = 'Target ' + (a.label||a.id);
      btn.innerHTML = `<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="#06b6d4" stroke-width="1.5"/><polygon points="10,2 14,5 10,8" fill="#06b6d4"/><circle cx="2.5" cy="5" r="2.5" fill="none" stroke="#06b6d4" stroke-width="1"/></svg><span>${(a.abbr||a.label||a.id).slice(0,3)}</span>`;
      if(state.edgeColorScheme === 'tgtAttr:'+a.id) btn.classList.add('active');
      container.appendChild(btn);
    });
  }
  // Sync active state on static buttons
  container.querySelectorAll('.dockOpt:not([data-dynamic])').forEach(b=>{
    b.classList.toggle('active', b.dataset.scheme === state.edgeColorScheme);
  });
}

function refreshEdgeColorScheme(){
  __edgeSchemeMap = new Map();
  if(state.edgeColorScheme && IDX && IDX.edges){
    for(const e of IDX.edges) getEdgeSchemeColor(e);
  }
  buildEdgeSchemeLegend();
}

/* =========================
   Filtering (Search + OnlyMapped + Metadata)
========================= */
function applyVisibility(){
  const term = norm(state.search);
  const useDim = state.filterMode === 'dim' && (hasActiveFilters() || !!term || state.onlyMapped);
  const useHighlightOnly = state.filterMode === 'highlight' && (hasActiveFilters() || !!term || state.onlyMapped);

  // Clear previous filter styles
  if(IDX && IDX.elementById){
    for(const el of IDX.elementById.values()){
      el.classList.remove('filterDimmed');
      el.style.removeProperty('--filter-bg');
      el.style.removeProperty('--filter-border');
      el.style.removeProperty('--filter-frame');
      el.classList.remove('filterHighlight','filterBold','filterFrame');
      // Clean up injected emojis
      el.querySelectorAll('.filterEmoji').forEach(e=>e.remove());
      const label = el.querySelector(':scope > .row .label');
      if(label) delete label.dataset.filterEmoji;
    }
  }

  function nodeSearchMatch(node){
    if(!term) return true;
    const hay = `${node.label ?? ""} ${node.id}`;
    return norm(hay).includes(term);
  }

  function setNodeVisibility(nodeId){
    const node = IDX.nodeById.get(nodeId);
    const el = IDX.elementById.get(nodeId);
    if(!node || !el) return false;

    let visible = false;
    let matches = false; // tracks if node actually matches criteria (for parent groups)

    if(node.type === "field"){
      const mappedOk = !state.onlyMapped || IDX.mappedFields.has(nodeId);
      const searchOk = !term || nodeSearchMatch(node);
      const { match: filterOk, highlights } = evaluateActiveFilters(node);

      matches = mappedOk && searchOk && (hasActiveFilters() ? filterOk : true);

      if(useHighlightOnly){
        visible = true;
        el.classList.toggle("hidden", false);
      } else if(useDim){
        visible = true;
        el.classList.toggle("hidden", false);
        if(!matches) el.classList.add('filterDimmed');
      } else if(hasActiveFilters()){
        visible = mappedOk && searchOk && filterOk;
        el.classList.toggle("hidden", !visible);
      } else {
        visible = mappedOk && searchOk;
        el.classList.toggle("hidden", !visible);
      }

      // Apply highlight styles from matching filters
      if(visible && highlights.length > 0) applyFilterHighlight(el, highlights);
    } else {
      let childVisible = false;
      let anyChildMatch = false;
      let anyChildFilterMatch = false;
      for(const child of (node.children || [])){
        const cv = setNodeVisibility(child.id);
        if(cv.visible) childVisible = true;
        if(cv.matches) anyChildMatch = true;
        if(hasActiveFilters()){
          const cn = IDX.nodeById.get(child.id);
          if(cn && evaluateActiveFilters(cn).match) anyChildFilterMatch = true;
        }
      }
      const groupSearchOk = !term || nodeSearchMatch(node);
      const { match: groupFilterOk, highlights } = evaluateActiveFilters(node);

      matches = (groupSearchOk || anyChildMatch) && (hasActiveFilters() ? (groupFilterOk || anyChildFilterMatch) : true);

      if(useHighlightOnly){
        visible = true;
        el.classList.toggle("hidden", false);
      } else if(useDim){
        visible = true;
        el.classList.toggle("hidden", false);
        if(!matches) el.classList.add('filterDimmed');
      } else if(hasActiveFilters()){
        visible = (groupSearchOk || childVisible) && (groupFilterOk || anyChildFilterMatch);
        el.classList.toggle("hidden", !visible);
      } else {
        visible = groupSearchOk || childVisible;
        el.classList.toggle("hidden", !visible);
      }

      if(visible && highlights.length > 0) applyFilterHighlight(el, highlights);

      if(term && (childVisible || anyChildMatch)){
        toggleCollapse(nodeId, false);
      }
    }

    return { visible, matches };
  }

  for(const col of IDX.columns){
    const kids = (col.schema && Array.isArray(col.schema.children)) ? col.schema.children : [];
    for(const ch of kids){ setNodeVisibility(ch.id); }
  }
}

function applyFilterHighlight(el, highlights){
  if(!highlights || !highlights.length) return;
  el.classList.add('filterHighlight');
  const hl = highlights[0].highlight || {}; // first = highest priority for colors/style
  if(hl.bgEnabled !== false && hl.bg) el.style.setProperty('--filter-bg', hl.bg + '33');
  if(hl.borderEnabled !== false && hl.border) el.style.setProperty('--filter-border', hl.border);
  else el.style.setProperty('--filter-border', 'transparent');
  if(hl.bold) el.classList.add('filterBold');
  if(hl.frame){
    el.classList.add('filterFrame');
    el.style.setProperty('--filter-frame', hl.frameColor || hl.border || hl.bg || '#3b82f6');
  }
  // Collect emojis from ALL matching filters (not just highest priority)
  const allEmojis = highlights.map(h=>(h.highlight||{}).emoji).filter(Boolean);
  if(allEmojis.length){
    const label = el.querySelector(':scope > .row .label');
    if(label && !label.dataset.filterEmoji){
      const combined = [...new Set(allEmojis)].join('');
      label.dataset.filterEmoji = combined;
      label.insertAdjacentHTML('afterbegin', `<span class="filterEmoji">${escapeHtml(combined)} </span>`);
    }
  }
}

/* =========================
   Highlighting
========================= */
function clearHighlightClasses(){
  for(const el of IDX.elementById.values()){
    el.classList.remove("active","connected","connectedParent","dimmed");
  }
}

function dimAll(){
  if(state.selectionDim === 'off') return;
  for(const el of IDX.elementById.values()){
    if(!el.classList.contains("hidden")) el.classList.add("dimmed");
  }
}

function computeHighlightForNode(nodeId){
  // selectedFields: fields under the node (node can be group or field)
  const selectedFields = new Set(IDX.nodeFieldDescendants.get(nodeId) || []);

  // connectedFields: full mapping chain (graph traversal) from selected fields
  const connectedFields = new Set(selectedFields);
  const q = [...selectedFields];
  while(q.length){
    const cur = q.shift();
    const adj = IDX.adjacency.get(cur);
    if(!adj) continue;
    for(const other of adj){
      if(!connectedFields.has(other)){
        connectedFields.add(other);
        q.push(other);
      }
    }
  }
  return { selectedFields, connectedFields };
}

// Directed chain traversal: 'upstream' follows mappings backwards (who maps TO me),
// 'downstream' follows mappings forwards (where do I map TO).
// direction: 'upstream' | 'downstream' | 'both'
function computeDirectedChain(nodeId, direction){
  const seeds = new Set(IDX.nodeFieldDescendants.get(nodeId) || []);
  const result = new Set(seeds);
  const q = [...seeds];

  // Build directed adjacency maps on first call / invalidate with edge count
  if(!computeDirectedChain._cache || computeDirectedChain._edgeCount !== IDX.edges.length){
    const upMap = new Map();   // field -> Set of fields that map TO it (upstream)
    const downMap = new Map(); // field -> Set of fields it maps TO (downstream)
    for(const e of IDX.edges){
      if(!downMap.has(e.from)) downMap.set(e.from, new Set());
      downMap.get(e.from).add(e.to);
      if(!upMap.has(e.to)) upMap.set(e.to, new Set());
      upMap.get(e.to).add(e.from);
    }
    computeDirectedChain._cache = { upMap, downMap };
    computeDirectedChain._edgeCount = IDX.edges.length;
  }
  const { upMap, downMap } = computeDirectedChain._cache;

  while(q.length){
    const cur = q.shift();
    const neighbors = [];
    if(direction === 'upstream' || direction === 'both'){
      const up = upMap.get(cur);
      if(up) for(const n of up) neighbors.push(n);
    }
    if(direction === 'downstream' || direction === 'both'){
      const down = downMap.get(cur);
      if(down) for(const n of down) neighbors.push(n);
    }
    for(const nb of neighbors){
      if(!result.has(nb)){
        result.add(nb);
        q.push(nb);
      }
    }
  }
  return result;
}


function updateColumnHeaderSelectionStyles(){
  const panels = Array.from(columnsRow.querySelectorAll('.panel'));
  for(const p of panels){
    const colId = p.dataset.columnId;
    const header = p.querySelector('.panelHeader');
    if(!header) continue;
    header.classList.toggle('selected', state.lockedId===colId);
  }
}
function applyHighlight(){
  const edgeFocusId = state.selectedEdgeId || state.hoverEdgeId;
  const hasMulti = state.multiSelection.size > 0;
  const nodeId = edgeFocusId ? null : (hasMulti ? null : currentEffectiveId());
  if(edgeFocusId){ state.lockedId = null; state.hoverId = null; state.multiSelection.clear(); }
  clearHighlightClasses();
 updateColumnHeaderSelectionStyles();
  if(!nodeId && !edgeFocusId && !hasMulti){
    setViewerStatus("Hover a node to preview mappings. Click to lock selection.");
    detailsMeta.textContent = "Project";
    const d = state.data || {};
    const sub = (d.subtitle||'').trim();
    const desc = (d.description||'').trim();
    const author = (d.author||'').trim();
    const org = (d.organization||'').trim();
    const contact = (d.contact||'').trim();
    const url = (d.url||'').trim();
    const ver = (d.projectVersion||'').trim();
    const dt = (d.date||'').trim();
    const hasInfo = sub || desc || author || org || contact || url || ver || dt;
    const infoRows = [
      sub ? `<div class="k">Subtitle</div><div class="v">${escapeHtml(sub)}</div>` : '',
      author ? `<div class="k">Author</div><div class="v">${escapeHtml(author)}</div>` : '',
      org ? `<div class="k">Organization</div><div class="v">${escapeHtml(org)}</div>` : '',
      contact ? `<div class="k">Contact</div><div class="v">${escapeHtml(contact)}</div>` : '',
      url ? `<div class="k">URL</div><div class="v"><a href="${escapeHtml(url)}" target="_blank" rel="noopener" style="color:var(--accent);word-break:break-all;">${escapeHtml(url)}</a></div>` : '',
      ver ? `<div class="k">Version</div><div class="v">${escapeHtml(ver)}</div>` : '',
      dt ? `<div class="k">Date</div><div class="v">${escapeHtml(dt)}</div>` : '',
    ].filter(Boolean).join('\n');
    detailsBody.innerHTML = `<div style="padding:2px 0;">
      ${infoRows ? `<div class="kv" style="grid-template-columns:90px 1fr;margin-bottom:6px;">${infoRows}</div>` : ''}
      ${desc ? `<div style="white-space:pre-wrap;font-size:12px;line-height:1.6;color:var(--text);opacity:.85;margin:6px 0 10px;">${escapeHtml(desc)}</div>` : ''}
      <div class="empty" style="margin-top:6px;">${hasInfo ? 'Select' : 'Hover'} a node, column, or mapping to see its details here.${state.editorMode ? ' Click  to edit project properties.' : ''}</div>
    </div>`;
    scheduleArrowsUpdate();
    return;
  }

  let selectedFields, connectedFields;
  if(edgeFocusId){
    let e = IDX.edges.find(x=>x.id===edgeFocusId);
    
    // If not found in real edges, check virtual edges
    if(!e && edgeFocusId.startsWith('virtual:')){
      const virtualEdges = findChainsThoughHiddenColumns();
      e = virtualEdges.find(x=>x.id===edgeFocusId);
    }
    
    if(e){
      // Check if this is a consolidated arrow (from SVG path metadata or cache)
      const pathEl = Array.from(edgesLayer.querySelectorAll('path.edge')).find(p => p.dataset.edgeId === edgeFocusId);
      const cache = (state._consolidatedEdgeCache && state._consolidatedEdgeCache.edgeId === edgeFocusId) ? state._consolidatedEdgeCache : null;
      const consolidated = pathEl?.__consolidated || cache?.consolidated;
      
      // Only use consolidated highlighting if the fields are still collapsed
      // If they've been expanded, just highlight the single selected edge
      const fromVisible = isVisibleNodeId(e.from);
      const toVisible = isVisibleNodeId(e.to);
      const fieldsAreExpanded = fromVisible && toVisible;
      
      // If consolidated AND fields are still collapsed, compute highlights for ALL edges
      if(consolidated && consolidated.length > 1 && !fieldsAreExpanded){
        const allConnected = new Set();
        const allSelected = new Set();
        
        for(const edge of consolidated){
          const a = computeHighlightForNode(edge.from);
          const b = computeHighlightForNode(edge.to);
          allSelected.add(edge.from);
          allSelected.add(edge.to);
          for(const f of a.connectedFields) allConnected.add(f);
          for(const f of b.connectedFields) allConnected.add(f);
        }
        
        selectedFields = allSelected;
        connectedFields = allConnected;
      } else {
        // Single edge or fields are expanded - compute highlights for just this edge
        const a = computeHighlightForNode(e.from);
        const b = computeHighlightForNode(e.to);
        selectedFields = new Set([e.from, e.to]);
        connectedFields = new Set([...a.connectedFields, ...b.connectedFields]);
      }
    } else { selectedFields = new Set(); connectedFields = new Set(); }
  } else if(hasMulti){
    // Multi-select: combine highlights for all selected nodes
    selectedFields = new Set();
    connectedFields = new Set();
    for(const nid of state.multiSelection){
      const tmp = computeHighlightForNode(nid);
      if(state.multiSelectArrowMode === 'direct'){
        // Direct-only: selected fields highlighted, but no chain following
        for(const f of tmp.selectedFields) selectedFields.add(f);
        for(const f of tmp.selectedFields) connectedFields.add(f);
        // Add only immediate neighbors (not full chain)
        for(const f of tmp.selectedFields){
          const adj = IDX.adjacency.get(f);
          if(adj) for(const other of adj) connectedFields.add(other);
        }
      } else {
        // Chain mode (default): full chain for all selected nodes
        for(const f of tmp.selectedFields) selectedFields.add(f);
        for(const f of tmp.connectedFields) connectedFields.add(f);
      }
    }
  } else {
    const tmp = computeHighlightForNode(nodeId);
    if(state.multiSelectArrowMode === 'direct'){
      selectedFields = tmp.selectedFields;
      connectedFields = new Set(tmp.selectedFields);
      for(const f of tmp.selectedFields){
        const adj = IDX.adjacency.get(f);
        if(adj) for(const other of adj) connectedFields.add(other);
      }
    } else {
      selectedFields = tmp.selectedFields; connectedFields = tmp.connectedFields;
    }
  }
  dimAll();

  // Determine which fields to visually highlight
  const fieldsToHighlight = (state.multiSelectArrowMode === 'selected') ? selectedFields : connectedFields;

  // Standard highlight: connected (or selected-only) fields
  for(const fid of fieldsToHighlight){
    const el = IDX.elementById.get(fid);
    if(el && !el.classList.contains('hidden')){
      el.classList.add('connected');
      el.classList.remove('dimmed');
    }
  }

  // Un-dim directly selected group nodes and their descendant groups
  // (groups aren't in fieldsToHighlight since it only has leaf fields)
  const directlySelected = new Set(state.multiSelection);
  if(nodeId) directlySelected.add(nodeId);
  for(const nid of directlySelected){
    const el = IDX.elementById.get(nid);
    if(el && el.classList.contains('group') && !el.classList.contains('hidden')){
      el.classList.add('connected');
      el.classList.remove('dimmed');
    }
  }
  // Also un-dim intermediate subgroups that are descendants of a selected group
  if(directlySelected.size > 0){
    for(const [id, el] of IDX.elementById.entries()){
      if(directlySelected.has(id)) continue;
      if(!el.classList.contains('group') || el.classList.contains('hidden')) continue;
      // Walk up parent chain to see if this group is inside a selected group
      let pid = IDX.parentById.get(id);
      while(pid){
        if(directlySelected.has(pid)){
          el.classList.add('connected');
          el.classList.add('connectedParent');
          el.classList.remove('dimmed');
          break;
        }
        pid = IDX.parentById.get(pid);
      }
    }
  }

  // Highlight ancestor groups that contain highlighted fields
  for(const [id, el] of IDX.elementById.entries()){
    if(el.classList.contains('hidden')) continue;
    if(fieldsToHighlight.has(id)) continue; // already highlighted directly
    const fields = IDX.nodeFieldDescendants.get(id) || [];
    let hasConn = false;
    for(const f of fields){
      if(fieldsToHighlight.has(f)) { hasConn = true; break; }
    }
    if(hasConn){
      const isGroup = el.classList.contains('group');
      const isCollapsed = isGroup && el.classList.contains('collapsed');
      if(isCollapsed){
        // Collapsed groups stand in for their children  always highlight + un-dim
        el.classList.add('connected');
        el.classList.remove('dimmed');
      } else if(state.selectionDim === 'keepParents'){
        // Parents dim mode: expanded groups get subtle highlight + un-dimmed
        el.classList.add('connected');
        el.classList.add('connectedParent');
        el.classList.remove('dimmed');
      }
      // selectionDim 'all': expanded parents stay dimmed
    }
  }

  // When focusing an edge, mark both endpoints ACTIVE (yellow)
  if(edgeFocusId){
    let ee = IDX.edges.find(x=>x.id===edgeFocusId);
    
    // If not found in real edges, check virtual edges
    if(!ee && edgeFocusId.startsWith('virtual:')){
      const virtualEdges = findChainsThoughHiddenColumns();
      ee = virtualEdges.find(x=>x.id===edgeFocusId);
    }
    
    if(ee){
      // Check if we should use redirected IDs (collapsed groups) or actual field IDs
      const pathEl = Array.from(edgesLayer.querySelectorAll('path.edge')).find(p => p.dataset.edgeId === edgeFocusId);
      const ehCache = (state._consolidatedEdgeCache && state._consolidatedEdgeCache.edgeId === edgeFocusId) ? state._consolidatedEdgeCache : null;
      let fromIdToHighlight = ee.from;
      let toIdToHighlight = ee.to;
      
      // Only use redirected IDs if the fields are actually not visible (still in collapsed groups)
      // If they've been expanded, use the actual field IDs
      const cachedFromId = pathEl?.__fromId || ehCache?.fromId;
      const cachedToId = pathEl?.__toId || ehCache?.toId;
      if(cachedFromId && cachedToId){
        // Check if the actual fields are visible now
        const fromVisible = isVisibleNodeId(ee.from);
        const toVisible = isVisibleNodeId(ee.to);
        
        // Only use redirected IDs if the original fields are not visible
        if(!fromVisible) fromIdToHighlight = cachedFromId;
        if(!toVisible) toIdToHighlight = cachedToId;
      }
      
      [fromIdToHighlight, toIdToHighlight].forEach((fid, i)=>{
        const el2 = IDX.elementById.get(fid);
        if(el2 && !el2.classList.contains('hidden')){
          // If this endpoint was redirected to a collapsed group, use 'connected' not 'active'
          const isRedirected = (i === 0 && fid !== ee.from) || (i === 1 && fid !== ee.to);
          if(isRedirected){
            el2.classList.add('connected');
          } else {
            el2.classList.add('active');
            el2.classList.remove('connected');
          }
          el2.classList.remove('dimmed');
        }
      });
    }
  }
// Special highlight: ONLY the directly selected node(s) (skip when an edge is focused)
if(!edgeFocusId){
  if(hasMulti){
    for(const nid of state.multiSelection){
      const nEl = IDX.elementById.get(nid);
      if(nEl && !nEl.classList.contains('hidden')){
        nEl.classList.add('active');
        nEl.classList.remove('connected');
        nEl.classList.remove('dimmed');
      }
    }
  } else {
    const nEl = IDX.elementById.get(nodeId);
    if(nEl && !nEl.classList.contains('hidden')){
      nEl.classList.add('active');
      nEl.classList.remove('connected');
      nEl.classList.remove('dimmed');
    }
  }
}
  if(hasMulti){
    setViewerStatus(`Multi-selection: ${state.multiSelection.size} nodes  selected fields: ${selectedFields.size}  connected: ${connectedFields.size}`);
    updateDetailsMulti(state.multiSelection, selectedFields);
  } else {
    const mode = state.hoverId ? "Hover" : "Selection";
    const lock = state.lockedId ? "LOCKED" : "preview";
    setViewerStatus(`${mode} (${lock}): ${nodeId}  selected fields: ${selectedFields.size}  connected fields: ${connectedFields.size}`);
    updateDetails(nodeId, selectedFields);
  }
  scheduleArrowsUpdate();
}

/* =========================
   Details panel (grouped + effective vs alternatives)
========================= */
function edgeTooltip(edge){
  const tlist = (edge.transforms && edge.transforms.length) ? edge.transforms.map(formatTransformRef).join('  ') : '';
  return [
    `${edge.from}  ${edge.to}`,
    edge.cardinality ? `Cardinality: ${edge.cardinality}` : "",
    tlist ? `Transform: ${tlist}` : "",
    (edge.default !== "" && edge.default !== undefined) ? `Default: ${edge.default}` : "",
    edge.note ? `Note: ${edge.note}` : "",
  ].filter(Boolean).join("\n");
}



function badgeHtml(edge){
  const parts = [];
  if(edge.cardinality) parts.push(`<span class="tag" title="Cardinality">${escapeHtml(edge.cardinality)}</span>`);
  const tarr = (edge.transforms && edge.transforms.length) ? edge.transforms : [];
  if(tarr.length){
    parts.push(`<span class="tag" title="Transforms">${escapeHtml(short(tarr.map(formatTransformRef).join('  '), 34))}</span>`);
  }
  if(edge.default !== "" && edge.default !== undefined) parts.push(`<span class="tag" title="Default">${escapeHtml(short(edge.default, 16))}</span>`);
return parts.join('\n');
}





// Render readonly tag chips for a node (Details pane)

function miniNodeCard(nodeId){
  const node = IDX.nodeById.get(nodeId);
  if(!node) return '';
  const isField = node.type === 'field';
  const colId = columnOf(nodeId) || '';
  const colIdx = IDX.columnIndex.get(colId);
  const colObj = (colIdx !== undefined) ? IDX.columns[colIdx] : null;
  const colLabel = colObj ? (colObj.label || colObj.id) : colId;
  
  // Mapping summary
  const selectedFields = isField ? [nodeId] : (IDX.nodeFieldDescendants.get(nodeId) || []);
  const fieldSet = new Set(selectedFields);
  let inCount = 0, outCount = 0;
  const candidates = isField ? (IDX.edgesByField.get(nodeId) || []) : IDX.edges;
  const seen = new Set();
  for(const e of candidates){
    if(!e || seen.has(e.id)) continue;
    if(!isField && !(fieldSet.has(e.from) || fieldSet.has(e.to))) continue;
    seen.add(e.id);
    if(fieldSet.has(e.from) && !fieldSet.has(e.to)) outCount++;
    if(fieldSet.has(e.to) && !fieldSet.has(e.from)) inCount++;
  }
  
  const label = node.label || nodeId;
  const note = (node.note || '').trim();
  const childCount = (!isField && node.children) ? node.children.length : 0;
  
  // Tags
  const tagIds = sortTagIdsByPriority(normalizeNodeTags(node));
  const chips = tagIds.length ? tagIds.slice(0, 5).map(tid => {
    const td = tagById(tid) || { id:tid, label:tid, abbr:tid.slice(0,1).toUpperCase(), color:'#3b82f6' };
    return `<span class="tagChip" data-color="1" style="--c:${tagColor(td)};">${escapeHtml(tagAbbr(td)||td.id)}</span>`;
  }).join(' ') : '';
  
  // Custom attributes
  let attrsHtml = '';
  if(node.customAttributes){
    const keys = Object.keys(node.customAttributes || {});
    if(keys.length){
      attrsHtml = keys.sort().map(aid => {
        const raw = node.customAttributes[aid];
        const a = customAttrById(aid) || { id:aid, label:aid };
        const vals = Array.isArray(raw) ? raw : [raw];
        const valueTags = vals.map(vid => {
          const v = customValueById(aid, vid) || { id:vid, label:vid };
          return `<span class="dtAttrVal">${escapeHtml(v.label||v.id)}</span>`;
        }).join('');
        return `<div class="dtAttrGroup"><span class="dtAttrLabel">${escapeHtml(a.label||a.id)}</span>${valueTags}</div>`;
      }).join('');
    }
  }
  
  const typeLabel = isField ? 'field' : 'group';
  return `
    <div class="box clickable" data-jump-id="${escapeHtml(nodeId)}" style="margin-bottom:8px;cursor:pointer;">
      <div class="dtHero" style="padding-bottom:6px;">
        <div class="dtName" style="font-size:14px;">${escapeHtml(label)}</div>
        <span class="dtType${isField?'':' group'}" style="font-size:8px;padding:2px 6px;">${escapeHtml(typeLabel)}</span>
      </div>
      <div class="dtRow" style="padding:3px 2px;">
        <span class="dtRowK" style="min-width:28px;">ID</span>
        <span class="dtRowV"><span class="dtId">${escapeHtml(nodeId)}${isLikelyAutoId(node) ? '<span class="autoTag" style="font-size:7px;padding:0 3px;">auto</span>' : ''}</span></span>
      </div>
      <div class="dtStatRow" style="padding:3px 0;">
        <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${inCount}</span><span class="dtStatL">in</span></span>
        <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${outCount}</span><span class="dtStatL">out</span></span>
        ${childCount ? `<span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${childCount}</span><span class="dtStatL">ch</span></span>` : ''}
      </div>
      ${note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(note)}</div>` : ''}
      ${tagIds.length ? `<div class="dtChipWrap" style="padding:2px 0;">${chips}</div>` : ''}
      ${attrsHtml ? `<div style="padding:1px 0;">${attrsHtml}</div>` : ''}
    </div>`;
}

function tagsHtmlForDetails(node){
  if(!node) return '';
  const tags = sortTagIdsByPriority(normalizeNodeTags(node));
  if(!tags.length) return '';
  const chips = tags.map(tid => {
    const td = tagById(tid) || { id: tid, label: tid, abbr: (tid||'').slice(0,1).toUpperCase(), color: DEFAULT_TAG_COLOR };
    const title = (td.label || td.id || '') + (td.note ? ('  ' + td.note) : '');
    const abbr  = tagAbbr(td);
    const color = tagColor(td);
    return `<span class="tagChip" title="${escapeHtml(title)}" data-color="1" style="--c:${escapeHtml(color)}">${escapeHtml(abbr)}</span>`;
  }).join('');
  return `<div class="tagStrip" style="flex-wrap:wrap;">${chips}</div>`;
}


function updateDetailsMulti(selectedIds, selectedFieldsSet){
  const nodes = [];
  const byCol = new Map();
  let fields = 0, groups = 0;
  for(const nid of selectedIds){
    const n = IDX.nodeById.get(nid);
    if(!n) continue;
    nodes.push(n);
    if(n.type === 'field') fields++; else groups++;
    const col = columnOf(nid);
    if(!byCol.has(col)) byCol.set(col, []);
    byCol.get(col).push(n);
  }

  // Count edges involving selected fields
  const allFields = new Set();
  for(const nid of selectedIds){
    const descendants = IDX.nodeFieldDescendants.get(nid) || [];
    for(const f of descendants) allFields.add(f);
  }
  let inCount = 0, outCount = 0, internalCount = 0;
  const seenEdges = new Set();
  for(const e of IDX.edges){
    if(seenEdges.has(e.id)) continue;
    const fromIn = allFields.has(e.from);
    const toIn = allFields.has(e.to);
    if(!fromIn && !toIn) continue;
    seenEdges.add(e.id);
    if(fromIn && toIn) internalCount++;
    else if(fromIn) outCount++;
    else inCount++;
  }

  detailsMeta.textContent = `${selectedIds.size} selected`;

  // Build node list
  let nodeList = '';
  const showNodes = nodes;
  for(const n of showNodes){
    const colId = columnOf(n.id||'');
    const colIdx = IDX.columnIndex.get(colId);
    const colObj = colIdx !== undefined ? IDX.columns[colIdx] : null;
    const colLabel = colObj ? (colObj.label || colObj.id) : '';
    const icon = n.type === 'field' ? '' : '';
    nodeList += `<div class="miniCard" style="cursor:pointer;padding:4px 6px;border-radius:4px;margin:1px 0;font-size:11.5px;display:flex;align-items:center;gap:6px;" data-jump-id="${escapeHtml(n.id||'')}">
      <span style="opacity:.4;font-size:10px;">${icon}</span>
      <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(n.label || n.id || '?')}</span>
      <span style="opacity:.35;font-size:10px;">${escapeHtml(colLabel)}</span>
    </div>`;
  }

  // Collect edges involving selected fields for the edge section
  const internalEdges = [], inboundEdges = [], outboundEdges = [];
  for(const e of IDX.edges){
    const fromIn = allFields.has(e.from);
    const toIn = allFields.has(e.to);
    if(!fromIn && !toIn) continue;
    if(fromIn && toIn) internalEdges.push(e);
    else if(fromIn) outboundEdges.push(e);
    else inboundEdges.push(e);
  }
  const allRelatedEdges = [...internalEdges, ...outboundEdges, ...inboundEdges];

  // === ACTIONS SECTION (top) ===
  let actionsHtml = '';
  if(state.editorMode){
    let mappingActionsHtml = '';
    if(allRelatedEdges.length > 0){
      const hasTransforms = allRelatedEdges.some(e=>(e.transforms||[]).length > 0);
      mappingActionsHtml = `
      <div class="msCard danger">
        <div class="msCardHead">
          <span>Mapping actions</span><span class="msCount">${allRelatedEdges.length}</span>
        </div>
        <div id="bulkDeleteWrap">
          <button class="msActBtn danger" id="bulkDeleteEdgesBtn"><span class="msIco"></span>Delete mappings<span class="msArrow"></span></button>
        </div>
        <button class="msActBtn" id="bulkAddTransform"><span class="msIco"></span>Transforms</button>
        ${hasTransforms ? `<div id="bulkClearTWrap">
          <button class="msActBtn danger" id="bulkClearTransformsBtn"><span class="msIco"></span>Clear transforms<span class="msArrow"></span></button>
        </div>` : ''}
      </div>`;
    }

    actionsHtml = `<div class="msBulk">
      <div class="msCard">
        <div class="msCardHead">
          <span>Node actions</span><span class="msCount">${selectedIds.size}</span>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;">
          <button class="msActBtn danger" id="bulkDeleteBtn"><span class="msIco"></span>Delete</button>
          <button class="msActBtn" id="bulkMapBtn"><span class="msIco"></span>Map to</button>
          <button class="msActBtn" id="bulkTagBtn"><span class="msIco"></span>Set tags</button>
          <button class="msActBtn" id="bulkAttrBtn"><span class="msIco"></span>Set attribute</button>
        </div>
      </div>
      ${mappingActionsHtml}
    </div>`;
  }

  // Count transforms per edge type
  const countTransforms = (edges) => edges.reduce((n, e) => n + (normalizeTransforms(e.transforms)||[]).length, 0);
  const inTransformCount = countTransforms(inboundEdges);
  const outTransformCount = countTransforms(outboundEdges);
  const intTransformCount = countTransforms(internalEdges);
  const fmtT = (count) => count > 0 ? `${count} transform${count===1?'':'s'}` : '';

  // === STATISTICS ===
  const totalMappings = inCount + outCount + internalCount;
  const totalTransforms = inTransformCount + outTransformCount + intTransformCount;
  let edgeStatCards = '';
  if(inCount) edgeStatCards += `<div class="msStat"><div class="msStatLabel">Inbound</div><div class="msStatVal">${inCount}</div>${inTransformCount ? `<div class="msStatSub">${fmtT(inTransformCount)}</div>` : ''}</div>`;
  if(outCount) edgeStatCards += `<div class="msStat"><div class="msStatLabel">Outbound</div><div class="msStatVal">${outCount}</div>${outTransformCount ? `<div class="msStatSub">${fmtT(outTransformCount)}</div>` : ''}</div>`;
  if(internalCount) edgeStatCards += `<div class="msStat"><div class="msStatLabel">Internal</div><div class="msStatVal">${internalCount}</div>${intTransformCount ? `<div class="msStatSub">${fmtT(intTransformCount)}</div>` : ''}</div>`;

  const statsHtml = `
    <div class="msStatGrid">
      <div class="msStat"><div class="msStatLabel">Fields</div><div class="msStatVal">${fields}</div></div>
      <div class="msStat"><div class="msStatLabel">Groups</div><div class="msStatVal">${groups}</div></div>
      ${edgeStatCards}
    </div>`;

  // === COLUMN BREAKDOWN ===
  let colChips = '';
  for(const [colId, colNodes] of byCol.entries()){
    const colIdx = IDX.columnIndex.get(colId);
    const colObj = colIdx !== undefined ? IDX.columns[colIdx] : null;
    const colLabel = colObj ? (colObj.label || colObj.id) : (colId || '?');
    const colColor = colObj?.color || '#6b7280';
    colChips += `<span class="msColChip">
      <span class="msColDot" style="background:${escapeHtml(colColor)};color:${escapeHtml(colColor)};"></span>
      <span style="opacity:.6;">${escapeHtml(colLabel)}</span>
      <span class="msColCount">${colNodes.length}</span>
    </span>`;
  }
  const colHtml = `<div style="display:flex;flex-wrap:wrap;gap:5px;margin-top:8px;">${colChips}</div>`;

  // === NODE LIST ===
  const _nodesCollapsed = state._multiCollapsed.nodes;
  const nodeListHtml = `<div style="border-top:1px solid var(--border);padding-top:6px;margin-top:8px;">
    <div data-collapse-toggle="nodes" style="font-size:10px;opacity:.5;margin-bottom:4px;cursor:pointer;user-select:none;display:flex;align-items:center;gap:4px;">
      <span style="font-size:8px;display:inline-block;transition:transform .15s;${_nodesCollapsed?'transform:rotate(-90deg);':''}">\u25BE</span>
      Selected nodes (${nodes.length})
    </div>
    <div data-collapse-body="nodes" style="${_nodesCollapsed?'display:none;':''}">${nodeList}</div>
  </div>`;

  // === EDGE LIST ===
  let edgeListSection = '';
  if(allRelatedEdges.length > 0){
    const _mapCollapsed = state._multiCollapsed.mappings;
    const secDefs = [
      { label: 'Internal', key: 'mapInternal', edges: internalEdges, color: 'rgba(168,85,247,.5)' },
      { label: 'Outbound', key: 'mapOutbound', edges: outboundEdges, color: 'rgba(59,130,246,.5)' },
      { label: 'Inbound', key: 'mapInbound', edges: inboundEdges, color: 'rgba(34,197,94,.5)' }
    ];
    let edgeListHtml = '';
    for(const sec of secDefs){
      if(!sec.edges.length) continue;
      const subCollapsed = state._multiCollapsed[sec.key];
      edgeListHtml += `<div>
        <div data-collapse-toggle="${sec.key}" style="font-size:9px;text-transform:uppercase;letter-spacing:.5px;opacity:.35;margin:6px 0 2px;padding-left:2px;cursor:pointer;user-select:none;display:flex;align-items:center;gap:4px;">
          <span style="font-size:7px;display:inline-block;transition:transform .15s;${subCollapsed?'transform:rotate(-90deg);':''}">\u25BE</span>
          ${sec.label} (${sec.edges.length})
        </div>
        <div data-collapse-body="${sec.key}" style="${subCollapsed?'display:none;':''}">`;
      for(const edge of sec.edges){
        const fromNode = IDX.nodeById.get(edge.from);
        const toNode = IDX.nodeById.get(edge.to);
        const fromLabel = fromNode ? (fromNode.label || edge.from) : edge.from;
        const toLabel = toNode ? (toNode.label || edge.to) : edge.to;
        const transformCount = (edge.transforms||[]).length;
        const transformBadge = transformCount > 0 ? `<span style="font-size:9px;opacity:.4;padding:1px 4px;border:1px solid var(--border);border-radius:4px;">${transformCount}T</span>` : '';
        edgeListHtml += `<div class="miniCard" style="cursor:pointer;padding:4px 6px;border-radius:4px;margin:1px 0;font-size:11px;display:flex;align-items:center;gap:5px;" data-edge-select="${escapeHtml(edge.id)}">
          <span style="width:4px;height:4px;border-radius:50%;background:${sec.color};flex-shrink:0;"></span>
          <span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:40%;">${escapeHtml(fromLabel)}</span>
          <span style="opacity:.3;font-size:9px;"></span>
          <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(toLabel)}</span>
          ${transformBadge}
        </div>`;
      }
      edgeListHtml += `</div></div>`;
    }
    edgeListSection = `<div style="border-top:1px solid var(--border);padding-top:6px;margin-top:8px;">
      <div data-collapse-toggle="mappings" style="font-size:10px;opacity:.5;margin-bottom:2px;cursor:pointer;user-select:none;display:flex;align-items:center;gap:4px;">
        <span style="font-size:8px;display:inline-block;transition:transform .15s;${_mapCollapsed?'transform:rotate(-90deg);':''}">\u25BE</span>
        Mappings (${allRelatedEdges.length})
      </div>
      <div data-collapse-body="mappings" style="${_mapCollapsed?'display:none;':''}">${edgeListHtml}</div>
    </div>`;
  }

  detailsBody.innerHTML = `<div style="padding:2px 0;">
    ${actionsHtml}
    ${statsHtml}
    ${colHtml}
    ${nodeListHtml}
    ${edgeListSection}
  </div>`;

  // Collapsible section toggles
  detailsBody.querySelectorAll('[data-collapse-toggle]').forEach(hdr=>{
    hdr.addEventListener('click', ()=>{
      const key = hdr.dataset.collapseToggle;
      const body = detailsBody.querySelector(`[data-collapse-body="${key}"]`);
      if(!body) return;
      const collapsed = body.style.display === 'none';
      body.style.display = collapsed ? '' : 'none';
      const caret = hdr.querySelector('span');
      if(caret) caret.style.transform = collapsed ? '' : 'rotate(-90deg)';
      state._multiCollapsed[key] = !collapsed;
    });
  });

  // Click to jump to a node
  detailsBody.querySelectorAll('[data-jump-id]').forEach(el=>{
    el.addEventListener('click', ()=>{
      const id = el.dataset.jumpId;
      if(id){ lockSelection(id); scrollIntoView(id); }
    });
  });

  // Click an edge row to select it
  detailsBody.querySelectorAll('[data-edge-select]').forEach(el=>{
    el.addEventListener('click', ()=>{
      const eid = el.dataset.edgeSelect;
      if(eid) selectEdge(eid);
    });
  });

  // Wire up bulk actions
  if(state.editorMode){
    const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
    if(bulkDeleteBtn) bulkDeleteBtn.addEventListener('click', async ()=>{
      // Count children inside selected groups
      let childFieldCount = 0, childGroupCount = 0;
      for(const nid of selectedIds){
        const node = IDX.nodeById.get(nid);
        if(!node || node.type !== 'group') continue;
        (function walk(n){ if(!n) return; (n.children||[]).forEach(c=>{
          if(c.type==='field') childFieldCount++;
          else if(c.type==='group') childGroupCount++;
          walk(c);
        }); })(node);
      }
      const childParts = [];
      if(childFieldCount) childParts.push(childFieldCount + ' child field' + (childFieldCount>1?'s':''));
      if(childGroupCount) childParts.push(childGroupCount + ' child group' + (childGroupCount>1?'s':''));
      const childInfo = childParts.length ? `\nThis includes ${childParts.join(' and ')} inside selected groups.` : '';
      // Count affected mappings
      const allFieldIds = new Set();
      for(const nid of selectedIds){
        const node = IDX.nodeById.get(nid);
        if(node) for(const f of collectFieldIdsFromNode(node)) allFieldIds.add(f);
      }
      const mapCount = (state.data.mappings||[]).filter(m => m && (allFieldIds.has(m.from) || allFieldIds.has(m.to))).length;
      const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
      const ok = await customConfirm(`Delete ${selectedIds.size} selected node${selectedIds.size>1?'s':''}?${childInfo}${mapInfo}\n\nThis action can be undone with Ctrl+Z.`);
      if(!ok) return;
      pushUndo();
      const idsToDelete = [...selectedIds];
      removeMappingsReferencingInState(allFieldIds);
      // Remove nodes from column schemas
      for(const nid of idsToDelete){
        const col = columnOf(nid);
        if(!col) continue;
        const colData = findColumnById(col);
        if(!colData || !colData.schema) continue;
        const loc = locateNode(colData.schema, nid);
        if(loc && loc.siblings && loc.idx !== null){
          loc.siblings.splice(loc.idx, 1);
        }
      }
      state.multiSelection.clear();
      state.lockedId = null;
      state.hoverId = null;
      markDirty();
      renderAll();
      setGlobalStatus(`Deleted ${idsToDelete.length} nodes.`);
    });

    const bulkTagBtn = document.getElementById('bulkTagBtn');
    if(bulkTagBtn) bulkTagBtn.addEventListener('click', ()=>{ showBulkTagModal([...selectedIds]); });

    const bulkAttrBtn = document.getElementById('bulkAttrBtn');
    if(bulkAttrBtn) bulkAttrBtn.addEventListener('click', ()=>{ showBulkAttrModal([...selectedIds]); });

    const bulkMapBtn = document.getElementById('bulkMapBtn');
    if(bulkMapBtn) bulkMapBtn.addEventListener('click', ()=>{ showBulkMapModal([...selectedIds]); });

    // --- Scope dropdown helper (inline expansion) ---
    function toggleScopeMenu(wrapId, btnEl, options, onPick){
      const wrap = document.getElementById(wrapId);
      if(!wrap) return;
      const existing = wrap.querySelector('.scopeMenu');
      if(existing){ existing.remove(); btnEl.dataset.open = ''; return; }
      // Close any other open scope menus
      document.querySelectorAll('.scopeMenu').forEach(m=>m.remove());
      document.querySelectorAll('[data-open="1"]').forEach(b=>b.dataset.open='');
      btnEl.dataset.open = '1';
      const menu = document.createElement('div');
      menu.className = 'scopeMenu';
      menu.style.cssText = 'display:flex;flex-direction:column;gap:1px;margin-top:4px;border:1px solid var(--border);border-radius:6px;overflow:hidden;';
      for(const opt of options){
        if(!opt.count) continue;
        const row = document.createElement('button');
        row.className = 'btn';
        row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;width:100%;border:none;border-radius:0;font-size:11px;padding:6px 10px;text-align:left;';
        row.innerHTML = `<span>${opt.label}</span><span style="opacity:.4;font-family:var(--mono);font-size:10px;">${opt.badge || opt.count}</span>`;
        row.addEventListener('click', (e)=>{ e.stopPropagation(); menu.remove(); btnEl.dataset.open = ''; onPick(opt); });
        menu.appendChild(row);
      }
      wrap.appendChild(menu);
      const closeMenu = (e)=>{ if(!wrap.contains(e.target)){ menu.remove(); btnEl.dataset.open = ''; document.removeEventListener('click', closeMenu, true); } };
      setTimeout(()=> document.addEventListener('click', closeMenu, true), 0);
    }

    // --- Delete mappings dropdown ---
    const delEdgesBtn = document.getElementById('bulkDeleteEdgesBtn');
    if(delEdgesBtn) delEdgesBtn.addEventListener('click', ()=>{
      const opts = [];
      if(internalEdges.length) opts.push({ id:'internal', label:'Internal', count:internalEdges.length, edges:internalEdges });
      if(inboundEdges.length) opts.push({ id:'inbound', label:'Inbound', count:inboundEdges.length, edges:inboundEdges });
      if(outboundEdges.length) opts.push({ id:'outbound', label:'Outbound', count:outboundEdges.length, edges:outboundEdges });
      if(opts.length > 1) opts.push({ id:'all', label:'All', count:allRelatedEdges.length, edges:allRelatedEdges });
      if(opts.length === 1){ opts[0].label = 'All'; }
      toggleScopeMenu('bulkDeleteWrap', delEdgesBtn, opts, async (opt)=>{
        const ok = await customConfirm(`Delete ${opt.count} ${opt.label.toLowerCase()} mapping${opt.count>1?'s':''}?`);
        if(!ok) return;
        pushUndo();
        const killPairs = new Set(opt.edges.map(e=>e.from+'|'+e.to));
        state.data.mappings = (state.data.mappings||[]).filter(m=> m && !killPairs.has(m.from+'|'+m.to));
        markDirty(); renderAll(); applyHighlight();
        setGlobalStatus(`Deleted ${opt.count} ${opt.label.toLowerCase()} mappings.`);
      });
    });

    const addTransformBtn = document.getElementById('bulkAddTransform');
    if(addTransformBtn) addTransformBtn.addEventListener('click', ()=>{
      showBulkTransformModal({ internal: internalEdges, inbound: inboundEdges, outbound: outboundEdges });
    });

    // --- Clear transforms dropdown ---
    const clearTBtn = document.getElementById('bulkClearTransformsBtn');
    if(clearTBtn) clearTBtn.addEventListener('click', ()=>{
      const withT = (edges) => edges.filter(e=>(e.transforms||[]).length > 0);
      const tCount = (edges) => edges.reduce((n,e)=> n + (normalizeTransforms(e.transforms)||[]).length, 0);
      const opts = [];
      if(withT(internalEdges).length) opts.push({ id:'internal', label:'Internal', count:withT(internalEdges).length, badge:`${withT(internalEdges).length}  ${tCount(internalEdges)}T`, tCount:tCount(internalEdges), edges:withT(internalEdges) });
      if(withT(inboundEdges).length) opts.push({ id:'inbound', label:'Inbound', count:withT(inboundEdges).length, badge:`${withT(inboundEdges).length}  ${tCount(inboundEdges)}T`, tCount:tCount(inboundEdges), edges:withT(inboundEdges) });
      if(withT(outboundEdges).length) opts.push({ id:'outbound', label:'Outbound', count:withT(outboundEdges).length, badge:`${withT(outboundEdges).length}  ${tCount(outboundEdges)}T`, tCount:tCount(outboundEdges), edges:withT(outboundEdges) });
      const allWith = withT(allRelatedEdges);
      if(opts.length > 1 && allWith.length) opts.push({ id:'all', label:'All', count:allWith.length, badge:`${allWith.length}  ${tCount(allRelatedEdges)}T`, tCount:tCount(allRelatedEdges), edges:allWith });
      if(opts.length === 1){ opts[0].label = 'All'; }
      toggleScopeMenu('bulkClearTWrap', clearTBtn, opts, async (opt)=>{
        const ok = await customConfirm(`Clear ${opt.tCount} transform${opt.tCount>1?'s':''} from ${opt.count} ${opt.label.toLowerCase()} mapping${opt.count>1?'s':''}?`);
        if(!ok) return;
        pushUndo();
        for(const edge of opt.edges){
          const mapping = (state.data.mappings||[]).find(m=> m && m.from===edge.from && m.to===edge.to);
          if(mapping) mapping.transforms = [];
        }
        markDirty(); renderAll(); applyHighlight();
        setGlobalStatus(`Cleared transforms from ${opt.count} ${opt.label.toLowerCase()} mappings.`);
      });
    });
  }
}

function updateDetails(nodeId, selectedFieldsSet){
  /* EDGE-FOCUS OVERRIDE */
  const edgeId = state.selectedEdgeId || state.hoverEdgeId;
  if(edgeId){
    const isHoverOnly = !state.selectedEdgeId && !!state.hoverEdgeId;
    // In editor mode: hover uses viewer preview, selected uses editor
    if(state.editorMode && typeof renderSelectedEdgeEditor==="function"){
      if(isHoverOnly && typeof renderSelectedEdgeViewer==="function"){
        renderSelectedEdgeViewer(edgeId);
      } else {
        renderSelectedEdgeEditor();
      }
      return;
    } else if(state.tab==="viewer" && typeof renderSelectedEdgeViewer==="function"){
      renderSelectedEdgeViewer(edgeId);
      return;
    }
  }
  const node = IDX.nodeById.get(nodeId);
  const locked = (state.lockedId === nodeId);
  detailsMeta.textContent = locked ? "locked" : (state.hoverId ? "hover" : "preview");

  const isFieldNode = node?.type === "field";
  const selectedFields = new Set(selectedFieldsSet || []);

  const inbound = [];
  const outbound = [];
  const seen = new Set();
  const candidates = isFieldNode ? (IDX.edgesByField.get(nodeId) || []) : IDX.edges;

  for(const e of candidates){
    if(!e || seen.has(e.id)) continue;
    if(!isFieldNode){
      if(!(selectedFields.has(e.from) || selectedFields.has(e.to))) continue;
    }
    seen.add(e.id);
    if(selectedFields.has(e.from) && !selectedFields.has(e.to)) outbound.push(e);
    if(selectedFields.has(e.to) && !selectedFields.has(e.from)) inbound.push(e);
  }

  inbound.sort(compareEdgesSimple);
  outbound.sort(compareEdgesSimple);

  const summary = `Inbound: ${inbound.length}  Outbound: ${outbound.length}`;

  function otherEnd(edge, dir){
    return dir==='out' ? edge.to : edge.from;
  }

  function item(edge, dir){
    const jump = otherEnd(edge, dir);
    const jumpNode = IDX.nodeById.get(jump);
    const jumpLabel = jumpNode?.label ?? jump;
    const side = columnOf(jump) ?? "node";
    const title = escapeHtml(edgeTooltip(edge));
    const route = `${edge.from}  ${edge.to}`;
    const prefix = (dir==='out') ? 'out' : 'in';
    return `
      <li class="item" data-jump-id="${escapeHtml(jump)}" data-edge-id="${escapeHtml(edge.id)}" title="${title}">
        <span class="pill">${escapeHtml(side)}</span>
        <span class="pill">${escapeHtml(prefix)}</span>
 <span class=\"itemBreak\"></span>
        <span class="txt">${escapeHtml(jumpLabel)}</span>
        ${badgeHtml(edge)}
        <span class="route">${escapeHtml(route)}</span>${(edge.note && String(edge.note).trim()) ? `<span class="mapNote">${escapeHtml(short(edge.note, 120))}</span>` : ``}
      </li>
    `;
  }

  function section(title, arr, dir, collapsed){
    const cls = collapsed ? 'collapsed' : '';
    return `
      <div class="box detailSection ${cls}">
        <h3 class="detailSectionHead"><span>${escapeHtml(title)}</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${arr.length}</span></h3>
        <div class="detailSectionBody">
        ${arr.length ? `<ul class="list">${arr.map(e => item(e, dir)).join("\n")}</ul>` : `<div class="empty">None.</div>`}
        </div>
      </div>
    `;
  }

  // Children section for groups
  let childrenHtml = '';
  if(!isFieldNode && node && Array.isArray(node.children) && node.children.length){
    const childCards = node.children.map(ch => miniNodeCard(ch.id)).join('');
    childrenHtml = `
      <div class="box detailSection collapsed">
        <h3 class="detailSectionHead"><span>Children</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${node.children.length}</span></h3>
        <div class="detailSectionBody" style="padding-top:8px;">
          ${childCards}
        </div>
      </div>
    `;
  }

  const defaultCollapsed = !isFieldNode;

  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtHero">
        <div class="dtName">${escapeHtml(node?.label ?? "")}</div>
        <span class="dtType${node?.type==='group' ? ' group' : ''}">${escapeHtml(node?.type ?? "")}</span>
      </div>
      <div class="dtRow">
        <span class="dtRowK">ID</span>
        <span class="dtRowV"><span class="dtId">${escapeHtml(nodeId)}${isLikelyAutoId(node) ? '<span class="autoTag">auto</span>' : ''}</span></span>
      </div>
      ${(() => {
        const _colId = columnOf(nodeId);
        const _colIdx = IDX.columnIndex.get(_colId);
        const _colObj = _colIdx !== undefined ? IDX.columns[_colIdx] : null;
        const _colLabel = _colObj ? (_colObj.label || _colObj.id) : _colId;
        return _colId ? `<div class="dtRow"><span class="dtRowK">Column</span><span class="dtRowV">${escapeHtml(_colLabel)}${_colLabel !== _colId ? ` <span style="font-family:var(--mono);font-size:10px;opacity:.35;">  ${escapeHtml(_colId)}</span>` : ''}</span></div>` : '';
      })()}
      ${(node && node.note && String(node.note).trim()) ? `<div class="dtNote">${escapeHtml(node.note)}</div>` : ''}
      ${(node && node.color) ? `<div class="dtRow">
        <span class="dtRowK">Color</span>
        <span class="dtRowV"><span class="dtColorSwatch" style="background:${escapeHtml(node.color)};"></span> <span style="font-family:var(--mono);font-size:11px;opacity:.55;">${escapeHtml(node.color)}</span></span>
      </div>` : ''}
      <div class="dtStatRow">
        <span class="dtStatChip"><span class="dtStatN">${inbound.length}</span><span class="dtStatL">in</span></span>
        <span class="dtStatChip"><span class="dtStatN">${outbound.length}</span><span class="dtStatL">out</span></span>
      </div>
${(node && Array.isArray(node.tags) && node.tags.length) ? `<div class="dtChipWrap">${tagsHtmlForDetails(node)}</div>` : ''}
${(node && node.customAttributes && Object.keys(node.customAttributes||{}).length) ? `<div style="padding:2px 0;">${Object.keys(node.customAttributes).sort().map(aid=>{
      const raw = node.customAttributes[aid];
      const a = customAttrById(aid)||{id:aid,label:aid};
      const vals = Array.isArray(raw) ? raw : [raw];
      const valueTags = vals.map(vid=>{
        const v = customValueById(aid, vid)||{id:vid,label:vid};
        return `<span class="dtAttrVal">${escapeHtml(v.label||v.id)}</span>`;
      }).join('');
      return `<div class="dtAttrGroup"><span class="dtAttrLabel">${escapeHtml(a.label||a.id)}</span>${valueTags}</div>`;
    }).join('')}</div>` : ''}
    </div>
    ${childrenHtml}
    ${section('Inbound mappings', inbound, 'in', defaultCollapsed)}
    ${section('Outbound mappings', outbound, 'out', defaultCollapsed)}
  `;

  // Wire collapsible section toggles
  detailsBody.querySelectorAll('.detailSectionHead').forEach(h => {
    h.style.cursor = 'pointer';
    h.addEventListener('click', () => {
      h.closest('.detailSection').classList.toggle('collapsed');
    });
  });

  detailsBody.querySelectorAll('[data-jump-id]').forEach(li => {
  li.addEventListener('click', () => {
    const eid = li.getAttribute('data-edge-id');
    if(eid){ selectEdge(eid); } else {
      const id = li.dataset.jumpId; lockSelection(id); scrollIntoView(id);
    }
  });
});
}


function scrollIntoView(nodeId){
  const el = IDX.elementById.get(nodeId);
  if(!el || el.classList.contains("hidden")) return;

  // expand ancestors
  let p = IDX.parentById.get(nodeId);
  while(p){
    toggleCollapse(p, false);
    p = IDX.parentById.get(p);
  }

  const row = IDX.rowById.get(nodeId);
 // If the node is a column root (not rendered), scroll the whole panel into view
 if(!row){
   const panel = IDX.panelByColumnId.get(nodeId);
   if(panel){ panel.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' }); }
   scheduleArrowsUpdate();
   return;
 }
  if(row){
    row.scrollIntoView({ behavior: "smooth", block: "center", inline: "nearest" });
  }
  scheduleArrowsUpdate();
}

/* =========================
   Interactions
========================= */
// Centralized edge selection (clears node selection + editor snapshots)
function selectEdge(eid){
  if(!eid) return;
  
  // Toggle: if already selected, clear selection
  if(state.selectedEdgeId === eid){
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    state._consolidatedEdgeCache = null;
    state._selectedEdgeEndpoints = null;
    try{ if(IDX && IDX.elementById){ IDX.elementById.forEach(el=>{ el.classList && el.classList.remove('active','connected','dimmed'); }); } }catch(e){}
    if(state.editorMode){
      try{ clearEdgeEditSession({clearSelection:true}); }catch(e){}
    }
    renderAll(); // includes applyHighlight
    return;
  }
  
  try{ if(IDX && IDX.elementById){ IDX.elementById.forEach(el=>{ el.classList && el.classList.remove('active','connected','dimmed'); }); } }catch(e){}
  let __nodeEditReverted = false;
  if(state.editorMode){
    try{ clearEdgeEditSession({clearSelection:false}); }catch(e){}
    try{ if(typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'){ revertEditSnapshot(); __nodeEditReverted = true; checkDirtyState(); } }catch(e){}
    __editSnapshot = null;
    state.selectedColumnId = null;
  }
  // clear any node selection/hover
  state.lockedId = null;
  state.hoverId = null;
  state.multiSelection.clear();
  state.selectedEdgeId = eid;
  state.hoverEdgeId = null;
  // Cache edge endpoints for multi-select transition
  const _selE = IDX.edges.find(x=>x.id===eid);
  state._selectedEdgeEndpoints = _selE ? { from: _selE.from, to: _selE.to } : null;
  
  // If we reverted a node edit, we must rebuild columns to clear stale tag pills etc.
  if(__nodeEditReverted){
    renderAll(); // includes applyHighlight + updateDetails + scheduleArrowsUpdate
  } else {
    applyHighlight(); // includes updateDetails + scheduleArrowsUpdate
  }
}

function lockSelection(nodeId, evt){
  // Capture edge endpoints BEFORE clearing, so Ctrl+click can preserve them
  const _prevEdgeEndpoints = state._selectedEdgeEndpoints || null;
  state._selectedEdgeEndpoints = null;
  // Close any mapping edit session when focusing a node (Editor mode).
  // Don't use clearSelection  lockSelection manages node selection itself.
  if(state.editorMode){ clearEdgeEditSession(); }
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state._consolidatedEdgeCache = null;

  const isCtrl = evt && (evt.ctrlKey || evt.metaKey);
  const isShift = evt && evt.shiftKey;
  const isAlt = evt && evt.altKey;

  // --- Chain select: Alt+click (full), Alt+Shift (upstream), Alt+Ctrl/Cmd (downstream) ---
  if(isAlt){
    // Clear edit sessions (guard already prompted in row click handler)
    __editSnapshot = null;
    __edgeEditSession = null;
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;

    // Determine direction
    const direction = (isShift && !isCtrl) ? 'upstream'
                    : (isCtrl && !isShift) ? 'downstream'
                    : 'both';

    // Gather current selection set
    const currentSel = new Set(state.multiSelection);
    if(state.lockedId) currentSel.add(state.lockedId);

    if(direction === 'both'){
      // Full chain select: original bidirectional logic
      // Compute the connected fields for the entire current selection
      const currentConnected = new Set();
      for(const nid of currentSel){
        const tmp = computeHighlightForNode(nid);
        for(const f of tmp.connectedFields) currentConnected.add(f);
      }

      const alreadySelected = currentSel.has(nodeId);
      const isConnected = currentConnected.has(nodeId);

      if(!alreadySelected && isConnected && currentSel.size > 0){
        // Connected but not selected  find path from clicked node to nearest selected node
        const visited = new Map();
        const queue = [nodeId];
        visited.set(nodeId, null);
        let foundTarget = null;
        while(queue.length > 0){
          const cur = queue.shift();
          if(cur !== nodeId && currentSel.has(cur)){
            foundTarget = cur;
            break;
          }
          const adj = IDX.adjacency.get(cur);
          if(adj){
            for(const nb of adj){
              if(!visited.has(nb)){
                visited.set(nb, cur);
                queue.push(nb);
              }
            }
          }
        }
        if(foundTarget !== null){
          let cur = foundTarget;
          while(cur !== null){
            currentSel.add(cur);
            cur = visited.get(cur);
          }
        } else {
          currentSel.add(nodeId);
        }
      } else {
        // Already selected OR not connected  add entire chain
        const chain = computeHighlightForNode(nodeId);
        for(const f of chain.connectedFields) currentSel.add(f);
      }
    } else {
      // Directional chain select (upstream or downstream)
      const directedNodes = computeDirectedChain(nodeId, direction);
      for(const f of directedNodes) currentSel.add(f);
    }

    // Always include the clicked node itself and all its descendants (including child groups)
    currentSel.add(nodeId);
    const clickedNode = IDX.nodeById.get(nodeId);
    if(clickedNode && clickedNode.children){
      const stack = [...clickedNode.children];
      while(stack.length){
        const n = stack.pop();
        currentSel.add(n.id);
        if(n.children) stack.push(...n.children);
      }
    }

    // Apply to state
    state.multiSelection = currentSel;
    state.lockedId = null;
    if(state.multiSelection.size === 1){
      state.lockedId = [...state.multiSelection][0];
      state.multiSelection.clear();
    }
    state.hoverId = null;
    state.nodeEditorAttrFocus = '';
    state._lastClickedNodeId = nodeId;
    applyHighlight();
    return;
  }

  // --- Multi-select: Ctrl/Cmd+click ---
  if(isCtrl){
    // Capture lockedId before cleanup
    const _prevLocked = state.lockedId;
    // Clear edit sessions (guard already prompted in row click handler)
    __editSnapshot = null;
    __edgeEditSession = null;
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    // If there's a single lockedId and multiSelection is empty, seed it
    if(state.multiSelection.size === 0 && _prevLocked && _prevLocked !== nodeId){
      state.multiSelection.add(_prevLocked);
    }
    // Preserve selected edge endpoints into multi-selection
    if(_prevEdgeEndpoints){
      state.multiSelection.add(_prevEdgeEndpoints.from);
      state.multiSelection.add(_prevEdgeEndpoints.to);
    }
    // Toggle this node in the set
    if(state.multiSelection.has(nodeId)){
      state.multiSelection.delete(nodeId);
    } else {
      state.multiSelection.add(nodeId);
      state._lastClickedNodeId = nodeId; // move anchor for Shift+click range
    }
    // If multi-selection reduced to 0, clear; if 1, convert to single lock
    if(state.multiSelection.size === 0){
      state.lockedId = null;
    } else if(state.multiSelection.size === 1){
      state.lockedId = [...state.multiSelection][0];
      state.multiSelection.clear();
    } else {
      state.lockedId = null; // multi takes over
    }
    state.hoverId = null;
    state.nodeEditorAttrFocus = '';
    applyHighlight();
    return;
  }

  // --- Multi-select: Shift+click (range within column) ---
  if(isShift && state._lastClickedNodeId){
    // Clear edit sessions (guard already prompted in row click handler)
    __editSnapshot = null;
    __edgeEditSession = null;
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    // Preserve selected edge endpoints
    if(_prevEdgeEndpoints){
      state.multiSelection.add(_prevEdgeEndpoints.from);
      state.multiSelection.add(_prevEdgeEndpoints.to);
    }
    const lastCol = columnOf(state._lastClickedNodeId);
    const thisCol = columnOf(nodeId);
    if(lastCol && lastCol === thisCol){
      // Get visible order of nodes in this column's tree
      const panel = IDX.panelByColumnId.get(lastCol);
      if(panel){
        const allRows = Array.from(panel.querySelectorAll('.row[data-node-id]'));
        const visibleIds = allRows
          .filter(r => !r.closest('.hidden') && r.offsetParent !== null)
          .map(r => r.dataset.nodeId);
        const idxA = visibleIds.indexOf(state._lastClickedNodeId);
        const idxB = visibleIds.indexOf(nodeId);
        if(idxA >= 0 && idxB >= 0){
          const start = Math.min(idxA, idxB);
          const end = Math.max(idxA, idxB);
          // Seed with existing lockedId if needed
          if(state.multiSelection.size === 0 && state.lockedId){
            state.multiSelection.add(state.lockedId);
          }
          for(let i = start; i <= end; i++){
            state.multiSelection.add(visibleIds[i]);
          }
          state.lockedId = null;
          state.hoverId = null;
          state.nodeEditorAttrFocus = '';
          applyHighlight();
          return;
        }
      }
    }
  }

  // --- Normal single click (original behavior) ---
  // Clear multi-selection on normal click
  if(state.multiSelection.size > 0){
    state.multiSelection.clear();
  }

  // DESELECT_AS_CANCEL: if node editor has pending snapshot and user deselects the same node, treat as Cancel.
  let didCancelEdit = false;
  if(state.editorMode && state.lockedId===nodeId && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node' && __editSnapshot.id===nodeId){
    cancelEditAndDeselect();
    didCancelEdit = true;
    // Don't return - but we'll skip toggle logic below since cancel already deselected
  }

  // If a mapping editor is open, close it (Cancel behavior) before changing focus.
  if(state.editorMode && state.selectedEdgeId){
    clearEdgeEditSession({clearSelection:true});
  }

  // If we are editing a node (snapshot exists) and the user clicks a different node,
  // abandon the pending node edits (like Cancel) but keep the new focus change.
  let reverted = false;
  try{
    if(state.editorMode && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'
      && state.lockedId && state.lockedId!==nodeId){
      revertEditSnapshot();
      __editSnapshot = null;
      reverted = true;
      checkDirtyState();
    }
  }catch(e){ /* safe no-op */ }

  // Toggle logic: if already locked on this node, unlock; otherwise lock
  // Skip if we just canceled an edit (already deselected)
  if(!didCancelEdit){
    if(state.lockedId === nodeId){
      // Reset attribute editor UI focus when clearing selection.
      if(state) state.nodeEditorAttrFocus = '';
      state.lockedId = null;
      state.hoverId = null;
    } else {
      // Reset attribute editor UI focus when switching nodes.
      if(state) state.nodeEditorAttrFocus = '';
      state.lockedId = nodeId;
      state.hoverId = null;
    }
  }

  // Track last clicked node for shift+click range
  state._lastClickedNodeId = nodeId;

  // We must re-render if we reverted, because the UI may have been updated live while editing.
  if(reverted){
    renderAll();
  }
  applyHighlight();
}

function attachTreeInteractions(treeEl){
  // hover preview
  treeEl.addEventListener("mouseover", (e) => {
    if(state.panMode) return;
    if(state._lassoActive) return;
    if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
    if(state.__hoverCooldownUntil && Date.now() < state.__hoverCooldownUntil) return;
    const row = e.target.closest(".row");
    if(!row) return;
    const id = row.dataset.nodeId;
    if(!id) return;
    if(IDX.elementById.get(id)?.classList.contains("hidden")) return;
    state.hoverId = id;
    applyHighlight();
  });

  treeEl.addEventListener("mouseout", (e) => {
    if(state.panMode) return;
    if(state._lassoActive) return;
    if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
    const row = e.target.closest(".row");
    if(!row) return;
    const related = e.relatedTarget;
    if(related && row.contains(related)) return;
    state.hoverId = null;
    applyHighlight();
  });

  // click: caret collapses, row locks selection
  treeEl.addEventListener("click", async (e) => {
    const caret = e.target.closest(".caret");
    if(caret){
      const id = caret.dataset.caretFor;
      if(id) toggleCollapse(id, null);
      e.stopPropagation();
      return;
    }
    const row = e.target.closest(".row");
    if(!row) return;
    const id = row.dataset.nodeId;
    if(!id) return;
    if(IDX.elementById.get(id)?.classList.contains("hidden")) return;
    if(state.editorMode && nodeEditIsDirty() && __editSnapshot?.id !== id){
      if(!await guardNodeAbandon()) return;
      revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
    }
    if(state.editorMode && edgeEditIsDirty()){
      const eid = __edgeEditSession?.edgeId || '';
      if(!await guardAbandonEdit('mapping', eid)) return;
    }
    lockSelection(id, e);
  });

  // arrows update on scroll
  treeEl.addEventListener("scroll", () => scheduleArrowsUpdate(), { passive: true });
}

/* =========================
   Arrows (multi-column)
   - Can connect any columns (non-adjacent supported)
   - Optional scope toggles (same-column, distant) reduce clutter
   - Default: show only arrows for highlighted selection (unless arrow mode is All)
========================= */
let arrowRaf = null;

function scheduleArrowsUpdate(){
  if(!state.arrowsOn) return;
  if(arrowRaf) return;
  arrowRaf = requestAnimationFrame(() => {
    arrowRaf = null;
    drawArrows();
  });
}

window.addEventListener("resize", () => scheduleArrowsUpdate(), { passive: true });
columnsScroller.addEventListener("scroll", () => scheduleArrowsUpdate(), { passive: true });
// Redraw arrows when scroller area changes (panel resize, dock changes)
if(typeof ResizeObserver !== 'undefined'){
  new ResizeObserver(() => scheduleArrowsUpdate()).observe(columnsScroller);
}

// Click empty space in viewer  deselect node/edge (Cancel if editing)
columnsScroller.addEventListener("click", (e) => {
  if(state.panMode) return;
  // Skip if lasso just completed
  if(state._lassoJustCompleted && Date.now() - state._lassoJustCompleted < 200) return;
  // Only fire if click is directly on background areas, not on nodes/rows/buttons/inputs
  const t = e.target;
  if(t.closest('.row') || t.closest('.btn') || t.closest('input') || t.closest('select') ||
     t.closest('label') || t.closest('.panelHeader') || t.closest('.tagChip') ||
     t.closest('.rowActions') || t.closest('.caret') || t.closest('path') || t.closest('svg')) return;
  // Don't deselect if a modal is open
  if(document.querySelector('.modal.active')) return;
  if(state.lockedId || state.selectedEdgeId || state.selectedColumnId || state.multiSelection.size > 0){
    if(state.editorMode && __editSnapshot && __editSnapshot.data){
      cancelEditAndDeselect();
    } else if(state.editorMode && state.selectedEdgeId){
      clearEdgeEditSession({clearSelection:true});
      state.lockedId = null;
      state.hoverId = null;
      state.multiSelection.clear();
      state.__hoverCooldownUntil = Date.now() + 300;
      renderAll();
    } else {
      state.lockedId = null;
      state.hoverId = null;
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
      state.selectedColumnId = null;
      state.multiSelection.clear();
      state.__hoverCooldownUntil = Date.now() + 300;
      renderAll();
    }
  }
});

function isVisibleNodeId(id){
  const el = IDX.elementById.get(id);
  if(!el || el.classList.contains("hidden")) return false;
  const row = IDX.rowById.get(id);
  if(!row || !row.offsetParent) return false; // hidden by collapsed parent
  
  // Check if the node's column is hidden
  const col = columnOf(id);
  if(col && state.hiddenColumns && state.hiddenColumns.has(col)) return false;
  
  return true;
}

function anchorPoint(nodeId, svgRect, zoomFactor){
  const row = IDX.rowById.get(nodeId);
  if(!row) return null;
  const r = row.getBoundingClientRect();
  const z = zoomFactor || 1;
  const left = { x: (r.left - svgRect.left) / z, y: ((r.top + r.height/2) - svgRect.top) / z };
  const right = { x: (r.right - svgRect.left) / z, y: ((r.top + r.height/2) - svgRect.top) / z };
  return { left, right };
}


function bezier(p1, p2){
  const dist = Math.abs(p2.x - p1.x);
  const dx = Math.max(40, dist * 0.35);
  const c1x = p1.x + (p2.x > p1.x ? dx : -dx);
  const c2x = p2.x - (p2.x > p1.x ? dx : -dx);
  return `M ${p1.x.toFixed(1)} ${p1.y.toFixed(1)} C ${c1x.toFixed(1)} ${p1.y.toFixed(1)}, ${c2x.toFixed(1)} ${p2.y.toFixed(1)}, ${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
}

function orthoPath(p1, p2, midX){
  // simple orthogonal routing: horizontal -> vertical -> horizontal
  const mx = midX;
  return `M ${p1.x.toFixed(1)} ${p1.y.toFixed(1)} L ${mx.toFixed(1)} ${p1.y.toFixed(1)} L ${mx.toFixed(1)} ${p2.y.toFixed(1)} L ${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
}

// Arrowhead geometry tuning (must match marker path tip X: 12.5)
const ARROW_TIP_LEN = 13; // px in userSpaceOnUse
function adjustEndForArrow(p1, p2, len=ARROW_TIP_LEN){
  // Keep the arrow tip vertically centered on the target row.
  // We only shift along X so the marker tip lands on the element edge,
  // while the line end stays at the base midpoint and Y remains at the row center.
  const dx = p2.x - p1.x;
  const dir = dx === 0 ? 0 : Math.sign(dx);
  return { x: p2.x - dir * len, y: p2.y };
}


function isAdjacentColumns(fromId, toId){
  const fc = columnOf(fromId);
  const tc = columnOf(toId);
  if(!fc || !tc) return false;
  const fi = visualColumnIndex(fc);
  const ti = visualColumnIndex(tc);
  if(fi < 0 || ti < 0) return false;
  return Math.abs(fi - ti) === 1;
}

/** Check if an edge passes arrow scope filters (same-column, distant) */
function edgeScopeVisible(fromId, toId){
  const fc = columnOf(fromId);
  const tc = columnOf(toId);
  if(!fc || !tc) return true;
  const fi = visualColumnIndex(fc);
  const ti = visualColumnIndex(tc);
  if(fi < 0 || ti < 0) return true;
  const span = Math.abs(fi - ti);
  if(span === 0 && !state.showSameColumn) return false;
  if(span > 1 && !state.showDistant) return false;
  return true;
}

// Returns the visual index of a column (skipping hidden columns)
function visualColumnIndex(colId){
  let vi = 0;
  for(const c of IDX.columns){
    if(state.hiddenColumns.has(c.id)) continue;
    if(c.id === colId) return vi;
    vi++;
  }
  return -1;
}


function findCollapsedParent(nodeId){
  // Walk up the parent chain to find the first VISIBLE collapsed group
  let currentId = nodeId;
  while(currentId){
    const parent = IDX.parentById.get(currentId);
    if(!parent) break;
    if(isCollapsedGroup(parent)){
      // Check if this collapsed parent is itself visible
      // If it's visible, this is our target
      // If it's not visible, keep walking up
      const parentEl = IDX.elementById.get(parent);
      if(parentEl && parentEl.offsetParent){
        // Parent is visible, use it
        return parent;
      }
      // Parent is not visible (hidden by its own collapsed parent), keep walking
    }
    currentId = parent;
  }
  return null;
}

function isCollapsedGroup(nodeId){
  const el = IDX.elementById.get(nodeId);
  if(!el) return false;
  // Check if element has 'collapsed' class (for groups)
  return el.classList.contains('collapsed');
}

function hasHiddenColumnsBetween(fromColId, toColId){
  if(fromColId === toColId) return false;
  
  const fromIdx = IDX.columnIndex.get(fromColId);
  const toIdx = IDX.columnIndex.get(toColId);
  if(fromIdx === undefined || toIdx === undefined) return false;
  
  const minIdx = Math.min(fromIdx, toIdx);
  const maxIdx = Math.max(fromIdx, toIdx);
  
  // Check if any column between fromIdx and toIdx is hidden
  for(let i = minIdx + 1; i < maxIdx; i++){
    const col = IDX.columns[i];
    if(col && state.hiddenColumns.has(col.id)){
      return true;
    }
  }
  return false;
}

// Find mapping chains that go through hidden columns
// Returns array of virtual edges: {from, to, chain: [edge1, edge2, ...], throughHiddenColumn: true}
function findChainsThoughHiddenColumns(){
  const virtualEdges = [];
  const processedPairs = new Set();
  
  // Recursive chain follower that handles branching through hidden columns
  function followChain(lastVisibleField, currentFieldId, chain, visited){
    if(visited.has(currentFieldId)) return; // cycle protection
    visited.add(currentFieldId);
    const col = columnOf(currentFieldId);
    if(!col) return;
    
    if(!state.hiddenColumns.has(col)){
      // Reached a visible column  emit virtual edge if chain went through hidden
      if(chain.length > 1){
        if(lastVisibleField === currentFieldId) return; // skip self-loops
        const pairKey = `${lastVisibleField}${currentFieldId}`;
        if(!processedPairs.has(pairKey)){
          processedPairs.add(pairKey);
          virtualEdges.push({
            from: lastVisibleField,
            to: currentFieldId,
            chain: [...chain],
            throughHiddenColumn: true,
            id: `virtual:${pairKey}`
          });
        }
      }
      return;
    }
    
    // Current field is in a hidden column  find ALL outgoing edges and branch
    const outgoing = IDX.edges.filter(e => e.from === currentFieldId);
    if(outgoing.length === 0) return; // dead end
    
    for(const nextEdge of outgoing){
      followChain(lastVisibleField, nextEdge.to, [...chain, nextEdge], visited);
    }
  }
  
  // For each edge starting from a visible column, try to follow chains
  for(const startEdge of IDX.edges){
    const startCol = columnOf(startEdge.from);
    if(!startCol || state.hiddenColumns.has(startCol)) continue; // Start must be visible
    
    const toCol = columnOf(startEdge.to);
    if(!toCol || !state.hiddenColumns.has(toCol)) continue; // Only interested if target is hidden
    
    // Start following the chain from the hidden target
    followChain(startEdge.from, startEdge.to, [startEdge], new Set([startEdge.from]));
  }
  
  return virtualEdges;
}


function drawArrows(){
  if(!state.arrowsOn) { edgesLayer.innerHTML = ""; return; }
  // Reset SVG size before measuring to prevent self-inflating scrollWidth
  svgOverlay.style.width = '0';
  svgOverlay.style.height = '0';
  svgOverlay.setAttribute("width", 0);
  svgOverlay.setAttribute("height", 0);
  const zoomFactor = parseFloat(columnsScroller.style.zoom) || 1;
  const fullW = Math.max(columnsRow.scrollWidth, columnsScroller.clientWidth);
  const fullH = Math.max(columnsRow.scrollHeight, columnsScroller.clientHeight);
  svgOverlay.setAttribute("width", fullW);
  svgOverlay.setAttribute("height", fullH);
  svgOverlay.style.width = fullW + "px";
  svgOverlay.style.height = fullH + "px";
  const svgRect = svgOverlay.getBoundingClientRect();

  const effectiveNode = currentEffectiveId();
  const hasMulti = state.multiSelection.size > 0;
  // Pre-compute rightmost visible column for same-column arrow direction
  const __visColIds = IDX.columns.filter(c => !state.hiddenColumns.has(c.id)).map(c => c.id);
  const __rightmostColId = __visColIds.length ? __visColIds[__visColIds.length - 1] : null;
  const edgeFocusId = state.selectedEdgeId || state.hoverEdgeId;
  let highlightFields = null;
  let activeFields = null;
  if(hasMulti){
    // Multi-select: combine highlights for all selected nodes
    const allSelected = new Set();
    const allConnected = new Set();
    for(const nid of state.multiSelection){
      const { selectedFields, connectedFields } = computeHighlightForNode(nid);
      if(state.multiSelectArrowMode === 'direct'){
        for(const f of selectedFields){ allSelected.add(f); allConnected.add(f); }
        for(const f of selectedFields){
          const adj = IDX.adjacency.get(f);
          if(adj) for(const other of adj) allConnected.add(other);
        }
      } else {
        for(const f of selectedFields) allSelected.add(f);
        for(const f of connectedFields) allConnected.add(f);
      }
    }
    highlightFields = (state.multiSelectArrowMode === 'selected') ? allSelected : allConnected;
    activeFields = allSelected;
  } else if(effectiveNode){
    const { selectedFields, connectedFields } = computeHighlightForNode(effectiveNode);
    if(state.multiSelectArrowMode === 'direct'){
      const directConnected = new Set(selectedFields);
      for(const f of selectedFields){
        const adj = IDX.adjacency.get(f);
        if(adj) for(const other of adj) directConnected.add(other);
      }
      highlightFields = (state.multiSelectArrowMode === 'selected') ? selectedFields : directConnected;
    } else {
      highlightFields = (state.multiSelectArrowMode === 'selected') ? selectedFields : connectedFields;
    }
    activeFields = IDX.fieldIds.has(effectiveNode) ? selectedFields : new Set();
  } else if(edgeFocusId){
    // Check both real edges and virtual edges
    let ee = IDX.edges.find(x=>x.id===edgeFocusId);
    
    // If not found in real edges, check virtual edges
    if(!ee && edgeFocusId.startsWith('virtual:')){
      const virtualEdges = findChainsThoughHiddenColumns();
      ee = virtualEdges.find(x=>x.id===edgeFocusId);
    }
    
    if(ee){
      // Check if this edge has consolidated metadata (from path or edge object)
      // We need to check the path that will be drawn, but paths haven't been created yet...
      // So we compute it the same way: check if any endpoint will be redirected to collapsed group
      let needsConsolidatedCheck = false;
      let fromVisible = isVisibleNodeId(ee.from);
      let toVisible = isVisibleNodeId(ee.to);
      
      if(!fromVisible || !toVisible){
        // At least one endpoint might be redirected - might need consolidated handling
        needsConsolidatedCheck = true;
      }
      
      // If might be consolidated, find all edges with same redirected endpoints
      let edgesToHighlight = [ee];
      if(needsConsolidatedCheck){
        // Find all edges that will consolidate to the same arrow
        const allEdgesGrouped = new Map();
        for(const e of IDX.edges){
          let fid = e.from;
          let tid = e.to;
          
          if(!isVisibleNodeId(fid)){
            const cp = findCollapsedParent(fid);
            if(cp) fid = cp;
          }
          if(!isVisibleNodeId(tid)){
            const cp = findCollapsedParent(tid);
            if(cp) tid = cp;
          }
          
          const key = `${fid}${tid}`;
          if(!allEdgesGrouped.has(key)) allEdgesGrouped.set(key, []);
          allEdgesGrouped.get(key).push(e);
        }
        
        // Find which group ee belongs to
        let eeFid = ee.from;
        let eeTid = ee.to;
        if(!fromVisible){
          const cp = findCollapsedParent(eeFid);
          if(cp) eeFid = cp;
        }
        if(!toVisible){
          const cp = findCollapsedParent(eeTid);
          if(cp) eeTid = cp;
        }
        const eeKey = `${eeFid}${eeTid}`;
        edgesToHighlight = allEdgesGrouped.get(eeKey) || [ee];
      }
      
      // Compute highlights for all edges in the group
      const allConnected = new Set();
      const allSelected = new Set();
      for(const edge of edgesToHighlight){
        const a = computeHighlightForNode(edge.from);
        const b = computeHighlightForNode(edge.to);
        allSelected.add(edge.from);
        allSelected.add(edge.to);
        for(const f of a.connectedFields) allConnected.add(f);
        for(const f of b.connectedFields) allConnected.add(f);
      }
      
      highlightFields = (state.multiSelectArrowMode === 'selected') ? allSelected : allConnected;
      activeFields = allSelected;
    }
  }
  const shouldDimEdges = !!(highlightFields && state.selectionDim !== 'off');
  // if not "all arrows" and no selection, show none
  if(!state.allArrows && !effectiveNode && !edgeFocusId && !hasMulti){
    // fade out existing arrows smoothly and disable hitboxes
    Array.from(edgesLayer.querySelectorAll('path.edge')).forEach(path=>{
      path.classList.add('fadeOut');
      if(path.__hitbox) path.__hitbox.style.pointerEvents = 'none';
      setTimeout(()=>{ 
        if(path.__hitbox) path.__hitbox.remove();
        path.remove(); 
      }, 180);
    });
    return;
  }

  // mark existing as not alive; we'll flip to alive when we (re)use them
  const existing = new Map();
  Array.from(edgesLayer.querySelectorAll('path.edge')).forEach(p=>{
    existing.set(p.dataset.edgeId, p);
    p.__alive = false;
  });

  const candidates = [];
  const collapsedGroupPairs = new Map(); // Track arrows between collapsed groups
  const bidirectionalFieldPairs = new Map(); // Track bidirectional field mappings
  
  // Find chains through hidden columns and create virtual edges
  const virtualEdges = findChainsThoughHiddenColumns();
  virtualEdges.forEach(ve => {
  });
  
  // Combine real edges with virtual edges for processing
  const allEdgesToProcess = [...IDX.edges, ...virtualEdges];
  
  for(const e of allEdgesToProcess){
    // Check visibility and redirect to collapsed groups if needed
    let fromId = e.from;
    let toId = e.to;
    let fromRedirected = false;
    let toRedirected = false;
    
    // If 'from' node is not visible, check if it's hidden by a collapsed parent
    if(!isVisibleNodeId(fromId)){
      const collapsedParent = findCollapsedParent(fromId);
      if(collapsedParent){
        fromId = collapsedParent;
        fromRedirected = true;
      } else {
        continue; // Skip if not visible and no collapsed parent
      }
    }
    
    // If 'to' node is not visible, check if it's hidden by a collapsed parent
    if(!isVisibleNodeId(toId)){
      const collapsedParent = findCollapsedParent(toId);
      if(collapsedParent){
        toId = collapsedParent;
        toRedirected = true;
      } else {
        continue; // Skip if not visible and no collapsed parent
      }
    }
    
    const isDotted = fromRedirected || toRedirected;
    const bothCollapsed = fromRedirected && toRedirected;
    const anyCollapsed = fromRedirected || toRedirected;
    
    // If any endpoint is redirected to collapsed group, consolidate by redirected endpoints
    // This handles:
    // 1. Both endpoints collapsed (A collapsed  B collapsed)
    // 2. One visible field  multiple fields in collapsed group (A  B collapsed)
    // 3. Multiple fields in collapsed group  one visible field (A collapsed  B)
    if(anyCollapsed){
      const pairKey = `${fromId}${toId}`;
      if(!collapsedGroupPairs.has(pairKey)){
        collapsedGroupPairs.set(pairKey, []);
      }
      collapsedGroupPairs.get(pairKey).push(e);
      // We'll process these separately below
      continue;
    }
    
    // Check for bidirectional field mappings
    // This includes:
    // 1. Both endpoints visible (not redirected)
    // 2. One endpoint redirected to collapsed group (hybrid case)
    const pairKey = `${fromId}${toId}`;
    const reversePairKey = `${toId}${fromId}`;
    
    // Check if reverse mapping exists (checking original field IDs)
    const reverseExists = IDX.edges.some(edge => 
      edge.from === e.to && edge.to === e.from
    );
    
    if(reverseExists && !bothCollapsed){
      // Add to bidirectional pairs (even if one is redirected)
      if(!bidirectionalFieldPairs.has(pairKey)){
        bidirectionalFieldPairs.set(pairKey, []);
      }
      bidirectionalFieldPairs.get(pairKey).push(e);
      continue; // Process later
    }
    
    if(!edgeScopeVisible(fromId, toId)) continue;
    if(!state.allArrows && highlightFields){
      if(!highlightFields.has(e.from) && !highlightFields.has(e.to)) continue;
    }
    const aFrom = anchorPoint(fromId, svgRect, zoomFactor);
    const aTo = anchorPoint(toId, svgRect, zoomFactor);
    if(!aFrom || !aTo) continue;
    const fCol = columnOf(fromId);
    const tCol = columnOf(toId);
    const fi = visualColumnIndex(fCol);
    const ti = visualColumnIndex(tCol);
    if(fi < 0 || ti < 0) continue;
    let p1, p2;
    if(fi < ti){ p1 = aFrom.right; p2 = aTo.left; }
    else if(fi > ti){ p1 = aFrom.left; p2 = aTo.right; }
    else { const __isRM = fCol === __rightmostColId; p1 = __isRM ? aFrom.left : aFrom.right; p2 = __isRM ? aTo.left : aTo.right; }
    // Back off the path end so the marker tip lands exactly on the element edge
    p2 = adjustEndForArrow(p1, p2);
    const span = Math.abs(fi - ti);
    const key = `${Math.min(fi,ti)}-${Math.max(fi,ti)}-${span}`;
    candidates.push({ e, p1, p2, fi, ti, span, key, isDotted, fromId, toId, edgeCount: 1 });
  }
  
  // Process collapsed group pairs - create one representative arrow per pair
  for(const [pairKey, edges] of collapsedGroupPairs.entries()){
    if(edges.length === 0) continue;
    
    // Use the first edge as representative
    const e = edges[0];
    const [fromId, toId] = pairKey.split('');
    
    // Skip self-referencing arrows (both fields collapsed into the same group)
    if(fromId === toId) continue;
    
    // Check if there's a reverse pair (bidirectional)
    const reversePairKey = `${toId}${fromId}`;
    const isBidirectional = collapsedGroupPairs.has(reversePairKey);
    
    
    // Only process each pair once (skip the reverse)
    if(isBidirectional && fromId > toId){
      continue; // Skip reverse pair
    }
    
    if(!edgeScopeVisible(fromId, toId)) continue;
    
    // For consolidated arrows, show if ANY of the edges would be visible
    // Don't apply the highlight filter - consolidated arrows are structural
    if(!state.allArrows && highlightFields){
      // Check if this consolidated arrow is related to current selection
      // Show it if the collapsed groups are selected/hovered, OR if any constituent edge matches
      const groupsMatch = (highlightFields.has(fromId) || highlightFields.has(toId));
      const anyEdgeMatch = edges.some(edge => 
        highlightFields.has(edge.from) || highlightFields.has(edge.to)
      );
      // For bidirectional, also check reverse edges
      let reverseEdgeMatch = false;
      if(isBidirectional){
        const reverseEdges = collapsedGroupPairs.get(reversePairKey) || [];
        reverseEdgeMatch = reverseEdges.some(edge =>
          highlightFields.has(edge.from) || highlightFields.has(edge.to)
        );
      }
      if(!groupsMatch && !anyEdgeMatch && !reverseEdgeMatch) continue;
    }
    
    const aFrom = anchorPoint(fromId, svgRect, zoomFactor);
    const aTo = anchorPoint(toId, svgRect, zoomFactor);
    if(!aFrom || !aTo) continue;
    const fCol = columnOf(fromId);
    const tCol = columnOf(toId);
    const fi = visualColumnIndex(fCol);
    const ti = visualColumnIndex(tCol);
    if(fi < 0 || ti < 0) continue;
    let p1, p2;
    if(fi < ti){ p1 = aFrom.right; p2 = aTo.left; }
    else if(fi > ti){ p1 = aFrom.left; p2 = aTo.right; }
    else { const __isRM = fCol === __rightmostColId; p1 = __isRM ? aFrom.left : aFrom.right; p2 = __isRM ? aTo.left : aTo.right; }
    p2 = adjustEndForArrow(p1, p2);
    
    // For bidirectional arrows, also adjust p1 so the line starts at the arrow base
    if(isBidirectional){
      const dx = p2.x - p1.x;
      const dir = dx === 0 ? 0 : Math.sign(dx);
      const oldP1 = {...p1};
      p1 = { x: p1.x + dir * ARROW_TIP_LEN, y: p1.y }; // Push p1 forward
    }
    
    const span = Math.abs(fi - ti);
    const key = `${Math.min(fi,ti)}-${Math.max(fi,ti)}-${span}`;
    
    // Combine edges from both directions if bidirectional
    let allEdges = [...edges];
    if(isBidirectional){
      const reverseEdges = collapsedGroupPairs.get(reversePairKey) || [];
      allEdges = [...edges, ...reverseEdges];
    }
    
    // Note: For collapsed groups, we store consolidated info here since it's dynamic
    // (depends on which groups are currently collapsed)
    e.__consolidated = allEdges;
    e.__isBidirectional = isBidirectional;
    e.__fromId = fromId;
    e.__toId = toId;
    
    candidates.push({ 
      e, 
      p1, p2, fi, ti, span, key, 
      isDotted: true, 
      fromId, toId, 
      edgeCount: allEdges.length,
      consolidatedEdges: allEdges,
      isBidirectional // Store for marker selection
    });
  }
  
  // Process bidirectional field pairs - create one arrow with dual heads
  for(const [pairKey, edges] of bidirectionalFieldPairs.entries()){
    if(edges.length === 0) continue;
    
    const e = edges[0];
    const [fromId, toId] = pairKey.split('');
    
    // Check if reverse pair exists
    const reversePairKey = `${toId}${fromId}`;
    const isBidirectional = bidirectionalFieldPairs.has(reversePairKey);
    
    // Only process each pair once (skip the reverse)
    if(isBidirectional && fromId > toId) continue;
    
    // Check if either endpoint is redirected (hybrid case with collapsed group)
    const fromRedirected = fromId !== e.from;
    const toRedirected = toId !== e.to;
    const isDotted = fromRedirected || toRedirected;
    
    if(!edgeScopeVisible(fromId, toId)) continue;
    if(!state.allArrows && highlightFields){
      const anyMatch = edges.some(edge => 
        highlightFields.has(edge.from) || highlightFields.has(edge.to)
      );
      if(isBidirectional){
        const reverseEdges = bidirectionalFieldPairs.get(reversePairKey) || [];
        const reverseMatch = reverseEdges.some(edge =>
          highlightFields.has(edge.from) || highlightFields.has(edge.to)
        );
        if(!anyMatch && !reverseMatch) continue;
      } else if(!anyMatch) continue;
    }
    
    const aFrom = anchorPoint(fromId, svgRect, zoomFactor);
    const aTo = anchorPoint(toId, svgRect, zoomFactor);
    if(!aFrom || !aTo) continue;
    const fCol = columnOf(fromId);
    const tCol = columnOf(toId);
    const fi = visualColumnIndex(fCol);
    const ti = visualColumnIndex(tCol);
    if(fi < 0 || ti < 0) continue;
    let p1, p2;
    if(fi < ti){ p1 = aFrom.right; p2 = aTo.left; }
    else if(fi > ti){ p1 = aFrom.left; p2 = aTo.right; }
    else { const __isRM = fCol === __rightmostColId; p1 = __isRM ? aFrom.left : aFrom.right; p2 = __isRM ? aTo.left : aTo.right; }
    p2 = adjustEndForArrow(p1, p2);
    
    const span = Math.abs(fi - ti);
    const key = `${Math.min(fi,ti)}-${Math.max(fi,ti)}-${span}`;
    
    // For bidirectional arrows, also adjust p1
    if(isBidirectional){
      const dx = p2.x - p1.x;
      const dir = dx === 0 ? 0 : Math.sign(dx);
      p1 = { x: p1.x + dir * ARROW_TIP_LEN, y: p1.y };
    }
    
    // Combine edges from both directions
    let allEdges = [...edges];
    if(isBidirectional){
      const reverseEdges = bidirectionalFieldPairs.get(reversePairKey) || [];
      allEdges = [...edges, ...reverseEdges];
    }
    
    // Note: __consolidated is already set on the edge by markConsolidatedEdges()
    // We just use it here for drawing
    
    candidates.push({
      e,
      p1, p2, fi, ti, span, key,
      isDotted, // Use dotted line if one endpoint is redirected to collapsed group
      fromId, toId,
      edgeCount: allEdges.length,
      consolidatedEdges: allEdges,
      isBidirectional
    });
  }
  
  // Lane assignment for distant (span>1) and same-column edges
  const bucket = new Map();
  for(const c of candidates){
    if(c.span > 1 || c.span === 0){
      if(!bucket.has(c.key)) bucket.set(c.key, []);
      bucket.get(c.key).push(c);
    }
  }
  const laneIndex = new Map();
  for(const [k, arr] of bucket.entries()){
    arr.sort((a,b)=> a.e.id.localeCompare(b.e.id));
    arr.forEach((c, i)=> laneIndex.set(c.e.id, { i, n: arr.length }));
  }

  for(const c of candidates){
    const { e, p1, p2, span, isDotted: collapsedDotted, fromId, toId, edgeCount, consolidatedEdges, isBidirectional } = c;
    
    if(consolidatedEdges && consolidatedEdges.length > 1){
    }
    
    const isConsolidated = consolidatedEdges && consolidatedEdges.length > 1;
    
    let inHL = false;
    let inActive = false;
    
    if(isConsolidated){
      // For consolidated arrows, check if ANY of the constituent edges match the highlight
      inHL = highlightFields && consolidatedEdges.some(edge => 
        highlightFields.has(edge.from) && highlightFields.has(edge.to)
      );
      inActive = activeFields && consolidatedEdges.some(edge =>
        activeFields.has(edge.from) && activeFields.has(edge.to)
      );
      
    } else {
      // Regular arrow or virtual edge - check endpoints
      inHL = highlightFields && (highlightFields.has(e.from) && highlightFields.has(e.to));
      inActive = (state.selectedEdgeId===e.id) || (state.hoverEdgeId===e.id) || (activeFields && activeFields.has(e.from) && activeFields.has(e.to));
      
      // Debug logging for arrows that should be highlighted
      if(highlightFields && (highlightFields.has(e.from) || highlightFields.has(e.to))){
      }
    }

    // Check if this is a virtual edge (chain through hidden column)
    const isHiddenChain = e.throughHiddenColumn === true;
    
    // Determine dash pattern based on what's happening:
    // - Collapsed group only: 5,5 (medium dashes)
    // - Hidden chain only: 2,6 (small dots)
    // - Both collapsed AND hidden chain: 5,5,2,6 (dash-dot pattern)
    let dashPattern = null;
    if(collapsedDotted && isHiddenChain){
      dashPattern = '5,5,2,6'; // Dash-dot for both
    } else if(collapsedDotted){
      dashPattern = '5,5'; // Medium dashes for collapsed only
    } else if(isHiddenChain){
      dashPattern = '2,6'; // Small dots for hidden chain only
    }

    let d = "";
    
    if(span === 0){
      // Same-column mapping: curve that loops out
      // Direction depends on anchor side (right for most columns, left for rightmost)
      const colId = columnOf(fromId);
      const isRightSide = colId !== __rightmostColId;
      
      const lane = laneIndex.get(e.id);
      const n = lane ? lane.n : 1;
      const i = lane ? lane.i : 0;
      const fan = (i - (n - 1) / 2) * 14;
      const yDist = Math.abs(p2.y - p1.y);
      const baseBulge = Math.min(60, Math.max(30, yDist * 0.35));
      
      if(isRightSide){
        const p2Adj = { x: p2.x + ARROW_TIP_LEN, y: p2.y };
        const p1Adj = isBidirectional ? { x: p1.x + ARROW_TIP_LEN, y: p1.y } : p1;
        const bulge = Math.max(p1Adj.x, p2Adj.x) + baseBulge + fan;
        d = `M ${p1Adj.x.toFixed(1)} ${p1Adj.y.toFixed(1)} C ${bulge.toFixed(1)} ${p1Adj.y.toFixed(1)}, ${bulge.toFixed(1)} ${p2Adj.y.toFixed(1)}, ${p2Adj.x.toFixed(1)} ${p2Adj.y.toFixed(1)}`;
      } else {
        const p2Adj = { x: p2.x - ARROW_TIP_LEN, y: p2.y };
        const p1Adj = isBidirectional ? { x: p1.x - ARROW_TIP_LEN, y: p1.y } : p1;
        const bulge = Math.min(p1Adj.x, p2Adj.x) - baseBulge - fan;
        d = `M ${p1Adj.x.toFixed(1)} ${p1Adj.y.toFixed(1)} C ${bulge.toFixed(1)} ${p1Adj.y.toFixed(1)}, ${bulge.toFixed(1)} ${p2Adj.y.toFixed(1)}, ${p2Adj.x.toFixed(1)} ${p2Adj.y.toFixed(1)}`;
      }
    } else {
      // All cross-column mappings (adjacent, distant, collapsed): smooth bezier
      d = bezier(p1, p2);
    }

    // Compute tooltip text (used for both new and existing paths)
    let tooltipText = edgeTooltip(e);
    if(consolidatedEdges && consolidatedEdges.length > 1){
      tooltipText = `${consolidatedEdges.length} mappings:\n${consolidatedEdges.map(edge => `${edge.from}  ${edge.to}`).join('\n')}`;
    } else if(isHiddenChain && e.chain){
      const hiddenCols = [];
      for(const chainEdge of e.chain){
        const fromCol = columnOf(chainEdge.from);
        const toCol = columnOf(chainEdge.to);
        if(fromCol && state.hiddenColumns.has(fromCol)){
          const col = IDX.columns[IDX.columnIndex.get(fromCol)];
          if(col && !hiddenCols.includes(col.label || col.id)) hiddenCols.push(col.label || col.id);
        }
        if(toCol && state.hiddenColumns.has(toCol)){
          const col = IDX.columns[IDX.columnIndex.get(toCol)];
          if(col && !hiddenCols.includes(col.label || col.id)) hiddenCols.push(col.label || col.id);
        }
      }
      tooltipText = `Indirect link through hidden column${hiddenCols.length > 1 ? 's' : ''}: ${hiddenCols.join(', ')}\n${e.chain.map(edge => `${edge.from}  ${edge.to}`).join('  ')}\n\nClick to reveal hidden columns and select the first edge.`;
    }

    let path = existing.get(e.id);
    if(path){
      // Update geometry + classes; mark alive
      path.setAttribute('d', d);
      path.__alive = true;
      path.classList.toggle('hl', !!inHL);
      path.classList.toggle('active', !!inActive);
      path.classList.toggle('dimmed', !!(shouldDimEdges && !inHL && !inActive && !(state.multiSelectArrowMode === 'selected' && !state.allArrows)));
      path.classList.toggle('fadeOut', !!(shouldDimEdges && !inHL && !inActive && state.multiSelectArrowMode === 'selected' && !state.allArrows));
      
      // Set dash pattern
      if(dashPattern){
        path.setAttribute('stroke-dasharray', dashPattern);
      } else {
        path.removeAttribute('stroke-dasharray');
      }
      
      // Store consolidated edges info for click handler
      path.__consolidated = consolidatedEdges;
      path.__fromId = fromId;
      path.__toId = toId;
      path.__isBidirectional = isBidirectional;
      path.__isHiddenChain = isHiddenChain;
      path.__chainEdges = isHiddenChain ? e.chain : null;
      
      let marker = inActive ? 'url(#arrowActive)' : (inHL ? 'url(#arrowHL)' : 'url(#arrowDefault)');
      if(state.editorMode && state.selectedEdgeId===e.id){ marker = 'url(#arrowActive)'; }
      
      // Use bidirectional markers if this is a bidirectional consolidated arrow
      if(isBidirectional){
        const startMarker = inActive ? 'url(#arrowStartActive)' : (inHL ? 'url(#arrowStartHL)' : 'url(#arrowStartDefault)');
        if(state.editorMode && state.selectedEdgeId===e.id){ 
          path.setAttribute('marker-start', 'url(#arrowStartActive)');
        } else {
          path.setAttribute('marker-start', startMarker);
        }
      } else {
        path.removeAttribute('marker-start'); // Remove start marker if not bidirectional
      }
      
      path.setAttribute('marker-end', marker);
      path.classList.toggle('selected', !!(state.editorMode && state.selectedEdgeId===e.id));
      
      // Edge coloring priority: filter > scheme > per-edge custom
      const fEdgeColor = getFilterEdgeColor(fromId, toId, consolidatedEdges);
      const schemeEdgeColor = !fEdgeColor ? getEdgeSchemeColor(e) : '';
      const customEdgeColor = (!fEdgeColor && !schemeEdgeColor && e.color) ? e.color : '';
      const edgeColor = fEdgeColor || schemeEdgeColor || customEdgeColor;
      if(edgeColor && !inHL && !inActive){
        path.style.stroke = edgeColor;
        path.setAttribute('marker-end', getOrCreateFilterMarker(edgeColor, false));
        if(isBidirectional) path.setAttribute('marker-start', getOrCreateFilterMarker(edgeColor, true));
      } else { path.style.removeProperty('stroke'); }
      path.style.removeProperty('opacity');
      
      // Update tooltip on path
      const pathTitle = path.querySelector('title');
      if(pathTitle) pathTitle.textContent = tooltipText;
      
      // Update hitbox if it exists
      if(path.__hitbox){
        path.__hitbox.setAttribute('d', d);
        path.__hitbox.style.pointerEvents = 'stroke';
        // Update hitbox consolidated info too
        path.__hitbox.__consolidated = consolidatedEdges;
        path.__hitbox.__fromId = fromId;
        path.__hitbox.__toId = toId;
        path.__hitbox.__isBidirectional = isBidirectional;
        path.__hitbox.__isHiddenChain = isHiddenChain;
        path.__hitbox.__chainEdges = isHiddenChain ? e.chain : null;
        // Update tooltip text on hitbox
        const existingTitle = path.__hitbox.querySelector('title');
        if(existingTitle) existingTitle.textContent = tooltipText;
      }
  } else {
      // Create new path (fade-in)
      path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', d);
      path.classList.add('edge');
      path.dataset.edgeId = e.id;
      if(state.editorMode && state.selectedEdgeId===e.id) path.classList.add('selected');
      if(inHL) path.classList.add('hl');
      if(inActive) path.classList.add('active');
      if(shouldDimEdges && !inHL && !inActive){
        if(state.multiSelectArrowMode === 'selected' && !state.allArrows) path.classList.add('fadeOut');
        else path.classList.add('dimmed');
      }
      
      // Set dash pattern
      if(dashPattern){
        path.setAttribute('stroke-dasharray', dashPattern);
      }
      
      // Store consolidated edges info for click handler
      path.__consolidated = consolidatedEdges;
      path.__fromId = fromId;
      path.__toId = toId;
      path.__isBidirectional = isBidirectional;
      path.__isHiddenChain = isHiddenChain;
      path.__chainEdges = isHiddenChain ? e.chain : null;
      
      let marker = inActive ? 'url(#arrowActive)' : (inHL ? 'url(#arrowHL)' : 'url(#arrowDefault)');
      if(state.editorMode && state.selectedEdgeId===e.id){ marker = 'url(#arrowActive)'; }
      
      // Use bidirectional markers if this is a bidirectional consolidated arrow
      if(isBidirectional){
        const startMarker = inActive ? 'url(#arrowStartActive)' : (inHL ? 'url(#arrowStartHL)' : 'url(#arrowStartDefault)');
        if(state.editorMode && state.selectedEdgeId===e.id){ 
          path.setAttribute('marker-start', 'url(#arrowStartActive)');
        } else {
          path.setAttribute('marker-start', startMarker);
        }
      }
      
      path.setAttribute('marker-end', marker);
      
      // Edge coloring priority: filter > scheme > per-edge custom
      const fEdgeColor2 = getFilterEdgeColor(fromId, toId, consolidatedEdges);
      const schemeEdgeColor2 = !fEdgeColor2 ? getEdgeSchemeColor(e) : '';
      const customEdgeColor2 = (!fEdgeColor2 && !schemeEdgeColor2 && e.color) ? e.color : '';
      const edgeColor2 = fEdgeColor2 || schemeEdgeColor2 || customEdgeColor2;
      if(edgeColor2 && !inHL && !inActive){
        path.style.stroke = edgeColor2;
        path.setAttribute('marker-end', getOrCreateFilterMarker(edgeColor2, false));
        if(isBidirectional) path.setAttribute('marker-start', getOrCreateFilterMarker(edgeColor2, true));
      }

      const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
      title.textContent = tooltipText;
      path.appendChild(title);
      path.style.pointerEvents='none';
      
      // Create invisible hitbox path for easier clicking
      const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      hitbox.setAttribute('d', d);
      hitbox.classList.add('edge-hitbox');
      hitbox.dataset.edgeId = e.id;
      hitbox.setAttribute('stroke', 'transparent');
      hitbox.setAttribute('stroke-width', '12');
      hitbox.setAttribute('fill', 'none');
      hitbox.style.pointerEvents = 'stroke';
      hitbox.style.cursor = 'pointer';
      
      // Copy tooltip to hitbox (since hitbox captures pointer events, path's <title> won't show)
      const hitTitle = document.createElementNS('http://www.w3.org/2000/svg', 'title');
      hitTitle.textContent = tooltipText;
      hitbox.appendChild(hitTitle);
      
      // Store consolidated info on hitbox
      hitbox.__consolidated = consolidatedEdges;
      hitbox.__fromId = fromId;
      hitbox.__toId = toId;
      hitbox.__isBidirectional = isBidirectional;
      hitbox.__isHiddenChain = isHiddenChain;
      hitbox.__chainEdges = isHiddenChain ? e.chain : null;
      
      // Event handlers on hitbox
      hitbox.addEventListener('click', async (evt)=>{ 
        evt.stopPropagation(); 

        // Alt+click on edge: chain select using same logic as Alt+click on node
        // Check Alt BEFORE Ctrl so Alt+Ctrl (downstream) works
        if(evt.altKey){
          // Guard dirty edits before transitioning to multi-select
          if(state.editorMode && nodeEditIsDirty()){
            if(!await guardNodeAbandon()) return;
            revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
          }
          if(state.editorMode && edgeEditIsDirty()){
            const eid = __edgeEditSession?.edgeId || '';
            if(!await guardAbandonEdit('mapping', eid)) return;
          }
          // Snapshot ALL relevant state before any cleanup destroys it
          const _snapLocked = state.lockedId;
          const _snapMulti = new Set(state.multiSelection);
          const _snapEP = state._selectedEdgeEndpoints;

          // Clear edit sessions (guard already prompted above)
          __editSnapshot = null;
          __edgeEditSession = null;

          const fromId = hitbox.__fromId || e.from;
          const toId = hitbox.__toId || e.to;
          const isShiftMod = evt.shiftKey;
          const isCtrlMod = evt.ctrlKey || evt.metaKey;
          const direction = (isShiftMod && !isCtrlMod) ? 'upstream'
                          : (isCtrlMod && !isShiftMod) ? 'downstream'
                          : 'both';

          // Build prior selection from snapshot (not from current state)
          const prevSel = new Set(_snapMulti);
          if(_snapLocked) prevSel.add(_snapLocked);
          if(_snapEP){ prevSel.add(_snapEP.from); prevSel.add(_snapEP.to); }

          // Start building new selection with both edge endpoints
          const currentSel = new Set(prevSel);
          currentSel.add(fromId);
          currentSel.add(toId);

          if(direction === 'both'){
            if(prevSel.size > 0){
              // Check connectivity from prevSel
              const currentConnected = new Set();
              for(const nid of prevSel){
                const tmp = computeHighlightForNode(nid);
                for(const f of tmp.connectedFields) currentConnected.add(f);
              }
              const fromConnected = currentConnected.has(fromId);
              const toConnected = currentConnected.has(toId);

              if(fromConnected || toConnected){
                // For each connected endpoint NOT already in prevSel, find path back
                for(const nid of [fromId, toId]){
                  if(prevSel.has(nid)) continue; // already selected, skip
                  if(!currentConnected.has(nid)) continue; // not connected, skip
                  const visited = new Map();
                  const queue = [nid];
                  visited.set(nid, null);
                  let foundTarget = null;
                  while(queue.length > 0){
                    const cur = queue.shift();
                    if(prevSel.has(cur)){ foundTarget = cur; break; }
                    const adj = IDX.adjacency.get(cur);
                    if(adj) for(const nb of adj){
                      if(!visited.has(nb)){ visited.set(nb, cur); queue.push(nb); }
                    }
                  }
                  if(foundTarget !== null){
                    let cur = foundTarget;
                    while(cur !== null){ currentSel.add(cur); cur = visited.get(cur); }
                  }
                }
              } else {
                // Not connected to existing selection  full chain
                for(const nid of [fromId, toId]){
                  const chain = computeHighlightForNode(nid);
                  for(const f of chain.connectedFields) currentSel.add(f);
                }
              }
            } else {
              // No prior selection  full chain from both endpoints
              for(const nid of [fromId, toId]){
                const chain = computeHighlightForNode(nid);
                for(const f of chain.connectedFields) currentSel.add(f);
              }
            }
          } else {
            // Directional chain select
            for(const nid of [fromId, toId]){
              const directed = computeDirectedChain(nid, direction);
              for(const f of directed) currentSel.add(f);
            }
          }

          // Apply  set state from scratch
          state.multiSelection = currentSel;
          state._selectedEdgeEndpoints = null;
          state.selectedEdgeId = null;
          state.hoverEdgeId = null;
          state.lockedId = null;
          state.hoverId = null;
          state.selectedColumnId = null;
          if(state.multiSelection.size === 1){
            state.lockedId = [...state.multiSelection][0];
            state.multiSelection.clear();
          }
          applyHighlight();
          return;
        }

        // Ctrl+click: add/remove both edge endpoints to/from multi-selection
        if(evt.ctrlKey || evt.metaKey){
          // Guard dirty edits before transitioning to multi-select
          if(state.editorMode && nodeEditIsDirty()){
            if(!await guardNodeAbandon()) return;
            revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
          }
          if(state.editorMode && edgeEditIsDirty()){
            const eid = __edgeEditSession?.edgeId || '';
            if(!await guardAbandonEdit('mapping', eid)) return;
          }
          // Snapshot state before cleanup destroys it
          const _snapLocked = state.lockedId;
          const _snapMulti = new Set(state.multiSelection);
          const _snapEP = state._selectedEdgeEndpoints;

          // Clear edit sessions (guard already prompted above)
          __editSnapshot = null;
          __edgeEditSession = null;

          const fromId = hitbox.__fromId || e.from;
          const toId = hitbox.__toId || e.to;
          
          // Build selection from snapshot
          const newSel = new Set(_snapMulti);
          if(_snapLocked) newSel.add(_snapLocked);
          if(_snapEP){ newSel.add(_snapEP.from); newSel.add(_snapEP.to); }
          
          // Toggle: if both endpoints already in selection, remove them
          const bothIn = newSel.has(fromId) && newSel.has(toId);
          if(bothIn){
            newSel.delete(fromId);
            newSel.delete(toId);
          } else {
            newSel.add(fromId);
            newSel.add(toId);
          }
          
          // Apply from scratch
          state.multiSelection = newSel;
          state._selectedEdgeEndpoints = null;
          state.selectedEdgeId = null;
          state.hoverEdgeId = null;
          state.lockedId = null;
          state.hoverId = null;
          state.selectedColumnId = null;
          if(state.multiSelection.size === 1){
            state.lockedId = [...state.multiSelection][0];
            state.multiSelection.clear();
          }
          applyHighlight();
          return;
        }

        if(state.editorMode && nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        if(state.editorMode && edgeEditIsDirty()){
          const eid = __edgeEditSession?.edgeId || '';
          if(!await guardAbandonEdit('mapping', eid)) return;
        }
        
        // Check if this is a chain through hidden column(s)
        if(hitbox.__isHiddenChain && hitbox.__chainEdges){
          // Unhide all columns involved in the chain
          const columnsToUnhide = new Set();
          for(const chainEdge of hitbox.__chainEdges){
            const fromCol = columnOf(chainEdge.from);
            const toCol = columnOf(chainEdge.to);
            if(fromCol && state.hiddenColumns.has(fromCol)) columnsToUnhide.add(fromCol);
            if(toCol && state.hiddenColumns.has(toCol)) columnsToUnhide.add(toCol);
          }
          
          // Unhide the columns
          for(const colId of columnsToUnhide){
            state.hiddenColumns.delete(colId);
          }
          
          // Redraw to show the full chain
          renderAll();
          applyHighlight();
          scheduleArrowsUpdate();
          
          // Optionally select the first edge in the chain
          if(hitbox.__chainEdges.length > 0){
            const firstEdgeInChain = hitbox.__chainEdges[0];
            setTimeout(() => selectEdge(firstEdgeInChain.id), 100);
          }
          return;
        }
        
        // Check if this is collapsed groups or bidirectional fields
        const firstEdge = hitbox.__consolidated && hitbox.__consolidated[0];
        const isCollapsedGroups = firstEdge && (hitbox.__fromId !== firstEdge.from || hitbox.__toId !== firstEdge.to);
        const isBidirectional = hitbox.__isBidirectional;
        
        
        // Always select consolidated arrows (both collapsed groups and bidirectional)
        // Details panel will show all mappings with click-to-edit/view functionality
        selectEdge(e.id);
        
      });
      hitbox.addEventListener('mouseenter', ()=>{
        if(state.panMode) return;
        if(state._lassoActive) return;
        if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
        state.hoverEdgeId = e.id; applyHighlight();
      });
      hitbox.addEventListener('mouseleave', ()=>{
        if(state.panMode) return;
        if(state._lassoActive) return;
        if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
        state.hoverEdgeId = null; applyHighlight();
      });
      
      // Append visible path first, then hitbox on top
      edgesLayer.appendChild(path);
      edgesLayer.appendChild(hitbox);
      
      // Link hitbox to path for lifecycle management
      path.__hitbox = hitbox;
      
      // start transparent, then allow CSS to fade to target opacity
      path.style.opacity = '0';
      requestAnimationFrame(()=>{ path.style.opacity = ''; });
      path.__alive = true;
    }
  }

  // Fade out any paths not marked alive and disable their hitboxes
  const deadPaths = [];
  Array.from(edgesLayer.querySelectorAll('path.edge')).forEach(path=>{
    if(path.__alive) return;
    deadPaths.push(path.dataset.edgeId);
    // Remove immediately instead of fading - the fade causes the overlap issue
    if(path.__hitbox) path.__hitbox.remove();
    path.remove();
  });
  if(deadPaths.length > 0){
  }

  // Z-order: re-append highlighted  active  selected VISUAL paths only (not hitboxes).
  // Moving hitboxes in DOM triggers mouseleave/mouseenter thrashing, so we leave them in place.
  const hlPaths = [];
  const activePaths = [];
  const selectedPaths = [];
  Array.from(edgesLayer.querySelectorAll('path.edge')).forEach(p=>{
    if(p.classList.contains('selected')) selectedPaths.push(p);
    else if(p.classList.contains('active')) activePaths.push(p);
    else if(p.classList.contains('hl')) hlPaths.push(p);
  });
  for(const p of hlPaths) edgesLayer.appendChild(p);
  for(const p of activePaths) edgesLayer.appendChild(p);
  for(const p of selectedPaths) edgesLayer.appendChild(p);
}

/* =========================
   Tab navigation
========================= */
function setTab(name){
  state.tab = name;
  for(const [k, el] of Object.entries(views)){
    if(el) el.classList.toggle("active", k === name);
  }
  viewerControls.style.display = (name === "viewer") ? "flex" : "none";
  togglePopover(false);
  if(name === "viewer"){
    scheduleArrowsUpdate();
  }
}


// Docs modal
function openDocs(){
  buildDocs();
  const mask = document.getElementById('docsMask');
  const modal = document.getElementById('docsModal');
  if(mask) mask.classList.add('active');
  if(modal) modal.classList.add('active');
}
function closeDocs(){
  const mask = document.getElementById('docsMask');
  const modal = document.getElementById('docsModal');
  if(mask) mask.classList.remove('active');
  if(modal) modal.classList.remove('active');
}
const closeDocsBtn = document.getElementById('closeDocsBtn');
if(closeDocsBtn) closeDocsBtn.addEventListener('click', closeDocs);
const docsMask = document.getElementById('docsMask');
if(docsMask) docsMask.addEventListener('click', closeDocs);

// Bright mode toggle
(function(){
  const btn = document.getElementById('brightModeBtn');
  if(!btn) return;
  // Restore from localStorage
  try {
    if(localStorage.getItem('ms_brightMode') === '1'){
      document.body.classList.add('brightMode');
      btn.textContent = '';
      btn.title = 'Switch to dark mode';
    }
  } catch(e){}
  btn.addEventListener('click', ()=>{
    const on = document.body.classList.toggle('brightMode');
    btn.textContent = on ? '' : '';
    btn.title = on ? 'Switch to dark mode' : 'Switch to bright mode';
    try { localStorage.setItem('ms_brightMode', on ? '1' : '0'); } catch(e){}
    // Redraw arrows after CSS settles  mode toggle can shift row positions
    setTimeout(()=> scheduleArrowsUpdate(), 50);
  });
})();

// === Details Panel Mode Manager ===
(function(){
  const MODES = ['left','right','bottom','float','hidden'];
  const DOCK_MODES = ['left','right','bottom']; // modes that can be snapped to
  const viewerGrid = document.querySelector('.viewerGrid');
  const detailsPanel = document.getElementById('detailsPanel');
  const detailsHeader = document.getElementById('detailsHeader');
  const resizeHandle = document.getElementById('resizeHandle');
  const resizeHandleH = document.getElementById('resizeHandleH');
  const closeBtn = document.getElementById('detailsCloseBtn');
  const panelModeSelector = document.getElementById('panelModeSelector');
  const snapIndicator = document.getElementById('snapIndicator');
  const dockActions = document.getElementById('detailsDockActions');

  if(!viewerGrid || !detailsPanel) return;

  // Restore from localStorage
  try {
    const saved = localStorage.getItem('ms_panelMode');
    // Migrate old 'side' to 'right'
    const migrated = saved === 'side' ? 'right' : saved;
    if(migrated && MODES.includes(migrated)) state.panelMode = migrated;
    const savedW = localStorage.getItem('ms_panelWidth');
    if(savedW) state.panelWidth = Math.max(424, Math.min(800, Number(savedW)));
    const savedH = localStorage.getItem('ms_panelHeight');
    if(savedH) state.panelHeight = Math.max(100, Math.min(600, Number(savedH)));
  } catch(e){}

  // Responsive auto-detect on first load
  if(!localStorage.getItem('ms_panelMode')){
    if(window.innerWidth < 1000) state.panelMode = 'bottom';
  }

  function updateSelectorHighlight(mode){
    if(!panelModeSelector) return;
    panelModeSelector.querySelectorAll('.dockOpt').forEach(b=>{
      b.classList.toggle('active', b.dataset.mode === mode);
    });
  }

  function positionResizeHandles(){
    if(!resizeHandle || !resizeHandleH) return;
    if(state.panelMode === 'right' || state.panelMode === 'left'){
      const detRect = detailsPanel.getBoundingClientRect();
      const gridRect = viewerGrid.getBoundingClientRect();
      if(state.panelMode === 'right'){
        resizeHandle.style.left = (detRect.left - gridRect.left - 6) + 'px';
      } else {
        resizeHandle.style.left = (detRect.right - gridRect.left - 6) + 'px';
      }
    } else if(state.panelMode === 'bottom'){
      const detRect = detailsPanel.getBoundingClientRect();
      const gridRect = viewerGrid.getBoundingClientRect();
      resizeHandleH.style.top = (detRect.top - gridRect.top - 6) + 'px';
    }
  }

  function applyPanelMode(mode, save){
    state.panelMode = mode;
    viewerGrid.setAttribute('data-panel', mode);
    updateSelectorHighlight(mode);

    // Reset inline styles and order
    detailsPanel.style.cssText = '';
    // Reset float-only state when leaving float mode
    detailsPanel.classList.remove('minimized');
    const _minBtn = document.getElementById('detailsMinBtn');
    if(_minBtn){ _minBtn.textContent = ''; _minBtn.title = 'Minimize panel'; }
    const _opPop = document.getElementById('opacityPopover');
    if(_opPop) _opPop.style.display = 'none';

    if(mode === 'right'){
      viewerGrid.style.gridTemplateColumns = `1fr ${state.panelWidth}px`;
      viewerGrid.style.gridTemplateRows = '1fr';
    } else if(mode === 'left'){
      viewerGrid.style.gridTemplateColumns = `${state.panelWidth}px 1fr`;
      viewerGrid.style.gridTemplateRows = '1fr';
    } else if(mode === 'bottom'){
      viewerGrid.style.gridTemplateColumns = '1fr';
      if(state.panelHeight){
        viewerGrid.style.gridTemplateRows = `1fr ${state.panelHeight}px`;
      } else {
        viewerGrid.style.gridTemplateRows = '1fr calc(30vh - 28px)';
      }
    } else if(mode === 'float'){
      viewerGrid.style.gridTemplateColumns = '1fr';
      viewerGrid.style.gridTemplateRows = '1fr';
      // Default position: bottom-right area of viewport
      let floatTop = window.innerHeight - 400;
      let floatLeft = window.innerWidth - 464;
      let floatW = 444, floatH = 380;
      try {
        const pos = JSON.parse(localStorage.getItem('ms_floatPos') || '{}');
        // Migrate old right/bottom format to top/left
        if(pos.right !== undefined && pos.top === undefined){
          pos.left = window.innerWidth - (pos.right || 16) - (pos.width || 444);
          pos.top = window.innerHeight - (pos.bottom || 16) - (pos.height || 380);
          delete pos.right; delete pos.bottom;
          localStorage.setItem('ms_floatPos', JSON.stringify(pos));
        }
        if(pos.top !== undefined) floatTop = pos.top;
        if(pos.left !== undefined) floatLeft = pos.left;
        if(pos.width) floatW = pos.width;
        if(pos.height) floatH = pos.height;
      } catch(e){}
      // Clamp so top stays on screen
      floatTop = Math.max(0, Math.min(floatTop, window.innerHeight - 60));
      floatLeft = Math.max(-floatW + 80, Math.min(floatLeft, window.innerWidth - 80));
      detailsPanel.style.top = floatTop + 'px';
      detailsPanel.style.left = floatLeft + 'px';
      detailsPanel.style.width = floatW + 'px';
      detailsPanel.style.height = floatH + 'px';
      // Start fully visible; mouseleave will apply inactive opacity
      detailsPanel.style.opacity = '1';
    } else {
      viewerGrid.style.gridTemplateColumns = '1fr';
      viewerGrid.style.gridTemplateRows = '1fr';
    }

    if(save !== false){
      try { localStorage.setItem('ms_panelMode', mode); } catch(e){}
    }
    renderDockActions(mode);
    setTimeout(()=>{ positionResizeHandles(); scheduleArrowsUpdate(); }, 60);
  }

  // SVG icon templates for dock actions
  const DOCK_ICONS = {
    left:   '<svg width="14" height="12" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="5" height="12" rx="1" fill="currentColor" opacity=".5"/></svg>',
    right:  '<svg width="14" height="12" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="10" y="1" width="5" height="12" rx="1" fill="currentColor" opacity=".5"/></svg>',
    bottom: '<svg width="14" height="12" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="9" width="14" height="4" rx="1" fill="currentColor" opacity=".5"/></svg>',
    float:  '<svg width="14" height="12" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1" stroke-dasharray="2,2" opacity=".5"/><rect x="5" y="3" width="9" height="8" rx="1.5" fill="currentColor" opacity=".4" stroke="currentColor" stroke-width=".7"/><path d="M3.5,5 L1.5,3 M1.5,3 L1.5,5 M1.5,3 L3.5,3" stroke="currentColor" stroke-width="1" fill="none" stroke-linecap="round" opacity=".7"/></svg>',
  };
  const DOCK_LABELS = { left:'Dock left', right:'Dock right', bottom:'Dock bottom', float:'Pop out' };

  // Dynamically render dock action buttons based on current mode
  function renderDockActions(mode){
    if(!dockActions) return;
    // Determine which actions to show: the alternatives to the current mode
    let actions = [];
    if(mode === 'right')  actions = ['left','bottom','float'];
    else if(mode === 'left')   actions = ['right','bottom','float'];
    else if(mode === 'bottom') actions = ['left','right','float'];
    else if(mode === 'float')  actions = ['left','bottom','right'];
    else { dockActions.innerHTML = ''; return; }

    dockActions.innerHTML = actions.map(a =>
      `<button class="dockAction" data-dock="${a}" title="${DOCK_LABELS[a] || a}">${DOCK_ICONS[a] || ''}</button>`
    ).join('');

    // Wire click handlers
    dockActions.querySelectorAll('.dockAction').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        const target = btn.dataset.dock;
        if(target && MODES.includes(target)) applyPanelMode(target, true);
      });
    });
  }

  // Wire Layout popover selector buttons
  if(panelModeSelector){
    panelModeSelector.querySelectorAll('.dockOpt').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        const mode = btn.dataset.mode;
        if(mode && MODES.includes(mode)) applyPanelMode(mode, true);
      });
    });
  }

  // Close button  hidden
  if(closeBtn){
    closeBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      applyPanelMode('hidden', true);
    });
  }

  // Default size button  reset panel dimensions
  const defaultBtn = document.getElementById('detailsDefaultBtn');
  if(defaultBtn){
    defaultBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      state.panelWidth = 444;
      state.panelHeight = null;
      try {
        localStorage.removeItem('ms_panelWidth');
        localStorage.removeItem('ms_panelHeight');
        localStorage.removeItem('ms_floatPos');
      } catch(ex){}
      applyPanelMode(state.panelMode, true);
      setTimeout(()=>{ positionResizeHandles(); scheduleArrowsUpdate(); }, 30);
    });
  }

  // === Minimize toggle (float mode only) ===
  const minBtn = document.getElementById('detailsMinBtn');
  if(minBtn){
    minBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const isMin = detailsPanel.classList.toggle('minimized');
      minBtn.textContent = isMin ? '' : '';
      minBtn.title = isMin ? 'Expand panel' : 'Minimize panel';
    });
  }

  // === Float panel: fade on mouse-leave ===
  let floatInactiveOpacity = 0.30;
  try {
    const saved = parseFloat(localStorage.getItem('ms_floatOpacity'));
    if(saved >= 0.1 && saved <= 1) floatInactiveOpacity = saved;
  } catch(e){}

  let _floatHovered = false;
  detailsPanel.addEventListener('mouseenter', ()=>{
    _floatHovered = true;
    if(state.panelMode === 'float') detailsPanel.style.opacity = '1';
  });
  detailsPanel.addEventListener('mouseleave', ()=>{
    _floatHovered = false;
    if(state.panelMode === 'float') detailsPanel.style.opacity = floatInactiveOpacity;
  });

  // === Opacity popover ===
  const opacityBtn = document.getElementById('detailsOpacityBtn');
  const opacityPop = document.getElementById('opacityPopover');
  const opacitySlider = document.getElementById('opacitySlider');
  const opacityVal = document.getElementById('opacityVal');
  if(opacityBtn && opacityPop && opacitySlider){
    opacitySlider.value = Math.round(floatInactiveOpacity * 100);
    if(opacityVal) opacityVal.textContent = Math.round(floatInactiveOpacity * 100) + '%';

    opacityBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const show = opacityPop.style.display === 'none';
      opacityPop.style.display = show ? 'block' : 'none';
    });
    // Prevent slider interaction from triggering panel drag
    opacityPop.addEventListener('mousedown', (e)=> e.stopPropagation());
    opacitySlider.addEventListener('input', ()=>{
      floatInactiveOpacity = parseInt(opacitySlider.value) / 100;
      if(opacityVal) opacityVal.textContent = opacitySlider.value + '%';
      if(!_floatHovered && state.panelMode === 'float'){
        detailsPanel.style.opacity = floatInactiveOpacity;
      }
      try { localStorage.setItem('ms_floatOpacity', floatInactiveOpacity); } catch(e){}
    });
    // Close popover on outside click
    document.addEventListener('click', (e)=>{
      if(!opacityBtn.contains(e.target) && !opacityPop.contains(e.target)){
        opacityPop.style.display = 'none';
      }
    });
  }

  // === Side mode resize handle (horizontal  works for both left and right) ===
  if(resizeHandle){
    let startX = 0, startW = 0, dragging = false;
    resizeHandle.addEventListener('mousedown', (e)=>{
      if(state.panelMode !== 'right' && state.panelMode !== 'left') return;
      e.preventDefault();
      dragging = true;
      startX = e.clientX;
      startW = detailsPanel.getBoundingClientRect().width;
      resizeHandle.classList.add('active');
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const dir = (state.panelMode === 'right') ? -1 : 1;
      const delta = (e.clientX - startX) * dir;
      const newW = Math.max(424, Math.min(800, startW + delta));
      state.panelWidth = newW;
      if(state.panelMode === 'right'){
        viewerGrid.style.gridTemplateColumns = `1fr ${newW}px`;
      } else {
        viewerGrid.style.gridTemplateColumns = `${newW}px 1fr`;
      }
      // Keep handle glued to the cursor
      positionResizeHandles();
      scheduleArrowsUpdate();
    });
    document.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging = false;
      resizeHandle.classList.remove('active');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      try { localStorage.setItem('ms_panelWidth', String(state.panelWidth)); } catch(e){}
      setTimeout(()=>{ positionResizeHandles(); scheduleArrowsUpdate(); }, 30);
    });
  }

  // === Bottom mode resize handle (vertical) ===
  if(resizeHandleH){
    let startY = 0, startH = 0, dragging = false;
    resizeHandleH.addEventListener('mousedown', (e)=>{
      if(state.panelMode !== 'bottom') return;
      e.preventDefault();
      dragging = true;
      startY = e.clientY;
      startH = detailsPanel.getBoundingClientRect().height;
      resizeHandleH.classList.add('active');
      document.body.style.cursor = 'row-resize';
      document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const delta = startY - e.clientY;
      const newH = Math.max(100, Math.min(window.innerHeight * 0.7, startH + delta));
      state.panelHeight = newH;
      viewerGrid.style.gridTemplateRows = `1fr ${newH}px`;
      // Keep handle glued to the cursor
      positionResizeHandles();
      scheduleArrowsUpdate();
    });
    document.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging = false;
      resizeHandleH.classList.remove('active');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      try { localStorage.setItem('ms_panelHeight', String(state.panelHeight)); } catch(e){}
      setTimeout(()=>{ positionResizeHandles(); scheduleArrowsUpdate(); }, 30);
    });
  }

  // === Snap-to-edge detection ===
  const SNAP_THRESHOLD = 48; // px from edge to trigger snap
  function detectSnapZone(clientX, clientY){
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    if(clientX < SNAP_THRESHOLD) return 'left';
    if(clientX > vw - SNAP_THRESHOLD) return 'right';
    if(clientY > vh - SNAP_THRESHOLD) return 'bottom';
    return null;
  }

  function showSnapPreview(zone){
    if(!snapIndicator) return;
    const headerH = document.querySelector('header')?.getBoundingClientRect()?.height || 0;
    const mainPad = 14;
    // Reset all positioning
    snapIndicator.style.cssText = 'display:block;position:fixed;z-index:175;';
    if(zone === 'left'){
      snapIndicator.style.left = mainPad + 'px';
      snapIndicator.style.top = (headerH + mainPad) + 'px';
      snapIndicator.style.width = '35%';
      snapIndicator.style.height = `calc(100vh - ${headerH + mainPad*2}px)`;
    } else if(zone === 'right'){
      snapIndicator.style.right = mainPad + 'px';
      snapIndicator.style.top = (headerH + mainPad) + 'px';
      snapIndicator.style.width = '35%';
      snapIndicator.style.height = `calc(100vh - ${headerH + mainPad*2}px)`;
    } else if(zone === 'bottom'){
      snapIndicator.style.left = mainPad + 'px';
      snapIndicator.style.bottom = mainPad + 'px';
      snapIndicator.style.width = `calc(100vw - ${mainPad*2}px)`;
      snapIndicator.style.height = '35%';
    }
  }

  function hideSnapPreview(){
    if(snapIndicator) snapIndicator.style.display = 'none';
  }

  // === Floating panel drag  entire header is grab area with snap-to-edge ===
  if(detailsHeader){
    let startX = 0, startY = 0, startTop = 0, startLeft = 0, dragging = false;
    let currentSnap = null;

    detailsHeader.addEventListener('mousedown', (e)=>{
      if(state.panelMode !== 'float') return;
      if(e.target.closest('button') || e.target.closest('a') || e.target.closest('input')) return;
      e.preventDefault();
      dragging = true;
      currentSnap = null;
      const rect = detailsPanel.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      startTop = rect.top;
      startLeft = rect.left;
      document.body.style.cursor = 'move';
      document.body.style.userSelect = 'none';
    });

    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      // Clamp top so at least 40px of header stays visible
      const newTop = Math.max(-10, Math.min(window.innerHeight - 40, startTop + dy));
      const newLeft = Math.max(-detailsPanel.offsetWidth + 80, startLeft + dx);
      detailsPanel.style.top = newTop + 'px';
      detailsPanel.style.left = newLeft + 'px';

      // Snap detection
      const zone = detectSnapZone(e.clientX, e.clientY);
      if(zone !== currentSnap){
        currentSnap = zone;
        if(zone) showSnapPreview(zone);
        else hideSnapPreview();
      }
    });

    document.addEventListener('mouseup', (e)=>{
      if(!dragging) return;
      dragging = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      hideSnapPreview();

      // If snapped to an edge, dock there
      if(currentSnap && DOCK_MODES.includes(currentSnap)){
        applyPanelMode(currentSnap, true);
        currentSnap = null;
        return;
      }
      currentSnap = null;

      // Save floating position
      try {
        const rect = detailsPanel.getBoundingClientRect();
        localStorage.setItem('ms_floatPos', JSON.stringify({
          top: rect.top,
          left: rect.left,
          width: rect.width,
          height: rect.height
        }));
      } catch(e){}
    });
  }

  // === Float panel resize handle (custom corner drag) ===
  const floatResizeHandle = document.getElementById('floatResizeHandle');
  if(floatResizeHandle){
    let startX = 0, startY = 0, startW = 0, startH = 0, dragging = false;
    floatResizeHandle.addEventListener('mousedown', (e)=>{
      if(state.panelMode !== 'float') return;
      e.preventDefault();
      e.stopPropagation();
      dragging = true;
      const rect = detailsPanel.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      startW = rect.width;
      startH = rect.height;
      document.body.style.cursor = 'nwse-resize';
      document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const newW = Math.max(420, startW + (e.clientX - startX));
      const newH = Math.max(160, startH + (e.clientY - startY));
      detailsPanel.style.width = newW + 'px';
      detailsPanel.style.height = newH + 'px';
    });
    document.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      // Save size
      try {
        const rect = detailsPanel.getBoundingClientRect();
        const pos = JSON.parse(localStorage.getItem('ms_floatPos') || '{}');
        pos.width = rect.width;
        pos.height = rect.height;
        localStorage.setItem('ms_floatPos', JSON.stringify(pos));
      } catch(e){}
    });
  }

  // Keyboard shortcut: D to toggle panel (when not in input)
  document.addEventListener('keydown', (e)=>{
    if(e.target.closest('input, textarea, select, [contenteditable]')) return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;
    if(e.key === 'd' || e.key === 'D'){
      e.preventDefault();
      // Toggle: if hidden, restore last docked mode; if visible, hide
      if(state.panelMode === 'hidden'){
        const last = localStorage.getItem('ms_panelModeLast') || 'right';
        applyPanelMode(MODES.includes(last) && last !== 'hidden' ? last : 'right', true);
      } else {
        try { localStorage.setItem('ms_panelModeLast', state.panelMode); } catch(e){}
        applyPanelMode('hidden', true);
      }
    }
  });

  // Reposition handles on window resize + clamp float panel
  window.addEventListener('resize', ()=>{
    positionResizeHandles();
    if(window.innerWidth < 900 && (state.panelMode === 'right' || state.panelMode === 'left')){
      applyPanelMode('bottom', false);
    }
    // Keep float panel visible on screen
    if(state.panelMode === 'float'){
      const rect = detailsPanel.getBoundingClientRect();
      let changed = false;
      if(rect.top > window.innerHeight - 40){
        detailsPanel.style.top = (window.innerHeight - 40) + 'px';
        changed = true;
      }
      if(rect.left > window.innerWidth - 80){
        detailsPanel.style.left = (window.innerWidth - 80) + 'px';
        changed = true;
      }
      if(rect.top < -10){
        detailsPanel.style.top = '0px';
        changed = true;
      }
      if(changed){
        try {
          const r = detailsPanel.getBoundingClientRect();
          const pos = JSON.parse(localStorage.getItem('ms_floatPos') || '{}');
          pos.top = r.top; pos.left = r.left;
          localStorage.setItem('ms_floatPos', JSON.stringify(pos));
        } catch(e){}
      }
    }
  });

  // Apply initial mode
  applyPanelMode(state.panelMode, false);
})();

// === Pan mode for viewer (press P to toggle) ===
(function(){
  const scroller = document.getElementById('columnsScroller');
  if(!scroller) return;
  let panning = false;
  let startX = 0, startY = 0, scrollStartX = 0, scrollStartY = 0;

  function setPanMode(on){
    state.panMode = on;
    scroller.classList.toggle('panReady', on);
    if(on){
      // Clear any hover highlight
      if(state.hoverId || state.hoverEdgeId){
        state.hoverId = null;
        state.hoverEdgeId = null;
        applyHighlight();
      }
    }
    if(!on){
      panning = false;
      scroller.classList.remove('panning');
    }
    // Show status hint
    const status = document.getElementById('viewerStatus');
    if(status && on) status.textContent = 'Pan mode  drag to scroll, press P or Esc to exit';
    // Update pan toggle button
    const panBtn = document.getElementById('panToggleBtn');
    if(panBtn){
      panBtn.style.opacity = on ? '1' : '.6';
      panBtn.style.background = on ? 'rgba(59,130,246,.18)' : '';
      panBtn.style.borderColor = on ? 'rgba(59,130,246,.5)' : '';
    }
  }

  // Pan toggle button
  const panToggleBtn = document.getElementById('panToggleBtn');
  if(panToggleBtn) panToggleBtn.addEventListener('click', ()=> setPanMode(!state.panMode));

  document.addEventListener('keydown', (e)=>{
    if(e.target.closest('input, textarea, select, [contenteditable]')) return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;
    if(e.key === 'p' || e.key === 'P'){
      e.preventDefault();
      setPanMode(!state.panMode);
    }
    if(e.key === 'Escape' && state.panMode){
      setPanMode(false);
    }
  });

  scroller.addEventListener('mousedown', (e)=>{
    if(!state.panMode) return;
    e.preventDefault();
    e.stopPropagation();
    panning = true;
    startX = e.clientX;
    startY = e.clientY;
    scrollStartX = scroller.scrollLeft;
    scrollStartY = scroller.scrollTop;
    scroller.classList.add('panning');
    scroller.classList.remove('panReady');
  });

  document.addEventListener('mousemove', (e)=>{
    if(!panning) return;
    scroller.scrollLeft = scrollStartX - (e.clientX - startX);
    scroller.scrollTop = scrollStartY - (e.clientY - startY);
  });

  document.addEventListener('mouseup', ()=>{
    if(!panning) return;
    panning = false;
    scroller.classList.remove('panning');
    if(state.panMode) scroller.classList.add('panReady');
  });

  window.addEventListener('blur', ()=>{
    if(state.panMode) setPanMode(false);
  });

  // During pan mode, forward wheel events to the column .tree under the cursor
  // (pointer-events:none on children blocks native wheel scrolling)
  scroller.addEventListener('wheel', (e)=>{
    if(!state.panMode) return;
    // Temporarily enable pointer-events to hit-test the real element
    scroller.classList.remove('panReady', 'panning');
    const el = document.elementFromPoint(e.clientX, e.clientY);
    scroller.classList.add(panning ? 'panning' : 'panReady');
    const tree = el && (el.closest('.tree') || (el.classList && el.classList.contains('tree') ? el : null));
    if(tree && tree.scrollHeight > tree.clientHeight){
      tree.scrollTop += e.deltaY;
      e.preventDefault();
    }
  }, {passive: false});
})();

// --- Marquee / lasso select ---
(function(){
  const scroller = document.getElementById('columnsScroller');
  const rectEl = document.getElementById('lassoRect');
  const lassoSvg = document.getElementById('lassoSvg');
  const lassoPoly = document.getElementById('lassoPolygon');
  if(!scroller || !rectEl) return;

  let active = false, startX = 0, startY = 0, dragging = false;
  let freeform = false; // Alt  freeform lasso
  let points = [];      // freeform path points [{x,y}]

  // Point-in-polygon (ray casting)
  function pointInPolygon(px, py, poly){
    let inside = false;
    for(let i = 0, j = poly.length - 1; i < poly.length; j = i++){
      const xi = poly[i].x, yi = poly[i].y;
      const xj = poly[j].x, yj = poly[j].y;
      if(((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)){
        inside = !inside;
      }
    }
    return inside;
  }

  // Convert client coords to scroller-space
  function toScrollerXY(e){
    const rect = scroller.getBoundingClientRect();
    const zoom = parseFloat(scroller.style.zoom) || 1;
    return {
      x: (e.clientX - rect.left) / zoom + scroller.scrollLeft,
      y: (e.clientY - rect.top) / zoom + scroller.scrollTop
    };
  }

  scroller.addEventListener('mousedown', (e) => {
    if(state.panMode) return;
    if(e.button !== 0) return;
    if(document.querySelector('.modal.active')) return;
    const t = e.target;
    if(t.closest('.row') || t.closest('.btn') || t.closest('input') || t.closest('select') ||
       t.closest('label') || t.closest('.panelHeader') || t.closest('.tagChip') ||
       t.closest('.rowActions') || t.closest('.caret') || t.closest('path') || t.closest('svg') ||
       t.closest('.modal') || t.closest('.tbPop') || t.closest('.popover')) return;
    const p = toScrollerXY(e);
    startX = p.x; startY = p.y;
    freeform = e.altKey;
    points = [p];
    active = true;
    dragging = false;
  });

  document.addEventListener('mousemove', (e) => {
    if(!active) return;
    const p = toScrollerXY(e);
    if(!dragging && Math.abs(p.x - startX) < 5 && Math.abs(p.y - startY) < 5) return;
    if(!dragging){
      dragging = true;
      state._lassoActive = true;
      // Suppress hover highlights during marquee/lasso
      state.hoverId = null;
      state.hoverEdgeId = null;
      scroller.classList.add('lassoActive');
      document.body.style.userSelect = 'none';
    }

    if(freeform){
      // Freeform lasso: collect points (skip if too close to last)
      const last = points[points.length - 1];
      const dx = p.x - last.x, dy = p.y - last.y;
      if(dx*dx + dy*dy > 16){ // min 4px distance
        points.push(p);
      }
      // Draw polygon
      const pts = points.map(pt => `${pt.x},${pt.y}`).join(' ');
      lassoPoly.setAttribute('points', pts);
      lassoSvg.style.display = 'block';
      lassoSvg.setAttribute('width', scroller.scrollWidth);
      lassoSvg.setAttribute('height', scroller.scrollHeight);
      rectEl.style.display = 'none';
    } else {
      // Rectangle marquee
      const left = Math.min(startX, p.x), top = Math.min(startY, p.y);
      rectEl.style.cssText = `display:block;position:absolute;left:${left}px;top:${top}px;width:${Math.abs(p.x-startX)}px;height:${Math.abs(p.y-startY)}px;border:1.5px dashed rgba(59,130,246,.7);background:rgba(59,130,246,.08);border-radius:2px;pointer-events:none;z-index:9999;`;
      lassoSvg.style.display = 'none';
    }
    e.preventDefault();
  });

  document.addEventListener('mouseup', async (e) => {
    if(!active) return;
    active = false;
    if(dragging) document.body.style.userSelect = '';
    const wasDragging = dragging;
    dragging = false;
    state._lassoActive = false;
    scroller.classList.remove('lassoActive');

    const wasFreeform = freeform;
    const wasRectVisible = rectEl.style.display === 'block';
    const wasLassoVisible = lassoSvg.style.display === 'block';
    rectEl.style.display = 'none';
    lassoSvg.style.display = 'none';

    if(!wasDragging || (!wasRectVisible && !wasLassoVisible)) return;

    const zoom = parseFloat(scroller.style.zoom) || 1;
    const sRect = scroller.getBoundingClientRect();
    const hits = new Set();

    if(wasFreeform && points.length >= 3){
      // Freeform: point-in-polygon on each node center
      for(const [nid, rowEl] of IDX.rowById.entries()){
        if(!rowEl.offsetParent) continue;
        const el = IDX.elementById.get(nid);
        if(el && el.classList.contains('hidden')) continue;
        const rr = rowEl.getBoundingClientRect();
        const cx = (rr.left - sRect.left + rr.width/2) / zoom + scroller.scrollLeft;
        const cy = (rr.top - sRect.top + rr.height/2) / zoom + scroller.scrollTop;
        if(pointInPolygon(cx, cy, points)) hits.add(nid);
      }
    } else if(!wasFreeform && wasRectVisible){
      // Rectangle: AABB intersection
      const p = toScrollerXY(e);
      const lassoL = Math.min(startX, p.x), lassoT = Math.min(startY, p.y);
      const lassoR = Math.max(startX, p.x), lassoB = Math.max(startY, p.y);
      for(const [nid, rowEl] of IDX.rowById.entries()){
        if(!rowEl.offsetParent) continue;
        const el = IDX.elementById.get(nid);
        if(el && el.classList.contains('hidden')) continue;
        const rr = rowEl.getBoundingClientRect();
        const nL = (rr.left - sRect.left) / zoom + scroller.scrollLeft;
        const nT = (rr.top - sRect.top) / zoom + scroller.scrollTop;
        const nR = nL + rr.width / zoom;
        const nB = nT + rr.height / zoom;
        if(nL < lassoR && nR > lassoL && nT < lassoB && nB > lassoT) hits.add(nid);
      }
    }

    if(hits.size > 0){
      if(state.editorMode && nodeEditIsDirty()){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      if(state.editorMode && edgeEditIsDirty()){
        const eid = __edgeEditSession?.edgeId || '';
        if(!await guardAbandonEdit('mapping', eid)) return;
      }
      if(state.editorMode && __editSnapshot){
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }

      // Clear any edge selection  marquee transitions to node multi-select
      // But preserve edge endpoints for Shift-add / Ctrl-subtract mode
      const _prevEdgeEP = state._selectedEdgeEndpoints;
      state._selectedEdgeEndpoints = null;
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
      state.selectedColumnId = null;

      const isAdd = e.shiftKey;
      const isSubtract = (e.ctrlKey || e.metaKey);

      if(isSubtract){
        if(state.lockedId && state.multiSelection.size === 0){
          state.multiSelection.add(state.lockedId);
          state.lockedId = null;
        }
        // Preserve edge endpoints into multi-select
        if(_prevEdgeEP && state.multiSelection.size === 0){
          state.multiSelection.add(_prevEdgeEP.from);
          state.multiSelection.add(_prevEdgeEP.to);
        }
        for(const nid of hits) state.multiSelection.delete(nid);
      } else if(isAdd){
        if(state.lockedId && state.multiSelection.size === 0){
          state.multiSelection.add(state.lockedId);
          state.lockedId = null;
        }
        // Preserve edge endpoints into multi-select
        if(_prevEdgeEP && state.multiSelection.size === 0){
          state.multiSelection.add(_prevEdgeEP.from);
          state.multiSelection.add(_prevEdgeEP.to);
        }
        for(const nid of hits) state.multiSelection.add(nid);
      } else {
        state.multiSelection.clear();
        state.lockedId = null;
        for(const nid of hits) state.multiSelection.add(nid);
      }
      state.hoverId = null;
      state._lassoJustCompleted = Date.now();
      applyHighlight();
    }
  });
})();




/* =========================
 Column manager (show/hide + reorder)
========================= */
function togglePopover(on){
  columnsPopover.classList.toggle('active', !!on);
}
function buildColumnsMenu(){
  if(!state.data) return;
  const cols = state.data.columns || [];
  // Dynamic title
  const popTitle = document.querySelector('#columnsPopover .popTitle');
  if(popTitle) popTitle.textContent = 'Columns';
  columnsList.innerHTML = '';
  let __colDragIdx = null;
  cols.forEach((c, idx) => {
    const row = document.createElement('div');
    row.className = 'popItem';
    row.dataset.colIdx = idx;
    if(state.editorMode){
      row.draggable = true;
      row.style.cursor = 'grab';
      row.addEventListener('dragstart', (e)=>{
        __colDragIdx = idx;
        row.style.opacity = '0.4';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', '');
      });
      row.addEventListener('dragend', ()=>{
        row.style.opacity = '';
        columnsList.querySelectorAll('.popItem').forEach(r=>r.classList.remove('dragOver'));
        __colDragIdx = null;
      });
      row.addEventListener('dragover', (e)=>{
        e.preventDefault(); e.dataTransfer.dropEffect = 'move';
        columnsList.querySelectorAll('.popItem').forEach(r=>r.classList.remove('dragOver'));
        row.classList.add('dragOver');
      });
      row.addEventListener('dragleave', ()=>{ row.classList.remove('dragOver'); });
      row.addEventListener('drop', (e)=>{
        e.preventDefault();
        row.classList.remove('dragOver');
        const toIdx = parseInt(row.dataset.colIdx);
        if(__colDragIdx === null || __colDragIdx === toIdx) return;
        recordChange();
        const [moved] = cols.splice(__colDragIdx, 1);
        cols.splice(toIdx, 0, moved);
        jsonArea.value = JSON.stringify(state.data, null, 2);
        rebuildStructuredList();
        renderAll();
        buildColumnsMenu();
      });
    }

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = !state.hiddenColumns.has(c.id);
    cb.addEventListener('change', () => {
      if(cb.checked) state.hiddenColumns.delete(c.id);
      else state.hiddenColumns.add(c.id);
      // Reset selection when column visibility changes
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
      state.lockedId = null;
      state.hoverId = null;
      renderAll();
      togglePopover(true);
    });

    const grow = document.createElement('div');
    grow.className = 'grow';
    grow.innerHTML = `<div style=\"font-weight:900;font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;\">${escapeHtml(c.label || c.id)}</div>`+
                     `<div style=\"font-family:var(--mono);font-size:11px;opacity:.78;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;\">${escapeHtml(c.id)}</div>`;

    const up = document.createElement('button');
    up.className = 'btn';
    up.textContent = '';
    up.title = 'Move earlier';
    up.disabled = idx === 0;
    up.addEventListener('click', (e) => {
      e.stopPropagation();
      if(idx<=0) return;
      recordChange(); // Save BEFORE reordering
      const a = cols[idx-1]; cols[idx-1] = cols[idx]; cols[idx] = a;
      jsonArea.value = JSON.stringify(state.data, null, 2);
      rebuildStructuredList();
      renderAll();
      buildColumnsMenu();
    });

    const down = document.createElement('button');
    down.className = 'btn';
    down.textContent = '';
    down.title = 'Move later';
    down.disabled = idx === cols.length-1;
    down.addEventListener('click', (e) => {
      e.stopPropagation();
      if(idx>=cols.length-1) return;
      recordChange(); // Save BEFORE reordering
      const a = cols[idx+1]; cols[idx+1] = cols[idx]; cols[idx] = a;
      jsonArea.value = JSON.stringify(state.data, null, 2);
      rebuildStructuredList();
      renderAll();
      buildColumnsMenu();
    });

    row.appendChild(cb);
    row.appendChild(grow);
    // Click anywhere on row toggles visibility
    row.addEventListener('click', (e)=>{
      if(e.target === cb || e.target.closest('button')) return;
      cb.checked = !cb.checked;
      cb.dispatchEvent(new Event('change'));
    });
    row.style.cursor = state.editorMode ? 'grab' : 'pointer';
    if(state.editorMode){
      row.appendChild(up);
      row.appendChild(down);
      const del = document.createElement('button');
      del.className = 'btn';
      del.innerHTML = '';
      del.title = 'Delete column';
      del.style.cssText = 'font-size:11px;padding:2px 4px;margin-left:2px;color:rgba(255,120,120,.7);border-color:rgba(255,120,120,.25);background:rgba(255,120,120,.06);transition:all .15s;';
      del.addEventListener('mouseenter', ()=>{ del.style.background='rgba(255,120,120,.18)'; del.style.borderColor='rgba(255,120,120,.45)'; del.style.color='rgba(255,120,120,.95)'; });
      del.addEventListener('mouseleave', ()=>{ del.style.background='rgba(255,120,120,.06)'; del.style.borderColor='rgba(255,120,120,.25)'; del.style.color='rgba(255,120,120,.7)'; });
      del.addEventListener('click', async (e) => {
        e.stopPropagation();
        await deleteColumnById(c.id);
        // Rebuild columns menu (popover stays open)
        buildColumnsMenu();
        togglePopover(true);
      });
      row.appendChild(del);
    }
    columnsList.appendChild(row);
  });
  // Show/hide add column buttons inside popover
  const addBtnsWrap = document.getElementById('colPopAddBtns');
  if(addBtnsWrap) addBtnsWrap.style.display = state.editorMode ? 'inline-flex' : 'none';
  const nCols = cols.length;
  if(addColumnLeftBtn){
    addColumnLeftBtn.innerHTML = nCols === 0 ? '+ Add column' : ' Add left';
  }
  if(addColumnRightBtn){
    addColumnRightBtn.innerHTML = 'Add right ';
    addColumnRightBtn.style.display = nCols > 0 ? '' : 'none';
  }
}
function hideUnmappedColumns(){
  const colHasMapped = new Map();
  IDX.columns.forEach(c => colHasMapped.set(c.id, false));
  for(const fid of IDX.mappedFields){
    const c = columnOf(fid);
    if(c) colHasMapped.set(c, true);
  }
  for(const [cid, has] of colHasMapped.entries()){
    if(!has) state.hiddenColumns.add(cid);
  }
  renderAll();
}
/* =========================
   Viewer control wiring
========================= */

// ----- Toolbar popover toggle system -----
{
  // Filter bar toggle (not a popover  simple show/hide)
  const filterToggleBtn = document.getElementById('tbFilterToggle');
  const filterBar = document.getElementById('tbFilterBar');
  if(filterToggleBtn && filterBar){
    filterToggleBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const show = filterBar.style.display === 'none';
      filterBar.style.display = show ? '' : 'none';
      filterToggleBtn.classList.toggle('active', show);
      // Focus search when opening
      if(show){ const si = document.getElementById('searchInput'); if(si) si.focus(); }
    });
  }

  const tbBtns = document.querySelectorAll('.tbRow2 > .tbBtn:not(#tbFilterToggle)');
  function closeAllPopovers(){
    document.querySelectorAll('.tbPop').forEach(p => p.classList.remove('open'));
    tbBtns.forEach(b => b.classList.remove('active'));
  }
  tbBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
      // Clicking a .btn inside popover  close popover (it's an action button like Export CSV)
      const innerBtn = e.target.closest('.tbPop .btn');
      if(innerBtn){ setTimeout(closeAllPopovers, 80); return; }
      // Clicking toggles/sliders inside popover  keep open
      if(e.target.closest('.tbPop')) return;
      e.stopPropagation();
      const pop = btn.querySelector('.tbPop');
      if(!pop) return;
      const isOpen = pop.classList.contains('open');
      closeAllPopovers();
      if(!isOpen){ pop.classList.add('open'); btn.classList.add('active'); }
    });
  });
  // Close popovers on outside click
  document.addEventListener('click', (e) => {
    if(!e.target.closest('.tbBtn')) closeAllPopovers();
  });
  // Close on Escape
  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape') closeAllPopovers();
  });
}

const goDocsBtn = document.getElementById('goDocsBtn');
if(goDocsBtn) goDocsBtn.addEventListener('click', ()=>{ if(typeof openDocs==='function') openDocs(); });

if(searchInput) searchInput.addEventListener("input", () => {
  state.search = searchInput.value || "";
  updateFilterBadge();
  refreshViewer();
});

if(clearFilterBtn) clearFilterBtn.addEventListener("click", () => {
  state.search = "";
  if(searchInput) searchInput.value = "";
  state.onlyMapped = false;
  if(onlyMappedToggle) onlyMappedToggle.checked = false;
  const omWrap = document.getElementById('onlyMappedWrap');
  if(omWrap) omWrap.classList.remove('active');
  state.activeFilterIds = [];
  state.filterMode = 'hide';
  updateFilterModeUI();
  state.filterLogic = 'or';
  updateFilterLogicUI();
  renderActiveFilterChips();
  updateFilterBadge();
  refreshViewer();
});

if(onlyMappedToggle) onlyMappedToggle.addEventListener("change", () => {
  state.onlyMapped = !!onlyMappedToggle.checked;
  const wrap = document.getElementById('onlyMappedWrap');
  if(wrap) wrap.classList.toggle('active', state.onlyMapped);
  updateFilterBadge();
  refreshViewer();
});

// Filter display mode selector (Hide | Dim | Highlight)
const filterModeGroup = document.getElementById('filterModeGroup');
const FILTER_MODES = ['hide', 'dim', 'highlight'];
function updateFilterModeUI(){
  if(!filterModeGroup) return;
  filterModeGroup.querySelectorAll('.fbOpt').forEach(b => {
    b.classList.toggle('active', b.dataset.fmode === state.filterMode);
  });
}
function updateFilterModeBtn(){ updateFilterModeUI(); }
if(filterModeGroup){
  filterModeGroup.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-fmode]');
    if(!btn) return;
    state.filterMode = btn.dataset.fmode;
    updateFilterModeUI();
    refreshViewer();
  });
}

// AND/OR logic selector
const filterLogicGroup = document.getElementById('filterLogicGroup');
function updateFilterLogicUI(){
  if(!filterLogicGroup) return;
  filterLogicGroup.querySelectorAll('.fbOpt').forEach(b => {
    b.classList.toggle('active', b.dataset.flogic === state.filterLogic);
  });
}
if(filterLogicGroup){
  filterLogicGroup.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-flogic]');
    if(!btn) return;
    state.filterLogic = btn.dataset.flogic;
    updateFilterLogicUI();
    refreshViewer();
  });
}

// Filter catalog modal
const filtersBtn = document.getElementById('filtersBtn');
const filtersMask = document.getElementById('filtersMask');
const filtersModal = document.getElementById('filtersModal');
const closeFiltersBtn = document.getElementById('closeFiltersBtn');
const addFilterBtn = document.getElementById('addFilterBtn');

function openFilters(){
  ensureFilterCatalog();
  __filterEditId = null;
  __filterEditSnapshot = null;
  renderFiltersManager();
  if(addFilterBtn) addFilterBtn.style.display = state.editorMode ? '' : 'none';
  filtersMask?.classList.add('active');
  filtersModal?.classList.add('active');
}
async function closeFilters(){
  if(__filterEditId && filterFormIsDirty()){
    const cat = ensureFilterCatalog();
    const f = cat.find(x => x.id === __filterEditId);
    if(!await guardAbandonEdit(f?.label || __filterEditId, __filterEditId)) return;
    // Revert in-place rule changes
    if(__filterEditSnapshot){
      const snap = JSON.parse(__filterEditSnapshot);
      if(f && snap.rules) f.rules = snap.rules;
    }
  }
  __filterEditId = null;
  __filterEditSnapshot = null;
  filtersMask?.classList.remove('active');
  filtersModal?.classList.remove('active');
  renderActiveFilterChips();
  refreshViewer();
}
if(filtersBtn) filtersBtn.addEventListener('click', openFilters);
if(closeFiltersBtn) closeFiltersBtn.addEventListener('click', closeFilters);
if(filtersMask) filtersMask.addEventListener('click', closeFilters);
if(addFilterBtn) addFilterBtn.addEventListener('click', async ()=>{
  if(!await guardFilterAbandon()) return;
  const cat = ensureFilterCatalog();
  const id = 'filter_' + Date.now().toString(36);
  const minPri = cat.reduce((m,f)=>Math.min(m, typeof f.priority==='number'?f.priority:0), 0);
  cat.push({
    id, label: '', note: '', priority: minPri - 1,
    rules: [{ field:'tag', op:'has', value:'' }],
    highlight: { bg:'#3b82f6', border:'#3b82f6', edgeColor:'#3b82f6', frameColor:'#3b82f6', bold:false, frame:false, emoji:'', bgEnabled:true, borderEnabled:true, edgeEnabled:false }
  });
  __filterEditId = id;
  __filterIsNew = true;
  const newF = cat[cat.length - 1];
  __filterEditSnapshot = JSON.stringify(newF);
  checkDirtyState();
  renderFiltersManager();
});

// Initialize chips
renderActiveFilterChips();
updateFilterBadge();

// Arrow mode selector (Selected | All | Off)
let updateArrowModeUI = ()=>{};
{
  const arrowModeSelector = document.getElementById('arrowModeSelector');
  updateArrowModeUI = function(){
    if(!arrowModeSelector) return;
    const mode = !state.arrowsOn ? 'off' : (state.allArrows ? 'all' : 'selected');
    arrowModeSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.amode === mode));
  };
  if(arrowModeSelector){
    arrowModeSelector.addEventListener('click', (e)=>{
      const opt = e.target.closest('[data-amode]');
      if(!opt) return;
      const mode = opt.dataset.amode;
      if(mode === 'off'){ state.arrowsOn = false; state.allArrows = false; }
      else if(mode === 'all'){ state.arrowsOn = true; state.allArrows = true; }
      else { state.arrowsOn = true; state.allArrows = false; }
      svgOverlay.style.display = state.arrowsOn ? "block" : "none";
      updateArrowModeUI();
      scheduleArrowsUpdate();
    });
  }
  // Arrow scope toggles
  if(showSameColToggle) showSameColToggle.addEventListener("change", () => {
    state.showSameColumn = !!showSameColToggle.checked;
    scheduleArrowsUpdate();
  });
  if(showDistantToggle) showDistantToggle.addEventListener("change", () => {
    state.showDistant = !!showDistantToggle.checked;
    scheduleArrowsUpdate();
  });
}

{
  const dimSelector = document.getElementById('dimModeSelector');
  if(dimSelector){
    dimSelector.addEventListener('click', (e)=>{
      const opt = e.target.closest('.dockOpt');
      if(!opt) return;
      const mode = opt.dataset.dim;
      if(!mode) return;
      state.selectionDim = mode;
      dimSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.remove('active'));
      opt.classList.add('active');
      refreshViewer();
    });
  }
  const multiArrowSel = document.getElementById('multiArrowModeSelector');
  if(multiArrowSel){
    multiArrowSel.addEventListener('click', (e)=>{
      const opt = e.target.closest('.dockOpt');
      if(!opt) return;
      const mode = opt.dataset.mode;
      if(!mode) return;
      state.multiSelectArrowMode = mode;
      multiArrowSel.querySelectorAll('.dockOpt').forEach(b => b.classList.remove('active'));
      opt.classList.add('active');
      refreshViewer();
    });
  }
}

// Edge color scheme
{
  const edgeColorSel = document.getElementById('edgeColorSelector');
  if(edgeColorSel){
    edgeColorSel.addEventListener('click', (e)=>{
      const opt = e.target.closest('.dockOpt');
      if(!opt) return;
      const scheme = opt.dataset.scheme;
      if(scheme === undefined) return;
      state.edgeColorScheme = scheme;
      edgeColorSel.querySelectorAll('.dockOpt').forEach(b => b.classList.remove('active'));
      opt.classList.add('active');
      refreshEdgeColorScheme();
      scheduleArrowsUpdate();
    });
    // Hover preview: temporarily show legend for hovered scheme
    let _hoverActive = false;
    edgeColorSel.addEventListener('mouseover', (e)=>{
      const opt = e.target.closest('.dockOpt');
      if(!opt) return;
      const scheme = opt.dataset.scheme;
      if(scheme === undefined) return;
      if(!scheme){ // "Off" button
        const legend = document.getElementById('edgeColorLegend');
        if(legend){ legend.style.display = 'none'; }
        _hoverActive = true;
        return;
      }
      // Temporarily compute + show legend for hovered scheme
      const savedScheme = state.edgeColorScheme;
      const savedMap = __edgeSchemeMap;
      __edgeSchemeMap = new Map();
      state.edgeColorScheme = scheme;
      if(IDX && IDX.edges) for(const edge of IDX.edges) getEdgeSchemeColor(edge);
      buildEdgeSchemeLegend();
      state.edgeColorScheme = savedScheme;
      __edgeSchemeMap = savedMap;
      _hoverActive = true;
    });
    edgeColorSel.addEventListener('mouseleave', ()=>{
      if(!_hoverActive) return;
      _hoverActive = false;
      buildEdgeSchemeLegend(); // restore to actual selection
    });
  }
}

if(wrapToggle) wrapToggle.addEventListener("change", () => {
  state.wrapColumns = !!wrapToggle.checked;
  renderAll();
});

// Node label display toggles
(function(){
  const tagPillsToggle = document.getElementById('showTagPillsToggle');
  const attrPillsToggle = document.getElementById('showAttrPillsToggle');
  if(tagPillsToggle){
    tagPillsToggle.checked = state.showTagPills;
    tagPillsToggle.addEventListener('change', ()=>{
      state.showTagPills = !!tagPillsToggle.checked;
      renderAll();
    });
  }
  if(attrPillsToggle){
    attrPillsToggle.checked = state.showAttrPills;
    attrPillsToggle.addEventListener('change', ()=>{
      state.showAttrPills = !!attrPillsToggle.checked;
      renderAll();
    });
  }
})();

// Node color mode selector
(function(){
  const ncmSelector = document.getElementById('nodeColorModeSelector');
  if(ncmSelector){
    ncmSelector.addEventListener('click', (e)=>{
      const btn = e.target.closest('.dockOpt[data-ncm]');
      if(!btn) return;
      const mode = btn.dataset.ncm;
      state.nodeColorMode = mode;
      ncmSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderAll();
    });
  }
})();

// Column width & gap sliders
(function(){
  const widthSlider = document.getElementById('colWidthSlider');
  const widthVal = document.getElementById('colWidthVal');
  const gapSlider = document.getElementById('colGapSlider');
  const gapVal = document.getElementById('colGapVal');
  
  // Restore from localStorage
  try {
    const savedW = localStorage.getItem('ms_colWidth');
    const savedG = localStorage.getItem('ms_colGap');
    if(savedW){ widthSlider.value = savedW; widthVal.textContent = savedW; columnsRow.style.setProperty('--col-width', savedW + 'px'); }
    if(savedG){ gapSlider.value = savedG; gapVal.textContent = savedG; columnsRow.style.setProperty('--col-gap', savedG + 'px'); }
  } catch(e){}
  
  function applyWidth(v){
    columnsRow.style.setProperty('--col-width', v + 'px');
    widthVal.textContent = v;
    // Recalc min-width for scroll
    const visibleCols = IDX.columns.filter(c => !state.hiddenColumns.has(c.id));
    const minW = state.wrapColumns ? 0 : Math.max(920, visibleCols.length * (parseInt(v) + 20));
    columnsRow.style.minWidth = minW + 'px';
    try { localStorage.setItem('ms_colWidth', v); } catch(e){}
    scheduleArrowsUpdate();
  }
  function applyGap(v){
    columnsRow.style.setProperty('--col-gap', v + 'px');
    gapVal.textContent = v;
    try { localStorage.setItem('ms_colGap', v); } catch(e){}
    scheduleArrowsUpdate();
  }
  if(widthSlider){ widthSlider.addEventListener('input', ()=> applyWidth(widthSlider.value)); }
  if(gapSlider){ gapSlider.addEventListener('input', ()=> applyGap(gapSlider.value)); }

  // Inline reset buttons per slider
  const widthResetBtn = document.getElementById('colWidthReset');
  const gapResetBtn = document.getElementById('colGapReset');
  if(widthResetBtn){
    widthResetBtn.addEventListener('click', ()=>{
      if(widthSlider){ widthSlider.value = 300; applyWidth(300); }
    });
  }
  if(gapResetBtn){
    gapResetBtn.addEventListener('click', ()=>{
      if(gapSlider){ gapSlider.value = 20; applyGap(20); }
    });
  }

  // Zoom / density slider
  const zoomSlider = document.getElementById('colZoomSlider');
  const zoomVal = document.getElementById('colZoomVal');
  const zoomResetBtn = document.getElementById('colZoomReset');
  function applyZoom(v){
    const pct = Number(v);
    columnsScroller.style.zoom = (pct / 100);
    zoomVal.textContent = pct + '%';
    try { localStorage.setItem('ms_colZoom', v); } catch(e){}
    scheduleArrowsUpdate();
  }
  try {
    const savedZ = localStorage.getItem('ms_colZoom');
    if(savedZ){ zoomSlider.value = savedZ; applyZoom(savedZ); }
  } catch(e){}
  if(zoomSlider){ zoomSlider.addEventListener('input', ()=> applyZoom(zoomSlider.value)); }
  if(zoomResetBtn){
    zoomResetBtn.addEventListener('click', ()=>{
      if(zoomSlider){ zoomSlider.value = 100; applyZoom(100); }
    });
  }
})();

if(columnsBtn) columnsBtn.addEventListener("click", () => {
  buildColumnsMenu();
  togglePopover(!columnsPopover.classList.contains('active'));
});
if(closeColumnsBtn) closeColumnsBtn.addEventListener("click", () => togglePopover(false));
if(showAllColsBtn) showAllColsBtn.addEventListener("click", () => {
  state.hiddenColumns.clear();
  renderAll();
  buildColumnsMenu();
  togglePopover(true);
});
if(hideUnmappedColsBtn) hideUnmappedColsBtn.addEventListener("click", () => {
  hideUnmappedColumns();
  buildColumnsMenu();
  togglePopover(true);
});
document.addEventListener('click', (e) => {
  if(!columnsPopover.classList.contains('active')) return;
  const t = e.target;
  if(t === columnsBtn || t === showAllColumnsBtn || columnsPopover.contains(t)) return;
  // Don't close popover when interacting with modals/dialogs layered on top
  if(t.closest('.modal') || t.closest('.modalMask')) return;
  togglePopover(false);
});

function downloadText(name, mime, content){
  const blob = new Blob([content], {type: mime});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 600);
}
function csvEscape(v){
  const s = (v===null||v===undefined) ? '' : String(v);
  if(/[\n\r,\"]/g.test(s)) return '"' + s.replace(/\"/g,'""') + '"';
  return s;
}
if(exportCsvBtn) exportCsvBtn.addEventListener('click', () => {
  if(!state.data) return;
  const rows = [];
  rows.push(['from','to','fromColumn','toColumn','cardinality','default','transforms','note'].join(','));
  for(const e of IDX.edges){
    if(!isVisibleNodeId(e.from) || !isVisibleNodeId(e.to)) continue;
    if(!edgeScopeVisible(e.from, e.to)) continue;
    rows.push([
      csvEscape(e.from), csvEscape(e.to),
      csvEscape(columnOf(e.from)||''), csvEscape(columnOf(e.to)||''),
      csvEscape(e.cardinality||''),
      csvEscape(e.default||''),
      csvEscape(formatTransform(e.transform)||''),
csvEscape(e.note||'')
    ].join(','));
  }
  downloadText('mappings.csv', 'text/csv;charset=utf-8', rows.join('\n'));
  setGlobalStatus('Exported CSV for currently visible mappings.');
});


if(exportReportBtn) exportReportBtn.addEventListener('click', () => {
  if(!state.data) return;
  const now = new Date().toISOString();
  const summary = `Columns: ${IDX.columns.length}  Fields: ${IDX.fieldIds.size}  Edges: ${IDX.edges.length}`;
  const edgeRows = [];
  for(const e of IDX.edges){
    if(!isVisibleNodeId(e.from) || !isVisibleNodeId(e.to)) continue;
    edgeRows.push(`<tr><td><code>${escapeHtml(e.from)}</code></td><td></td><td><code>${escapeHtml(e.to)}</code></td>`+
      `<td>${escapeHtml(e.cardinality||'')}</td><td>${escapeHtml(e.default||'')}</td>`+
      `<td>${escapeHtml(short(formatTransform(e.transform)||'', 80))}</td>`+
      `<td>${escapeHtml(short(e.note||'', 120))}</td></tr>`);
  }
  const html = `<!doctype html><html><head><meta charset='utf-8'/><meta name='viewport' content='width=device-width,initial-scale=1'/>`+
  `<title>Dunnode Report</title><style>body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:20px;color:#111}`+
  `h1{margin:0 0 6px 0} .muted{color:#555} table{border-collapse:collapse;width:100%;margin-top:14px}`+
  `th,td{border:1px solid #ddd;padding:8px;vertical-align:top;font-size:12px}`+
  `th{background:#f6f6f6;text-align:left} code{font-family:ui-monospace,Consolas,monospace;font-size:11px}`+
  `
/* --- Inline Editor Mode (2026-02) --- */
#editorOverlay{position:absolute; inset:0; z-index:30; pointer-events:none;}
body.editorMode #editorOverlay{pointer-events:none;}






/* Row hover actions */
.row .rowActions{margin-left:8px; display:flex; gap:6px; align-items:center; opacity:0; transition: opacity .12s ease;}
body.editorMode .row:hover .rowActions{opacity:1;}
body.editorMode .row.menuOpen .rowActions{display:flex !important; opacity:1 !important; pointer-events:auto !important;}
body.editorMode .active > .row .rowActions{display:flex !important; opacity:1 !important; pointer-events:auto !important;}
.miniBtn{border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.14); color: rgba(232,238,252,.92);
  width:24px; height:24px; border-radius:10px; cursor:pointer; font-weight:900; font-size:13px; line-height:1;
  display:flex; align-items:center; justify-content:center;}
.miniBtn:hover{background: rgba(255,255,255,.08);}
.miniBtn.danger{border-color: rgba(255,154,168,.38); background: rgba(255,154,168,.10);}
.miniBtn.danger:hover{background: rgba(255,154,168,.18);}

/* Tag chips (replace field/group badges) */
.tagStrip{display:flex;gap:6px;align-items:center;flex:0 0 auto;}
.tagChip{font-family: var(--mono); font-size: 10px; padding:2px 6px; border-radius:999px; border:1px solid rgba(59,130,246,.55); background: rgba(59,130,246,.18); color: rgba(232,238,252,.95); line-height:1;}
.tagChip[data-color]{border-color: color-mix(in srgb, var(--c) 70%, rgba(255,255,255,.12)); background: color-mix(in srgb, var(--c) 22%, transparent);}
/* Inline action menu */
.miniMenu{position:absolute; right: 6px; top: 30px; z-index: 999; border:1px solid rgba(255,255,255,.14); border-radius: 12px; background: rgba(11,16,32,.95); box-shadow: 0 18px 50px rgba(0,0,0,.45); padding: 6px; display:none; gap:6px;}
.miniMenu.active{display:flex;}
.miniMenu .miniBtn{width:auto;padding:6px 8px;border-radius:10px;}
/* Hover menus */

/* Tag create swatches */
.swatch{width:22px;height:22px;border-radius:8px;border:1px solid rgba(255,255,255,.18);cursor:pointer;box-shadow:0 10px 24px rgba(0,0,0,.25);}
.swatch:hover{transform: translateY(-1px);}
.swatch.sel{outline:2px solid rgba(255,255,255,.60); outline-offset:2px;}



/* Drag & drop */
body.editorMode .node.field .row{cursor: grab;}
body.editorMode .node.field .row:active{cursor: grabbing;}
.row.dropTarget{outline: 2px solid rgba(59,130,246,.80); background: rgba(59,130,246,.12);}
.row.illegal{cursor:not-allowed !important;}

/* Make SVG clickable in editor mode */
#svgOverlay{pointer-events:none;}
body.editorMode #svgOverlay{pointer-events:none;}
body.editorMode .edge{
 transition: opacity .14s ease;
 stroke-linecap: round;
 stroke-linejoin: round;pointer-events:none;}
body.editorMode .edge.selected{stroke: rgba(255,208,92,.98); stroke-width: 3.0;}



/* --- Mapping list hard overrides (v6_5): force field label on its own line --- */
.detailsBody .item{flex-wrap:wrap !important; align-items:flex-start !important;}
.detailsBody .item > .txt{flex: 1 1 100% !important; width:100% !important; display:block !important; margin-top:2px !important; font-weight:800;}
.detailsBody .item .itemActions{margin-left:auto !important;}
.detailsBody .item .pill, .detailsBody .item .tag{flex: 0 0 auto;}

.box.clickable{cursor:pointer;}
.box.clickable:hover{background: rgba(255,255,255,.06);}
body.brightMode .box.clickable:hover{background: rgba(0,0,0,.05);}

/* --- Drag ghost (visual-only) --- */
#dragGhost{
  position:fixed; z-index:3000; pointer-events:none; display:none;
  background:rgba(11,16,32,.96);
  border:1px solid rgba(255,255,255,.14);
  border-radius:10px; padding:6px 8px; color:#e8eefc;
  font:12px var(--sans); box-shadow:0 12px 32px rgba(0,0,0,.45);
  max-width:480px; opacity:.98;
}
#dragGhost .top {display:flex; align-items:center; gap:8px; margin-bottom:6px;}
#dragGhost .chip {
  font-family: var(--mono, ui-monospace, Consolas, monospace);
  font-size:10px; padding:2px 6px; border-radius:999px;
  border:1px solid rgba(255,255,255,.22); line-height:1;
  background:rgba(255,255,255,.06);
}
#dragGhost .chip.move { border-color:#3b82f6; background:rgba(59,130,246,.20); color:#fff; }
#dragGhost .chip.copy { border-color:#22c55e; background:rgba(34,197,94,.18); color:#fff; }
#dragGhost .chip.copyPlus { border-color:#84cc16; background:rgba(132,204,22,.20); color:#fff; }
#dragGhost .chip.map  { border-color:#f59e0b; background:rgba(245,158,11,.18); color:#fff; }
#dragGhost .label { font-weight:900; letter-spacing:.2px; }
#dragGhost .body  { opacity:.92; }
#dragGhost .multiBadge {
  font-family: var(--mono, ui-monospace, Consolas, monospace);
  font-size:10px; font-weight:800; padding:2px 5px; border-radius:999px;
  background:rgba(255,255,255,.12); color:rgba(255,255,255,.85);
  line-height:1; display:none;
}


/* === Empty-column drop placeholder (v20.5) === */
body.editorMode .panel[data-empty="1"].dropOpen .emptyDrop { display: block; }
.emptyDrop { display: none;
  margin: 10px; border: 2px dashed rgba(59,130,246,.55); border-radius: 10px;
  padding: 12px 10px; color: rgba(232,238,252,.88); background: rgba(59,130,246,.08);
  font-size: 12px; text-align: center; user-select: none;
}
.emptyDrop.copy { border-color:#22c55e; background: rgba(34,197,94,.10); }
.emptyDrop.move { border-color:#3b82f6; background: rgba(59,130,246,.10); }


/* --- v23 header polish --- */
.brand .logo{filter:drop-shadow(0 2px 6px rgba(0,0,0,.25));}
.modeToggle.prominent{border-color: rgba(255,208,92,.55); background: rgba(255,208,92,.16);} 
.modeToggle.prominent:hover{background: rgba(255,208,92,.22);} 
.modeToggle.prominent input{accent-color:#f59e0b;}


/* v23.2.1: keep title visible when header wraps */
.brand{flex:1 1 260px; min-width:260px;}
.brand h1{display:block; max-width:48vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}


/* v23.2.2: ensure brand title remains visible */
.brand{flex:1 1 280px; min-width:260px}
.brand h1{display:block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:55vw}


/* v23.2.3b: ensure quick toolbar is visible and spaced */
#toolbarQuick{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 2px 0}
#toolbarQuick .btn{font-weight:700}

</style></head><body>`+
  `<h1>Dunnode  Exported report</h1><div class='muted'>Generated ${now}</div>`+
  `<div class='muted'>${escapeHtml(summary)}</div>`+
  `<h2>Mappings (visible in viewer at export time)</h2>`+
  `<table><thead><tr><th>From</th><th></th><th>To</th><th>Card</th><th>Default</th><th>Transforms</th><th>Note</th></tr></thead>`+
  `<tbody>${edgeRows.join('\n')}</tbody></table>`+
  `<h2>Embedded JSON</h2><pre><code>${escapeHtml(JSON.stringify(state.data, null, 2))}</code></pre>`+
  `</body></html>`;
  downloadText('mapping-report.html', 'text/html;charset=utf-8', html);
  setGlobalStatus('Exported HTML report.');
});

function openHelp(){
  helpBody.innerHTML = `
<div style="text-align:center;padding:18px 0 20px;margin-bottom:16px;border-bottom:1px solid var(--border);">
<div style="font-size:20px;font-weight:800;letter-spacing:1.2px;text-transform:uppercase;">Dunnode</div>
<div style="font-size:12px;font-weight:600;opacity:.5;letter-spacing:.4px;margin-top:2px;">Done. Now.</div>
<div style="font-size:11.5px;opacity:.45;margin-top:6px;">A lightweight mapping studio for complex flows.</div>
</div>
<h4 style="margin:0 0 6px;">1. Load data</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Load example</b> &mdash; try the built-in sample project to explore features.</li>
  <li><b>Open project</b> &mdash; load your own <code>.json</code> file.</li>
  <li><b>New project</b> &mdash; start with a blank two-column layout.</li>
</ul>

<h4 style="margin:14px 0 6px;">2. Explore mappings</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Hover</b> any field to see its mapping chain highlighted across all columns.</li>
  <li><b>Click</b> a field to lock the selection &mdash; scroll freely while connections stay visible.</li>
  <li><b>Click an arrow</b> to inspect a specific mapping (cardinality, transforms, notes).</li>
  <li><b>Multi-select</b>: Ctrl/Cmd+click to toggle nodes. Shift+click for range within a column. Alt+click for chain select (Alt+Shift=upstream, Alt+Ctrl=downstream). Drag on empty space for marquee select (Shift=add, Ctrl/Cmd=subtract). Alt+drag for freeform lasso.</li>
  <li><b>Esc</b> clears selection and search.</li>
</ul>

<h4 style="margin:14px 0 6px;">3. Edit your model</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li>Toggle <b>Editor mode</b> (top-right) to unlock editing.</li>
  <li><b>Add nodes</b>: hover a row to reveal  (add child) and  (context menu) buttons.</li>
  <li><b>Create mappings</b>: drag a field onto a field in another column.</li>
  <li><b>Edit properties</b>: click any field/mapping and use the Details pane on the right.</li>
  <li><b>Drag-and-drop</b>: reorder, move, copy, or map nodes using modifier keys:</li>
  <li style="list-style:none;margin-left:4px;font-size:11.5px;line-height:1.5;opacity:.85;">
    No modifier = Move &nbsp;&nbsp; Alt/Opt = Map &nbsp;&nbsp; Ctrl/Cmd = Copy &nbsp;&nbsp; Ctrl/Cmd+Alt/Opt = Copy with mappings
  </li>
  <li><b>Multi-select drag</b>: with multiple nodes selected, drag any selected node to bulk Move, Copy, Copy+, or Map all selected nodes at once. Children of selected groups are automatically deduplicated.</li>
  <li><b>Ctrl+Z / Ctrl+Y</b> (Cmd on Mac) to undo and redo any change.</li>
  <li><b>Ctrl+A</b> (Cmd+A) &mdash; select all visible nodes. <b>Ctrl+Shift+I</b> (Cmd+Shift+I) &mdash; invert selection. Also in the Selection menu.</li>
  <li><b>Ctrl+K</b> (Cmd+K) &mdash; command palette: search all commands, jump to any node by name, or search the documentation.</li>
  <li><b>D</b> &mdash; toggle details panel. <b>P</b> &mdash; pan mode (drag to scroll). <b>Esc</b> &mdash; clear selection.</li>
  <li><b>Toolbar buttons</b>: <b></b> toggles pan mode, <b></b> clears the current selection.</li>
</ul>

<h4 style="margin:14px 0 6px;">4. Filter &amp; highlight</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li>Click <b></b> to open the filter bar &mdash; type to search nodes, toggle <b>Only mapped</b> to focus.</li>
  <li>Open the <b>Filters</b> catalog () to create rule-based filters with colored highlights.</li>
  <li>Toggle active filters via checkboxes &mdash; chips appear in the filter bar.</li>
  <li><b>Display mode</b> (<b>Hide</b> / <b>Dim</b> / <b>Highlight</b>) &mdash; segmented selector controls how non-matching nodes appear.</li>
  <li><b>AND / OR</b> &mdash; segmented selector controls whether nodes must match ALL or ANY active filter. Search is always ANDed with filters.</li>
</ul>

<h4 style="margin:14px 0 6px;">5. Organize with catalogs</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Tags</b> &mdash; colored labels for nodes (e.g. Active, Draft, Retired). Drag to set priority order.</li>
  <li><b>Transforms</b> &mdash; reusable data conversion steps attached to mappings (e.g. Trim, Uppercase). Supports per-instance parameters.</li>
  <li><b>Custom attributes</b> &mdash; domain metadata on nodes (e.g. Data Type, Sensitivity). Each attribute can have its own <b>color</b> (inherited by values without their own). Each value has a color with an <b>Apply</b> checkbox &mdash; unchecked values inherit from the attribute color. Enable "Display on node" per attribute to show value pills on tree nodes. Pill order: Tags &gt; Attribute priority &gt; Value priority.</li>
  <li><b>Filters</b> &mdash; rule-based visual highlights (see section 4 above). Also managed from the  catalog toolbar group.</li>
  <li><b>Inline editing</b> &mdash; click <b>Add</b> to create items directly inside the catalog list. Click any existing item to edit it in place.</li>
  <li><b>Auto-ID &amp; abbreviation</b> &mdash; ID and abbreviation auto-generate from the label as you type. A blue <b style="font-size:9px;padding:1px 4px;border-radius:4px;background:rgba(59,130,246,.15);color:rgba(130,180,255,.8);">auto</b> badge shows when a field is linked. Edit the field to override; clear it to re-link.</li>
  <li><b>Save / Cancel / Delete</b> &mdash; Save activates when you make changes. New items have no Delete button. Label is required to save.</li>
</ul>

<h4 style="margin:14px 0 6px;">6. Save &amp; share</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Save project</b> &mdash; downloads your complete project as JSON. Blue button = unsaved changes.</li>
  <li><b>Export CSV</b> &mdash; all visible mappings as a spreadsheet-ready file.</li>
  <li><b>Export report</b> &mdash; standalone HTML snapshot for stakeholders.</li>
</ul>

<h4 style="margin:14px 0 6px;">Useful tips</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Columns</b> &mdash; hide/show/reorder columns. Hide unused ones to reduce noise.</li>
  <li><b>Only mapped</b> &mdash; filter to fields that have mappings.</li>
  <li><b>Arrow mode</b> &mdash; <b>Selected</b> (only hovered/selected), <b>All</b> (every arrow), or <b>Off</b>.</li>
  <li><b>Arrow scope</b> &mdash; toggle same-column and distant arrows independently.</li>
  <li><b> button</b> &mdash; edit project properties (title, author, description, etc.).</li>
  <li><b>Bright mode</b> &mdash; toggle light/dark theme.</li>
  <li><b>Unsaved changes</b> &mdash; Save buttons turn <span style="color:#f59e0b;font-weight:700;">yellow</span> when there are pending changes. Navigating away from unsaved edits prompts a confirmation.</li>
  <li><b>Dim others</b> (Selection menu) &mdash; choose how unselected nodes dim: <b>All</b>, <b>Parents</b> (keep groups visible), or <b>Off</b>.</li>
  <li><b>Highlight mode</b> (Selection menu) &mdash; <b>Chain</b> (full chain), <b>Direct</b> (adjacent only), or <b>Selected</b> (just the selection).</li>
  <li><b>Highlight colors</b> (Selection menu) &mdash; customize the Selected / Hovered and Connected highlight colors via picker or swatches. Live preview tester included. Colors saved to project file (Editor mode only).</li>
  <li><b>Zoom</b> (Layout popover) &mdash; scale the viewer from 50% to 150% for density control.</li>
  <li><b>Node &amp; mapping colors</b> &mdash; set a custom color on any field or mapping for at-a-glance visual coding.</li>
  <li><b>Color priority (nodes)</b> &mdash; Selection/hover &rarr; Filters &rarr; Node color (applied) &rarr; Parent group color &rarr; Column color &rarr; none. Set one color on a group to tint all its children; any child can override with its own.</li>
  <li><b>Color priority (mappings)</b> &mdash; Selection/hover &rarr; Filter color &rarr; Color-by scheme &rarr; Per-mapping manual color &rarr; default.</li>
  <li><b>Node color mode</b> (Layout popover) &mdash; choose which inheritance levels are active: <b>All</b>, <b>Groups</b> (column + group only), <b>Column</b> (column only), or <b>Off</b>.</li>
  <li><b>Color mappings by</b> &mdash; auto-color all arrows by cardinality, transform, tag, or custom attribute. Uses custom colors from tags and attribute values when available; falls back to palette. Opens a legend in the Graph popover.</li>
</ul>

<p style="margin:16px 0 0;font-size:12.5px;">For full details, open <b>Documentation</b> from the Help toolbar group.</p>
<div style="margin-top:14px;padding-top:10px;border-top:1px solid var(--border);text-align:center;">
<div style="font-size:12px;font-weight:700;opacity:.5;letter-spacing:.3px;">Dunnode. Done. Now.</div>
<div style="font-size:10px;opacity:.3;margin-top:4px;">v${APP_VERSION}</div>
</div>`;
  helpMask.classList.add('active');
  helpModal.classList.add('active');
}

// --- Release notes ---
const RELEASE_NOTES = [
  {
    version: '1.3.7',
    date: '2026-02-23',
    highlights: 'Arrow controls redesign, filter bar polish, mapping color hierarchy, command palette docs search, terminology sweep',
    changes: [
      '<b>Arrow mode selector</b>: the three arrow checkboxes (Arrows, All arrows, Adjacent-only) are replaced by a clean 3-way selector in the Graph menu  <b>Selected</b> (only hovered/selected), <b>All</b> (every arrow), or <b>Off</b>. Matches the "Dim unselected" and "Details panel" dock selector pattern',
      '<b>Arrow scope toggles</b>: new <b>Same-column</b> and <b>Distant</b> checkboxes in the Graph menu replace the old Adjacent-only toggle. Independently hide arrows within the same column or across non-adjacent columns  adjacent-column arrows are always shown when arrows are on',
      '<b>Mapping color priority</b>: revised hierarchy is now Selection highlight  Filter color  Color-by scheme  Per-mapping manual color (lowest). "Color mappings by" now takes priority over individual mapping colors, matching the node color inheritance philosophy',
      '<b>Mapping dimming fix</b>: colored mappings (scheme, filter, or manual) now properly dim when a selection is active. Previously, inline opacity overrode the CSS dimming class',
      '<b>Filter bar redesign</b>: the right section of the filter bar now uses segmented selectors  <b>Hide / Dim / Highlight</b> mode selector, <b>AND / OR</b> logic selector, and a pill-style <b>Only mapped</b> toggle. Replaces the old checkboxes and cycle button with a cleaner, more discoverable layout',
      '<b>Column header toning</b>: colored column headers now show a 2px accent line (down from 3px) and neutral-colored text  removes the doubled-up effect of colored text plus thick colored border',
      '<b>Command palette docs search</b>: typing 3+ characters now also searches the full Documentation  matching sections appear under a "Documentation" category with a snippet preview. Selecting a result opens the docs modal and scrolls to the relevant section. The Help category now includes a Documentation command alongside Quick Start, Release Notes, and About',
      '<b>Adjacent highlight removed</b>: the "Adjacent highlight" toggle in the Selection menu has been retired. Its functionality is now better served by the arrow scope toggles (Same-column / Distant) which control both drawing and visibility in a more intuitive way',
      '<b>Terminology sweep</b>: all user-facing text now consistently uses "mapping" instead of "edge"  detail panel headers, status bar counts, tooltips, export filenames, documentation, and changelog. Code internals retain "edge" as the correct graph theory term',
      '<b>Sample data refresh</b>: all five columns now have colors (Lab  emerald, Archive DB  slate, Obs  amber). New group-level colors on lab.personnel (pink), arch.fact_telemetry (sky blue), and arch.dim_crew (indigo). Seven mappings now have custom colors to showcase the color priority hierarchy',
      '<b>Select all / Invert selection</b>: previously hidden in the command palette, now surfaced as buttons in the Selection menu and as keyboard shortcuts  <b>Ctrl+A</b> (Cmd+A) selects all visible nodes, <b>Ctrl+Shift+I</b> (Cmd+Shift+I) inverts the current selection',
    ]
  },
  {
    version: '1.3.6',
    date: '2026-02-22',
    highlights: 'Column viewer, node color mode toggle, column header tint, bug fixes',
    changes: [
      '<b>Column viewer</b>: clicking a column header now shows a proper Column view in the details panel (label, ID, note, color, field/group/mapping counts) instead of incorrectly showing the root group node. Works in both viewer and editor mode',
      '<b>Column selection persistence</b>: toggling between viewer and editor mode no longer loses the column selection  the column stays selected and the details panel switches between column viewer and column editor automatically',
      '<b>Node color mode</b>: new "Node colors" section in the Layout popover with four modes  <b>All</b> (full inheritance), <b>Groups</b> (column + group colors only, no field overrides), <b>Column</b> (column colors only), <b>Off</b> (no background tinting). Styled with icon buttons matching the Dim unselected pattern',
      '<b>Column header tint</b>: column headers now display a subtle background tint in addition to the colored name and bottom border, making the column color more visible in the viewer',
    ]
  },
  {
    version: '1.3.5',
    date: '2026-02-22',
    highlights: 'Group color inheritance, updated sample data, documentation refresh',
    changes: [
      '<b>Group color inheritance</b>: groups with an applied color now cascade to all descendants. The full hierarchy is: Node color (applied)  nearest ancestor group color (applied)  Column color  none. This means a single color on a group can tint hundreds of children, and any child can override it with its own applied color',
      '<b>Sample data refresh</b>: the built-in Mars Mission example showcases color hierarchy  Mission Control (blue column), Crew group (red, overrides column), CommanderName field (amber, overrides group), Spacecraft Telemetry (purple column), Navigation subgroup (orange), Observatory Validation group (yellow). Attribute values include <code>colorEnabled</code> flags to demonstrate inheritance',
      '<b>Documentation updated</b>: Quick Start Guide, full Documentation, and JSON schema reference all updated to cover column colors, group color inheritance, attribute-level color, value Apply checkboxes, and the labelID auto-fill additions',
    ]
  },
  {
    version: '1.3.4',
    date: '2026-02-22',
    highlights: 'Color hierarchy: column colors, attribute colors, value colorEnabled, labelID auto-fill everywhere',
    changes: [
      '<b>Column colors</b>: columns now have an optional color with Apply checkbox. When applied, the column header is tinted and all child nodes without their own color inherit the column color as a subtle background',
      '<b>Attribute-level color</b>: attributes can now have their own color with swatch picker and Apply checkbox. When enabled, attribute values that don\u2019t have their own color applied will inherit the attribute\u2019s color for node pills',
      '<b>Attribute value Apply checkbox</b>: each value\u2019s color now has an explicit Apply toggle. Unchecked = color is stored but not used, inherits from attribute instead. For "Color mappings by", disabled value colors fall back to the default palette',
      '<b>Color hierarchy</b>: node background tint follows Node color (applied)  nearest ancestor color (applied)  Column color  none. A group with color applied cascades to all descendants until overridden by a child with its own applied color. Attribute value pill color follows Value color (applied)  Attribute color (applied)  none',
      '<b>LabelID auto-fill</b>: typing a label now auto-generates the ID (and abbreviation where applicable) in the column editor, node editor, and attribute value rows  matching the existing tag/transform pattern. "auto" badges show when values are auto-synced',
      '<b>Dirty detection fixes</b>: attribute value field edits (label, id, abbr, note), attribute color changes, and filter color changes now correctly activate the Save button',
    ]
  },
  {
    version: '1.3.3',
    date: '2026-02-21',
    highlights: 'Node attribute pills, transform colors, attribute ordering & display controls',
    changes: [
      '<b>Multi-select drag-and-drop</b>: when multiple nodes are selected, dragging any selected node performs the operation on all selected nodes at once. Same modifier keys apply: no modifier = Move, Alt = Map, Ctrl/Cmd = Copy, Ctrl/Cmd+Alt = Copy+',
      '<b>Multi MAP (Alt+drag)</b>: Alt-drag any selected node onto a non-selected field to create mappings from all selected fields to that target. Selection switches to the target field afterward',
      '<b>Multi MOVE</b>: drag selected nodes to reposition them together. Nodes maintain their original relative order. Automatic deduplication: children of selected groups are excluded since they move implicitly with their parent',
      '<b>Multi COPY / COPY+</b>: Ctrl-drag to duplicate all selected nodes at the drop location. Ctrl+Alt duplicates with mappings. Same deduplication and ordering rules as Move',
      '<b>Multi bin delete</b>: drag selected nodes to the  Delete zone to bulk-delete with confirmation. Shows affected mapping count',
      '<b>Transform custom color</b>: transforms now have an optional color field with swatch picker and hex input. Used by "Color mappings by  Transform" to override the default palette',
      '<b>Custom attribute ordering</b>: attributes and their values now have priority-based ordering with drag-and-drop reorder and / buttons, matching the tag catalog pattern',
      '<b>Attribute "Display on node"</b>: per-attribute checkbox controls whether its values appear as pills on tree nodes. Pill order: Tags first  Attributes by priority  Values by priority within each attribute',
      '<b>Value abbreviation</b>: each custom attribute value now has an optional abbreviation field. When set, the abbreviation is shown instead of the full label in node pills',
      '<b>Layout display toggles</b>: two new checkboxes in the Layout menu  "Display tags" and "Display attributes"  control visibility of tag and attribute pills on all nodes',
      '<b>Copy self-drop refinement</b>: copying a node before/after itself is allowed (duplicate in place), but copying into itself is blocked to prevent recursive nesting',
    ]
  },
  {
    version: '1.3.1',
    date: '2026-02-21',
    highlights: 'Unified editor UX: inline creation, smart auto-ID/abbr, dirty guards everywhere, "auto" indicators',
    changes: [
      '<b>Inline catalog creation</b>: adding a new tag, transform, or attribute opens an inline editor card at the top of the catalog list instead of a popup modal. Empty fields, auto-focused label, no Delete button for unsaved items',
      '<b>Unified Save/Cancel/Delete pattern</b>: all editors (catalog, filters, create modal, bulk modals) now follow the same pattern  Save (disabled until dirty), Cancel, and Delete (only for existing items). The old "Create X" buttons are replaced by a consistent "Save" button',
      '<b>Smart auto-ID from label</b>: typing a label auto-generates the ID in real time. Manually editing the ID stops the sync. Clearing the ID field re-derives it from the current label and resumes syncing. Works for all catalog items, filters, create modals, and transform param rows',
      '<b>Smart auto-abbreviation</b>: same sync logic applied to abbreviation fields  auto-fills from label, stops on manual edit, resumes on clear',
      '<b>Auto indicator badges</b>: a subtle blue <b>auto</b> pill appears next to ID and abbreviation fields when they are linked to the label. Disappears when manually overridden, reappears when cleared',
      '<b>Label validation</b>: all save handlers require a non-empty label  shows an alert and focuses the field if empty. Applies to tags, transforms, attributes, and filters',
      '<b>Dirty guards for new items</b>: cancelling or navigating away from an unsaved new item prompts "Discard new [kind]?" if the form has content, then removes the placeholder entry',
      '<b>Create modal dirty guards</b>: closing, cancelling, or clicking outside the create modal prompts if the form has content. Save button highlights when dirty',
      '<b>Bulk modal dirty tracking</b>: Apply buttons in bulk tag and bulk attribute modals now start inactive and highlight only when a change is made',
      '<b>Filter inline creation</b>: new filters start with an empty label and auto-generated ID, with the same Save/Cancel pattern and dirty guards as catalog items',
      '<b>ID regeneration on save</b>: saving any item with an empty ID field auto-generates the ID from the current label, whether the item is new or existing',
    ]
  },
  {
    version: '1.3.0',
    date: '2026-02-20',
    highlights: 'Multi-select with Ctrl+click, Shift+click range, bulk actions, and chain/direct arrow modes',
    changes: [
      '<b>Multi-select (Ctrl/Cmd+click)</b>: hold Ctrl (Cmd on Mac) and click nodes to add or remove them from a multi-selection. Works across columns',
      '<b>Shift+click range select</b>: hold Shift and click to select a range of visible nodes within the same column (from last clicked to current)',
      '<b>Alt+click chain select</b>: if the clicked node is connected to the current selection, adds it plus the entire path in between. If already selected or unconnected, adds the clicked node\u2019s full mapping chain',
      '<b>Directional chain select</b>: <b>Alt+Shift+click</b> selects upstream only (all sources), <b>Alt+Ctrl/Cmd+click</b> selects downstream only (all targets)',
      '<b>Marquee &amp; lasso select</b>: drag on empty viewer background to draw a selection rectangle. Hold Alt while dragging for freeform lasso. All nodes within the shape are selected. Hold Shift to add to existing selection, Ctrl/Cmd to subtract',
      '<b>Combined highlighting</b>: all selected nodes highlight their mapping chains simultaneously. Dimming, arrows, and chain-following work across the combined set',
      '<b>Highlight mode</b>: toggle between <b>Chain</b> (follow full mapping chain, default), <b>Direct</b> (show only immediate mappings), and <b>Selected</b> (highlight only the selection) in the Selection popover',
      '<b>Details panel summary</b>: when multiple nodes are selected, the details panel shows a count breakdown by type and column, mapping stats, and a scrollable node list',
      '<b>Bulk delete</b>: delete all selected nodes and their mappings with one click (undo supported)',
      '<b>Bulk tag assign</b>: add or remove tags across all selected nodes at once  checkboxes show current state (checked, unchecked, or indeterminate for partial)',
      '<b>Bulk set attribute</b>: set or clear a custom attribute value on all selected nodes',
      '<b>Bulk map to</b>: create mappings from all selected fields to a single target field  search by name or ID',
      '<b>Select all / Invert selection</b>: command palette commands to select all visible nodes or invert the current selection',
      '<b>Parameterized transforms</b>: transforms now support per-instance parameters. Catalog entries define a params schema (e.g. precision, fallback value, lookup table); each instance on a mapping can override the defaults. The same transform can be applied multiple times in a chain with different parameters',
      '<b>Transform params UI</b>: click a parameterized transform chip in the mapping editor to edit its parameters. Catalog editor now includes a params section to define parameter schemas (id, label, type, default)',
      '<b>Mapping color legend hover preview</b>: hovering any "Color mappings by" button temporarily shows its legend',
      '<b>Consistent context menu icons</b>: indent/outdent now use  /  (matching filter conditions), column move uses  / ',
    ]
  },
  {
    version: '1.2.5',
    date: '2026-02-20',
    highlights: 'Mapping dimming, visual adjacency, toolbar quick-actions, legend hover preview',
    changes: [
      '<b>Mapping dimming</b>: unrelated mappings now dim to match node dimming when a selection is active. Respects the 3-state dim mode (All / Parents / Off)',
      '<b>Active mapping z-ordering</b>: hovered or selected mappings always render on top of other mappings, fixing visual overlap in dense graphs',
      '<b>Visual column adjacency</b>: hidden columns are now skipped when calculating adjacency  two columns displayed side-by-side count as adjacent even if hidden columns exist between them',
      '<b>Node colors when dimmed</b>: custom node colors are now preserved (at reduced opacity) when dimmed instead of being stripped',
      '<b>Pan toggle button</b>:  four-way arrow icon in the toolbar for quick pan mode toggle',
      '<b>Clear selection button</b>:  icon in the toolbar to deselect  same as pressing Escape',
      '<b>Add column in Columns popover</b>: "Add column left/right" buttons moved into the Columns popover footer (editor mode)',
      '<b>Command palette background</b>: dark mode palette now uses a solid background matching other modals',
      '<b>Safari known limitation</b>: documented that drag-and-drop is not supported in Safari',
    ]
  },
  {
    version: '1.2.4',
    date: '2026-02-20',
    highlights: 'Command palette with fuzzy search for commands and nodes',
    changes: [
      '<b>Command palette</b>: press <b>Ctrl+K</b> (Cmd+K on Mac) or click the  button in the header to open a spotlight-style command bar',
      '<b>Fuzzy search</b>: type to filter all available commands (open catalogs, toggle modes, change panel layout, undo/redo, etc.) with match highlighting',
      '<b>Node search</b>: the palette also searches all nodes and fields by name or ID. Selecting a node expands parent groups, highlights it, and scrolls it into view',
      '<b>Keyboard navigation</b>:  to move, Enter to execute, Escape to close. Results grouped by Commands and Nodes & Fields',
      '<b>Shortcut hints</b>: commands show their keyboard shortcut when one exists (e.g. ?, D, Ctrl+Z)',
    ]
  },
  {
    version: '1.2.3',
    date: '2026-02-20',
    highlights: 'Custom attribute value colors with swatches, catalog overview color dots, create modal color picker',
    changes: [
      '<b>Attribute value color dots</b>: the Attributes catalog overview now shows a tiny colored dot next to each value that has a custom color assigned',
      '<b>Value editor color swatches</b>:  toggle button on each value row reveals a preset swatch panel (10 colors) for quick color selection  same pattern as the filter editor palette',
      '<b>Value color reset</b>:  icon next to each value\'s color picker clears the custom color and reverts to the uncolored default state',
      '<b>Create value modal color picker</b>: adding a new attribute value now includes the full color picker with swatches and hex input, auto-visible without a toggle.  reset icon included',
      '<b>Edge coloring priority</b>: "Color mappings by" attribute modes use the value\'s custom color when set, falling back to the 20-color palette for uncolored values',
    ]
  },
  {
    version: '1.2.2',
    date: '2026-02-20',
    highlights: 'Highlight colors modal redesign with live preview, project JSON persistence, editor/viewer modes',
    changes: [
      '<b>Highlight colors modal redesign</b>: full editor workflow with Save / Cancel / Delete buttons matching the tag editor pattern. Close button in header with unsaved-changes guard',
      '<b>Project JSON persistence</b>: highlight colors saved as <code>_highlightColors</code> in project data  colors travel with the file. Omitted when defaults are active (clean JSON)',
      '<b>Live preview tester</b>: interactive source  target preview in the modal. Hover or click nodes and arrow to see exactly how chosen colors render for connected vs selected states',
      '<b>Editor / Viewer mode</b>: color pickers and swatches are read-only in Viewer mode with a hint to switch to Editor. Save/Cancel/Delete only appear in Editor mode',
      '<b>Delete with confirmation</b>: removes custom colors from project data and reverts to defaults with a confirm dialog',
      '<b>Per-row  reset</b>: inline reset icon per color row, sitting alongside swatches for quick default restore',
      '<b>Standard button styling</b>: Save uses <code>btnSave</code>/<code>btnDirty</code> classes (yellow highlight when dirty), Delete uses the standard pink border pattern',
    ]
  },
  {
    version: '1.2.1',
    date: '2026-02-20',
    highlights: 'Zoom slider, selection controls, highlight color customization, same-column arrow improvements',
    changes: [
      '<b>Zoom / density slider</b>: new Zoom control (50150%) in the Layout popover scales the entire viewer for fitting more or less content on screen. Persisted to localStorage with inline  reset',
      '<b>Dim mode selector</b>: "Dim others" replaced with a 3-mode icon selector: <b>All</b> (dim everything unselected), <b>Parents</b> (keep parent groups visible), <b>Off</b> (no dimming)',
      '<b>Dim unselected: Parents mode</b>: expanded parent groups of connected fields get a subtle blue highlight and remain visible. In All mode, only direct connections are shown. Collapsed groups are always highlighted regardless',
      '<b>Highlight mode: Selected</b>: limits highlighting to the directly selected node  suppresses the full mapping chain highlight and restricts which arrows are drawn',
      '<b>Adjacent highlight</b>: moved from Graph to Selection popover where it logically belongs',
      '<b>Highlight colors modal</b>: customize Connected (chain) and Selected (active) highlight colors via color picker and 10-color swatches',
      '<b>Mapping color scheme selector</b>: "Color mappings by" dropdown replaced with icon buttons matching the dock selector pattern  Off, Cardinality, Transform, Source tag, Target tag',
      '<b>Same-column arrows (rightmost)</b>: arrows in the rightmost column now loop to the left instead of right, preventing overflow clipping',
      '<b>Same-column sample mappings</b>: sample dataset now includes within-column mappings in Observatory and Science Lab',
      '<b>Collapse recalculates highlights</b>: toggling a group collapsed/expanded now recalculates highlight state correctly',
      '<b>CSS dim inheritance fix</b>: changed <code>.dimmed .row</code> to <code>.dimmed > .row</code> so dimmed parents no longer cascade to connected children',
      'Viewer right padding added for consistent spacing on the rightmost column border',
      'Arrow zoom compensation: coordinates divide by CSS zoom factor for correct alignment at any zoom level',
      'Documentation footer updated to match Quick Start Guide style with version number',
    ]
  },
  {
    version: '1.2.0',
    date: '2026-02-20',
    highlights: 'Dunnode rebrand, float panel overhaul, color picker UX, scroll/resize fixes',
    changes: [
      '<b>Rebrand to Dunnode</b>: new name, all-caps wordmark with tracking, tagline "Done. Now."',
      '<b>About modal</b>: new Help  About with branding, creator info, and contact',
      '<b>App footer</b>: persistent footer with copyright and version, visible in all panel dock modes',
      '<b>_app metadata</b>: JSON format changed from string to <code>{ name, version, schema }</code> object. Old files auto-migrated on load',
      '<b>Float panel overhaul</b>: top/left CSS anchoring (resize grows down-right naturally), custom corner resize handle with  indicator',
      '<b>6-dot drag grip</b>: float panel header shows a standard 23 dot grip icon instead of invisible drag bar',
      '<b>Pan mode (P key)</b>: toggle pan mode with P, cross-arrow cursor, drag to scroll viewport. Press P or Esc to exit',
      '<b>Resize handles</b>: thicker (14px), blue glow on hover, groove line indicator, follow cursor during drag',
      '<b>Color preset swatches</b>: inline row of 10 color swatches in node and mapping editors alongside the picker and Apply checkbox',
      '<b>Color persistence</b>: picker value preserved as <code>_pendingColor</code> when Apply is unchecked  survives save/reload',
      '<b>Tag manager color picker</b>: native <code>&lt;input type="color"&gt;</code> added alongside hex input and swatches, all bidirectionally synced',
      '<b>Filter mapping highlighting</b>: collapsed group arrows now inherit filter colors from constituent mappings',
      '<b>Live arrow redraw</b>: arrows update in real-time during bottom and side panel resize, not just on mouse-up',
      '<b>Scroll area fix</b>: SVG overlay no longer inflates scroll dimensions; ResizeObserver triggers redraw on any container resize',
      '<b>Details panel min-width</b>: increased to 360px to prevent UI collapse at narrow widths',
      '<b>Nested group support</b>: sample dataset includes SAMPLE_ANALYSIS nested group inside EXPERIMENT',
      '<b>Quick Start Guide</b>: updated with welcome message and closing tagline',
      '<b>Documentation</b>: updated JSON schema reference with new <code>_app</code> object format',
      'Sample project author changed to "Mars Systems Integration Team"',
      'Dirty detection now tracks color picker value independently of Apply checkbox state',
      'Project title input made smaller (14px) to give more visual weight to the app name',
    ]
  },
  {
    version: '1.1.1',
    date: '2026-02-19',
    highlights: 'Editor polish, new metadata fields, bug fixes',
    changes: [
      '<b>_app identity</b>: JSON files now include <code>_app: "Mapping Studio"</code> to identify the source application',
      '<b>Project properties</b>: added Contact and URL fields (URL renders as clickable link in details pane)',
      '<b>Filter ID field</b>: filter editor now has an editable ID field with conflict detection, matching tag/transform/attribute behavior. ID shown in viewer cards',
      '<b>Condition editor buttons</b>:     action buttons on each condition row and group header for move up, move down, indent into group, and outdent from group',
      '<b>Edge color scheme palette</b>: extended from 10 to 20 distinct colors for better differentiation with many values',
      '<b>Catalog buttons hidden in viewer</b>: "Add tag/transform/attribute/filter" buttons are hidden in Viewer mode instead of showing an error',
      '<b>Toggle hover effect</b>: all toggle/checkbox controls now have hover highlighting in both dark and bright themes',
      '<b>Save button states</b>: Save buttons start greyed out (disabled appearance) when no changes are pending, including the Project Properties save button',
      'Mapping editor no longer shows false dirty state on open (undefined vs empty string normalization)',
      'Node and mapping color picker changes now correctly trigger dirty state on Save buttons',
      'New project / Load example / Open file now clears stale edit sessions, preventing phantom abandon-guard prompts',
      'Release notes now render HTML formatting (bold tags) correctly',
    ]
  },
  {
    version: '1.1.0',
    date: '2026-02-19',
    highlights: 'Filtering overhaul, unsaved-changes protection, UX polish',
    changes: [
      '<b>Filter system</b>: rule-based filters with recursive condition groups (AND/OR), priority ordering, and rich highlight styles (background, stripe, mapping color, frame, bold, emoji)',
      '<b>Filter catalog</b>: create, edit, reorder, delete filters with live preview. Priority-based evaluation with drag-and-drop and  button reordering',
      '<b>Filter bar</b>: toolbar toggle () with search input, Only mapped, display mode cycle, Filters AND/OR, Clear all, and active filter chips',
      '<b>Display mode cycle</b>: Hide  Dim  Highlight only. "Highlight only" keeps all nodes visible and just applies color styles to matches',
      '<b>Color palette</b>:  button in filter editor shows preset color swatches  click to apply to all enabled channels, or drag onto individual swatches',
      '<b>Unsaved-changes guard</b>: navigating away from edited nodes, columns, mappings, or catalog items prompts "Abandon unsaved changes?" Only fires when actual changes detected',
      '<b>Yellow Save buttons</b>: Save buttons turn gold when the form has pending changes vs. the snapshot. Reverts when user manually restores original values',
      '<b>Greyed-out catalog items</b>: while editing a tag/transform/attribute/filter, other items are dimmed and unclickable to prevent accidental switching',
      '<b>Details panel enhancements</b>: groups show rich Children cards with type, summary, tags, and attributes. Inbound/Outbound/Children sections are collapsible ( caret)',
      '<b>Undo/Redo guards</b>: Ctrl+Z/Y prompts if there are unsaved edits in the active editor before reverting state',
      '<b>EditorViewer mode guard</b>: switching to Viewer mode prompts if node or mapping edits are unsaved',
      '<b>Node ID dirty check</b>: changing a node or column ID field is now properly detected as a pending change',
      '<b>Node colors</b>: optional per-node color applied as subtle background tint on the viewer row. Shown in details pane. Overridden by filter/selection highlights',
      '<b>Mapping colors</b>: optional per-mapping color applied to arrow strokes. Filter mapping colors take priority, then custom mapping colors, then default',
      '<b>Color mappings by</b>: automatic arrow coloring by cardinality, first transform, source/target tag, or source/target custom attribute. Select in Graph popover; legend auto-generated',
      '<b>Selection dim toggle</b>: "Dim others" checkbox in Selection popover  uncheck to keep all nodes at full opacity when something is selected',
      '<b>Color palette</b>:  button in filter editor shows 10 preset swatches with drag-to-swatch and click-to-apply-all-channels',
      '<b>Condition DnD</b>: drag  handles in the filter condition editor to reorder conditions, move between groups, or indent into a group',
      'Rephrased "new project" and "load example" confirmation prompts to be clearer',
      'Filter AND/OR toggle relabeled to "Filters: AND" to clarify it only affects filters (search is always ANDed)',
      'Context menu toggle fix for column and node  buttons',
      'Escape key now cancels column edits and mapping drafts (previously only handled node edits)',
      'Indent/outdent now correctly preserves mappings by passing state.data to replaceIdsInMappings',
      'Filter badge (Escape) correctly resets to 0',
    ]
  },
  {
    version: '1.0.0',
    date: '2026-02-18',
    highlights: 'Initial release',
    changes: [
      'Multi-column schema viewer with nested tree structure and collapsible groups',
      'Bezier curve arrows across adjacent and non-adjacent columns with virtual edge discovery',
      'Full inline editor: create, edit, delete, move, indent/outdent nodes and columns',
      'Drag-and-drop support for nodes and columns',
      'Mapping editor with cardinality, default values, notes, and ordered transforms',
      'Tag catalog with color-coded chips, abbreviations, notes, and drag-to-reorder priority',
      'Transform catalog with abbreviations and notes',
      'Custom attribute catalog with multi/single-value modes and per-value notes',
      'All entity IDs independently editable with cascading rename across the full data model',
      'Hierarchical node IDs with auto-calculated path prefix and editable local segment',
      'Undo/redo with snapshot-based dirty tracking (save button reflects true state)',
      'Project properties modal: title, subtitle, author, organization, contact, URL, version, date, description',
      'App version and save timestamp stamped into JSON on every save',
      'Bright/dark mode with comprehensive theme coverage',
      'Column visibility controls, reordering, wrap mode for screenshots',
      'Arrow display modes: all, adjacent-only, highlight-only; plus adjacent-only highlight mode',
      'Details panel showing node metadata, mapping details, and project summary',
      'Tooltips on hover for nodes, mappings, and virtual mappings through hidden columns',
      'Context menus for columns and nodes with full action set',
      'CSV export of visible edges and HTML report export with embedded JSON',
      'Search/filter by text, filter by unmapped fields',
      'Inline Quick help, comprehensive Documentation page, and Release notes',
      'Sample dataset: Mars mission data pipeline across 5 systems (31 mappings, 3 tags, 8 transforms, 2 custom attributes)',
      'Keyboard shortcuts: Escape to deselect, ? for help, Ctrl+Z/Y for undo/redo',
    ]
  }
];

function openReleaseNotes(){
  const rnBody = document.getElementById('releaseNotesBody');
  const rnMask = document.getElementById('releaseNotesMask');
  const rnModal = document.getElementById('releaseNotesModal');
  if(!rnBody || !rnMask || !rnModal) return;

  const html = RELEASE_NOTES.map(r=>{
    const items = r.changes.map(c=>`<li>${c}</li>`).join('');
    return `<div style="margin-bottom:20px;">
      <h3 style="margin:0 0 4px 0;">v${escapeHtml(r.version)} <span style="font-weight:400;font-size:12px;opacity:.5;">${escapeHtml(r.date)}</span></h3>
      ${r.highlights ? `<p style="margin:0 0 8px 0;font-size:13px;font-style:italic;opacity:.7;">${escapeHtml(r.highlights)}</p>` : ''}
      <ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.65;">${items}</ul>
    </div>`;
  }).join('');

  rnBody.innerHTML = html;
  rnMask.classList.add('active');
  rnModal.classList.add('active');
}

function closeReleaseNotes(){
  const rnMask = document.getElementById('releaseNotesMask');
  const rnModal = document.getElementById('releaseNotesModal');
  if(rnMask) rnMask.classList.remove('active');
  if(rnModal) rnModal.classList.remove('active');
}

{
  const rnBtn = document.getElementById('releaseNotesBtn');
  const rnClose = document.getElementById('closeReleaseNotesBtn');
  const rnMask = document.getElementById('releaseNotesMask');
  if(rnBtn) rnBtn.addEventListener('click', openReleaseNotes);
  if(rnClose) rnClose.addEventListener('click', closeReleaseNotes);
  if(rnMask) rnMask.addEventListener('click', closeReleaseNotes);
  document.addEventListener('keydown', (e)=>{
    if(e.key==='Escape'){
      const docsM = document.getElementById('docsModal');
      if(docsM && docsM.classList.contains('active')){ e.preventDefault(); closeDocs(); return; }
      const rnModal = document.getElementById('releaseNotesModal');
      if(rnModal && rnModal.classList.contains('active')){ e.preventDefault(); closeReleaseNotes(); return; }
      const aboutM = document.getElementById('aboutModal');
      if(aboutM && aboutM.classList.contains('active')){ e.preventDefault(); closeAbout(); }
    }
  });

  // About modal
  const aboutBtn = document.getElementById('aboutBtn');
  const aboutModal = document.getElementById('aboutModal');
  const aboutMask = document.getElementById('aboutMask');
  const aboutClose = document.getElementById('aboutClose');
  function openAbout(){ aboutModal?.classList.add('active'); aboutMask?.classList.add('active'); const av=document.getElementById('aboutVersion'); if(av) av.textContent='v'+APP_VERSION; }
  function closeAbout(){ aboutModal?.classList.remove('active'); aboutMask?.classList.remove('active'); }
  if(aboutBtn){
    aboutBtn.addEventListener('click', ()=>{
      openAbout();
      // Close the help popover
      document.querySelectorAll('.tbPop').forEach(p => p.classList.remove('open'));
      document.querySelectorAll('.tbBtn').forEach(b => b.classList.remove('active'));
    });
  }
  if(aboutClose) aboutClose.addEventListener('click', closeAbout);
  if(aboutMask) aboutMask.addEventListener('click', closeAbout);
}

// --- Highlight colors modal ---
const HL_DEFAULTS = { connected: '#3b82f6', active: '#ffd05c' };
const HL_SWATCHES = [
  '#3b82f6','#06b6d4','#8b5cf6','#ec4899','#ef4444',
  '#f97316','#eab308','#22c55e','#14b8a6','#6366f1'
];
let __hlSnapshot = null; // { connected, active } at modal open

function hexToRgb(hex){
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return { r, g, b };
}

function applyHlCssVars(connHex, actHex){
  const root = document.documentElement;
  const c = hexToRgb(connHex);
  const a = hexToRgb(actHex);
  root.style.setProperty('--hl-bg', `rgba(${c.r},${c.g},${c.b},0.22)`);
  root.style.setProperty('--hl-br', `rgba(${c.r},${c.g},${c.b},0.88)`);
  root.style.setProperty('--line-hl', `rgba(${c.r},${c.g},${c.b},0.92)`);
  root.style.setProperty('--active-bg', `rgba(${a.r},${a.g},${a.b},0.26)`);
  root.style.setProperty('--active-br', `rgba(${a.r},${a.g},${a.b},0.78)`);
  root.style.setProperty('--line-active', `rgba(${a.r},${a.g},${a.b},0.95)`);
}

function getHlFromData(){
  const d = state.data?._highlightColors;
  return { connected: d?.connected || HL_DEFAULTS.connected, active: d?.active || HL_DEFAULTS.active };
}

function syncHlPickerUI(connHex, actHex){
  const cp = document.getElementById('hlConnectedPicker');
  const ap = document.getElementById('hlActivePicker');
  if(cp) cp.value = connHex;
  if(ap) ap.value = actHex;
  ['hlConnectedSwatches','hlActiveSwatches'].forEach((id, i)=>{
    const c = document.getElementById(id);
    if(!c) return;
    const hex = i === 0 ? connHex : actHex;
    c.querySelectorAll('.swatch').forEach(s => s.classList.toggle('sel', s.dataset.color === hex));
  });
}

function hlColorsIsDirty(){
  if(!__hlSnapshot) return false;
  const cp = document.getElementById('hlConnectedPicker');
  const ap = document.getElementById('hlActivePicker');
  return (cp?.value || HL_DEFAULTS.connected) !== __hlSnapshot.connected ||
         (ap?.value || HL_DEFAULTS.active) !== __hlSnapshot.active;
}

function hlUpdateSaveBtnState(){
  const saveBtn = document.getElementById('hlColorsSave');
  if(!saveBtn) return;
  saveBtn.classList.toggle('btnDirty', hlColorsIsDirty());
}

function restoreHlColors(){
  const hl = getHlFromData();
  applyHlCssVars(hl.connected, hl.active);
  syncHlPickerUI(hl.connected, hl.active);
  try {
    localStorage.setItem('ms_hlConnected', hl.connected);
    localStorage.setItem('ms_hlActive', hl.active);
  } catch(e){}
}

{
  const hlModal = document.getElementById('hlColorsModal');
  const hlMask = document.getElementById('hlColorsMask');
  const hlOpenBtn = document.getElementById('hlColorsBtn');
  const hlCloseBtn = document.getElementById('hlColorsClose');
  const hlSaveBtn = document.getElementById('hlColorsSave');
  const hlCancelBtn = document.getElementById('hlColorsCancel');
  const hlDeleteBtn = document.getElementById('hlColorsDelete');
  const hlConnPicker = document.getElementById('hlConnectedPicker');
  const hlActPicker = document.getElementById('hlActivePicker');
  const hlConnSwatches = document.getElementById('hlConnectedSwatches');
  const hlActSwatches = document.getElementById('hlActiveSwatches');
  const hlConnReset = document.getElementById('hlConnectedReset');
  const hlActReset = document.getElementById('hlActiveReset');

  function openHlColors(){
    const isEditor = state.editorMode;
    // Show/hide editor actions and viewer hint
    document.getElementById('hlColorsEditorActions').style.display = isEditor ? '' : 'none';
    document.getElementById('hlViewerHint').style.display = isEditor ? 'none' : '';
    // Disable/enable inputs
    const body = document.getElementById('hlColorsBody');
    body.querySelectorAll('input[type=color]').forEach(i=>{ i.disabled = !isEditor; i.style.opacity = isEditor ? '1' : '.5'; });
    body.querySelectorAll('.swatch').forEach(s=>{ s.style.pointerEvents = isEditor ? '' : 'none'; s.style.opacity = isEditor ? '1' : '.5'; });
    body.querySelectorAll('.hlEditOnly').forEach(el=>{ el.style.display = isEditor ? '' : 'none'; });
    // Take snapshot
    const hl = getHlFromData();
    __hlSnapshot = { connected: hl.connected, active: hl.active };
    syncHlPickerUI(hl.connected, hl.active);
    applyHlCssVars(hl.connected, hl.active);
    hlUpdateSaveBtnState();
    if(typeof hlTesterFullReset === 'function') hlTesterFullReset();
    hlModal?.classList.add('active');
    hlMask?.classList.add('active');
  }

  async function closeHlColors(force){
    if(!force && state.editorMode && hlColorsIsDirty()){
      const ok = await customConfirm('Abandon unsaved highlight color changes?');
      if(!ok) return;
      // Revert CSS to snapshot
      applyHlCssVars(__hlSnapshot.connected, __hlSnapshot.active);
      syncHlPickerUI(__hlSnapshot.connected, __hlSnapshot.active);
    } else if(!force && __hlSnapshot){
      // Viewer mode or no changes: still revert preview
      applyHlCssVars(__hlSnapshot.connected, __hlSnapshot.active);
      syncHlPickerUI(__hlSnapshot.connected, __hlSnapshot.active);
    }
    __hlSnapshot = null;
    hlModal?.classList.remove('active');
    hlMask?.classList.remove('active');
  }

  function hlPreview(){
    const conn = hlConnPicker?.value || HL_DEFAULTS.connected;
    const act = hlActPicker?.value || HL_DEFAULTS.active;
    applyHlCssVars(conn, act);
    hlUpdateSaveBtnState();
  }

  function hlPickSwatch(container, picker, hex){
    if(picker) picker.value = hex;
    if(container) container.querySelectorAll('.swatch').forEach(s => s.classList.toggle('sel', s.dataset.color === hex));
    hlPreview();
  }

  if(hlOpenBtn) hlOpenBtn.addEventListener('click', openHlColors);
  if(hlCloseBtn) hlCloseBtn.addEventListener('click', ()=> closeHlColors());
  if(hlMask) hlMask.addEventListener('click', ()=> closeHlColors());
  document.addEventListener('keydown', e=>{ if(e.key==='Escape' && hlModal?.classList.contains('active')) closeHlColors(); });

  // Save: persist to project data + close
  if(hlSaveBtn) hlSaveBtn.addEventListener('click', ()=>{
    const conn = hlConnPicker?.value || HL_DEFAULTS.connected;
    const act = hlActPicker?.value || HL_DEFAULTS.active;
    if(state.data){
      if(conn === HL_DEFAULTS.connected && act === HL_DEFAULTS.active){
        delete state.data._highlightColors;
      } else {
        state.data._highlightColors = { connected: conn, active: act };
      }
    }
    try {
      localStorage.setItem('ms_hlConnected', conn);
      localStorage.setItem('ms_hlActive', act);
    } catch(e){}
    __hlSnapshot = { connected: conn, active: act };
    checkDirtyState();
    closeHlColors(true);
  });

  // Cancel: revert to snapshot + close
  if(hlCancelBtn) hlCancelBtn.addEventListener('click', ()=>{
    if(__hlSnapshot){
      applyHlCssVars(__hlSnapshot.connected, __hlSnapshot.active);
      syncHlPickerUI(__hlSnapshot.connected, __hlSnapshot.active);
    }
    __hlSnapshot = null;
    hlModal?.classList.remove('active');
    hlMask?.classList.remove('active');
  });

  // Delete: remove from data, revert to defaults
  if(hlDeleteBtn) hlDeleteBtn.addEventListener('click', async ()=>{
    const ok = await customConfirm('Remove custom highlight colors and revert to defaults?');
    if(!ok) return;
    if(state.data) delete state.data._highlightColors;
    applyHlCssVars(HL_DEFAULTS.connected, HL_DEFAULTS.active);
    syncHlPickerUI(HL_DEFAULTS.connected, HL_DEFAULTS.active);
    try { localStorage.removeItem('ms_hlConnected'); localStorage.removeItem('ms_hlActive'); } catch(e){}
    __hlSnapshot = { connected: HL_DEFAULTS.connected, active: HL_DEFAULTS.active };
    checkDirtyState();
    closeHlColors(true);
  });

  // Live preview on picker change
  if(hlConnPicker) hlConnPicker.addEventListener('input', hlPreview);
  if(hlActPicker) hlActPicker.addEventListener('input', hlPreview);

  // Per-row resets
  if(hlConnReset) hlConnReset.addEventListener('click', ()=> hlPickSwatch(hlConnSwatches, hlConnPicker, HL_DEFAULTS.connected));
  if(hlActReset) hlActReset.addEventListener('click', ()=> hlPickSwatch(hlActSwatches, hlActPicker, HL_DEFAULTS.active));

  // Build swatches
  function buildHlSwatches(container, picker){
    if(!container) return;
    container.innerHTML = '';
    HL_SWATCHES.forEach(hex=>{
      const s = document.createElement('div');
      s.className = 'swatch';
      s.dataset.color = hex;
      s.style.cssText = 'width:18px;height:18px;border-radius:6px;flex-shrink:0;cursor:pointer;border:1px solid rgba(255,255,255,.12);transition:transform .1s;box-shadow:0 2px 8px rgba(0,0,0,.2);';
      s.style.background = hex;
      s.title = hex;
      s.addEventListener('click', ()=> hlPickSwatch(container, picker, hex));
      container.appendChild(s);
    });
  }

  buildHlSwatches(hlConnSwatches, hlConnPicker);
  buildHlSwatches(hlActSwatches, hlActPicker);

  // --- Tester preview ---
  let __hlTesterLocked = null; // null | 'source' | 'target' | 'edge'
  function hlTesterFullReset(){
    __hlTesterLocked = null;
    hlTesterApplyState(null);
  }
  function hlTesterApplyState(focus){
    // focus: null | 'source' | 'target' | 'edge'
    const src = document.getElementById('hlTesterSource');
    const tgt = document.getElementById('hlTesterTarget');
    const al = document.getElementById('hlTesterLine');
    const ah = document.getElementById('hlTesterHead');
    if(!focus){
      // Default: everything neutral
      if(src){ src.style.background = 'var(--panel)'; src.style.borderColor = 'var(--border)'; }
      if(tgt){ tgt.style.background = 'var(--panel)'; tgt.style.borderColor = 'var(--border)'; }
      if(al){ al.style.stroke = 'var(--line)'; } if(ah){ ah.style.fill = 'var(--line)'; }
    } else if(focus === 'source' || focus === 'target'){
      // Hover/click node: that node = active, other + edge = connected
      const act = focus === 'source' ? src : tgt;
      const conn = focus === 'source' ? tgt : src;
      if(act){ act.style.background = 'var(--active-bg)'; act.style.borderColor = 'var(--active-br)'; }
      if(conn){ conn.style.background = 'var(--hl-bg)'; conn.style.borderColor = 'var(--hl-br)'; }
      if(al){ al.style.stroke = 'var(--line-hl)'; } if(ah){ ah.style.fill = 'var(--line-hl)'; }
    } else if(focus === 'edge'){
      // Hover/click edge: edge = active, both nodes = active
      if(src){ src.style.background = 'var(--active-bg)'; src.style.borderColor = 'var(--active-br)'; }
      if(tgt){ tgt.style.background = 'var(--active-bg)'; tgt.style.borderColor = 'var(--active-br)'; }
      if(al){ al.style.stroke = 'var(--line-active)'; } if(ah){ ah.style.fill = 'var(--line-active)'; }
    }
  }
  {
    const testerSrc = document.getElementById('hlTesterSource');
    const testerTgt = document.getElementById('hlTesterTarget');
    const testerArrow = document.getElementById('hlTesterArrow');

    [['source', testerSrc], ['target', testerTgt], ['edge', testerArrow]].forEach(([which, el]) => {
      if(!el) return;
      el.addEventListener('mouseenter', ()=>{
        if(!__hlTesterLocked) hlTesterApplyState(which);
      });
      el.addEventListener('mouseleave', ()=>{
        if(!__hlTesterLocked) hlTesterApplyState(null);
      });
      el.addEventListener('click', ()=>{
        if(__hlTesterLocked === which){ __hlTesterLocked = null; hlTesterApplyState(null); }
        else { __hlTesterLocked = which; hlTesterApplyState(which); }
      });
    });
  }

  // Initial restore
  try {
    const sc = localStorage.getItem('ms_hlConnected');
    const sa = localStorage.getItem('ms_hlActive');
    if(sc || sa) applyHlCssVars(sc || HL_DEFAULTS.connected, sa || HL_DEFAULTS.active);
  } catch(e){}
}

// Set version label in header
{ const vl = document.getElementById('appVersionLabel'); if(vl) vl.textContent = 'v' + APP_VERSION; }
{ const fl = document.getElementById('footerLicenseLink'); if(fl) fl.addEventListener('click', e => { e.preventDefault(); openDocs(); requestAnimationFrame(()=>{ const t = docsBody.querySelector('#doc-license'); if(t) t.scrollIntoView({ behavior:'smooth', block:'start' }); }); }); }
{ const al = document.getElementById('aboutLicenseLink'); if(al) al.addEventListener('click', e => { e.preventDefault(); closeAbout(); openDocs(); requestAnimationFrame(()=>{ const t = docsBody.querySelector('#doc-license'); if(t) t.scrollIntoView({ behavior:'smooth', block:'start' }); }); }); }


// --- Tag manager modal ---
// Catalog edit state (shared across all managers)
let __catalogEdit = { kind: null, idx: -1, snapshot: null, isNew: false };

function catalogEditBegin(kind, idx, snapshot, isNew){
  __catalogEdit = { kind, idx, snapshot: JSON.parse(JSON.stringify(snapshot)), isNew: !!isNew };
}
function catalogEditEnd(){
  __catalogEdit = { kind: null, idx: -1, snapshot: null, isNew: false };
}
function catalogIsEditing(kind, idx){
  return __catalogEdit.kind === kind && __catalogEdit.idx === idx;
}

// --- Dirty checking for catalog edit forms ---
function catalogFormIsDirty(){
  if(!__catalogEdit.kind || __catalogEdit.idx < 0 || !__catalogEdit.snapshot) return false;
  const snap = __catalogEdit.snapshot;
  const kind = __catalogEdit.kind;
  let containerId = kind==='tag' ? 'tagsBody' : kind==='transform' ? 'transformsBody' : kind==='attr' ? 'customAttrsBody' : null;
  if(!containerId) return false;
  const card = document.querySelector(`#${containerId} .catEditing`);
  if(!card) return false;
  const fields = card.querySelectorAll('.inp[data-f]');
  for(const f of fields){
    const key = f.dataset.f;
    if(key === 'colorSwatches') continue;
    // For new items, skip ID comparison (ID is auto-generated)
    if(key === 'id' && __catalogEdit.isNew) continue;
    const current = (f.value||'').trim();
    const original = String(snap[key]||'').trim();
    if(current !== original) return true;
  }
  // For transforms, also check param schema changes (add/remove/edit params)
  if(kind === 'transform'){
    const paramRows = card.querySelectorAll('.trParamRow');
    const currentParams = [];
    paramRows.forEach(row => {
      let pid = (row.querySelector('[data-pf="id"]')?.value||'').trim();
      const plabel = (row.querySelector('[data-pf="label"]')?.value||'').trim();
      const ptype = row.querySelector('[data-pf="type"]')?.value || 'text';
      const pdef = (row.querySelector('[data-pf="default"]')?.value||'').trim();
      if(!pid && plabel) pid = plabel.toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
      if(pid) currentParams.push({ id: pid, label: plabel || pid, type: ptype, ...(pdef !== '' ? { default: ptype === 'number' ? Number(pdef) : pdef } : {}) });
    });
    const origParams = snap.params || [];
    if(JSON.stringify(currentParams) !== JSON.stringify(origParams)) return true;
  }
  // For attrs, also check in-place value changes, checkboxes, and displayOnNode
  if(kind === 'attr'){
    const cat = ensureCustomAttributeCatalog();
    const item = cat[__catalogEdit.idx];
    // Structural changes (add/remove values, priority reorder) are reflected in item.values
    if(item && (item.values||[]).length !== (snap.values||[]).length) return true;
    if(item && JSON.stringify((item.values||[]).map(v=>v.priority)) !== JSON.stringify((snap.values||[]).map(v=>v.priority))) return true;
    // Read DOM inputs for each value row to detect label/id/abbr/note/color edits
    const card2 = document.querySelector(`#customAttrsBody .catEditing`);
    if(card2){
      const origVals = snap.values || [];
      const valRows = card2.querySelectorAll('.attrValRow');
      for(const row of valRows){
        const vi = Number(row.dataset.vi);
        const ov = origVals[vi];
        if(!ov) return true; // new value added
        const curLabel = (row.querySelector('[data-vf="vlabel"]')?.value||'').trim();
        const curId = (row.querySelector('[data-vf="vid"]')?.value||'').trim();
        const curAbbr = (row.querySelector('[data-vf="vabbr"]')?.value||'').trim();
        const curNote = (row.querySelector('[data-vf="vnote"]')?.value||'').trim();
        if(curLabel !== (ov.label||'').trim()) return true;
        if(curId !== (ov.id||'').trim()) return true;
        if(curAbbr !== (ov.abbr||'').trim()) return true;
        if(curNote !== (ov.note||'').trim()) return true;
        // Color change via DOM checkbox and live object
        const curColorOn = row.querySelector('[data-vf="vcolorOn"]')?.checked;
        const origColorOn = ov.color ? (ov.colorEnabled !== false) : false;
        if(!!curColorOn !== !!origColorOn) return true;
        const curColor = item?.values?.[vi]?.color || '';
        const origColor = ov.color || '';
        if(curColor !== origColor) return true;
        // Auto-link state change
        if((row.dataset.autoId === '1') !== !!ov._autoId) return true;
        if((row.dataset.autoAbbr === '1') !== !!ov._autoAbbr) return true;
      }
      const multiCb = card2.querySelector('[data-f="multi"]');
      const displayCb = card2.querySelector('[data-f="displayOnNode"]');
      if(multiCb && !!multiCb.checked !== !!snap.multi) return true;
      if(displayCb && !!displayCb.checked !== !!snap.displayOnNode) return true;
      // Attribute-level color
      const attrColorPicker = card2.querySelector('[data-f="attrColorPicker"]');
      const attrColorOn = card2.querySelector('[data-f="attrColorOn"]');
      const origAttrColorOn = snap.color ? (snap.colorEnabled !== false) : false;
      if(attrColorOn && !!attrColorOn.checked !== !!origAttrColorOn) return true;
      if(attrColorPicker){
        const origAttrColor = snap.color || '#6b7280';
        if(attrColorPicker.value !== origAttrColor) return true;
      }
    }
  }
  // Auto-link state change
  if(__editorAutoId !== !!snap._autoId) return true;
  if(__editorAutoAbbr !== !!snap._autoAbbr) return true;
  return false;
}

// --- Dirty checking for filter edit ---
let __filterEditSnapshot = null;
function filterFormIsDirty(){
  if(!__filterEditId || !__filterEditSnapshot) return false;
  const cat = ensureFilterCatalog();
  const f = cat.find(x => x.id === __filterEditId);
  if(!f) return false;
  const snap = JSON.parse(__filterEditSnapshot);
  // Rules are modified in-place on the filter object
  if(JSON.stringify(f.rules||[]) !== JSON.stringify(snap.rules||[])) return true;
  // Form fields are not yet written back  check the DOM
  const card = document.querySelector('.filterEditCard');
  if(card){
    const curId = sanitizeManualId(card.querySelector('.feId')?.value||'');
    if(curId && curId !== (snap.id||'')) return true;
    if((card.querySelector('.feLabel')?.value||'').trim() !== (snap.label||'')) return true;
    if((card.querySelector('.feNote')?.value||'').trim() !== (snap.note||'')) return true;
    const hl = snap.highlight || {};
    if((card.querySelector('.feBg')?.value||'') !== (hl.bg||'')) return true;
    if((card.querySelector('.feBorder')?.value||'') !== (hl.border||'')) return true;
    if((card.querySelector('.feEdge')?.value||'') !== (hl.edgeColor||'')) return true;
    if((card.querySelector('.feFrameColor')?.value||'') !== (hl.frameColor||'')) return true;
    if(!!card.querySelector('.feBgOn')?.checked !== !!hl.bgEnabled) return true;
    if(!!card.querySelector('.feBorderOn')?.checked !== !!hl.borderEnabled) return true;
    if(!!card.querySelector('.feEdgeOn')?.checked !== !!hl.edgeEnabled) return true;
    if(!!card.querySelector('.feBold')?.checked !== !!hl.bold) return true;
    if(!!card.querySelector('.feFrame')?.checked !== !!hl.frame) return true;
    if((card.querySelector('.feEmoji')?.value||'').trim() !== (hl.emoji||'')) return true;
    // Auto-link state change
    if(card.__filterAutoId && card.__filterAutoId() !== !!snap._autoId) return true;
  }
  return false;
}

// --- Dirty checking for node/column edit ---
function nodeEditIsDirty(){
  if(!__editSnapshot || !__editSnapshot.data) return false;
  const { kind, id, data } = __editSnapshot;
  if(kind === 'column'){
    const col = findColumnById(id);
    if(!col) return false;
    const labelInp = document.getElementById('colLabel');
    const noteInp = document.getElementById('colNote');
    const idInp = document.getElementById('colId');
    // If DOM elements don't exist (editor was unmounted), can't be dirty
    if(!labelInp && !noteInp && !idInp) return false;
    if(labelInp && labelInp.value.trim() !== (data.label||'')) return true;
    if(noteInp && noteInp.value.trim() !== (data.note||'')) return true;
    if(idInp && idInp.value.trim() !== (data.id||'')) return true;
    if(__editorAutoId !== !!data._autoId) return true;
    // Color dirty check
    const colColorOnEl = document.getElementById('colColorOn');
    const colColorEl = document.getElementById('colColor');
    if(!colColorOnEl || !colColorEl) return false; // editor not mounted
    const colColorOn = colColorOnEl.checked;
    const colColorVal = colColorEl.value || '#3b82f6';
    const origColColor = data.color || '';
    const origColPickerVal = origColColor || data._pendingColor || '#3b82f6';
    if(colColorOn !== !!origColColor) return true;
    if(colColorVal !== origColPickerVal) return true;
    return false;
  } else if(kind === 'node'){
    const node = IDX?.nodeById?.get(id);
    if(!node) return false;
    const labelInp = document.getElementById('ndLabel');
    const noteInp = document.getElementById('ndNote');
    const idInp = document.getElementById('ndId');
    if(labelInp && labelInp.value.trim() !== (data.label||'')) return true;
    if(noteInp && noteInp.value.trim() !== (data.note||'')) return true;
    if(idInp){
      const origLocal = localIdSegment(data.id || id);
      if(idInp.value.trim() !== origLocal) return true;
    }
    if(__editorAutoId !== !!data._autoId) return true;
    const curTags = Array.isArray(node.tags) ? [...node.tags].sort().join(',') : '';
    const snapTags = Array.isArray(data.tags) ? [...data.tags].sort().join(',') : '';
    if(curTags !== snapTags) return true;
    // Color dirty check  detect picker change OR checkbox toggle independently
    const colorOn = document.getElementById('ndColorOn')?.checked;
    const colorVal = document.getElementById('ndColor')?.value || '#3b82f6';
    const origColor = data.color || '';
    const origPickerVal = origColor || data._pendingColor || '#3b82f6';
    if(colorOn !== !!origColor) return true;       // checkbox toggled
    if(colorVal !== origPickerVal) return true;     // picker value changed
    if(JSON.stringify(node.customAttributes||{}) !== JSON.stringify(data.customAttributes||{})) return true;
    return false;
  }
  return false;
}

// --- Generic abandon guard ---
async function guardAbandonEdit(label, id){
  const display = label ? `"${label}"` : '';
  // Strip internal edge counter prefix (e.g. "e23:fromto"  "from  to")
  let cleanId = id || '';
  if(/^e\d+:/.test(cleanId)) cleanId = cleanId.replace(/^e\d+:/, '').replace(//g, '  ');
  const idStr = cleanId ? ` (${cleanId})` : '';
  return await customConfirm(`Abandon unsaved changes on ${display}${idStr}?`);
}

// --- Guard for catalog edits ---
async function guardCatalogAbandon(){
  if(__catalogEdit.isNew){
    // New item that was never saved  always prompt if dirty, remove on abandon
    if(catalogFormIsDirty()){
      const ok = await customConfirm('Discard new ' + (__catalogEdit.kind || 'item') + '?');
      if(!ok) return false;
    }
    // Remove the unsaved new entry
    _removeCatalogNewEntry();
    catalogEditEnd();
    return true;
  }
  if(!catalogFormIsDirty()) return true;
  const snap = __catalogEdit.snapshot;
  const label = snap?.label || snap?.id || __catalogEdit.kind;
  const ok = await guardAbandonEdit(label, snap?.id);
  if(ok && __catalogEdit.kind === 'attr' && __catalogEdit.idx >= 0 && snap){
    // Revert in-place changes (values array, multi flag)
    const cat = ensureCustomAttributeCatalog();
    const item = cat[__catalogEdit.idx];
    if(item){
      item.values = snap.values ? JSON.parse(JSON.stringify(snap.values)) : [];
      item.multi = !!snap.multi;
    }
  }
  return ok;
}

function _removeCatalogNewEntry(){
  const { kind, idx } = __catalogEdit;
  if(idx < 0) return;
  if(kind === 'tag'){
    ensureTagCatalog().splice(idx, 1);
  } else if(kind === 'transform'){
    ensureTransformCatalog().splice(idx, 1);
  } else if(kind === 'attr'){
    ensureCustomAttributeCatalog().splice(idx, 1);
  }
}

function _wireLabelToId(card, kind, dataObj){
  const labelInp = card.querySelector('[data-f="label"]');
  const idInp = card.querySelector('[data-f="id"]');
  const abbrInp = card.querySelector('[data-f="abbr"]');
  if(!labelInp || !idInp) return;
  const isNew = __catalogEdit.isNew;

  const slugify = (raw)=>{
    if(kind === 'tag') return slugifyTagLabel(raw);
    if(kind === 'transform') return slugifyTransformLabel(raw);
    return idPartFromLabel(raw, {lower:true});
  };
  const autoAbbr = (raw)=>{
    if(kind === 'tag') return raw ? raw.slice(0,1).toUpperCase() : '';
    return raw ? raw.replace(/\s+/g,'').slice(0,2).toUpperCase() : '';
  };

  const idAutoTag = card.querySelector('[data-auto="id"]');
  const abbrAutoTag = card.querySelector('[data-auto="abbr"]');

  // Determine initial auto state from persisted flag
  const initLabel = labelInp.value.trim();
  const initIdAuto = slugify(initLabel) || '';
  let lastAutoId = (dataObj && dataObj._autoId) ? initIdAuto : '';
  __editorAutoId = lastAutoId !== '';

  let lastAutoAbbr = '';
  if(abbrInp){
    const initAbbrAuto = autoAbbr(initLabel);
    lastAutoAbbr = (dataObj && dataObj._autoAbbr) ? initAbbrAuto : '';
  }
  __editorAutoAbbr = lastAutoAbbr !== '';

  const refreshTags = ()=>{
    if(idAutoTag) idAutoTag.style.display = lastAutoId !== '' ? '' : 'none';
    if(abbrAutoTag) abbrAutoTag.style.display = lastAutoAbbr !== '' ? '' : 'none';
  };
  refreshTags();

  labelInp.addEventListener('input', ()=>{
    const raw = labelInp.value.trim();
    const cur = idInp.value.trim();
    if(!cur || cur === lastAutoId){
      const autoId = slugify(raw) || '';
      idInp.value = autoId;
      lastAutoId = autoId;
    }
    __editorAutoId = lastAutoId !== '';
    if(abbrInp){
      const curAbbr = abbrInp.value.trim();
      if(!curAbbr || curAbbr === lastAutoAbbr){
        const a = autoAbbr(raw);
        abbrInp.value = a;
        lastAutoAbbr = a;
      }
    }
    __editorAutoAbbr = lastAutoAbbr !== '';
    refreshTags();
  });

  idInp.addEventListener('input', ()=>{
    if(!idInp.value.trim()){
      const autoId = slugify(labelInp.value.trim()) || '';
      idInp.value = autoId;
      lastAutoId = autoId;
    } else {
      lastAutoId = '';
    }
    __editorAutoId = lastAutoId !== '';
    refreshTags();
  });

  if(abbrInp){
    abbrInp.addEventListener('input', ()=>{
      if(!abbrInp.value.trim()){
        const a = autoAbbr(labelInp.value.trim());
        abbrInp.value = a;
        lastAutoAbbr = a;
      } else {
        lastAutoAbbr = '';
      }
      __editorAutoAbbr = lastAutoAbbr !== '';
      refreshTags();
    });
  }

  if(isNew) setTimeout(()=> labelInp.focus(), 50);
}

// --- Guard for filter edits ---
async function guardFilterAbandon(){
  if(__filterIsNew){
    if(filterFormIsDirty()){
      const ok = await customConfirm('Discard new filter?');
      if(!ok) return false;
    }
    // Remove the unsaved new filter
    const cat = ensureFilterCatalog();
    const i = cat.findIndex(x => x.id === __filterEditId);
    if(i >= 0) cat.splice(i, 1);
    __filterEditId = null;
    __filterEditSnapshot = null;
    __filterIsNew = false;
    return true;
  }
  if(!filterFormIsDirty()) return true;
  const cat = ensureFilterCatalog();
  const f = cat.find(x => x.id === __filterEditId);
  const ok = await guardAbandonEdit(f?.label || __filterEditId, __filterEditId);
  if(ok && f && __filterEditSnapshot){
    // Revert in-place rule changes
    const snap = JSON.parse(__filterEditSnapshot);
    if(snap.rules) f.rules = snap.rules;
  }
  return ok;
}

// --- Guard for node/column edits ---
async function guardNodeAbandon(){
  if(!nodeEditIsDirty()) return true;
  const { kind, id } = __editSnapshot;
  let label = id;
  if(kind === 'column'){
    const col = findColumnById(id);
    label = col?.label || id;
  } else if(kind === 'node'){
    const node = IDX?.nodeById?.get(id);
    label = node?.label || id;
  }
  return await guardAbandonEdit(label, id);
}

// --- Dirty-highlight helper: toggles .btnDirty on Save button when form is dirty ---
function wireDirtyHighlight(container, saveBtn, dirtyFn){
  if(!container || !saveBtn || !dirtyFn) return;
  const update = ()=>{ saveBtn.classList.toggle('btnDirty', dirtyFn()); };
  container.addEventListener('input', update);
  container.addEventListener('change', update);
  // click catches tag chip add/remove, transform chips, checkbox labels, etc.
  container.addEventListener('click', ()=> setTimeout(update, 50));
  // Initial check
  update();
  // Expose updater so external code (tag toggles, transform adds) can trigger it
  saveBtn.__dirtyUpdate = update;
}

function renderTagsManager(){
  const cat = ensureTagCatalog();
  if(!tagsBody) return;
  if(!cat.length){
    tagsBody.innerHTML = '<div class="empty">' + (state.editorMode ? 'No tags yet. Click \u201cAdd tag\u201d.' : 'No tags defined.') + '</div>';
    return;
  }
  // Build sorted index array by priority
  const sortedIdxs = cat.map((_,i)=>i).sort((a,b)=>{
    const pa = typeof cat[a].priority==='number' ? cat[a].priority : 9999;
    const pb = typeof cat[b].priority==='number' ? cat[b].priority : 9999;
    return pa - pb;
  });
  const rows = sortedIdxs.map((idx, sortPos)=>{
    const t = cat[idx];
    const id = escapeHtml(t.id||'');
    const label = escapeHtml(t.label||'');
    const abbr = escapeHtml(t.abbr||'');
    const color = t.color || DEFAULT_TAG_COLOR;
    const note = escapeHtml(t.note||'');
    const isEditing = catalogIsEditing('tag', idx);
    const isFirst = sortPos === 0;
    const isLast = sortPos === sortedIdxs.length - 1;

    if(!isEditing){
      const editable = state.editorMode;
      return `<div class="mapCard catItem" data-tidx="${idx}" data-sort-pos="${sortPos}" ${editable?'draggable="true"':''} style="margin-bottom:10px;${editable?'cursor:pointer;':''}padding:12px 14px;display:flex;align-items:center;gap:10px;" ${editable?'title="Click to edit  Drag to reorder"':''}>
        <span class="tagChip" style="background:${escapeHtml(color)};color:#fff;font-size:12px;pointer-events:none;flex-shrink:0;">${abbr || label.charAt(0).toUpperCase()}</span>
        <div style="flex:1;min-width:0;">
          <div style="display:flex;align-items:center;gap:8px;">
            <strong style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${label}</strong>
            <code style="font-size:10px;opacity:.5;flex-shrink:0;">${id}</code>${isLikelyAutoId(t) ? '<span class="autoTag" style="font-size:8px;padding:0 4px;">auto</span>' : ''}
          </div>
          ${note ? `<div class="empty" style="margin-top:4px;font-size:11px;">${note}</div>` : ''}
        </div>
        ${editable ? `<button class="btn catMoveBtn" data-act="moveUp" data-tidx="${idx}" title="Move up" style="padding:2px 6px;font-size:12px;flex-shrink:0;${isFirst?'visibility:hidden;':''}"></button>
        <button class="btn catMoveBtn" data-act="moveDown" data-tidx="${idx}" title="Move down" style="padding:2px 6px;font-size:12px;flex-shrink:0;${isLast?'visibility:hidden;':''}"></button>` : ''}
      </div>`;
    }
    const _isNew = isEditing && __catalogEdit.isNew;
    return `<div class="mapCard catItem catEditing" data-tidx="${idx}" style="margin-bottom:12px;border-color:rgba(59,130,246,.5);padding:12px 14px;">
      <div class="kv" style="grid-template-columns: 90px 1fr;">
        <div class="k">Label</div><div class="v"><input class="inp" data-f="label" value="${_isNew ? '' : label}" placeholder="e.g. Critical"/></div>
        <div class="k">Id <span class="autoTag" data-auto="id">auto</span></div><div class="v"><input class="inp" data-f="id" value="${_isNew ? '' : id}" placeholder="auto" style="font-family:var(--mono);font-size:11px;"/></div>
        <div class="k">Abbr <span class="autoTag" data-auto="abbr">auto</span></div><div class="v"><input class="inp" data-f="abbr" value="${_isNew ? '' : abbr}" placeholder="S"/></div>
        <div class="k">Color</div><div class="v"><div data-f="colorSwatches" style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px;"></div><div style="display:flex;align-items:center;gap:6px;"><input type="color" data-f="colorPicker" value="${escapeHtml(color||'#3b82f6')}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;"/><input class="inp" data-f="color" value="${escapeHtml(color)}" placeholder="#3b82f6" style="flex:1;"/></div></div>
        <div class="k">Note</div><div class="v"><input class="inp" data-f="note" value="${_isNew ? '' : note}" placeholder="optional"/></div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap;">
        ${_isNew ? '' : '<button class="btn" data-act="del" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
        <span style="flex:1;"></span>
        <button class="btn" data-act="cancel">Cancel</button>
        <button class="btn btnSave" data-act="save">Save</button>
      </div>
    </div>`;
  }).join('\n');
  tagsBody.innerHTML = rows;
  tagsBody.classList.toggle('catEditActive', __catalogEdit.kind === 'tag' && __catalogEdit.idx >= 0);

  // Reorder button handlers (must be before click-to-edit so stopPropagation works)
  tagsBody.querySelectorAll('.catMoveBtn').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(!state.editorMode) return;
      const tidx = Number(btn.dataset.tidx);
      const dir = btn.dataset.act === 'moveUp' ? -1 : 1;
      const pos = sortedIdxs.indexOf(tidx);
      const swapPos = pos + dir;
      if(swapPos < 0 || swapPos >= sortedIdxs.length) return;
      const otherIdx = sortedIdxs[swapPos];
      recordChange();
      const tmp = cat[tidx].priority;
      cat[tidx].priority = cat[otherIdx].priority;
      cat[otherIdx].priority = tmp;
      renderTagsManager();
      renderAll();
    });
  });

  // Drag-and-drop reorder
  let __tagDragSortPos = null;
  let __tagDragTime = 0;
  tagsBody.querySelectorAll('.catItem:not(.catEditing)').forEach(card=>{
    card.addEventListener('dragstart', (e)=>{
      __tagDragSortPos = Number(card.dataset.sortPos);
      __tagDragTime = Date.now();
      card.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', ''); // required for Firefox
    });
    card.addEventListener('dragend', ()=>{
      card.style.opacity = '';
      tagsBody.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      __tagDragSortPos = null;
    });
    card.addEventListener('dragover', (e)=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      tagsBody.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      card.classList.add('dragOver');
    });
    card.addEventListener('dragleave', ()=>{
      card.classList.remove('dragOver');
    });
    card.addEventListener('drop', (e)=>{
      e.preventDefault();
      card.classList.remove('dragOver');
      const fromPos = __tagDragSortPos;
      const toPos = Number(card.dataset.sortPos);
      if(fromPos === null || fromPos === toPos) return;
      // Reassign priorities: reorder sortedIdxs, then assign sequential priorities
      const reordered = [...sortedIdxs];
      const [moved] = reordered.splice(fromPos, 1);
      reordered.splice(toPos, 0, moved);
      recordChange();
      reordered.forEach((catIdx, newPos) => { cat[catIdx].priority = newPos + 1; });
      renderTagsManager();
      renderAll();
    });
  });

  tagsBody.querySelectorAll('.catItem').forEach(card=>{
    const idx = Number(card.dataset.tidx);
    const isEditing = catalogIsEditing('tag', idx);
    if(!isEditing){
      card.addEventListener('click', async (e)=>{
        if(!state.editorMode) return;
        // Don't enter edit mode if clicking reorder buttons or just finished a drag
        if(e.target.closest('.catMoveBtn')) return;
        if(Date.now() - __tagDragTime < 300) return;
        const itemId = cat[idx]?.id; // capture before guard may shift indices
        if(!await guardCatalogAbandon()) return;
        catalogEditEnd();
        const freshIdx = cat.findIndex(t => t.id === itemId);
        if(freshIdx < 0) { renderTagsManager(); return; }
        catalogEditBegin('tag', freshIdx, cat[freshIdx]);
        renderTagsManager();
      });
      return;
    }
    // Build color swatches
    const sw = card.querySelector('[data-f="colorSwatches"]');
    const colorInp = card.querySelector('input[data-f="color"]');
    const colorPick = card.querySelector('input[data-f="colorPicker"]');
    if(sw){
      const curColor = (colorInp?.value || DEFAULT_TAG_COLOR).trim();
      TAG_COLOR_PRESETS.forEach(p=>{
        const s = document.createElement('div');
        s.className = 'swatch' + (p.value===curColor ? ' sel' : '');
        s.style.background = p.value;
        s.title = p.name + ' ' + p.value;
        s.addEventListener('click', (e)=>{
          e.stopPropagation();
          if(colorInp){ colorInp.value = p.value; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
          if(colorPick) colorPick.value = p.value;
          sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
          s.classList.add('sel');
        });
        sw.appendChild(s);
      });
      if(colorPick){
        colorPick.addEventListener('input', ()=>{
          if(colorInp) colorInp.value = colorPick.value;
          sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        });
      }
      if(colorInp) colorInp.addEventListener('input', ()=>{
        const v = (colorInp.value||'').trim();
        if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
          if(colorPick) colorPick.value = v;
          sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        }
      });
    }
    // Save
    card.querySelector('[data-act="save"]')?.addEventListener('click', ()=>{
      const t = cat[idx]; if(!t) return;
      const newLabel = (card.querySelector('[data-f="label"]')?.value||'').trim() || t.label;
      if(!newLabel){ customAlert('Please enter a label.'); card.querySelector('[data-f="label"]')?.focus(); return; }
      let newId = sanitizeManualId(card.querySelector('[data-f="id"]')?.value||'');
      if(!newId) newId = slugifyTagLabel(newLabel) || t.id;
      const newAbbr = (card.querySelector('[data-f="abbr"]')?.value||'').trim();
      const newColor = (card.querySelector('[data-f="color"]')?.value||'').trim() || DEFAULT_TAG_COLOR;
      const newNote = (card.querySelector('[data-f="note"]')?.value||'').trim();
      recordChange();
      t.label = newLabel; t.abbr = newAbbr; t.color = newColor; t.note = newNote;
      t._autoId = __editorAutoId; t._autoAbbr = __editorAutoAbbr;
      if(newId !== t.id){
        const result = reIdTagInData(state.data, t.id, newId);
        if(result === t.id) setGlobalStatus('Tag ID conflict \u2014 not changed.');
      }
      catalogEditEnd(); renderTagsManager(); renderAll();
    });
    // Cancel
    card.querySelector('[data-act="cancel"]')?.addEventListener('click', ()=>{
      if(__catalogEdit.isNew) _removeCatalogNewEntry();
      catalogEditEnd(); renderTagsManager();
    });
    // Delete
    card.querySelector('[data-act="del"]')?.addEventListener('click', async ()=>{
      if(!__catalogEdit.isNew && !await customConfirm('Delete tag?')) return;
      if(!__catalogEdit.isNew) recordChange();
      const tid = cat[idx]?.id;
      cat.splice(idx,1);
      if(tid){ for(const n of IDX.nodeById.values()){ if(Array.isArray(n.tags)) n.tags = n.tags.filter(x=>x!==tid); } }
      catalogEditEnd(); renderAll(); renderTagsManager();
    });
    wireDirtyHighlight(card, card.querySelector('[data-act="save"]'), catalogFormIsDirty);
    _wireLabelToId(card, 'tag', cat[idx]);
  });
}


// --- Transform manager modal ---
function renderTransformsManager(){
  const cat = ensureTransformCatalog();
  const body = document.getElementById('transformsBody');
  if(!body) return;
  if(!cat.length){
    body.innerHTML = '<div class="empty">' + (state.editorMode ? 'No transforms yet. Click \u201cAdd transform\u201d.' : 'No transforms defined.') + '</div>';
    return;
  }
  body.innerHTML = cat.map((t, idx)=>{
    const id = escapeHtml(t.id||'');
    const label = escapeHtml(t.label||'');
    const abbr = escapeHtml(t.abbr||'');
    const note = escapeHtml(t.note||'');
    const isEditing = catalogIsEditing('transform', idx);

    if(!isEditing){
      const editable = state.editorMode;
      const paramCount = Array.isArray(t.params) ? t.params.length : 0;
      const paramInfo = paramCount ? `<span style="font-size:10px;opacity:.45;margin-left:4px;">${paramCount} param${paramCount>1?'s':''}</span>` : '';
      const tColorDot = t.color ? `<span style="width:10px;height:10px;border-radius:3px;background:${escapeHtml(t.color)};display:inline-block;flex-shrink:0;border:1px solid rgba(255,255,255,.12);"></span>` : '';
      return `<div class="mapCard catItem" data-tidx="${idx}" style="margin-bottom:8px;${editable?'cursor:pointer;':''}" ${editable?'title="Click to edit"':''}>
        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
          ${tColorDot}
          ${abbr ? `<span class="tagChip" style="font-size:12px;pointer-events:none;${t.color?'background:'+escapeHtml(t.color)+';color:#fff;':''}">${abbr}</span>` : ''}
          <strong style="flex:1;">${label}${paramInfo}</strong>
          <code style="font-size:10px;opacity:.5;">${id}</code>${isLikelyAutoId(t) ? '<span class="autoTag" style="font-size:8px;padding:0 4px;">auto</span>' : ''}
        </div>
        ${note ? `<div class="empty" style="margin-top:4px;font-size:11px;">${note}</div>` : ''}
      </div>`;
    }
    const paramsArr = Array.isArray(t.params) ? t.params : [];
    const paramsHtml = paramsArr.map((p, pi)=>`
      <div class="trParamRow" data-pi="${pi}" style="display:flex;gap:4px;align-items:center;margin-bottom:4px;">
        <input class="inp" data-pf="label" value="${escapeHtml(p.label||'')}" placeholder="label" style="flex:2;"/>
        <input class="inp" data-pf="id" value="${escapeHtml(p.id||'')}" placeholder="id (auto)" style="flex:1;font-family:var(--mono);font-size:10px;"/>
        <select class="inp" data-pf="type" style="flex:0 0 70px;font-size:11px;">
          <option value="text"${p.type==='text'?' selected':''}>text</option>
          <option value="number"${p.type==='number'?' selected':''}>number</option>
        </select>
        <input class="inp" data-pf="default" value="${escapeHtml(p.default!==undefined?String(p.default):'')}" placeholder="default" style="flex:1;font-size:11px;"/>
        <button class="btn" data-act="rmParam" data-pi="${pi}" style="padding:2px 6px;font-size:11px;" title="Remove"></button>
      </div>
    `).join('');
    const _isNew = isEditing && __catalogEdit.isNew;
    const tColor = escapeHtml(t.color||'');
    return `<div class="mapCard catItem catEditing" data-tidx="${idx}" style="margin-bottom:10px;border-color:rgba(59,130,246,.5);">
      <div class="kv" style="grid-template-columns: 90px 1fr;">
        <div class="k">Label</div><div class="v"><input class="inp" data-f="label" value="${_isNew ? '' : label}" placeholder="e.g. Trim whitespace"/></div>
        <div class="k">Id <span class="autoTag" data-auto="id">auto</span></div><div class="v"><input class="inp" data-f="id" value="${_isNew ? '' : id}" placeholder="auto" style="font-family:var(--mono);font-size:11px;"/></div>
        <div class="k">Abbr <span class="autoTag" data-auto="abbr">auto</span></div><div class="v"><input class="inp" data-f="abbr" value="${_isNew ? '' : abbr}" placeholder="TR"/></div>
        <div class="k">Color</div><div class="v"><div data-f="colorSwatches" style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px;"></div><div style="display:flex;align-items:center;gap:6px;"><input type="color" data-f="colorPicker" value="${tColor||'#6b7280'}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${tColor?'':'opacity:.3;'}"/><input class="inp" data-f="color" value="${tColor}" placeholder="optional" style="flex:1;"/><span class="layoutReset trColorReset" title="Reset color" style="opacity:.3;cursor:pointer;font-size:12px;color:var(--muted);"></span></div></div>
        <div class="k">Note</div><div class="v"><input class="inp" data-f="note" value="${_isNew ? '' : note}" placeholder="optional"/></div>
        <div class="k">Params</div><div class="v">
          <div id="trParams_${idx}">${_isNew ? '<span class="empty" style="font-size:11px;">No parameters</span>' : (paramsHtml || '<span class="empty" style="font-size:11px;">No parameters</span>')}</div>
          <button class="btn" data-act="addParam" style="margin-top:4px;font-size:11px;padding:2px 8px;">+ Add param</button>
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap;">
        ${_isNew ? '' : '<button class="btn" data-act="del" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
        <span style="flex:1;"></span>
        <button class="btn" data-act="cancel">Cancel</button>
        <button class="btn btnSave" data-act="save">Save</button>
      </div>
    </div>`;
  }).join('\n');
  body.classList.toggle('catEditActive', __catalogEdit.kind === 'transform' && __catalogEdit.idx >= 0);

  body.querySelectorAll('.catItem').forEach(card=>{
    const idx = Number(card.dataset.tidx);
    const isEditing = catalogIsEditing('transform', idx);
    if(!isEditing){
      card.addEventListener('click', async ()=>{
        if(!state.editorMode) return;
        const itemId = cat[idx]?.id; // capture before guard may shift indices
        if(!await guardCatalogAbandon()) return;
        catalogEditEnd();
        const freshIdx = cat.findIndex(t => t.id === itemId);
        if(freshIdx < 0) { renderTransformsManager(); return; }
        catalogEditBegin('transform', freshIdx, cat[freshIdx]);
        renderTransformsManager();
      });
      return;
    }
    // Save
    card.querySelector('[data-act="save"]')?.addEventListener('click', ()=>{
      const t = cat[idx]; if(!t) return;
      const newLabel = (card.querySelector('[data-f="label"]')?.value||'').trim() || t.label;
      if(!newLabel){ customAlert('Please enter a label.'); card.querySelector('[data-f="label"]')?.focus(); return; }
      let newId = sanitizeManualId(card.querySelector('[data-f="id"]')?.value||'');
      if(!newId) newId = slugifyTransformLabel(newLabel) || t.id;
      const newAbbr = (card.querySelector('[data-f="abbr"]')?.value||'').trim();
      const newNote = (card.querySelector('[data-f="note"]')?.value||'').trim();
      // Read params from form
      const paramRows = card.querySelectorAll('.trParamRow');
      const newParams = [];
      paramRows.forEach(row => {
        let pid = (row.querySelector('[data-pf="id"]')?.value||'').trim();
        const plabel = (row.querySelector('[data-pf="label"]')?.value||'').trim();
        const ptype = row.querySelector('[data-pf="type"]')?.value || 'text';
        const pdef = (row.querySelector('[data-pf="default"]')?.value||'').trim();
        // Auto-generate id from label if empty
        if(!pid && plabel) pid = plabel.toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
        if(pid){
          const p = { id: pid, label: plabel || pid, type: ptype };
          if(pdef !== '') p.default = ptype === 'number' ? Number(pdef) : pdef;
          newParams.push(p);
        }
      });
      recordChange();
      t.label = newLabel; t.abbr = newAbbr; t.note = newNote;
      t._autoId = __editorAutoId; t._autoAbbr = __editorAutoAbbr;
      const newColor = (card.querySelector('[data-f="color"]')?.value||'').trim();
      if(newColor) t.color = newColor; else delete t.color;
      t.params = newParams.length ? newParams : undefined;
      if(!t.params) delete t.params;
      if(newId !== t.id){
        const result = reIdTransformInData(state.data, t.id, newId);
        if(result === t.id) setGlobalStatus('Transform ID conflict \u2014 not changed.');
      }
      catalogEditEnd(); renderTransformsManager(); renderAll();
    });
    // Add param button
    card.querySelector('[data-act="addParam"]')?.addEventListener('click', ()=>{
      const container = card.querySelector(`#trParams_${idx}`);
      if(!container) return;
      const empty = container.querySelector('.empty');
      if(empty) empty.remove();
      const pi = container.querySelectorAll('.trParamRow').length;
      const row = document.createElement('div');
      row.className = 'trParamRow';
      row.dataset.pi = pi;
      row.style.cssText = 'display:flex;gap:4px;align-items:center;margin-bottom:4px;';
      row.innerHTML = `
        <input class="inp" data-pf="label" value="" placeholder="label" style="flex:2;"/>
        <input class="inp" data-pf="id" value="" placeholder="id (auto)" style="flex:1;font-family:var(--mono);font-size:10px;"/>
        <select class="inp" data-pf="type" style="flex:0 0 70px;font-size:11px;">
          <option value="text">text</option>
          <option value="number">number</option>
        </select>
        <input class="inp" data-pf="default" value="" placeholder="default" style="flex:1;font-size:11px;"/>
        <button class="btn" data-act="rmParam" style="padding:2px 6px;font-size:11px;" title="Remove"></button>
      `;
      // Auto-generate id from label whenever id is empty
      const lblInp = row.querySelector('[data-pf="label"]');
      const idInp = row.querySelector('[data-pf="id"]');
      const slugP = (s)=> s.trim().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
      if(lblInp && idInp){
        let _lastAuto = idInp.value.trim();
        lblInp.addEventListener('input', ()=>{
          const cur = idInp.value.trim();
          if(!cur || cur === _lastAuto){ const a = slugP(lblInp.value); idInp.value = a; _lastAuto = a; }
        });
        idInp.addEventListener('input', ()=>{
          if(!idInp.value.trim()){ const a = slugP(lblInp.value); idInp.value = a; _lastAuto = a; }
          else _lastAuto = '';
        });
      }
      row.querySelector('[data-act="rmParam"]').addEventListener('click', ()=> row.remove());
      container.appendChild(row);
    });
    // Remove param buttons
    card.querySelectorAll('[data-act="rmParam"]').forEach(btn => {
      btn.addEventListener('click', ()=> btn.closest('.trParamRow')?.remove());
    });
    // Color swatches, picker, reset (same pattern as tags)
    {
      const sw = card.querySelector('[data-f="colorSwatches"]');
      const colorInp = card.querySelector('input[data-f="color"]');
      const colorPick = card.querySelector('input[data-f="colorPicker"]');
      const colorReset = card.querySelector('.trColorReset');
      if(sw){
        const curColor = (colorInp?.value || '').trim();
        TAG_COLOR_PRESETS.forEach(p=>{
          const s = document.createElement('div');
          s.className = 'swatch' + (p.value===curColor ? ' sel' : '');
          s.style.background = p.value;
          s.title = p.name + ' ' + p.value;
          s.addEventListener('click', (e)=>{
            e.stopPropagation();
            if(colorInp){ colorInp.value = p.value; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
            if(colorPick){ colorPick.value = p.value; colorPick.style.opacity = '1'; }
            sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
            s.classList.add('sel');
          });
          sw.appendChild(s);
        });
      }
      if(colorPick){
        colorPick.addEventListener('input', ()=>{
          if(colorInp){ colorInp.value = colorPick.value; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
          colorPick.style.opacity = '1';
          if(sw) sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        });
      }
      if(colorInp) colorInp.addEventListener('input', ()=>{
        const v = (colorInp.value||'').trim();
        if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
          if(colorPick){ colorPick.value = v; colorPick.style.opacity = '1'; }
          if(sw) sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        }
      });
      if(colorReset){
        colorReset.addEventListener('click', ()=>{
          if(colorInp){ colorInp.value = ''; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
          if(colorPick){ colorPick.value = '#6b7280'; colorPick.style.opacity = '.3'; }
          if(sw) sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        });
      }
    }
    // Cancel
    card.querySelector('[data-act="cancel"]')?.addEventListener('click', ()=>{
      if(__catalogEdit.isNew) _removeCatalogNewEntry();
      catalogEditEnd(); renderTransformsManager();
    });
    // Delete
    card.querySelector('[data-act="del"]')?.addEventListener('click', async ()=>{
      if(!__catalogEdit.isNew && !await customConfirm('Delete transform?')) return;
      if(!__catalogEdit.isNew) recordChange();
      const tid = ensureTransformCatalog()[idx]?.id;
      ensureTransformCatalog().splice(idx,1);
      if(tid && state.data && Array.isArray(state.data.mappings)){
        state.data.mappings.forEach(m=>{ if(m && Array.isArray(m.transforms)) m.transforms = m.transforms.filter(x=> transformRefId(x) !== tid); });
      }
      catalogEditEnd(); renderAll(); renderTransformsManager();
    });
    wireDirtyHighlight(card, card.querySelector('[data-act="save"]'), catalogFormIsDirty);
    _wireLabelToId(card, 'transform', cat[idx]);
  });
}
function openTransforms(){
  ensureTransformCatalog();
  catalogEditEnd();
  renderTransformsManager();
  if(addTransformBtn) addTransformBtn.style.display = state.editorMode ? '' : 'none';
  document.getElementById('transformsMask')?.classList.add('active');
  document.getElementById('transformsModal')?.classList.add('active');
}
async function closeTransforms(){
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  document.getElementById('transformsMask')?.classList.remove('active');
  document.getElementById('transformsModal')?.classList.remove('active');
}
function openTransformCreatePrompt(after){
  openTransformCreateModal({ afterCreate: (id)=>{ if(typeof after==='function') after(id); } });
}



// --- Custom Attributes manager modal ---
function renderCustomAttrsManager(){
  const cat = ensureCustomAttributeCatalog();
  normalizeCatalogMultiFlag();
  const body = document.getElementById('customAttrsBody');
  if(!body) return;
  if(!cat.length){
    body.innerHTML = '<div class="empty">' + (state.editorMode ? 'No attributes yet. Click \u201cAdd attribute\u201d.' : 'No attributes defined.') + '</div>';
    return;
  }
  // Build sorted index array by priority (like tags)
  const sortedIdxs = cat.map((_,i)=>i).sort((a,b)=>{
    const pa = typeof cat[a].priority==='number' ? cat[a].priority : 9999;
    const pb = typeof cat[b].priority==='number' ? cat[b].priority : 9999;
    return pa - pb;
  });
  const rows = sortedIdxs.map((idx, sortPos)=>{
    const a = cat[idx];
    const id = escapeHtml(a.id||'');
    const label = escapeHtml(a.label||'');
    const abbr = escapeHtml(a.abbr||'');
    const note = escapeHtml(a.note||'');
    const vals = Array.isArray(a.values) ? a.values : [];
    const isEditing = catalogIsEditing('attr', idx);
    const isFirst = sortPos === 0;
    const isLast = sortPos === sortedIdxs.length - 1;

    if(!isEditing){
      const editable = state.editorMode;
      // Sort values by priority for display
      const sortedVals = [...vals].sort((x,y)=>{
        const px = typeof x.priority==='number' ? x.priority : 9999;
        const py = typeof y.priority==='number' ? y.priority : 9999;
        return px - py;
      });
      const valDots = sortedVals.map(v=>{
        const vColorEnabled = v.color && v.colorEnabled !== false;
        const attrColorEnabled = a.color && a.colorEnabled !== false;
        const c = escapeHtml(vColorEnabled ? v.color : (attrColorEnabled ? a.color : ''));
        const dimmed = v.color && !vColorEnabled ? 'opacity:.4;' : '';
        const vabbr = escapeHtml(v.abbr||'');
        const vlbl = escapeHtml(v.label||v.id);
        return `<span style="display:inline-flex;align-items:center;gap:3px;white-space:nowrap;${dimmed}">${c ? `<span style="width:8px;height:8px;border-radius:3px;background:${c};display:inline-block;flex-shrink:0;border:1px solid rgba(255,255,255,.12);"></span>` : ''}${vabbr ? `<b style="font-size:10px;">${vabbr}</b> ` : ''}${vlbl}</span>`;
      }).join('<span style="opacity:.3;">, </span>');
      const attrColorDot = (a.color && a.colorEnabled !== false) ? `<span style="width:10px;height:10px;border-radius:4px;background:${escapeHtml(a.color)};display:inline-block;flex-shrink:0;border:1px solid rgba(255,255,255,.15);"></span>` : '';
      const displayBadge = a.displayOnNode ? '<span style="font-size:9px;opacity:.4;margin-left:4px;" title="Displayed on nodes"></span>' : '';
      return `<div class="mapCard catItem" data-aidx="${idx}" data-sort-pos="${sortPos}" ${editable?'draggable="true"':''} style="margin-bottom:10px;${editable?'cursor:pointer;':''}padding:12px 14px;display:flex;align-items:center;gap:10px;" ${editable?'title="Click to edit  Drag to reorder"':''}>
        ${attrColorDot}
        <div style="flex:1;min-width:0;">
          <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
            ${abbr ? `<span class="tagChip" style="font-size:12px;pointer-events:none;">${escapeHtml(abbr)}</span>` : ''}
            <strong style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${label}${displayBadge}</strong>
            <span style="font-size:11px;opacity:.5;">${a.multi ? 'multi' : 'single'} \u00b7 ${vals.length} value${vals.length!==1?'s':''}</span>
            <code style="font-size:10px;opacity:.5;flex-shrink:0;">${id}</code>${isLikelyAutoId(a) ? '<span class="autoTag" style="font-size:8px;padding:0 4px;">auto</span>' : ''}
          </div>
          ${vals.length ? `<div class="empty" style="margin-top:4px;font-size:11px;display:flex;flex-wrap:wrap;gap:2px 6px;align-items:center;">${valDots}</div>` : ''}
          ${note ? `<div class="empty" style="margin-top:2px;font-size:11px;">${note}</div>` : ''}
        </div>
        ${editable ? `<button class="btn catMoveBtn" data-act="moveUp" data-aidx="${idx}" title="Move up" style="padding:2px 6px;font-size:12px;flex-shrink:0;${isFirst?'visibility:hidden;':''}"></button>
        <button class="btn catMoveBtn" data-act="moveDown" data-aidx="${idx}" title="Move down" style="padding:2px 6px;font-size:12px;flex-shrink:0;${isLast?'visibility:hidden;':''}"></button>` : ''}
      </div>`;
    }

    // Sort values by priority for edit form
    const sortedValIdxs = vals.map((_,i)=>i).sort((a,b)=>{
      const pa = typeof vals[a].priority==='number' ? vals[a].priority : 9999;
      const pb = typeof vals[b].priority==='number' ? vals[b].priority : 9999;
      return pa - pb;
    });
    const valsHtml = sortedValIdxs.map((vi, vSortPos)=>{
      const v = vals[vi];
      const vid = escapeHtml(v.id||'');
      const vlabel = escapeHtml(v.label||'');
      const vnote = escapeHtml(v.note||'');
      const vcolor = escapeHtml(v.color||'');
      const vabbr = escapeHtml(v.abbr||'');
      const vFirst = vSortPos === 0;
      const vLast = vSortPos === sortedValIdxs.length - 1;
      return `<div class="attrValRow" data-vi="${vi}" style="margin-top:6px;">
        <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
          <button class="btn catMoveBtn" data-act="valUp" data-vi="${vi}" title="Move up" style="padding:1px 4px;font-size:10px;flex-shrink:0;${vFirst?'visibility:hidden;':''}"></button>
          <button class="btn catMoveBtn" data-act="valDown" data-vi="${vi}" title="Move down" style="padding:1px 4px;font-size:10px;flex-shrink:0;${vLast?'visibility:hidden;':''}"></button>
          <input class="inp" data-vf="vlabel" data-vi="${vi}" value="${vlabel}" placeholder="Label" style="flex:1 1 80px;"/>
          <input class="inp" data-vf="vid" data-vi="${vi}" data-orig-id="${vid}" value="${vid}" style="font-family:var(--mono);font-size:11px;max-width:80px;flex:0 0 auto;" title="Value ID"/><span class="autoTag" data-auto="vid" data-vi="${vi}">auto</span>
          <input class="inp" data-vf="vabbr" data-vi="${vi}" value="${vabbr}" placeholder="Abbr" style="max-width:50px;flex:0 0 auto;font-size:11px;" title="Abbreviation (shown as pill on nodes)"/><span class="autoTag" data-auto="vabbr" data-vi="${vi}">auto</span>
          <input type="color" data-vf="vcolor" data-vi="${vi}" value="${vcolor||'#6b7280'}" style="width:24px;height:20px;padding:0;border:1px solid var(--border);border-radius:3px;cursor:pointer;${vcolor && v.colorEnabled!==false?'':'opacity:.3;'}" title="Value color (used in edge coloring)"/>
          <label style="font-size:10px;cursor:pointer;display:inline-flex;align-items:center;gap:2px;flex-shrink:0;"><input type="checkbox" data-vf="vcolorOn" data-vi="${vi}" ${(vcolor && v.colorEnabled!==false)?'checked':''} style="margin:0;"/> Apply</label>
          <span class="layoutReset attrValColorReset" data-vi="${vi}" title="Reset color" style="opacity:.3;cursor:pointer;font-size:12px;color:var(--muted);transition:opacity .15s;"></span>
          <button class="btn attrValSwatchBtn" data-vi="${vi}" style="font-size:10px;padding:1px 5px;" title="Show color presets"></button>
          <input class="inp" data-vf="vnote" data-vi="${vi}" value="${vnote}" placeholder="Note" style="flex:1 1 80px;"/>
          <button class="btn" data-act="delVal" data-vi="${vi}" style="border-color:rgba(255,154,168,.45);">\u00d7</button>
        </div>
        <div class="attrValSwatchPanel" data-vi="${vi}" style="display:none;margin:4px 0 2px 0;padding:4px 0;"></div>
      </div>`;
    }).join('');

    const _isNew = isEditing && __catalogEdit.isNew;
    return `<div class="mapCard catItem catEditing" data-aidx="${idx}" style="margin-bottom:10px;border-color:rgba(59,130,246,.5);">
      <div class="kv" style="grid-template-columns: 90px 1fr;">
        <div class="k">Label</div><div class="v"><input class="inp" data-f="label" value="${_isNew ? '' : label}" placeholder="e.g. Status"/></div>
        <div class="k">Id <span class="autoTag" data-auto="id">auto</span></div><div class="v"><input class="inp" data-f="id" value="${_isNew ? '' : id}" placeholder="auto" style="font-family:var(--mono);font-size:11px;"/></div>
        <div class="k">Abbr <span class="autoTag" data-auto="abbr">auto</span></div><div class="v"><input class="inp" data-f="abbr" value="${_isNew ? '' : abbr}" placeholder="TY"/></div>
        <div class="k">Note</div><div class="v"><input class="inp" data-f="note" value="${_isNew ? '' : note}" placeholder="optional"/></div>
        <div class="k">Color</div><div class="v" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
          <div data-f="attrColorSwatches" style="display:flex;gap:3px;flex-wrap:wrap;"></div>
          <input type="color" data-f="attrColorPicker" value="${a.color||'#6b7280'}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${a.color && a.colorEnabled!==false?'':'opacity:.3;'}"/>
          <label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" data-f="attrColorOn" ${(a.color && a.colorEnabled!==false)?'checked':''}/> Apply</label>
          <span class="layoutReset attrColorReset" title="Reset color" style="opacity:.3;cursor:pointer;font-size:12px;color:var(--muted);"></span>
          <span style="font-size:10px;opacity:.4;">Inherited by values without color</span>
        </div>
        <div class="k">Options</div>
        <div class="v" style="display:flex;flex-wrap:wrap;gap:8px 18px;">
          <label class="toggle" style="padding:6px 10px;display:inline-flex;">
            <input type="checkbox" data-f="multi" ${a.multi ? 'checked' : ''}/>
            Multi-value
          </label>
          <label class="toggle" style="padding:6px 10px;display:inline-flex;">
            <input type="checkbox" data-f="displayOnNode" ${a.displayOnNode ? 'checked' : ''}/>
            Display on node
          </label>
        </div>
        <div class="k">Values</div>
        <div class="v">
          ${valsHtml || '<div class="empty">No values yet.</div>'}
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;">
            <button class="btn" data-act="addVal">Add value\u2026</button>
          </div>
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap;">
        ${_isNew ? '' : '<button class="btn" data-act="delAttr" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
        <span style="flex:1;"></span>
        <button class="btn" data-act="cancel">Cancel</button>
        <button class="btn btnSave" data-act="save">Save</button>
      </div>
    </div>`;
  }).join('\n');
  body.innerHTML = rows;
  body.classList.toggle('catEditActive', __catalogEdit.kind === 'attr' && __catalogEdit.idx >= 0);

  // Reorder button handlers (must be before click-to-edit so stopPropagation works)
  body.querySelectorAll('.catMoveBtn[data-act="moveUp"], .catMoveBtn[data-act="moveDown"]').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(!state.editorMode) return;
      const aidx = Number(btn.dataset.aidx);
      if(isNaN(aidx)) return; // skip value reorder buttons handled separately
      const dir = btn.dataset.act === 'moveUp' ? -1 : 1;
      const pos = sortedIdxs.indexOf(aidx);
      const swapPos = pos + dir;
      if(swapPos < 0 || swapPos >= sortedIdxs.length) return;
      const otherIdx = sortedIdxs[swapPos];
      recordChange();
      const tmp = cat[aidx].priority;
      cat[aidx].priority = cat[otherIdx].priority;
      cat[otherIdx].priority = tmp;
      renderCustomAttrsManager();
      renderAll();
    });
  });

  // Drag-and-drop reorder (like tags)
  let __attrDragSortPos = null;
  let __attrDragTime = 0;
  body.querySelectorAll('.catItem:not(.catEditing)').forEach(card=>{
    card.addEventListener('dragstart', (e)=>{
      __attrDragSortPos = Number(card.dataset.sortPos);
      __attrDragTime = Date.now();
      card.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    });
    card.addEventListener('dragend', ()=>{
      card.style.opacity = '';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      __attrDragSortPos = null;
    });
    card.addEventListener('dragover', (e)=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      card.classList.add('dragOver');
    });
    card.addEventListener('dragleave', ()=>{
      card.classList.remove('dragOver');
    });
    card.addEventListener('drop', (e)=>{
      e.preventDefault();
      card.classList.remove('dragOver');
      const fromPos = __attrDragSortPos;
      const toPos = Number(card.dataset.sortPos);
      if(fromPos === null || fromPos === toPos) return;
      const reordered = [...sortedIdxs];
      const [moved] = reordered.splice(fromPos, 1);
      reordered.splice(toPos, 0, moved);
      recordChange();
      reordered.forEach((catIdx, newPos) => { cat[catIdx].priority = newPos + 1; });
      renderCustomAttrsManager();
      renderAll();
    });
  });

  body.querySelectorAll('.catItem').forEach(card=>{
    const aidx = Number(card.dataset.aidx);
    const a = ensureCustomAttributeCatalog()[aidx];
    if(!a) return;
    const isEditing = catalogIsEditing('attr', aidx);

    if(!isEditing){
      card.addEventListener('click', async (e)=>{
        if(!state.editorMode) return;
        if(e.target.closest('.catMoveBtn')) return;
        if(Date.now() - __attrDragTime < 300) return;
        const itemId = a?.id;
        if(!await guardCatalogAbandon()) return;
        catalogEditEnd();
        const freshCat = ensureCustomAttributeCatalog();
        const freshIdx = freshCat.findIndex(x => x.id === itemId);
        if(freshIdx < 0) { renderCustomAttrsManager(); return; }
        catalogEditBegin('attr', freshIdx, freshCat[freshIdx]);
        renderCustomAttrsManager();
      });
      return;
    }

    // ---- Edit mode wiring ----

    // Value reorder buttons (within edit form)
    card.querySelectorAll('[data-act="valUp"], [data-act="valDown"]').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        const vi = Number(btn.dataset.vi);
        if(!a.values || !a.values[vi]) return;
        const vals = a.values;
        // Sort to find neighbors
        const sorted = vals.map((_,i)=>i).sort((x,y)=>{
          const px = typeof vals[x].priority==='number' ? vals[x].priority : 9999;
          const py = typeof vals[y].priority==='number' ? vals[y].priority : 9999;
          return px - py;
        });
        const pos = sorted.indexOf(vi);
        const dir = btn.dataset.act === 'valUp' ? -1 : 1;
        const swapPos = pos + dir;
        if(swapPos < 0 || swapPos >= sorted.length) return;
        const otherVi = sorted[swapPos];
        const tmp = vals[vi].priority;
        vals[vi].priority = vals[otherVi].priority;
        vals[otherVi].priority = tmp;
        renderCustomAttrsManager();
      });
    });

    // Save: read ALL form values and apply in one shot
    card.querySelector('[data-act="save"]')?.addEventListener('click', ()=>{
      const newLabel = (card.querySelector('[data-f="label"]')?.value||'').trim() || a.label;
      if(!newLabel){ customAlert('Please enter a label.'); card.querySelector('[data-f="label"]')?.focus(); return; }
      let newId = sanitizeManualId(card.querySelector('[data-f="id"]')?.value||'');
      if(!newId) newId = idPartFromLabel(newLabel, {lower:true}) || a.id;
      const newAbbr = (card.querySelector('[data-f="abbr"]')?.value||'').trim();
      const newNote = (card.querySelector('[data-f="note"]')?.value||'').trim();
      const newMulti = !!card.querySelector('[data-f="multi"]')?.checked;
      const newDisplayOnNode = !!card.querySelector('[data-f="displayOnNode"]')?.checked;

      // Collect value edits from form + track renames
      const valRenames = []; // [{oldId, newId}]
      const newValues = [];
      card.querySelectorAll('[data-vf="vlabel"]').forEach(inp=>{
        const vi = Number(inp.dataset.vi);
        const vidInp = card.querySelector(`[data-vf="vid"][data-vi="${vi}"]`);
        const vnoteInp = card.querySelector(`[data-vf="vnote"][data-vi="${vi}"]`);
        const vcolorInp = card.querySelector(`[data-vf="vcolor"][data-vi="${vi}"]`);
        const vabbrInp = card.querySelector(`[data-vf="vabbr"][data-vi="${vi}"]`);
        const origId = vidInp?.dataset?.origId || '';
        const curId = sanitizeManualId(vidInp?.value||'') || origId;
        if(origId && curId && origId !== curId) valRenames.push({oldId: origId, newId: curId});
        const vObj = {
          id: curId,
          label: (inp.value||'').trim() || curId,
          note: (vnoteInp?.value||'').trim()
        };
        // Persist auto-link flags from row dataset
        const valRow = inp.closest('.attrValRow');
        if(valRow) {
          vObj._autoId = valRow.dataset.autoId === '1';
          vObj._autoAbbr = valRow.dataset.autoAbbr === '1';
        }
        // Preserve priority from the original value
        const origVal = a.values && a.values[vi];
        if(origVal && typeof origVal.priority === 'number') vObj.priority = origVal.priority;
        // Abbreviation
        const vabbrVal = (vabbrInp?.value||'').trim();
        if(vabbrVal) vObj.abbr = vabbrVal;
        // Only store color if the picker was actively used (not the placeholder gray)
        const vcolorVal = vcolorInp?.value || '';
        const vcolorOnCb = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
        const vcolorEnabled = vcolorOnCb ? !!vcolorOnCb.checked : (parseFloat(vcolorInp?.style?.opacity||'1') > 0.5);
        if(vcolorVal && vcolorEnabled){ vObj.color = vcolorVal; vObj.colorEnabled = true; }
        else if(vcolorVal && parseFloat(vcolorInp?.style?.opacity||'1') > 0.5){ vObj.color = vcolorVal; vObj.colorEnabled = false; }
        else { vObj.colorEnabled = false; }
        newValues.push(vObj);
      });

      recordChange();
      a.label = newLabel; a.abbr = newAbbr; a.note = newNote; a.multi = newMulti;
      a._autoId = __editorAutoId; a._autoAbbr = __editorAutoAbbr;
      a.displayOnNode = newDisplayOnNode;
      // Attribute-level color
      const attrColorPicker = card.querySelector('[data-f="attrColorPicker"]');
      const attrColorOn = card.querySelector('[data-f="attrColorOn"]');
      if(attrColorOn && attrColorOn.checked && attrColorPicker){
        a.color = attrColorPicker.value; a.colorEnabled = true;
      } else if(attrColorPicker && parseFloat(attrColorPicker.style.opacity||'1') > 0.5){
        a.color = attrColorPicker.value; a.colorEnabled = false;
      } else {
        delete a.color; a.colorEnabled = false;
      }
      a.values = newValues;

      // Handle attribute ID rename
      const attrIdForRenames = a.id;
      if(newId !== a.id){
        const result = reIdCustomAttrInData(state.data, a.id, newId);
        if(result === a.id) setGlobalStatus('Attribute ID conflict \u2014 not changed.');
      }

      // Handle value ID renames (cascade to node assignments)
      valRenames.forEach(({oldId, newId: vid})=>{
        reIdCustomAttrValueInData(state.data, a.id, oldId, vid);
      });

      catalogEditEnd(); renderCustomAttrsManager(); renderAll();
    });

    // Cancel
    card.querySelector('[data-act="cancel"]')?.addEventListener('click', ()=>{
      if(__catalogEdit.isNew){
        _removeCatalogNewEntry();
      } else {
        const snap = __catalogEdit.snapshot;
        if(snap && a){
          Object.assign(a, JSON.parse(JSON.stringify(snap)));
        }
      }
      catalogEditEnd(); checkDirtyState(); renderCustomAttrsManager();
    });

    // Delete value
    card.querySelectorAll('[data-act="delVal"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const vi = Number(btn.dataset.vi);
        if(!a.values) return;
        a.values.splice(vi, 1);
        renderCustomAttrsManager();
      });
    });

    // Add value
    card.querySelector('[data-act="addVal"]')?.addEventListener('click', ()=>{
      const taken = new Set((a.values||[]).map(v=>v && v.id).filter(Boolean));
      openCreateModal({
        kind:'customAttrValue',
        title:`Add value to ${a.label||a.id}`,
        placeholder:'Value label\u2026',
        hint:'ID is generated from the value label.',
        taken,
        onCommit: ({label,id,note,color,abbr,_autoId,_autoAbbr})=>{
          if(!Array.isArray(a.values)) a.values = [];
          // Auto-assign next priority
          let maxVP = 0;
          a.values.forEach(v=>{ if(v && typeof v.priority==='number' && v.priority > maxVP) maxVP = v.priority; });
          const vObj = {id, label, note: (note||''), priority: maxVP + 1, _autoId, _autoAbbr};
          if(abbr) vObj.abbr = abbr;
          if(color) vObj.color = color;
          a.values.push(vObj);
          renderCustomAttrsManager();
        }
      });
    });

    // Value color picker
    card.querySelectorAll('[data-vf="vcolor"]').forEach(inp=>{
      inp.addEventListener('input', ()=>{
        inp.style.opacity = '1';
        const vi = Number(inp.dataset.vi);
        if(a.values && a.values[vi]){ a.values[vi].color = inp.value; a.values[vi].colorEnabled = true; }
        const cb = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
        if(cb) cb.checked = true;
      });
    });

    // Value colorEnabled checkboxes
    card.querySelectorAll('[data-vf="vcolorOn"]').forEach(cb=>{
      cb.addEventListener('change', ()=>{
        const vi = Number(cb.dataset.vi);
        const colorInp = card.querySelector(`[data-vf="vcolor"][data-vi="${vi}"]`);
        if(colorInp) colorInp.style.opacity = cb.checked ? '1' : '.3';
        if(a.values && a.values[vi]) a.values[vi].colorEnabled = cb.checked;
      });
    });

    // Value color swatch toggle buttons
    card.querySelectorAll('.attrValSwatchBtn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const vi = btn.dataset.vi;
        const panel = card.querySelector(`.attrValSwatchPanel[data-vi="${vi}"]`);
        if(!panel) return;
        const visible = panel.style.display !== 'none';
        panel.style.display = visible ? 'none' : 'flex';
        if(!visible && !panel.dataset.built){
          panel.dataset.built = '1';
          panel.style.cssText += 'gap:5px;flex-wrap:wrap;align-items:center;';
          const colorInp = card.querySelector(`[data-vf="vcolor"][data-vi="${vi}"]`);
          TAG_COLOR_PRESETS.forEach(p=>{
            const s = document.createElement('div');
            s.className = 'swatch';
            s.style.cssText = 'width:18px;height:18px;border-radius:6px;flex-shrink:0;cursor:pointer;border:1px solid rgba(255,255,255,.12);box-shadow:0 2px 8px rgba(0,0,0,.2);';
            s.style.background = p.value;
            s.title = p.name;
            s.addEventListener('click', ()=>{
              if(colorInp){ colorInp.value = p.value; colorInp.style.opacity = '1'; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
              const cb2 = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
              if(cb2) cb2.checked = true;
            });
            panel.appendChild(s);
          });
        }
      });
    });

    // Value color reset icons
    card.querySelectorAll('.attrValColorReset').forEach(icon=>{
      icon.addEventListener('click', ()=>{
        const vi = Number(icon.dataset.vi);
        const colorInp = card.querySelector(`[data-vf="vcolor"][data-vi="${vi}"]`);
        if(colorInp){ colorInp.value = '#6b7280'; colorInp.style.opacity = '.3'; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
        const cb = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
        if(cb) cb.checked = false;
        if(a.values && a.values[vi]){ delete a.values[vi].color; a.values[vi].colorEnabled = false; }
      });
    });

    // Attribute-level color swatches, picker, checkbox, reset
    {
      const attrColorPicker = card.querySelector('[data-f="attrColorPicker"]');
      const attrColorOn = card.querySelector('[data-f="attrColorOn"]');
      const attrColorReset = card.querySelector('.attrColorReset');
      const attrSwatchWrap = card.querySelector('[data-f="attrColorSwatches"]');
      if(attrSwatchWrap && attrColorPicker){
        buildColorSwatches(attrSwatchWrap, attrColorPicker);
        // When picker changes, auto-check Apply
        attrColorPicker.addEventListener('input', ()=>{
          if(attrColorOn) attrColorOn.checked = true;
          attrColorPicker.style.opacity = '1';
        });
      }
      if(attrColorOn){
        attrColorOn.addEventListener('change', ()=>{
          if(attrColorPicker) attrColorPicker.style.opacity = attrColorOn.checked ? '1' : '.3';
        });
      }
      if(attrColorReset){
        attrColorReset.addEventListener('click', ()=>{
          if(attrColorPicker){ attrColorPicker.value = '#6b7280'; attrColorPicker.style.opacity = '.3'; attrColorPicker.dispatchEvent(new Event('input',{bubbles:true})); }
          if(attrColorOn) attrColorOn.checked = false;
        });
      }
    }

    // Value row labelidabbr auto-fill
    card.querySelectorAll('.attrValRow').forEach(row=>{
      const vi = row.dataset.vi;
      const vlabelInp = row.querySelector('[data-vf="vlabel"]');
      const vidInp = row.querySelector('[data-vf="vid"]');
      const vabbrInp = row.querySelector('[data-vf="vabbr"]');
      const vidAutoTag = row.querySelector('[data-auto="vid"]');
      const vabbrAutoTag = row.querySelector('[data-auto="vabbr"]');
      if(!vlabelInp || !vidInp) return;
      const slugV = (raw)=> idPartFromLabel(raw, {lower:true});
      const autoAbbrV = (raw)=> raw ? raw.replace(/\s+/g,'').slice(0,3).toUpperCase() : '';
      const initLabel = vlabelInp.value.trim();
      const initIdAuto = slugV(initLabel) || '';
      // Use persisted flag if available
      const valObj = a.values && a.values[Number(vi)];
      let lastAutoId = (valObj && valObj._autoId) ? initIdAuto : '';
      let lastAutoAbbr = '';
      if(vabbrInp){
        const initAbbrAuto = autoAbbrV(initLabel);
        lastAutoAbbr = (valObj && valObj._autoAbbr) ? initAbbrAuto : '';
      }
      row.dataset.autoId = lastAutoId !== '' ? '1' : '0';
      row.dataset.autoAbbr = lastAutoAbbr !== '' ? '1' : '0';
      const refreshAutoTags = ()=>{
        if(vidAutoTag) vidAutoTag.style.display = lastAutoId !== '' ? '' : 'none';
        if(vabbrAutoTag) vabbrAutoTag.style.display = lastAutoAbbr !== '' ? '' : 'none';
      };
      refreshAutoTags();
      vlabelInp.addEventListener('input', ()=>{
        const raw = vlabelInp.value.trim();
        const cur = vidInp.value.trim();
        if(!cur || cur === lastAutoId){ const ai = slugV(raw)||''; vidInp.value = ai; lastAutoId = ai; }
        if(vabbrInp){
          const ca = vabbrInp.value.trim();
          if(!ca || ca === lastAutoAbbr){ const ab = autoAbbrV(raw); vabbrInp.value = ab; lastAutoAbbr = ab; }
        }
        row.dataset.autoId = lastAutoId !== '' ? '1' : '0';
        row.dataset.autoAbbr = lastAutoAbbr !== '' ? '1' : '0';
        refreshAutoTags();
      });
      vidInp.addEventListener('input', ()=>{
        if(!vidInp.value.trim()){ const ai = slugV(vlabelInp.value.trim())||''; vidInp.value = ai; lastAutoId = ai; }
        else lastAutoId = '';
        row.dataset.autoId = lastAutoId !== '' ? '1' : '0';
        refreshAutoTags();
      });
      if(vabbrInp){
        vabbrInp.addEventListener('input', ()=>{
          if(!vabbrInp.value.trim()){ const ab = autoAbbrV(vlabelInp.value.trim()); vabbrInp.value = ab; lastAutoAbbr = ab; }
          else lastAutoAbbr = '';
          row.dataset.autoAbbr = lastAutoAbbr !== '' ? '1' : '0';
          refreshAutoTags();
        });
      }
    });

    // Delete attribute
    card.querySelector('[data-act="delAttr"]')?.addEventListener('click', async ()=>{
      if(!__catalogEdit.isNew && !await customConfirm('Delete attribute? This will remove it from all nodes.')) return;
      if(!__catalogEdit.isNew) recordChange();
      const aid = a.id;
      ensureCustomAttributeCatalog().splice(aidx,1);
      if(aid){
        for(const n of IDX.nodeById.values()){
          if(n && n.customAttributes && typeof n.customAttributes==='object') delete n.customAttributes[aid];
        }
      }
      catalogEditEnd(); renderCustomAttrsManager(); renderAll();
    });
    wireDirtyHighlight(card, card.querySelector('[data-act="save"]'), catalogFormIsDirty);
    _wireLabelToId(card, 'attr', a);
  });
}
function openCustomAttrs(){
  ensureCustomAttributeCatalog();
  normalizeCatalogMultiFlag();
  catalogEditEnd();
  renderCustomAttrsManager();
  if(addCustomAttrBtn) addCustomAttrBtn.style.display = state.editorMode ? '' : 'none';
  document.getElementById('customAttrsMask')?.classList.add('active');
  document.getElementById('customAttrsModal')?.classList.add('active');
}
async function closeCustomAttrs(){
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  document.getElementById('customAttrsMask')?.classList.remove('active');
  document.getElementById('customAttrsModal')?.classList.remove('active');
}
function openTags(){
  ensureTagCatalog();
  catalogEditEnd();
  renderTagsManager();
  if(addTagBtn) addTagBtn.style.display = state.editorMode ? '' : 'none';
  tagsMask?.classList.add('active');
  tagsModal?.classList.add('active');
}
async function closeTags(){
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  tagsMask?.classList.remove('active');
  tagsModal?.classList.remove('active');
}
if(tagsBtn) tagsBtn.addEventListener('click', openTags);
const transformsBtn = document.getElementById('transformsBtn');
const customAttrsBtn = document.getElementById('customAttrsBtn');
if(transformsBtn) transformsBtn.addEventListener('click', openTransforms);
if(customAttrsBtn) customAttrsBtn.addEventListener('click', openCustomAttrs);
if(closeCustomAttrsBtn) closeCustomAttrsBtn.addEventListener('click', closeCustomAttrs);
if(customAttrsMask) customAttrsMask.addEventListener('click', closeCustomAttrs);
if(addCustomAttrBtn) addCustomAttrBtn.addEventListener('click', async ()=>{
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  const cat = ensureCustomAttributeCatalog();
  normalizeCatalogMultiFlag();
  let maxP = 0;
  cat.forEach(a=>{ if(a && typeof a.priority==='number' && a.priority > maxP) maxP = a.priority; });
  const blank = { id: 'attr_' + Date.now().toString(36), label: '', abbr: '', note: '', multi: false, displayOnNode: false, priority: maxP + 1, values: [] };
  cat.push(blank);
  const idx = cat.length - 1;
  catalogEditBegin('attr', idx, blank, true);
  renderCustomAttrsManager();
});

if(closeTagsBtn) closeTagsBtn.addEventListener('click', closeTags);
const closeTransformsBtn = document.getElementById('closeTransformsBtn');
if(closeTransformsBtn) closeTransformsBtn.addEventListener('click', closeTransforms);
if(tagsMask) tagsMask.addEventListener('click', closeTags);
const transformsMask = document.getElementById('transformsMask');
if(transformsMask) transformsMask.addEventListener('click', closeTransforms);
if(addTagBtn) addTagBtn.addEventListener('click', async ()=>{
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  const cat = ensureTagCatalog();
  const minPri = cat.reduce((m,t)=>Math.min(m, typeof t.priority==='number'?t.priority:0), 0);
  const blank = { id: 'tag_' + Date.now().toString(36), label: '', abbr: '', note: '', color: TAG_COLOR_PRESETS[0].value, priority: minPri - 1 };
  cat.push(blank);
  const idx = cat.length - 1;
  catalogEditBegin('tag', idx, blank, true);
  renderTagsManager();
});
if(addTransformBtn) addTransformBtn.addEventListener('click', async ()=>{
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  const cat = ensureTransformCatalog();
  const blank = { id: 'transform_' + Date.now().toString(36), label: '', abbr: '', note: '' };
  cat.unshift(blank);
  catalogEditBegin('transform', 0, blank, true);
  renderTransformsManager();
});
function closeHelp(){
  helpMask.classList.remove('active');
  helpModal.classList.remove('active');
}
if(helpBtn) helpBtn.addEventListener('click', openHelp);
if(closeHelpBtn) closeHelpBtn.addEventListener('click', closeHelp);
if(helpMask) helpMask.addEventListener('click', closeHelp);



if(expandAllBtn) expandAllBtn.addEventListener("click", () => setAllGroupsCollapsed(false));
if(collapseAllBtn) collapseAllBtn.addEventListener("click", () => setAllGroupsCollapsed(true));

if(clearSelectionBtn) clearSelectionBtn.addEventListener("click", () => {
  if(state.editorMode && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node') {
    cancelEditAndDeselect();
    return;
  }
  state.lockedId = null;
  state.hoverId = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.multiSelection.clear();
  applyHighlight();
});

const clearSelBtn = document.getElementById('clearSelBtn');
if(clearSelBtn) clearSelBtn.addEventListener('click', () => {
  if(clearSelectionBtn) clearSelectionBtn.click();
});

function selectAllNodes(){
  state.multiSelection.clear();
  for(const [nid,el] of IDX.elementById.entries()){
    if(!el.classList.contains('hidden') && IDX.rowById.get(nid)?.offsetParent) state.multiSelection.add(nid);
  }
  state.lockedId = null; state.hoverId = null;
  state.selectedEdgeId = null; state.hoverEdgeId = null;
  applyHighlight();
}
function invertSelection(){
  const cur = new Set(state.multiSelection);
  if(cur.size === 0 && state.lockedId) cur.add(state.lockedId);
  state.multiSelection.clear();
  for(const [nid,el] of IDX.elementById.entries()){
    if(!el.classList.contains('hidden') && IDX.rowById.get(nid)?.offsetParent && !cur.has(nid)) state.multiSelection.add(nid);
  }
  state.lockedId = null; state.hoverId = null;
  state.selectedEdgeId = null; state.hoverEdgeId = null;
  applyHighlight();
}
{ const b = document.getElementById('selectAllBtn'); if(b) b.addEventListener('click', selectAllNodes); }
{ const b = document.getElementById('invertSelectionBtn'); if(b) b.addEventListener('click', invertSelection); }

if(loadExampleBtn) loadExampleBtn.addEventListener("click", async () => {
  const sure = await customConfirm('Load the example project?\n\nAny unsaved changes to the current project will be lost.\nMake sure you\u2019ve saved your work first.');
  if(!sure) { setGlobalStatus('Load example cancelled.'); return; }
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.lockedId = null;
  state.hoverId = null;
  state.multiSelection.clear();
  // Clear any in-flight edit sessions
  __editSnapshot = null;
  __edgeEditSession = null;
  state.data = JSON.parse(JSON.stringify(EXAMPLE_JSON));
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  clearUndoHistory();
  renderAll();
  markClean();
  setGlobalStatus('Loaded example project.');
});
if(newMappingBtn) newMappingBtn.addEventListener('click', startNewMapping);

// Dirty state helpers
function markDirty(){
  state.isDirty = true;
  updateSaveButtonStyle();
}

// Combined function: save undo snapshot AND mark dirty
// Call this BEFORE making the change
function recordChange(){
  pushUndo();
  markDirty();
}

function markClean(){
  try { state.__cleanDataJSON = JSON.stringify(state.data); } catch(e) { state.__cleanDataJSON = null; }
  state.isDirty = false;
  updateSaveButtonStyle();
}

function checkDirtyState(){
  if(!state.__cleanDataJSON){ markDirty(); return; }
  try {
    state.isDirty = (JSON.stringify(state.data) !== state.__cleanDataJSON);
  } catch(e) { state.isDirty = true; }
  updateSaveButtonStyle();
}

function updateSaveButtonStyle(){
  if(!saveProjectBtn) return;
  if(state.isDirty){
    saveProjectBtn.classList.add('dirty');
    saveProjectBtn.title = 'Save project (unsaved changes)';
  } else {
    saveProjectBtn.classList.remove('dirty');
    saveProjectBtn.title = 'Download the current project as JSON';
  }
}

// Undo/Redo system
function deepCloneData(data){
  try {
    return JSON.parse(JSON.stringify(data));
  } catch(e) {
    console.error('Failed to clone data:', e);
    return data;
  }
}

function pushUndo(){
  if(!state.data) return;
  
  // Clone current state before it changes
  const snapshot = {
    data: deepCloneData(state.data),
    selection: {
      lockedId: state.lockedId,
      selectedEdgeId: state.selectedEdgeId,
      selectedColumnId: state.selectedColumnId,
      multiSelection: state.multiSelection.size > 0 ? [...state.multiSelection] : null
    }
  };
  
  // Add to undo stack
  state.undoStack.push(snapshot);
  
  // Limit stack size
  if(state.undoStack.length > state.maxUndoSteps){
    state.undoStack.shift();
  }
  
  // Clear redo stack when new action is taken
  state.redoStack = [];
  
  updateUndoRedoButtons();
}

// Save post-action selection into the most recent undo snapshot.
// Called after an action changes the selection (e.g. multi-move updates IDs).
// This lets redo restore the correct post-action selection even if the user
// manually clears the selection before pressing undo.
function savePostSelection(){
  if(state.undoStack.length === 0) return;
  const top = state.undoStack[state.undoStack.length - 1];
  top.postSelection = {
    lockedId: state.lockedId,
    selectedEdgeId: state.selectedEdgeId,
    selectedColumnId: state.selectedColumnId,
    multiSelection: state.multiSelection.size > 0 ? [...state.multiSelection] : null
  };
}

async function undo(){
  if(state.undoStack.length === 0){
    setViewerStatus('Nothing to undo');
    return;
  }
  // Guard unsaved edits
  if(nodeEditIsDirty()){
    if(!await guardNodeAbandon()) return;
    revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
  }
  if(edgeEditIsDirty()){
    if(!await guardAbandonEdit('mapping', __edgeEditSession?.edgeId || '')) return;
  }
  // Discard any active edit sessions (undo replaces state.data entirely)
  __editSnapshot = null;
  clearEdgeEditSession({clearSelection:false});
  
  // Restore previous state
  const snapshot = state.undoStack.pop();
  
  // Save current state to redo stack.
  // Use postSelection (the selection that existed right after the action) if available,
  // so redo restores the correct selection even if the user cleared it before undoing.
  const redoSelection = snapshot.postSelection || {
    lockedId: state.lockedId,
    selectedEdgeId: state.selectedEdgeId,
    selectedColumnId: state.selectedColumnId,
    multiSelection: state.multiSelection.size > 0 ? [...state.multiSelection] : null
  };
  state.redoStack.push({
    data: deepCloneData(state.data),
    selection: redoSelection
  });
  
  state.data = snapshot.data;
  
  
  // Update UI (full refresh without triggering markDirty)
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  try { validateEditor(); } catch(e) {}
  try { rebuildStructuredList(); } catch(e) {}
  
  // FIRST: Clear selections
  state.lockedId = null;
  state.hoverId = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.multiSelection.clear();
  
  // SECOND: Rebuild indexes (needed to check if items exist)
  buildIndexes(state.data);
  rebuildFieldDatalist();
  
  // THIRD: Try to restore selection from snapshot if item still exists

  const savedSelection = snapshot.selection || {};
  
  // Restore multi-selection if present
  let _pendingMultiSelection = null;
  if(savedSelection.multiSelection && Array.isArray(savedSelection.multiSelection)){
    _pendingMultiSelection = savedSelection.multiSelection;
    for(const nid of savedSelection.multiSelection){
      if(IDX && IDX.nodeById && IDX.nodeById.has(nid)){
        state.multiSelection.add(nid);
      }
    }
  }
  
  if(state.multiSelection.size === 0 && savedSelection.lockedId && IDX && IDX.nodeById && IDX.nodeById.has(savedSelection.lockedId)){
    state.lockedId = savedSelection.lockedId;

  } else if(state.multiSelection.size === 0 && savedSelection.selectedColumnId && IDX && IDX.columns && IDX.columns.some(c => c.id === savedSelection.selectedColumnId)){
    state.selectedColumnId = savedSelection.selectedColumnId;

  } else if(state.multiSelection.size === 0 && savedSelection.selectedEdgeId && IDX && IDX.edges && IDX.edges.some(e => e.id === savedSelection.selectedEdgeId)){
    state.selectedEdgeId = savedSelection.selectedEdgeId;

  }
  
  
  // FOURTH: Render and apply highlighting
  renderColumns();
  applyVisibility();
  
  // Force-restore multiSelection right before applyHighlight  ensures no intermediate
  // code path (renderColumns, applyVisibility, event handlers) can clear it
  if(_pendingMultiSelection && _pendingMultiSelection.length > 0){
    state.multiSelection.clear();
    for(const nid of _pendingMultiSelection){
      if(IDX && IDX.nodeById && IDX.nodeById.has(nid)){
        state.multiSelection.add(nid);
      }
    }
    if(state.multiSelection.size > 0){
      state.lockedId = null;
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
    }
  }
  
  applyHighlight();
  
  // Scroll first selected node into view
  if(state.multiSelection.size > 0){
    const firstId = state.multiSelection.values().next().value;
    if(firstId) try{ scrollIntoView(firstId); }catch(e){}
  } else if(state.lockedId){
    try{ scrollIntoView(state.lockedId); }catch(e){}
  }
  
  // Sync header inputs with restored data
  const __ti = document.getElementById('projectTitle');
  if(__ti && state.data) __ti.value = state.data.title || 'New Project';

  updateUndoRedoButtons();
  checkDirtyState();
  setViewerStatus('Undo');
}

async function redo(){
  if(state.redoStack.length === 0){
    setViewerStatus('Nothing to redo');
    return;
  }
  // Guard unsaved edits
  if(nodeEditIsDirty()){
    if(!await guardNodeAbandon()) return;
    revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
  }
  if(edgeEditIsDirty()){
    if(!await guardAbandonEdit('mapping', __edgeEditSession?.edgeId || '')) return;
  }
  __editSnapshot = null;
  clearEdgeEditSession({clearSelection:false});
  
  // Restore next state
  const snapshot = state.redoStack.pop();
  
  // Save current state to undo stack.
  // Preserve postSelection from the redo snapshot so that if the user undoes again,
  // the redo entry will still know the correct post-action selection.
  state.undoStack.push({
    data: deepCloneData(state.data),
    selection: {
      lockedId: state.lockedId,
      selectedEdgeId: state.selectedEdgeId,
      selectedColumnId: state.selectedColumnId,
      multiSelection: state.multiSelection.size > 0 ? [...state.multiSelection] : null
    },
    postSelection: snapshot.selection  // the redo target selection becomes the postSelection
  });
  
  state.data = snapshot.data;
  
  // Update UI (full refresh without triggering markDirty)
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  try { validateEditor(); } catch(e) {}
  try { rebuildStructuredList(); } catch(e) {}
  
  // FIRST: Clear selections
  state.lockedId = null;
  state.hoverId = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.multiSelection.clear();
  
  // SECOND: Rebuild indexes
  buildIndexes(state.data);
  rebuildFieldDatalist();
  
  // THIRD: Try to restore selection from snapshot if item still exists
  const savedSelection = snapshot.selection || {};
  
  // Restore multi-selection if present
  let _pendingMultiSelection = null;
  if(savedSelection.multiSelection && Array.isArray(savedSelection.multiSelection)){
    _pendingMultiSelection = savedSelection.multiSelection;
    for(const nid of savedSelection.multiSelection){
      if(IDX && IDX.nodeById && IDX.nodeById.has(nid)){
        state.multiSelection.add(nid);
      }
    }
  }
  
  if(state.multiSelection.size === 0 && savedSelection.lockedId && IDX && IDX.nodeById && IDX.nodeById.has(savedSelection.lockedId)){
    state.lockedId = savedSelection.lockedId;
  } else if(state.multiSelection.size === 0 && savedSelection.selectedColumnId && IDX && IDX.columns && IDX.columns.some(c => c.id === savedSelection.selectedColumnId)){
    state.selectedColumnId = savedSelection.selectedColumnId;
  } else if(state.multiSelection.size === 0 && savedSelection.selectedEdgeId && IDX && IDX.edges && IDX.edges.some(e => e.id === savedSelection.selectedEdgeId)){
    state.selectedEdgeId = savedSelection.selectedEdgeId;
  }
  
  // FOURTH: Render and apply highlighting
  renderColumns();
  applyVisibility();
  
  // Force-restore multiSelection right before applyHighlight
  if(_pendingMultiSelection && _pendingMultiSelection.length > 0){
    state.multiSelection.clear();
    for(const nid of _pendingMultiSelection){
      if(IDX && IDX.nodeById && IDX.nodeById.has(nid)){
        state.multiSelection.add(nid);
      }
    }
    if(state.multiSelection.size > 0){
      state.lockedId = null;
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
    }
  }
  
  applyHighlight();
  
  // Scroll first selected node into view
  if(state.multiSelection.size > 0){
    const firstId = state.multiSelection.values().next().value;
    if(firstId) try{ scrollIntoView(firstId); }catch(e){}
  } else if(state.lockedId){
    try{ scrollIntoView(state.lockedId); }catch(e){}
  }
  
  // Sync header inputs with restored data
  const __ti = document.getElementById('projectTitle');
  if(__ti && state.data) __ti.value = state.data.title || 'New Project';

  updateUndoRedoButtons();
  checkDirtyState();
  setViewerStatus('Redo');
}

function clearUndoHistory(){
  state.undoStack = [];
  state.redoStack = [];
  updateUndoRedoButtons();
}

function updateUndoRedoButtons(){
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  if(undoBtn) undoBtn.disabled = state.undoStack.length === 0;
  if(redoBtn) redoBtn.disabled = state.redoStack.length === 0;
}

// New project management buttons
if(saveProjectBtn) saveProjectBtn.addEventListener('click', async ()=>{
  if(!state.data) return;
  state.data._app = { name: 'Dunnode', version: APP_VERSION, schema: 1 };
  delete state.data._appVersion; // migrated into _app object
  state.data._savedAt = new Date().toISOString();
  const filename = (state.data.title || 'project').replace(/[^a-z0-9_-]/gi, '_').toLowerCase() + '.json';
  downloadText(filename, 'application/json;charset=utf-8', JSON.stringify(state.data,null,2));
  setGlobalStatus('Downloaded ' + filename);
  markClean();
});

if(openProjectBtn) openProjectBtn.addEventListener('click', ()=>{ 
  if(fileInput) fileInput.click(); 
});

if(showAllColumnsBtn) showAllColumnsBtn.addEventListener('click', async ()=>{
  buildColumnsMenu();
  togglePopover(!columnsPopover.classList.contains('active'));
});

if(undoBtn) undoBtn.addEventListener('click', async ()=>{
  undo();
});

if(redoBtn) redoBtn.addEventListener('click', async ()=>{
  redo();
});

if(addColumnLeftBtn) addColumnLeftBtn.addEventListener('click', async ()=>{
  if(!state.data) return;
  togglePopover(false);
  const cols = state.data.columns || (state.data.columns = []);
  const taken = new Set(cols.map(c=>c?.id));
  
  openCreateModal({
    kind: 'column',
    title: 'Add column (far left)',
    placeholder: 'Column title',
    hint: 'ID is generated from the title (no dots) and made unique.',
    taken,
    onCommit: ({label, id, note, color, _autoId})=>{
      recordChange(); // Save BEFORE adding
      const newCol = {
        id,
        label,
        note: (note||''),
        _autoId,
        schema: { id, label, _autoId, type: 'group', children: [] }
      };
      if(color) newCol.color = color;
      cols.unshift(newCol); // Add at beginning
      try{ syncJsonAreaFromObj(); }catch(e){}
      renderAll();
      setViewerStatus('Added column: ' + id);
    }
  });
});

if(addColumnRightBtn) addColumnRightBtn.addEventListener('click', async ()=>{
  if(!state.data) return;
  togglePopover(false);
  const cols = state.data.columns || (state.data.columns = []);
  const taken = new Set(cols.map(c=>c?.id));
  
  openCreateModal({
    kind: 'column',
    title: 'Add column (far right)',
    placeholder: 'Column title',
    hint: 'ID is generated from the title (no dots) and made unique.',
    taken,
    onCommit: ({label, id, note, color, _autoId})=>{
      recordChange(); // Save BEFORE adding
      const newCol = {
        id,
        label,
        note: (note||''),
        _autoId,
        schema: { id, label, _autoId, type: 'group', children: [] }
      };
      if(color) newCol.color = color;
      cols.push(newCol); // Add at end
      try{ syncJsonAreaFromObj(); }catch(e){}
      renderAll();
      setViewerStatus('Added column: ' + id);
    }
  });
});


document.addEventListener("keydown", (e) => {
  // Undo/Redo shortcuts
  if((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey){
    // Don't interfere with text inputs
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    undo();
    return;
  }
  if((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))){
    // Don't interfere with text inputs
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    redo();
    return;
  }
  // Select all visible nodes
  if((e.ctrlKey || e.metaKey) && e.key === 'a' && !e.shiftKey && !e.altKey){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    selectAllNodes();
    return;
  }
  // Invert selection
  if((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'i' || e.key === 'I') && !e.altKey){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    invertSelection();
    return;
  }
  
  if(e.key === "?") { openHelp(); return; }
  if(e.key === "Escape") {
    // If editing a node, Escape should cancel node edits (revert snapshot) before clearing selection.
    if(state.editorMode && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'){
      cancelEditAndDeselect();
      state.search = '';
      if(searchInput) searchInput.value = '';
      updateFilterBadge();
      refreshViewer();
      return;
    }
    // If editing a column, Escape should cancel column edits
    if(state.editorMode && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='column'){
      cancelEditAndDeselect();
      state.search = '';
      if(searchInput) searchInput.value = '';
      updateFilterBadge();
      refreshViewer();
      return;
    }
    // If editing an edge, Escape should discard draft
    if(state.editorMode && __edgeEditSession){
      clearEdgeEditSession({clearSelection:true});
    }
    // clear selection + search
    state.lockedId = null;
    state.hoverId = null;
    state.search = "";
    state._consolidatedEdgeCache = null;
    searchInput.value = "";
    updateFilterBadge();
    refreshViewer();
  }
});

/* =========================
   File loading & validation utilities
========================= */

function validateEditor(){
  if(!state.data) return { ok:false, errors:['No data loaded'], warnings:[] };
  const result = validateData(state.data);
  renderValidationLog(result);
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  return { ok: result.errors.length === 0, ...result, obj: state.data };
}

// Kept for backward compat  now just syncs jsonArea from state.data
function syncJsonAreaFromObj(){
  if(state.data && jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
}

// Kept for backward compat  now just syncs jsonArea + validates
function rebuildStructuredList(){
  syncJsonAreaFromObj();
  try { validateEditor(); } catch(e) {}
}

// File upload handler (shared by "Open project" button and legacy "Upload" button)
if(fileInput) fileInput.addEventListener('change', async () => {
  const f = fileInput.files && fileInput.files[0];
  if(!f) return;
  try{
    const text = await f.text();
    const sure = await customConfirm('Are you sure you want to load this file? This will override the current view and you will lose unsaved changes.');
    if(!sure) { setGlobalStatus('Upload cancelled.'); return; }
    let obj;
    try { obj = JSON.parse(text); } catch(err){ customAlert('Invalid JSON: '+err.message); setGlobalStatus('Upload failed: invalid JSON'); return; }
    const result = validateData(obj);
    if(result.errors.length === 0){
      state.data = obj;
      if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
      clearUndoHistory();
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
      state.lockedId = null;
      state.hoverId = null;
      state.multiSelection.clear();
      // Clear any in-flight edit sessions
      __editSnapshot = null;
      __edgeEditSession = null;
      renderAll();
      markClean();
      setGlobalStatus('Loaded mapping from file.');
    } else {
      renderValidationLog(result);
      customAlert('The loaded file has validation errors:\n' + result.errors.join('\n'));
      setGlobalStatus('Upload failed: validation errors');
    }
  } catch(e){ console.error(e); customAlert('Failed to read file: '+ e.message); }
  fileInput.value = '';
});

/* Field autocomplete datalist */
function collectFieldsFromData(data){
  const out = [];
  function walk(node){
    if(!node || typeof node !== "object") return;
    if(node.type === "field") out.push({ id: node.id, label: node.label || node.id });
    (node.children || []).forEach(walk);
  }
  (data.columns || []).forEach(c => walk(c.schema));
  out.sort((a,b)=> a.id.localeCompare(b.id));
  return out;
}

function rebuildFieldDatalist(){
  const data = state.data;
  if(data && typeof data==='object'){
    const fields = collectFieldsFromData(data);
    if(fieldDatalist) fieldDatalist.innerHTML = fields.map(f => `<option value="${escapeHtml(f.id)}">${escapeHtml(f.label)}</option>`).join("\n");
  }
}


/* =========================
 Tree utility functions (used by inline editor)
========================= */

function locateNode(root, targetId, parent=null){
  if(!root) return null;
  if(root.id === targetId) return { node: root, parent, idx: null, siblings: null };
  const kids = root.children || [];
  for(let i = 0; i < kids.length; i++){
    const ch = kids[i];
    if(ch && ch.id === targetId) return { node: ch, parent: root, idx: i, siblings: kids };
    const deep = locateNode(ch, targetId, root);
    if(deep) return deep;
  }
  return null;
}

function ensureGroup(node){
  if(!node.children) node.children = [];
  node.type = (node.type !== 'field') ? 'group' : node.type;
  return node;
}

function collectNodeIds(col){
  const ids = new Set();
  (function walk(n){ if(!n || typeof n !== 'object') return; if(n.id) ids.add(n.id); (n.children||[]).forEach(walk); })(col.schema);
  return ids;
}

function collectFieldIdsFromNode(node){
  const out = [];
  (function walk(n){ if(!n) return; if(n.type === 'field') out.push(n.id); (n.children||[]).forEach(walk); })(node);
  return out;
}

/* =========================
 INLINE_EDITOR_RUNTIME (viewer embedded)
========================= */

function findColumnById(colId){
  return (state.data?.columns||[]).find(c=>c && c.id===colId);
}

function removeMappingsReferencingInState(fieldIds){
  const kill = new Set(fieldIds);
  state.data.mappings = (state.data.mappings||[]).filter(m => {
    if(!m || typeof m !== 'object') return false;
    if(kill.has(m.from)) return false;
    if(kill.has(m.to)) return false;
    return true;
  });
}

function removeNodeFromTree(nodes, targetId){
  if(!nodes) return false;
  for(let i = 0; i < nodes.length; i++){
    if(nodes[i] && nodes[i].id === targetId){ nodes.splice(i,1); return true; }
    if(nodes[i] && nodes[i].children && removeNodeFromTree(nodes[i].children, targetId)) return true;
  }
  return false;
}

/* =========================
   Bulk action modals (multi-select)
========================= */
function findNodeInData(nodeId){
  if(!state.data || !state.data.columns) return null;
  for(const col of state.data.columns){
    if(!col.schema) continue;
    const loc = locateNode(col.schema, nodeId);
    if(loc && loc.node) return loc.node;
  }
  return null;
}

function _setupBulkModalHeader(dialog, title, closeFn){
  const hdr = dialog.querySelector('.modalHeader');
  if(hdr) hdr.style.display = '';
  const titleEl = hdr?.querySelector('.title');
  if(titleEl) titleEl.textContent = title;
  const controls = hdr?.querySelector('.controls');
  if(controls){
    controls.innerHTML = '';
    const closeBtn = document.createElement('button');
    closeBtn.className = 'btn';
    closeBtn.textContent = 'Close';
    closeBtn.style.fontSize = '12px';
    closeBtn.addEventListener('click', ()=> closeFn());
    controls.appendChild(closeBtn);
  }
}

// Replace shared mask element to clear stale handlers from previous customConfirm/customAlert
function _freshMask(){
  const old = document.getElementById('customDialogMask');
  const fresh = old.cloneNode(false);
  old.parentNode.replaceChild(fresh, old);
  return fresh;
}

// Show an inline guard overlay inside the dialog (avoids reusing shared customConfirm dialog)
// Global tracked mask handler for bulk modals (prevents stale listener accumulation)
let __bulkModalMaskHandler = null;
function _setBulkMaskGuard(mask, handler){
  if(__bulkModalMaskHandler) mask.removeEventListener('click', __bulkModalMaskHandler);
  __bulkModalMaskHandler = handler;
  mask.addEventListener('click', handler);
}
function _clearBulkMaskGuard(mask){
  if(__bulkModalMaskHandler){ mask.removeEventListener('click', __bulkModalMaskHandler); __bulkModalMaskHandler = null; }
}

function _showInlineGuard(dialog, message, onDiscard){
  if(dialog.querySelector('[data-guard-overlay]')) return; // prevent duplicates
  const overlay = document.createElement('div');
  overlay.dataset.guardOverlay = '1';
  overlay.style.cssText = 'position:absolute;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:10;border-radius:inherit;';
  const box = document.createElement('div');
  box.style.cssText = 'background:var(--bg);border:1px solid var(--border);border-radius:12px;padding:20px 24px;max-width:320px;text-align:center;';
  box.innerHTML = `<div style="font-size:14px;line-height:1.6;margin-bottom:16px;">${escapeHtml(message)}</div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button class="btn" data-act="keep" style="min-width:80px;">Cancel</button>
      <button class="btn" data-act="discard" style="min-width:80px;background:rgba(59,130,246,.15);border-color:rgba(59,130,246,.4);color:rgba(96,165,250,1);">OK</button>
    </div>`;
  box.querySelector('[data-act="keep"]').addEventListener('click', ()=> overlay.remove());
  box.querySelector('[data-act="discard"]').addEventListener('click', ()=>{ overlay.remove(); onDiscard(); });
  overlay.addEventListener('click', (ev)=>{ if(ev.target===overlay) overlay.remove(); });
  overlay.appendChild(box);
  dialog.appendChild(overlay);
}

// Wrap a close function to be guard-aware: won't close if a guard overlay is active
function _guardedCloseFactory(dialog, dirtyFn, message, rawClose){
  const close = ()=>{
    // Refuse to close while guard overlay is showing
    if(dialog.querySelector('[data-guard-overlay]')) return;
    rawClose();
  };
  const guardedClose = ()=>{
    if(dialog.querySelector('[data-guard-overlay]')) return; // already guarding
    if(dirtyFn()) _showInlineGuard(dialog, message, rawClose);
    else rawClose();
  };
  return { close, guardedClose };
}

function showBulkTagModal(nodeIds){
  const tags = ensureTagCatalog();
  if(!tags.length){ customAlert('No tags defined. Create tags in the Tags catalog first.'); return; }
  
  // Compute current tag state across all selected nodes
  const tagCounts = new Map();
  for(const nid of nodeIds){
    const node = IDX.nodeById.get(nid);
    if(!node) continue;
    const nTags = normalizeNodeTags(node);
    for(const tid of nTags) tagCounts.set(tid, (tagCounts.get(tid)||0) + 1);
  }

  const mask = _freshMask();
  const dialog = document.getElementById('customDialog');
  dialog.querySelectorAll('[data-guard-overlay]').forEach(el => el.remove());
  const total = nodeIds.length;

  const body = dialog.querySelector('.modalBody');
  body.innerHTML = `
    <div style="font-size:12px;margin-bottom:14px;opacity:.55;line-height:1.5;">Check to add, uncheck to remove. Dash means partially applied.</div>
    <div id="bulkTagList" style="display:flex;flex-direction:column;gap:2px;max-height:340px;overflow-y:auto;padding:2px 0;"></div>
    <div style="margin-top:18px;display:flex;gap:8px;justify-content:flex-end;border-top:1px solid var(--border);padding-top:14px;">
      <button class="btn" id="bulkTagCancel">Cancel</button>
      <button class="btn btnSave" id="bulkTagApply">Save</button>
    </div>`;

  const list = document.getElementById('bulkTagList');
  for(const t of tags){
    const count = tagCounts.get(t.id) || 0;
    const checked = count === total;
    const indeterminate = count > 0 && count < total;
    const color = tagColor(t);
    const row = document.createElement('label');
    row.style.cssText = 'display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;';
    row.addEventListener('mouseenter', ()=>{ row.style.background='rgba(255,255,255,.04)'; });
    row.addEventListener('mouseleave', ()=>{ row.style.background=''; });
    row.innerHTML = `
      <input type="checkbox" data-tag-id="${escapeHtml(t.id)}" ${checked?'checked':''} ${indeterminate?'data-indeterminate="1"':''} style="accent-color:${color};width:16px;height:16px;flex-shrink:0;">
      <span class="tagChip" data-color="1" style="--c:${color};flex-shrink:0;">${escapeHtml(tagAbbr(t)||t.id)}</span>
      <span style="flex:1;font-size:12.5px;font-weight:600;">${escapeHtml(t.label||t.id)}</span>
      <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${count}/${total}</span>`;
    list.appendChild(row);
  }
  list.querySelectorAll('input[data-indeterminate="1"]').forEach(cb=>{ cb.indeterminate = true; });

  mask.classList.add('active');
  dialog.classList.add('active');

  // Dirty tracking
  const applyBtn = document.getElementById('bulkTagApply');
  const initialStates = new Map();
  list.querySelectorAll('input[type=checkbox]').forEach(cb=>{
    initialStates.set(cb.dataset.tagId, cb.checked);
  });
  const checkDirty = ()=>{
    let dirty = false;
    list.querySelectorAll('input[type=checkbox]').forEach(cb=>{
      if(cb.checked !== initialStates.get(cb.dataset.tagId)) dirty = true;
    });
    return dirty;
  };
  if(applyBtn) wireDirtyHighlight(body, applyBtn, checkDirty);

  const rawClose = ()=>{ mask.classList.remove('active'); dialog.classList.remove('active'); _clearBulkMaskGuard(mask); };
  const { close, guardedClose } = _guardedCloseFactory(dialog, checkDirty, 'Abandon unsaved changes?', rawClose);
  _setupBulkModalHeader(dialog, `Set tags on ${total} node${total>1?'s':''}`, guardedClose);
  document.getElementById('bulkTagCancel').addEventListener('click', rawClose);
  _setBulkMaskGuard(mask, (e)=>{ if(e.target===mask){ e.stopImmediatePropagation(); guardedClose(); } });

  document.getElementById('bulkTagApply').addEventListener('click', ()=>{
    pushUndo();
    list.querySelectorAll('input[type=checkbox]').forEach(cb=>{
      const tid = cb.dataset.tagId;
      const shouldHave = cb.checked;
      for(const nid of nodeIds){
        const node = findNodeInData(nid);
        if(!node) continue;
        let nTags = normalizeNodeTags(node);
        if(shouldHave && !nTags.includes(tid)) nTags.push(tid);
        else if(!shouldHave) nTags = nTags.filter(x=>x!==tid);
        node.tags = nTags;
      }
    });
    markDirty();
    renderAll();
    close();
    setGlobalStatus(`Updated tags on ${nodeIds.length} nodes.`);
  });
}

function showBulkAttrModal(nodeIds){
  const attrs = ensureCustomAttributeCatalog();
  if(!attrs.length){ customAlert('No custom attributes defined. Create attributes in the Attributes catalog first.'); return; }

  const mask = _freshMask();
  const dialog = document.getElementById('customDialog');
  dialog.querySelectorAll('[data-guard-overlay]').forEach(el => el.remove());
  const total = nodeIds.length;

  const body = dialog.querySelector('.modalBody');

  body.innerHTML = `
    <div style="font-size:12px;margin-bottom:14px;opacity:.55;line-height:1.5;">Choose an attribute and a value to apply to all selected nodes.</div>
    <div style="margin-bottom:14px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:.5px;opacity:.4;margin-bottom:5px;">Attribute</div>
      <select id="bulkAttrSelect" class="inp" style="width:100%;">
        ${attrs.map(a=>`<option value="${escapeHtml(a.id)}">${escapeHtml(a.label||a.id)}${a.multi?' (multi)':''}</option>`).join('')}
      </select>
    </div>
    <div style="margin-bottom:14px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:.5px;opacity:.4;margin-bottom:5px;">Value</div>
      <div id="bulkAttrValues" style="display:flex;flex-direction:column;gap:2px;max-height:220px;overflow-y:auto;padding:2px 0;"></div>
    </div>
    <div style="margin-top:18px;display:flex;gap:8px;justify-content:flex-end;border-top:1px solid var(--border);padding-top:14px;">
      <button class="btn" id="bulkAttrCancel">Cancel</button>
      <button class="btn btnSave" id="bulkAttrApply">Save</button>
    </div>`;


  function renderValues(){
    const attrId = document.getElementById('bulkAttrSelect').value;
    const attr = attrs.find(a=>a.id===attrId);
    const isMulti = !!(attr && attr.multi);
    const vals = (attr && attr.values) || [];
    const container = document.getElementById('bulkAttrValues');

    // Compute current value distribution
    const valCounts = new Map();
    let hasAttrCount = 0;
    for(const nid of nodeIds){
      const node = IDX.nodeById.get(nid);
      if(!node) continue;
      const ca = node.customAttributes || {};
      const cur = ca[attrId];
      if(cur !== undefined && cur !== null && cur !== ''){
        hasAttrCount++;
        const curArr = Array.isArray(cur) ? cur : [cur];
        for(const v of curArr) valCounts.set(v, (valCounts.get(v)||0) + 1);
      }
    }

    let html = '';
    if(isMulti){
      // Multi-select: checkboxes
      for(const v of vals){
        const count = valCounts.get(v.id) || 0;
        const checked = count === total;
        const indeterminate = count > 0 && count < total;
        const vc = v.color ? `<span style="width:10px;height:10px;border-radius:3px;background:${v.color};flex-shrink:0;"></span>` : '';
        html += `<label style="display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;" onmouseenter="this.style.background='rgba(255,255,255,.04)'" onmouseleave="this.style.background=''">
          <input type="checkbox" name="bulkAttrVal" value="${escapeHtml(v.id)}" ${checked?'checked':''} ${indeterminate?'data-indeterminate="1"':''} style="width:16px;height:16px;flex-shrink:0;">
          ${vc}
          <span style="flex:1;font-size:12.5px;">${escapeHtml(v.label||v.id)}</span>
          <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${count}/${total}</span>
        </label>`;
      }
      // Clear all option
      html += `<label style="display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;margin-top:4px;border-top:1px solid var(--border);padding-top:10px;color:rgba(255,120,120,.8);" onmouseenter="this.style.background='rgba(255,120,120,.04)'" onmouseleave="this.style.background=''">
        <input type="checkbox" id="bulkAttrClear" style="width:16px;height:16px;flex-shrink:0;">
        <span style="flex:1;font-size:12px;">Clear all values for this attribute</span>
        <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${hasAttrCount}/${total} set</span>
      </label>`;
    } else {
      // Single-select: radio buttons
      for(const v of vals){
        const count = valCounts.get(v.id) || 0;
        const vc = v.color ? `<span style="width:10px;height:10px;border-radius:3px;background:${v.color};flex-shrink:0;"></span>` : '';
        html += `<label style="display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;" onmouseenter="this.style.background='rgba(255,255,255,.04)'" onmouseleave="this.style.background=''">
          <input type="radio" name="bulkAttrVal" value="${escapeHtml(v.id)}" ${count===total?'checked':''} style="width:16px;height:16px;flex-shrink:0;">
          ${vc}
          <span style="flex:1;font-size:12.5px;">${escapeHtml(v.label||v.id)}</span>
          <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${count}/${total}</span>
        </label>`;
      }
      // Clear option as a radio
      html += `<label style="display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;margin-top:4px;border-top:1px solid var(--border);padding-top:10px;color:rgba(255,120,120,.8);" onmouseenter="this.style.background='rgba(255,120,120,.04)'" onmouseleave="this.style.background=''">
        <input type="radio" name="bulkAttrVal" value="__clear__" id="bulkAttrClear" style="width:16px;height:16px;flex-shrink:0;">
        <span style="flex:1;font-size:12px;">Clear this attribute</span>
        <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${hasAttrCount}/${total} set</span>
      </label>`;
    }

    if(!vals.length) html = '<div style="opacity:.4;font-size:12px;padding:8px;">No values defined for this attribute.</div>';
    container.innerHTML = html;
    container.querySelectorAll('input[data-indeterminate="1"]').forEach(cb=>{ cb.indeterminate = true; });

    // Multi-select clear logic: uncheck all value checkboxes when "Clear all" is checked
    if(isMulti){
      const clearCb = document.getElementById('bulkAttrClear');
      if(clearCb){
        clearCb.addEventListener('change', ()=>{
          if(clearCb.checked){
            container.querySelectorAll('input[name=bulkAttrVal]').forEach(cb=>{ cb.checked = false; });
          }
        });
        container.querySelectorAll('input[name=bulkAttrVal]').forEach(cb=>{
          cb.addEventListener('change', ()=>{ if(cb.checked && clearCb) clearCb.checked = false; });
        });
      }
    }
  }

  renderValues();
  document.getElementById('bulkAttrSelect').addEventListener('change', ()=>{ renderValues(); });

  function _hasSelection(){
    const clearCb = document.getElementById('bulkAttrClear');
    if(clearCb && clearCb.checked) return true;
    const checked = document.querySelectorAll('input[name=bulkAttrVal]:checked');
    return checked.length > 0;
  }

  mask.classList.add('active');
  dialog.classList.add('active');

  const applyBtn = document.getElementById('bulkAttrApply');
  const checkDirty = ()=> _hasSelection();
  if(applyBtn) wireDirtyHighlight(body, applyBtn, checkDirty);

  // For guard: track if user actually changed any value from initial state
  let _attrDirty = false;
  const valuesContainer = document.getElementById('bulkAttrValues');
  if(valuesContainer) valuesContainer.addEventListener('change', ()=>{ _attrDirty = true; });

  const rawClose = ()=>{ mask.classList.remove('active'); dialog.classList.remove('active'); _clearBulkMaskGuard(mask); };
  const { close, guardedClose } = _guardedCloseFactory(dialog, ()=>_attrDirty, 'Abandon unsaved changes?', rawClose);
  document.getElementById('bulkAttrCancel').addEventListener('click', rawClose);
  _setupBulkModalHeader(dialog, `Set attribute on ${total} node${total>1?'s':''}`, guardedClose);
  _setBulkMaskGuard(mask, (e)=>{ if(e.target===mask){ e.stopImmediatePropagation(); guardedClose(); } });

  document.getElementById('bulkAttrApply').addEventListener('click', ()=>{
    const attrId = document.getElementById('bulkAttrSelect').value;
    const attr = attrs.find(a=>a.id===attrId);
    const isMulti = !!(attr && attr.multi);
    const clearCb = document.getElementById('bulkAttrClear');
    const shouldClear = clearCb ? clearCb.checked : false;

    if(isMulti){
      // Gather checked values
      const checkedVals = Array.from(document.querySelectorAll('input[name=bulkAttrVal]:checked')).map(cb=>cb.value);
      if(!shouldClear && !checkedVals.length){ customAlert('Select at least one value, or choose "Clear all values".'); return; }
      pushUndo();
      for(const nid of nodeIds){
        const node = findNodeInData(nid);
        if(!node) continue;
        if(!node.customAttributes) node.customAttributes = {};
        if(shouldClear){
          delete node.customAttributes[attrId];
        } else {
          // Merge: add checked, remove unchecked
          let cur = node.customAttributes[attrId];
          let curArr = Array.isArray(cur) ? [...cur] : (cur ? [cur] : []);
          // For each value in the list, add if checked, remove if unchecked
          const allValIds = (attr.values||[]).map(v=>v.id);
          for(const vid of allValIds){
            if(checkedVals.includes(vid) && !curArr.includes(vid)) curArr.push(vid);
            else if(!checkedVals.includes(vid)) curArr = curArr.filter(x=>x!==vid);
          }
          if(curArr.length) node.customAttributes[attrId] = curArr;
          else delete node.customAttributes[attrId];
        }
      }
    } else {
      // Single-select
      const selectedRadio = document.querySelector('input[name=bulkAttrVal]:checked');
      if(!selectedRadio){ customAlert('Select a value or choose "Clear this attribute".'); return; }
      const isClear = selectedRadio.value === '__clear__';
      pushUndo();
      for(const nid of nodeIds){
        const node = findNodeInData(nid);
        if(!node) continue;
        if(!node.customAttributes) node.customAttributes = {};
        if(isClear) delete node.customAttributes[attrId];
        else node.customAttributes[attrId] = selectedRadio.value;
      }
    }
    markDirty();
    renderAll();
    close();
    setGlobalStatus(`${shouldClear ? 'Cleared' : 'Set'} attribute "${attrId}" on ${nodeIds.length} nodes.`);
  });
}

function showBulkTransformModal(edgeGroups){
  const transforms = ensureTransformCatalog();
  if(!transforms.length){ customAlert('No transforms defined. Create transforms in the Transforms catalog first.'); return; }
  const allEdges = [...(edgeGroups.internal||[]), ...(edgeGroups.outbound||[]), ...(edgeGroups.inbound||[])];
  if(!allEdges.length){ customAlert('No mappings to modify.'); return; }

  const mask = _freshMask();
  const dialog = document.getElementById('customDialog');
  dialog.querySelectorAll('[data-guard-overlay]').forEach(el => el.remove());
  const body = dialog.querySelector('.modalBody');

  // Build scope definitions
  const scopes = [
    { id: 'all', label: 'All', edges: allEdges },
    { id: 'internal', label: 'Internal', edges: edgeGroups.internal || [] },
    { id: 'inbound', label: 'Inbound', edges: edgeGroups.inbound || [] },
    { id: 'outbound', label: 'Outbound', edges: edgeGroups.outbound || [] },
  ].filter(s => s.edges.length > 0);

  let _scope = 'all';
  function scopeEdges(){ return scopes.find(s=>s.id===_scope)?.edges || allEdges; }
  function scopeKeys(){ const keys = new Set(); for(const e of scopeEdges()) keys.add(e.from+'|'+e.to); return keys; }

  // Working copy: ALL edges (not scoped)  scope just controls what's displayed/modified
  const workingCopy = new Map();
  for(const edge of allEdges){
    const mapping = (state.data.mappings||[]).find(m=> m && m.from===edge.from && m.to===edge.to);
    const key = edge.from + '|' + edge.to;
    workingCopy.set(key, mapping ? JSON.parse(JSON.stringify(normalizeTransforms(mapping.transforms))) : []);
  }

  // Scope tab bar HTML
  const scopeBarHtml = scopes.length > 1 ? `<div id="bulkTransformScopeBar" style="display:flex;gap:0;margin-bottom:14px;border:1px solid var(--border);border-radius:8px;overflow:hidden;">
    ${scopes.map(s=>`<button class="btn" data-scope="${s.id}" style="flex:1;border:none;border-radius:0;font-size:11px;padding:6px 4px;text-align:center;white-space:nowrap;${s.id==='all'?'background:rgba(255,255,255,.08);':''}">${s.label} (${s.edges.length})</button>`).join('')}
  </div>` : '';

  body.innerHTML = `
    ${scopeBarHtml}
    <div id="bulkTransformSubtitle" style="font-size:12px;margin-bottom:14px;opacity:.55;line-height:1.5;">
      Add, remove, or reorder transforms across ${allEdges.length} mapping${allEdges.length>1?'s':''}.
    </div>
    <div style="margin-bottom:14px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:.5px;opacity:.4;margin-bottom:5px;">Add transform</div>
      <div style="display:flex;gap:6px;align-items:flex-start;">
        <select id="bulkTransformSel" class="inp" style="flex:1;">
          <option value="">Choose\u2026</option>
          ${transforms.map(t=>`<option value="${escapeHtml(t.id)}">${escapeHtml(t.label||t.id)}${(t.params&&t.params.length)?' \u2699':''}</option>`).join('')}
        </select>
        <button class="btn" id="bulkTransformAddBtn" style="font-size:11px;padding:6px 12px;white-space:nowrap;opacity:.4;pointer-events:none;">+ Add</button>
      </div>
      <div id="bulkTransformParams" style="display:none;margin-top:8px;padding:8px 10px;background:rgba(0,0,0,.12);border-radius:8px;border:1px solid var(--border);"></div>
    </div>
    <div style="border-top:1px solid var(--border);padding-top:10px;margin-bottom:14px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:.5px;opacity:.4;margin-bottom:5px;">Applied transforms</div>
      <div id="bulkTransformCurrent" style="display:flex;flex-direction:column;gap:2px;max-height:240px;overflow-y:auto;padding:2px 0;"></div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;border-top:1px solid var(--border);padding-top:14px;">
      <button class="btn" id="bulkTransformCancel">Cancel</button>
      <button class="btn btnSave" id="bulkTransformSave">Save</button>
    </div>`;

  const sel = document.getElementById('bulkTransformSel');
  const paramsDiv = document.getElementById('bulkTransformParams');
  const addBtn = document.getElementById('bulkTransformAddBtn');
  const currentDiv = document.getElementById('bulkTransformCurrent');
  const saveBtn = document.getElementById('bulkTransformSave');
  const subtitleEl = document.getElementById('bulkTransformSubtitle');

  function makeKey(inst){
    const rid = transformRefId(inst);
    const ps = (inst.params && Object.keys(inst.params).length > 0)
      ? Object.entries(inst.params).sort((a,b)=>a[0].localeCompare(b[0])).map(([k,v])=>`${k}=${v}`).join('|') : '';
    return ps ? `${rid}|${ps}` : rid;
  }

  // Snapshot for dirty detection  serializes working copy + display order
  function _serializeWC(){
    const arr = [];
    for(const [k, v] of workingCopy) arr.push([k, v]);
    return JSON.stringify([arr, _displayOrder]);
  }
  // Snapshot taken after initial rebuildDisplayOrder() below
  let _snapshotStr = null;

  function isDirty(){ return _serializeWC() !== _snapshotStr; }

  function updateDirtyState(){
    const dirty = isDirty();
    if(dirty) saveBtn.classList.add('btnDirty');
    else saveBtn.classList.remove('btnDirty');
    // Enable/disable scope tabs based on dirty state
    const scopeBar = document.getElementById('bulkTransformScopeBar');
    if(scopeBar){
      scopeBar.querySelectorAll('[data-scope]').forEach(b=>{
        if(dirty && b.dataset.scope !== _scope){
          b.style.opacity = '.3'; b.style.pointerEvents = 'none';
        } else {
          b.style.opacity = ''; b.style.pointerEvents = '';
        }
      });
    }
    return dirty;
  }

  // Build display order from scoped edges
  const _displayOrder = [];
  const _instByKey = new Map();
  function rebuildDisplayOrder(){
    _displayOrder.length = 0;
    _instByKey.clear();
    const seen = new Set();
    const keys = scopeKeys();
    for(const [ekey, tArr] of workingCopy){
      if(!keys.has(ekey)) continue;
      for(const inst of tArr){
        const k = makeKey(inst);
        if(!seen.has(k)){ seen.add(k); _displayOrder.push(k); _instByKey.set(k, inst); }
      }
    }
  }
  rebuildDisplayOrder();
  _snapshotStr = _serializeWC();

  function renderCurrentTransforms(){
    const keys = scopeKeys();
    const scopeTotal = keys.size;

    // Count how many scoped mappings have each transform
    const countMap = new Map();
    for(const [ekey, tArr] of workingCopy){
      if(!keys.has(ekey)) continue;
      for(const inst of tArr){
        const k = makeKey(inst);
        countMap.set(k, (countMap.get(k)||0) + 1);
        if(!_instByKey.has(k)) _instByKey.set(k, inst);
      }
    }

    // Filter displayOrder to only keys present in scoped edges
    for(let i = _displayOrder.length - 1; i >= 0; i--){
      if(!countMap.has(_displayOrder[i])) _displayOrder.splice(i, 1);
    }
    // Add any new keys not yet in displayOrder
    for(const k of countMap.keys()){
      if(!_displayOrder.includes(k)) _displayOrder.push(k);
    }

    if(_displayOrder.length === 0){
      currentDiv.innerHTML = '<div style="opacity:.35;font-size:11px;padding:4px;">No transforms applied.</div>';
      return;
    }

    currentDiv.innerHTML = '';
    _displayOrder.forEach((key, idx)=>{
      const inst = _instByKey.get(key);
      if(!inst) return;
      const rid = transformRefId(inst);
      const t = transformById(rid);
      const label = t ? (t.label || t.id) : rid;
      const ps = (inst.params && Object.keys(inst.params).length > 0)
        ? Object.entries(inst.params).sort((a,b)=>a[0].localeCompare(b[0])).map(([k,v])=>`${k}=${v}`).join(', ') : '';
      const paramDisplay = ps ? ` (${ps})` : '';
      const count = countMap.get(key) || 0;
      const isFirst = idx === 0, isLast = idx === _displayOrder.length - 1;

      const row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;gap:6px;padding:5px 8px;border-radius:8px;transition:background .1s;';
      row.innerHTML = `
        <span style="display:flex;flex-direction:column;gap:1px;flex-shrink:0;">
          <button class="btn" data-move="up" style="font-size:8px;padding:0 3px;line-height:1.2;${isFirst?'opacity:.2;pointer-events:none;':''}">&#9650;</button>
          <button class="btn" data-move="down" style="font-size:8px;padding:0 3px;line-height:1.2;${isLast?'opacity:.2;pointer-events:none;':''}">&#9660;</button>
        </span>
        <span style="font-size:12px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(label)}<span style="opacity:.4;font-size:10px;">${escapeHtml(paramDisplay)}</span></span>
        <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${count}/${scopeTotal}</span>
        <button class="btn btnDanger" data-act="rm" style="font-size:10px;padding:2px 6px;">\u2212</button>`;
      row.addEventListener('mouseenter', ()=>{ row.style.background='rgba(255,255,255,.04)'; });
      row.addEventListener('mouseleave', ()=>{ row.style.background=''; });

      row.querySelector('[data-act="rm"]').addEventListener('click', ()=>{
        for(const [ekey, tArr] of workingCopy){
          if(!keys.has(ekey)) continue;
          workingCopy.set(ekey, tArr.filter(x=> makeKey(x) !== key));
        }
        _instByKey.delete(key);
        updateDirtyState();
        renderCurrentTransforms();
      });

      row.querySelectorAll('[data-move]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const dir = btn.dataset.move === 'up' ? -1 : 1;
          const ni = idx + dir;
          if(ni < 0 || ni >= _displayOrder.length) return;
          [_displayOrder[idx], _displayOrder[ni]] = [_displayOrder[ni], _displayOrder[idx]];
          const neighborKey = _displayOrder[idx];
          for(const [ekey, tArr] of workingCopy){
            if(!keys.has(ekey)) continue;
            const ai = tArr.findIndex(x=> makeKey(x) === key);
            const bi = tArr.findIndex(x=> makeKey(x) === neighborKey);
            if(ai >= 0 && bi >= 0 && Math.abs(ai - bi) === 1){
              [tArr[ai], tArr[bi]] = [tArr[bi], tArr[ai]];
            }
          }
          updateDirtyState();
          renderCurrentTransforms();
        });
      });

      currentDiv.appendChild(row);
    });
  }

  // Scope bar handler
  const scopeBar = document.getElementById('bulkTransformScopeBar');
  if(scopeBar){
    scopeBar.addEventListener('click', (ev)=>{
      const btn = ev.target.closest('[data-scope]');
      if(!btn) return;
      if(isDirty()) return; // blocked while dirty (tabs are visually disabled)
      _scope = btn.dataset.scope;
      scopeBar.querySelectorAll('[data-scope]').forEach(b=>{
        b.style.background = b.dataset.scope === _scope ? 'rgba(255,255,255,.08)' : '';
      });
      const se = scopeEdges();
      subtitleEl.textContent = `Add, remove, or reorder transforms across ${se.length} mapping${se.length>1?'s':''}.`;
      rebuildDisplayOrder();
      renderCurrentTransforms();
    });
  }

  sel.addEventListener('change', ()=>{
    const tid = sel.value;
    const t = transforms.find(x=>x.id===tid);
    if(!t){ paramsDiv.style.display = 'none'; addBtn.style.opacity='.4'; addBtn.style.pointerEvents='none'; return; }
    addBtn.style.opacity = '1'; addBtn.style.pointerEvents = 'auto';
    if(t.params && t.params.length > 0){
      paramsDiv.style.display = '';
      paramsDiv.innerHTML = t.params.map((p,pi)=>`
        <div style="display:flex;align-items:center;gap:8px;margin:4px 0;">
          <label for="btParam${pi}" style="font-size:11px;opacity:.6;flex:0 0 100px;">${escapeHtml(p.label||p.id)}</label>
          <input class="inp" id="btParam${pi}" name="btParam${pi}" type="${p.type==='number'?'number':'text'}" data-param-id="${escapeHtml(p.id)}" value="${escapeHtml(p.default!=null?String(p.default):'')}" style="flex:1;font-size:11px;padding:5px 8px;">
        </div>`).join('');
    } else { paramsDiv.style.display = 'none'; paramsDiv.innerHTML = ''; }
  });

  addBtn.addEventListener('click', ()=>{
    const tid = sel.value;
    const t = transforms.find(x=>x.id===tid);
    if(!t) return;
    const inst = { ref: tid };
    if(t.params && t.params.length > 0){
      inst.params = {};
      paramsDiv.querySelectorAll('[data-param-id]').forEach(inp=>{
        const val = inp.type==='number' ? (inp.value!=='' ? Number(inp.value) : '') : inp.value;
        if(val !== '') inst.params[inp.dataset.paramId] = val;
      });
    }
    const keys = scopeKeys();
    for(const [ekey, tArr] of workingCopy){
      if(!keys.has(ekey)) continue;
      tArr.push(JSON.parse(JSON.stringify(inst)));
    }
    const addKey = makeKey(inst);
    if(!_instByKey.has(addKey)){ _instByKey.set(addKey, inst); _displayOrder.push(addKey); }
    updateDirtyState();
    sel.value = ''; paramsDiv.style.display = 'none';
    addBtn.style.opacity='.4'; addBtn.style.pointerEvents='none';
    renderCurrentTransforms();
  });

  renderCurrentTransforms();

  mask.classList.add('active');
  dialog.classList.add('active');

  const rawClose = ()=>{ mask.classList.remove('active'); dialog.classList.remove('active'); _clearBulkMaskGuard(mask); };
  const { close, guardedClose } = _guardedCloseFactory(dialog, isDirty, 'Abandon unsaved changes?', rawClose);
  _setupBulkModalHeader(dialog, `Transforms (${allEdges.length} mapping${allEdges.length>1?'s':''})`, guardedClose);
  document.getElementById('bulkTransformCancel').addEventListener('click', rawClose);

  saveBtn.addEventListener('click', ()=>{
    if(!isDirty()){ close(); return; }
    pushUndo();
    for(const edge of allEdges){
      const key = edge.from + '|' + edge.to;
      const mapping = (state.data.mappings||[]).find(m=> m && m.from===edge.from && m.to===edge.to);
      if(mapping) mapping.transforms = workingCopy.get(key) || [];
    }
    markDirty();
    close();
    renderAll();
    applyHighlight();
    setGlobalStatus(`Updated transforms on ${allEdges.length} mapping${allEdges.length>1?'s':''}.`);
  });

  _setBulkMaskGuard(mask, (e)=>{ if(e.target===mask){ e.stopImmediatePropagation(); guardedClose(); } });
}

function showBulkMapModal(nodeIds){
  // Only fields can be mapped  filter to fields only
  const fieldIds = nodeIds.filter(nid => {
    const n = IDX.nodeById.get(nid);
    return n && n.type === 'field';
  });
  if(!fieldIds.length){ customAlert('No fields in selection. Only fields can be mapped (not groups).'); return; }

  const mask = _freshMask();
  const dialog = document.getElementById('customDialog');
  dialog.querySelectorAll('[data-guard-overlay]').forEach(el => el.remove());

  const body = dialog.querySelector('.modalBody');

  body.innerHTML = `
    <div style="font-size:12px;margin-bottom:14px;opacity:.55;line-height:1.5;">Search for a target field. A mapping will be created from each selected field to the chosen target.</div>
    <input type="text" id="bulkMapSearch" class="inp" placeholder="Search fields by name or ID" style="width:100%;margin-bottom:10px;">
    <div id="bulkMapResults" style="display:flex;flex-direction:column;gap:2px;max-height:340px;overflow-y:auto;padding:2px 0;"></div>
    <div style="margin-top:18px;display:flex;gap:8px;justify-content:flex-end;border-top:1px solid var(--border);padding-top:14px;">
      <button class="btn" id="bulkMapCancel">Cancel</button>
    </div>`;

  const searchInput = document.getElementById('bulkMapSearch');
  const resultsEl = document.getElementById('bulkMapResults');
  const sourceSet = new Set(fieldIds);

  function renderResults(term){
    const t = (term||'').toLowerCase().trim();
    const matches = [];
    for(const fid of IDX.fieldIds){
      if(sourceSet.has(fid)) continue;
      const node = IDX.nodeById.get(fid);
      if(!node) continue;
      const label = (node.label||'').toLowerCase();
      const id = (fid||'').toLowerCase();
      if(t && !label.includes(t) && !id.includes(t)) continue;
      matches.push({ id: fid, node });
      if(matches.length >= 50) break;
    }
    resultsEl.innerHTML = matches.map(m=>{
      const col = columnOf(m.id);
      const colIdx = IDX.columnIndex.get(col);
      const colObj = colIdx !== undefined ? IDX.columns[colIdx] : null;
      const colLabel = colObj ? (colObj.label||colObj.id) : '';
      return `<div style="cursor:pointer;padding:7px 10px;border-radius:8px;font-size:12.5px;display:flex;align-items:center;gap:8px;transition:background .1s;" data-target-id="${escapeHtml(m.id)}" onmouseenter="this.style.background='rgba(255,255,255,.06)'" onmouseleave="this.style.background=''">
        <span style="opacity:.35;font-size:10px;flex-shrink:0;"></span>
        <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:600;">${escapeHtml(m.node.label||m.id)}</span>
        <span style="opacity:.3;font-size:10px;font-family:var(--mono);flex-shrink:0;">${escapeHtml(colLabel)}</span>
      </div>`;
    }).join('') || '<div style="opacity:.4;font-size:12px;padding:10px;text-align:center;">No matching fields.</div>';

    resultsEl.querySelectorAll('[data-target-id]').forEach(el=>{
      el.addEventListener('click', ()=>{
        const targetId = el.dataset.targetId;
        pushUndo();
        let created = 0;
        for(const fid of fieldIds){
          const exists = (state.data.mappings||[]).some(m=> m && m.from===fid && m.to===targetId);
          if(!exists){
            state.data.mappings = state.data.mappings || [];
            state.data.mappings.push({ from: fid, to: targetId, cardinality:'', transforms:[], note:'', default:'' });
            created++;
          }
        }
        markDirty();
        renderAll();
        close();
        // Lock selection on target to show all new arrows as visual confirmation
        state.multiSelection.clear();
        state.lockedId = targetId;
        state.hoverId = null;
        state.selectedColumnId = null;
        state.selectedEdgeId = null;
        applyHighlight();
        scrollIntoView(targetId);
        setGlobalStatus(`Created ${created} mapping${created===1?'':'s'}  ${el.querySelector('span:nth-child(2)')?.textContent || targetId}`);
      });
    });
  }

  renderResults('');
  searchInput.addEventListener('input', ()=> renderResults(searchInput.value));

  mask.classList.add('active');
  dialog.classList.add('active');
  setTimeout(()=> searchInput.focus(), 50);

  const close = ()=>{ mask.classList.remove('active'); dialog.classList.remove('active'); _clearBulkMaskGuard(mask); };
  _setupBulkModalHeader(dialog, `Map ${fieldIds.length} field${fieldIds.length>1?'s':''} to`, close);
  document.getElementById('bulkMapCancel').addEventListener('click', close);
  _setBulkMaskGuard(mask, (e)=>{ if(e.target===mask){ e.stopImmediatePropagation(); close(); } });
}

function ensureMapping(fromId, toId){
  if(!state.data) return;
  state.data.mappings = state.data.mappings || [];
  for(const m of state.data.mappings){
    if(!m || typeof m!=='object') continue;
    if(m.from===fromId && m.to===toId) return; // Already exists, no change
  }
  recordChange(); // Save BEFORE creating mapping
  state.data.mappings.push({ from: fromId, to: toId, cardinality:'', transforms: [], note:'', default:'' });
}


// removed legacy addColumnAtVisibleIndex + hover zones
function addColumnAtVisibleIndex(insertIndex){
  if(!state.data){ return; }
  const cols = state.data.columns || (state.data.columns = []);
  let pos = 0;
  if(typeof insertIndex==='number' && insertIndex>=0){
    const visibleIds = (IDX.columns||[]).filter(c=>!state.hiddenColumns.has(c.id)).map(c=>c.id);
    if(visibleIds.length){
      if(insertIndex<=0){
        const firstId = visibleIds[0];
        const p = cols.findIndex(c=>c && c.id===firstId);
        pos = p>=0 ? p : 0;
      } else {
        const beforeId = visibleIds[Math.min(insertIndex-1, visibleIds.length-1)];
        const p = cols.findIndex(c=>c && c.id===beforeId);
        pos = p>=0 ? p+1 : cols.length;
      }
    } else {
      pos = cols.length;
    }
  } else {
    pos = cols.length;
  }
  const taken = new Set(cols.map(c=>c.id));
  openCreateModal({
    kind: 'column',
    title: 'Add column',
    placeholder: 'Column title',
    hint: 'ID is generated from the title (no dots) and made unique.',
    taken,
    onCommit: ({label, id, note, color, _autoId})=>{
      if(cols.some(c=>c.id===id)) return;
      recordChange(); // Save BEFORE add
      const newCol = { id, label, note: (note||''), _autoId, schema: { id, label, _autoId, type:'group', children: [] } };
      if(color) newCol.color = color;
      cols.splice(Math.max(0, Math.min(pos, cols.length)), 0, newCol);
      state.hiddenColumns.delete(id);
      renderAll();
      state.selectedColumnId = id; state.lockedId = id; state.hoverId=null; state.selectedEdgeId=null;
      applyHighlight();
      setGlobalStatus('Added column '+id);
    }
  });
}

// ---- Column header actions (select + delete) ----
function collectFieldIdsOfColumn(col){
  const out=[];
  (function walk(n){
    if(!n || typeof n!=='object') return;
    if(n.type==='field') out.push(n.id);
    (n.children||[]).forEach(walk);
  })(col.schema);
  return out;
}

async function deleteColumnById(colId){
  if(!state.data) return;
  const cols = state.data.columns || [];
  if(cols.length<=0){
    customAlert('No columns to delete.');
    return;
  }
  const col = cols.find(c=>c && c.id===colId);
  if(!col) return;
  const colLabel = col.label || col.id;
  // Count contents
  let fieldCount = 0, groupCount = 0;
  (function walk(n){ if(!n) return; if(n.type==='field') fieldCount++; else if(n.type==='group') groupCount++; (n.children||[]).forEach(walk); })(col.schema);
  const killFields = collectFieldIdsOfColumn(col);
  const killSet = new Set(killFields);
  const mapCount = (state.data.mappings||[]).filter(m => m && (killSet.has(m.from) || killSet.has(m.to))).length;
  const contentParts = [];
  if(fieldCount) contentParts.push(fieldCount + ' field' + (fieldCount>1?'s':''));
  if(groupCount) contentParts.push(groupCount + ' group' + (groupCount>1?'s':''));
  const contentInfo = contentParts.length ? `\n\nContains ${contentParts.join(' and ')}.` : '';
  const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
  if(!await customConfirm(`Delete column "${colLabel}" (${colId})?${contentInfo}${mapInfo}`)) return;
  recordChange(); // Save BEFORE delete
  removeMappingsReferencingInState(killFields);
  state.data.columns = cols.filter(c=>c && c.id!==colId);
  state.hiddenColumns.delete(colId);
  if(state.selectedColumnId===colId) state.selectedColumnId = null;
  if(state.lockedId===colId) state.lockedId = null;
  renderAll();
  buildColumnsMenu();
  setGlobalStatus('Deleted column '+colId);
}


function addColumnLeftOf(colId){
  // Insert a new column immediately to the left of the given visible column id
  const visible = IDX.columns.filter(c=> !state.hiddenColumns.has(c.id)).map(c=>c.id);
  const idx = Math.max(0, visible.indexOf(colId));
  addColumnAtVisibleIndex(idx);
}
function addColumnRightOf(colId){
  const visible = IDX.columns.filter(c=> !state.hiddenColumns.has(c.id)).map(c=>c.id);
  const idx = visible.indexOf(colId);
  const ins = (idx<0) ? visible.length : idx+1;
  addColumnAtVisibleIndex(ins);
}
function moveColumn(colId, dir){
  if(!state.data) return;
  const cols = state.data.columns || [];
  const i = cols.findIndex(c=>c && c.id===colId);
  if(i<0) return;
  const j = i + (dir<0?-1:1);
  if(j<0 || j>=cols.length) return;
  const tmp = cols[i]; cols[i] = cols[j]; cols[j] = tmp;
  renderAll();
  // keep selection stable
  state.selectedColumnId = colId; state.lockedId = colId; state.hoverId=null; state.selectedEdgeId=null;
  applyHighlight();
}
function customPrompt(message, defaultValue){
  return new Promise((resolve) => {
    _ensureDialogBody();
    const mask = document.getElementById('customDialogMask');
    const dialog = document.getElementById('customDialog');
    const messageEl = document.getElementById('customDialogMessage');
    const buttonsEl = document.getElementById('customDialogButtons');
    
    messageEl.textContent = message;
    buttonsEl.innerHTML = '';
    const hdr = dialog.querySelector('.modalHeader');
    if(hdr) hdr.style.display = 'none';
    
    const inputEl = document.createElement('input');
    inputEl.className = 'inp';
    inputEl.type = 'text';
    inputEl.value = defaultValue || '';
    inputEl.style.cssText = 'width:100%;margin-bottom:16px;';
    messageEl.after(inputEl);
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.minWidth = '80px';
    cancelBtn.addEventListener('click', () => { cleanup(); resolve(null); });
    
    const okBtn = document.createElement('button');
    okBtn.className = 'btn';
    okBtn.textContent = 'OK';
    okBtn.style.cssText = 'min-width:80px;background:rgba(59,130,246,0.15);border-color:rgba(59,130,246,0.4);color:rgba(96,165,250,1);';
    okBtn.addEventListener('click', () => { cleanup(); resolve(inputEl.value); });
    
    buttonsEl.appendChild(cancelBtn);
    buttonsEl.appendChild(okBtn);
    
    mask.classList.add('active');
    dialog.classList.add('active');
    setTimeout(()=>{ inputEl.focus(); inputEl.select(); }, 50);
    
    const cleanup = ()=>{
      inputEl.remove();
      mask.classList.remove('active');
      dialog.classList.remove('active');
      document.removeEventListener('keydown', onKey);
    };
    const onKey = (e) => {
      if(e.key === 'Escape'){ cleanup(); resolve(null); }
      if(e.key === 'Enter'){ cleanup(); resolve(inputEl.value); }
    };
    document.addEventListener('keydown', onKey);
    mask.addEventListener('click', () => { cleanup(); resolve(null); }, {once: true});
  });
}

function renameColumnFromViewer(colId){
  const col = findColumnById(colId);
  if(!col) return;
  customPrompt('New label for column '+colId+':', col.label || col.id).then(v => {
    if(v===null) return;
    const oldId = col.id;
    const newId = renameColumnInData(state.data, oldId, v);
    state.selectedColumnId = newId; state.lockedId = newId; state.hoverId=null; state.selectedEdgeId=null;
    renderAll();
    applyHighlight();
  });
}
function openColumnMenu(anchorEl, colId){
  const cols = state.data?.columns || [];
  const i = cols.findIndex(c=>c && c.id===colId);
  const canMoveLeft = i>0;
  const canMoveRight = i>=0 && i<cols.length-1;
  openCtxMenu([
    { label:'Edit column',        icon:'',   onClick: ()=> selectColumn(colId) },
    { type:'sep' },
    { label:'Add field on top',    icon:'', onClick: ()=> addChildNode(colId, colId, true,  true) },
    { label:'Add field at bottom', icon:'', onClick: ()=> addChildNode(colId, colId, true,  false) },
    { type:'sep' },
    { label:'Add group on top',    icon:'', onClick: ()=> addChildNode(colId, colId, false, true) },
    { label:'Add group at bottom', icon:'', onClick: ()=> addChildNode(colId, colId, false, false) },
    { type:'sep' },
    { label:'Move column left',          icon:'',   disabled:!canMoveLeft,  onClick: ()=> moveColumn(colId, -1) },
    { label:'Move column right',         icon:'',   disabled:!canMoveRight, onClick: ()=> moveColumn(colId, +1) },
    { type:'sep' },
    { label:'Insert column left',  icon:'', onClick: ()=> addColumnLeftOf(colId) },
    { label:'Insert column right', icon:'', onClick: ()=> addColumnRightOf(colId) },
    { type:'sep' },
    { label:'Hide column',      icon:'', onClick: ()=> {
        state.hiddenColumns.add(colId); 
        state.selectedEdgeId = null;
        state.hoverEdgeId = null;
        state.lockedId = null;
        state.hoverId = null;
        renderAll();
      } },
    { type:'sep' },
    { label:'Delete',      icon:'', danger:true, onClick: ()=> deleteColumnById(colId) },
  ], anchorEl);
  __ctxMenuColId = colId;
}function selectColumn(colId){
  if(state.editorMode && state.selectedEdgeId){ clearEdgeEditSession({clearSelection:true}); }
  // Revert any pending node edit session
  let didRevert = false;
  if(state.editorMode && __editSnapshot && __editSnapshot.data && __editSnapshot.kind==='node'){
    revertEditSnapshot();
    __editSnapshot = null;
    didRevert = true;
    checkDirtyState();
  }
state.selectedColumnId = colId;
  state.lockedId = colId;
  state.hoverId = null;
  state.selectedEdgeId = null;
  if(didRevert) renderAll();
  updateColumnHeaderSelectionStyles();
 applyHighlight();
  scrollIntoView(colId);
}

function attachColumnHeaderActions(){
  const panels = Array.from(columnsRow.querySelectorAll('.panel'));
  for(const panel of panels){
    const colId = panel.dataset.columnId;
    const header = panel.querySelector('.panelHeader');
    if(!header) continue;

    header.classList.add('clickable');

    // Remove any legacy header actions when switching modes
    const existing = header.querySelector('.colActions');
    if(existing) existing.remove();

    // Add actions (different for editor vs viewer mode)
    const actions = document.createElement('div');
    actions.className='colActions';
    actions.style.display='flex';
    actions.style.gap='6px';
    actions.style.alignItems='center';

    if(state.editorMode){
      // Editor mode: hide button + menu button
      const btnHide = document.createElement('button');
      btnHide.className='miniBtn';
      btnHide.title='Hide column';
      btnHide.textContent='';
      btnHide.style.opacity = '0.7';
      actions.appendChild(btnHide);
      btnHide.addEventListener('click', async (e)=>{
        e.stopPropagation();
        if(nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        closeCtxMenu();
        state.hiddenColumns.add(colId);
        state.selectedEdgeId = null;
        state.hoverEdgeId = null;
        state.lockedId = null;
        state.hoverId = null;
        renderAll();
      });

      const btnMenu = document.createElement('button');
      btnMenu.className='miniBtn';
      btnMenu.title='Column actions';
      btnMenu.textContent='';
      actions.appendChild(btnMenu);
      
      btnMenu.addEventListener('click', async (e)=>{ 
        e.stopPropagation(); 
        
        // Menu is still open (capture handler skips miniBtn)  toggle it closed
        if(__ctxMenuEl && __ctxMenuColId === colId){
          closeCtxMenu();
          return;
        }
        
        // Close any other open menu first
        closeCtxMenu();
        
        // Guard unsaved node/edge edits before switching to this column
        if(nodeEditIsDirty() && __editSnapshot?.id !== colId){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        if(edgeEditIsDirty()){
          if(!await guardAbandonEdit('mapping', __edgeEditSession?.edgeId || '')) return;
        }
        
        // Select column if not already selected
        const savedRect = btnMenu.getBoundingClientRect();
        if(state.selectedColumnId !== colId || state.lockedId !== colId){
          selectColumn(colId);
        }
        // After potential re-render, find the new menu button in the rebuilt DOM
        const newPanel = columnsRow.querySelector(`.panel[data-column-id="${colId}"]`);
        const allBtns = newPanel ? Array.from(newPanel.querySelectorAll('.colActions .miniBtn')) : [];
        const newBtn = allBtns[1] || allBtns[0]; // second button is menu button
        const anchor = (newBtn && newBtn.getBoundingClientRect().width > 0) ? newBtn : {
          getBoundingClientRect(){ return savedRect; },
          closest(){ return null; },
          contains(){ return false; }
        };
        openColumnMenu(anchor, colId);
      });
    } else {
      // Viewer mode: hide column button
      const btnHide = document.createElement('button');
      btnHide.className='miniBtn';
      btnHide.title='Hide column';
      btnHide.textContent='';
      btnHide.style.opacity = '0.7';
      actions.appendChild(btnHide);
      
      btnHide.addEventListener('click', (e)=>{
        e.stopPropagation();
        state.hiddenColumns.add(colId);
        state.selectedEdgeId = null;
        state.hoverEdgeId = null;
        state.lockedId = null;
        state.hoverId = null;
        renderAll();
      });
    }
    
    header.appendChild(actions);

    // Bind header click once (viewer + editor)
    if(header.dataset.colClickBound !== '1'){
      header.dataset.colClickBound = '1';
      header.addEventListener('click', async (e)=>{
        if(state.selectedColumnId===colId && state.lockedId===colId){
          state.selectedColumnId = null;
          state.selectedEdgeId = null;
          state.lockedId = null;
          state.hoverId = null;
          __editSnapshot = null;
          updateColumnHeaderSelectionStyles();
          renderAll();
          applyHighlight();
          return;
        }
        if(state.editorMode && nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        if(state.editorMode && edgeEditIsDirty()){
          const eid = __edgeEditSession?.edgeId || '';
          if(!await guardAbandonEdit('mapping', eid)) return;
        }
        selectColumn(colId);
      });
    }

    // Column header hover preview
    if(header.dataset.colHoverBound !== '1'){
      header.dataset.colHoverBound = '1';
      header.addEventListener('mouseenter', ()=>{
        // Don't preview if something is locked/selected/editing
        if(state.lockedId || state.selectedColumnId || state.selectedEdgeId || state.multiSelection.size > 0) return;
        if(__editSnapshot || __edgeEditSession) return;
        renderColumnHoverPreview(colId);
      });
      header.addEventListener('mouseleave', ()=>{
        if(state.lockedId || state.selectedColumnId || state.selectedEdgeId || state.multiSelection.size > 0) return;
        if(__editSnapshot || __edgeEditSession) return;
        applyHighlight(); // restores default project view
      });
    }
  }
}

function renderColumnHoverPreview(colId){
  const col = findColumnById(colId);
  if(!col) return;
  const fieldCount = (IDX.nodeFieldDescendants.get(colId) || []).length;
  const groupCount = (() => {
    let c = 0;
    const walk = (n) => { if(n.type==='group') c++; (n.children||[]).forEach(walk); };
    if(col.schema) walk(col.schema);
    return c > 0 ? c - 1 : 0;
  })();
  const colEdges = (IDX.edges||[]).filter(e =>
    (columnOf(e.from) === colId || columnOf(e.to) === colId)
  );
  detailsMeta.textContent = 'hover';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtHero">
        <div class="dtName">${escapeHtml(col.label||col.id)}</div>
        <span class="dtType column">Column</span>
      </div>
      <div class="dtRow">
        <span class="dtRowK">ID</span>
        <span class="dtRowV"><span class="dtId">${escapeHtml(colId)}${isLikelyAutoId(col) ? '<span class="autoTag">auto</span>' : ''}</span></span>
      </div>
      ${col.note ? `<div class="dtNote">${escapeHtml(col.note)}</div>` : ''}
      ${col.color ? `<div class="dtRow">
        <span class="dtRowK">Color</span>
        <span class="dtRowV"><span class="dtColorSwatch" style="background:${escapeHtml(col.color)};"></span> <span style="font-family:var(--mono);font-size:11px;opacity:.55;">${escapeHtml(col.color)}</span></span>
      </div>` : ''}
      <div class="dtStatRow">
        <span class="dtStatChip"><span class="dtStatN">${fieldCount}</span><span class="dtStatL">field${fieldCount!==1?'s':''}</span></span>
        <span class="dtStatChip"><span class="dtStatN">${groupCount}</span><span class="dtStatL">group${groupCount!==1?'s':''}</span></span>
        <span class="dtStatChip"><span class="dtStatN">${colEdges.length}</span><span class="dtStatL">mapping${colEdges.length!==1?'s':''}</span></span>
      </div>
    </div>
  `;
}

function renderSelectedColumnViewer(){
  if(!state.selectedColumnId) return false;
  if(state.editorMode) return false; // editor mode uses renderSelectedColumnEditor
  const colId = state.selectedColumnId;
  if(state.lockedId !== colId) return false;
  const col = findColumnById(colId);
  if(!col) return false;

  const fieldCount = (IDX.nodeFieldDescendants.get(colId) || []).length;
  const groupCount = (() => {
    let c = 0;
    const walk = (n) => { if(n.type==='group') c++; (n.children||[]).forEach(walk); };
    if(col.schema) walk(col.schema);
    return c > 0 ? c - 1 : 0; // exclude root
  })();
  // Count mappings with at least one endpoint in this column
  const colEdges = (IDX.edges||[]).filter(e =>
    (columnOf(e.from) === colId || columnOf(e.to) === colId)
  );

  detailsMeta.textContent = 'column';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtHero">
        <div class="dtName">${escapeHtml(col.label||col.id)}</div>
        <span class="dtType column">Column</span>
      </div>
      <div class="dtRow">
        <span class="dtRowK">ID</span>
        <span class="dtRowV"><span class="dtId">${escapeHtml(colId)}${isLikelyAutoId(col) ? '<span class="autoTag">auto</span>' : ''}</span></span>
      </div>
      ${col.note ? `<div class="dtNote">${escapeHtml(col.note)}</div>` : ''}
      ${col.color ? `<div class="dtRow">
        <span class="dtRowK">Color</span>
        <span class="dtRowV"><span class="dtColorSwatch" style="background:${escapeHtml(col.color)};"></span> <span style="font-family:var(--mono);font-size:11px;opacity:.55;">${escapeHtml(col.color)}</span> <span style="font-size:10px;opacity:.35;">applied</span></span>
      </div>` : ''}
      <div class="dtStatRow">
        <span class="dtStatChip"><span class="dtStatN">${fieldCount}</span><span class="dtStatL">field${fieldCount!==1?'s':''}</span></span>
        <span class="dtStatChip"><span class="dtStatN">${groupCount}</span><span class="dtStatL">group${groupCount!==1?'s':''}</span></span>
        <span class="dtStatChip"><span class="dtStatN">${colEdges.length}</span><span class="dtStatL">mapping${colEdges.length!==1?'s':''}</span></span>
      </div>
    </div>
  `;
  updateColumnHeaderSelectionStyles();
  return true;
}

function renderSelectedColumnEditor(){
  if(!state.editorMode || !state.selectedColumnId) return false;
  const colId = state.selectedColumnId;
  if(state.lockedId !== colId) return false;
  const col = findColumnById(colId);
  if(!col) return false;

  const fieldCount = (IDX.nodeFieldDescendants.get(colId) || []).length;
  beginEditSnapshot('column', colId);
 detailsMeta.textContent = 'column';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtEditorHead">
        <span class="dtType column">Column</span>
        <span class="dtEditorLabel">Editor</span>
      </div>
      <div class="kv" style="grid-template-columns: 80px 1fr;">
        <div class="k">Label</div><div class="v"><input class="inp" id="colLabel" value="${escapeHtml(col.label||col.id)}"/></div>
        <div class="k">ID <span class="autoTag" id="colIdAuto">auto</span></div><div class="v" style="display:flex;align-items:center;gap:0;"><input class="inp" id="colId" value="${escapeHtml(col.id)}" style="font-family:var(--mono);font-size:11px;flex:1;"/></div>
        <div class="k">Note</div><div class="v"><input class="inp" id="colNote" value="${escapeHtml(col.note||'')}" placeholder="optional"/></div>
        <div class="k">Color</div><div class="v" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
          <div id="colColorSwatches" style="display:flex;gap:3px;flex-wrap:wrap;"></div>
          <input type="color" id="colColor" value="${escapeHtml(col.color||col._pendingColor||'#3b82f6')}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${col.color?'':'opacity:.3;'}"/>
          <label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" id="colColorOn" ${col.color?'checked':''}/> Apply</label>
          <div style="font-size:10px;opacity:.35;flex-basis:100%;">Colors header &amp; child nodes without own color</div>
        </div>
        <div class="k">Fields</div><div class="v"><span class="dtStatChip" style="padding:2px 7px;"><span class="dtStatN" style="font-size:12px;">${fieldCount}</span></span></div>
      </div>
      <div class="dtActions">
        <button class="btn" id="colDelete" style="border-color: rgba(255,154,168,.45);">Delete</button>
        <span class="spacer"></span>
        <button class="btn" id="colCancel">Cancel</button>
        <button class="btn btnSave" id="colSave">Save</button>
      </div>
      <div class="dtHint">Changing the column ID will rewrite all descendant node IDs and mappings.</div>
    </div>
  `;

  document.getElementById('colSave')?.addEventListener('click', async ()=>{
  const newLabel = (document.getElementById('colLabel')?.value || '').trim() || col.label || col.id;
  const newId = sanitizeManualId(document.getElementById('colId')?.value || '') || col.id;
  const newNote = (document.getElementById('colNote')?.value || '');
  const oldId = col.id;
  recordChange(); // Save BEFORE changes

  // Update label and note (independent of ID)
  col.label = newLabel;
  col.note = newNote;

  // Update column color
  const colColorOn = document.getElementById('colColorOn')?.checked;
  const colColorVal = document.getElementById('colColor')?.value || '';
  if(colColorOn && colColorVal){ col.color = colColorVal; }
  else { delete col.color; if(colColorVal && colColorVal !== '#3b82f6') col._pendingColor = colColorVal; else delete col._pendingColor; }

  // Persist auto-ID state
  col._autoId = __editorAutoId;

  // Update ID if changed
  let finalColId = oldId;
  if(newId !== oldId){
    const result = reIdColumnInData(state.data, oldId, newId);
    if(result === oldId){
      setGlobalStatus('Column ID conflict  ID not changed (duplicate).');
    } else {
      finalColId = result;
    }
  }

  __editSnapshot = null;
  // Stay on the column after save (use finalColId in case ID was changed)
  state.selectedColumnId = finalColId;
  state.lockedId = finalColId;
  state.selectedEdgeId = null;
  state.hoverId = null;
  state.__hoverCooldownUntil = Date.now() + 400;
  renderAll();
  setGlobalStatus('Saved column.');
});

  document.getElementById('colCancel')?.addEventListener('click', ()=>{
    const stayColId = state.selectedColumnId;
    revertEditSnapshot();
    __editSnapshot = null;
    state.selectedColumnId = stayColId; // stay on column
    state.lockedId = stayColId;
    state.selectedEdgeId = null;
    state.hoverId = null;
    state.__hoverCooldownUntil = Date.now() + 400;
    checkDirtyState();
    renderAll();
    setGlobalStatus('Cancelled changes.');
  });
 document.getElementById('colDelete')?.addEventListener('click', ()=> deleteColumnById(colId));
  // Column color swatches and checkbox
  {
    const _colColorPicker = document.getElementById('colColor');
    const _colColorOn = document.getElementById('colColorOn');
    const _colSwatchWrap = document.getElementById('colColorSwatches');
    if(_colSwatchWrap && _colColorPicker){
      buildColorSwatches(_colSwatchWrap, _colColorPicker);
      _colColorPicker.addEventListener('input', ()=>{
        if(_colColorOn) _colColorOn.checked = true;
        _colColorPicker.style.opacity = '1';
      });
    }
    if(_colColorOn){
      _colColorOn.addEventListener('change', ()=>{
        if(_colColorPicker) _colColorPicker.style.opacity = _colColorOn.checked ? '1' : '.3';
      });
    }
  }
  wireDirtyHighlight(detailsBody, document.getElementById('colSave'), nodeEditIsDirty);
  // Column labelid auto-fill
  {
    const _colLabelInp = document.getElementById('colLabel');
    const _colIdInp = document.getElementById('colId');
    const _colIdAutoTag = document.getElementById('colIdAuto');
    if(_colLabelInp && _colIdInp){
      const _slugCol = (raw)=> idPartFromLabel(raw, {lower:true});
      const initLabel = _colLabelInp.value.trim();
      const initIdAuto = _slugCol(initLabel) || '';
      let _lastAutoId = col._autoId ? initIdAuto : '';
      __editorAutoId = _lastAutoId !== '';
      const _refreshTag = ()=>{ if(_colIdAutoTag) _colIdAutoTag.style.display = _lastAutoId !== '' ? '' : 'none'; };
      _refreshTag();
      _colLabelInp.addEventListener('input', ()=>{
        const cur = _colIdInp.value.trim();
        if(!cur || cur === _lastAutoId){ const ai = _slugCol(_colLabelInp.value.trim())||''; _colIdInp.value = ai; _lastAutoId = ai; }
        __editorAutoId = _lastAutoId !== '';
        _refreshTag();
      });
      _colIdInp.addEventListener('input', ()=>{
        if(!_colIdInp.value.trim()){ const ai = _slugCol(_colLabelInp.value.trim())||''; _colIdInp.value = ai; _lastAutoId = ai; }
        else _lastAutoId = '';
        __editorAutoId = _lastAutoId !== '';
        _refreshTag();
      });
    }
  }
  return true;
}




function renderSelectedNodeEditor(nodeId){
  if(!state.editorMode) return false;
  if(!nodeId) return false;
  // avoid column editor overlap
  if(state.selectedColumnId && nodeId===state.selectedColumnId) return false;
  const node = IDX.nodeById.get(nodeId);
  if(!node || (node.type!=='field' && node.type!=='group')) return false;
  const __isLocked = (state.lockedId === nodeId);
  // Only show editor for locked (clicked) selections; hover falls through to viewer preview
  if(!__isLocked) return false;

  // Start snapshot for cancel
  beginEditSnapshot('node', nodeId);
  normalizeNodeTags(node);
  normalizeCustomAttributes(node);
  normalizeNodeNote(node);

  const isFieldNode = node.type==='field';

  // Build a summary like normal details does
  const selectedFields = new Set((IDX.nodeFieldDescendants.get(nodeId) || (IDX.fieldIds.has(nodeId) ? [nodeId] : [])));
  const inbound = [];
  const outbound = [];
  const candidates = node.type==='field' ? (IDX.edgesByField.get(nodeId) || []) : IDX.edges;
  const seen = new Set();
  for(const e of candidates){
    if(!e || seen.has(e.id)) continue;
    if(node.type!=='field'){
      if(!(selectedFields.has(e.from) || selectedFields.has(e.to))) continue;
    }
    seen.add(e.id);
    if(selectedFields.has(e.from) && !selectedFields.has(e.to)) outbound.push(e);
    if(selectedFields.has(e.to) && !selectedFields.has(e.from)) inbound.push(e);
  }
  inbound.sort(compareEdgesSimple);
  outbound.sort(compareEdgesSimple);
  const summary = `Inbound: ${inbound.length}  Outbound: ${outbound.length}`;
  function ioItem(edge, dir){
    const jump = (dir==='out') ? edge.to : edge.from;
    const jumpNode = IDX.nodeById.get(jump);
    const jumpLabel = jumpNode?.label ?? jump;
    const side = columnOf(jump) ?? 'node';
    const title = escapeHtml(edgeTooltip(edge));
    const route = `${edge.from}  ${edge.to}`;
    const prefix = (dir==='out') ? 'out' : 'in';
    return `
      <li class="item" data-jump-id="${escapeHtml(jump)}" data-edge="${escapeHtml(edge.id)}" title="${title}">
        <span class="pill">${escapeHtml(side)}</span>
        <span class="pill">${escapeHtml(prefix)}</span>
        <span class="itemActions" aria-hidden="true"><button class="miniBtn" data-act="editMap" title="Edit mapping"></button><button class="miniBtn" data-act="goTo" title="Go to mapped node"></button><button class="miniBtn danger" data-act="delMap" title="Delete mapping"></button></span>
 <span class=\"itemBreak\"></span>
        <span class="txt">${escapeHtml(jumpLabel)}</span>
        ${badgeHtml(edge)}
        <span class="route">${escapeHtml(route)}</span>${(edge.note && String(edge.note).trim()) ? `<span class="mapNote">${escapeHtml(short(edge.note, 120))}</span>` : ``}
      </li>
    `;
  }


  detailsMeta.textContent = 'node';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtEditorHead">
        <span class="dtType${node.type==='group'?' group':''}">${escapeHtml(node.type)}</span>
        <span class="dtEditorLabel">Editor</span>
      </div>
      <div class="kv" style="grid-template-columns: 80px 1fr;">
        <div class="k">Label</div><div class="v"><input class="inp" id="ndLabel" value="${escapeHtml(node.label||node.id)}"/></div>
        <div class="k">ID <span class="autoTag" id="ndIdAuto">auto</span></div><div class="v" style="display:flex;align-items:center;gap:0;"><span style="font-family:var(--mono);font-size:11px;opacity:.55;white-space:nowrap;">${escapeHtml(idPathPrefix(node.id))}</span><input class="inp" id="ndId" value="${escapeHtml(localIdSegment(node.id))}" style="font-family:var(--mono);font-size:11px;flex:1 1 auto;min-width:80px;"/></div>
        <div class="k">Summary</div><div class="v"><div class="dtStatRow" style="padding:0;"><span class="dtStatChip" style="padding:2px 7px;"><span class="dtStatN" style="font-size:11px;">${inbound.length}</span><span class="dtStatL">in</span></span><span class="dtStatChip" style="padding:2px 7px;"><span class="dtStatN" style="font-size:11px;">${outbound.length}</span><span class="dtStatL">out</span></span></div></div>
        <div class="k">Note</div><div class="v"><input class="inp" id="ndNote" value="${escapeHtml(node.note||'')}" placeholder="optional"/></div>
        <div class="k">Color</div><div class="v" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
          <div id="ndColorSwatches" style="display:flex;gap:3px;flex-wrap:wrap;"></div>
          <input type="color" id="ndColor" value="${escapeHtml(node.color||node._pendingColor||'#3b82f6')}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${node.color?'':'opacity:.3;'}"/>
          <label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" id="ndColorOn" ${node.color?'checked':''}/> Apply</label>
        </div>

        <div class="k">Tags</div>
        <div class="v">
          <div id="ndTagChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
          <div id="ndAttrInlineControls" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <select class="inp" id="ndTagSel" style="max-width:280px;flex:0 0 auto;"><option value="">Add tag</option></select>
            <button class="btn" id="ndTagNew" type="button">Tags</button>
          </div>
        </div>

        <div class="k">Custom</div>
        <div class="v">
          <div id="ndAttrChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <select class="inp" id="ndAttrSel" style="max-width:240px;flex:0 0 auto;"><option value="">Attribute</option></select>
            <select class="inp" id="ndAttrValSel" style="max-width:240px;flex:0 0 auto;"><option value="">Value</option></select>
                        <button class="btn" id="ndAttrCatalog" type="button">Attributes</button>
          </div>
          <div class="dtHint" style="padding:4px 0;">Choose an attribute and a value. Use Attributes to manage attributes/values.</div>
          <div id="multiValsWrap" class="multiVals hidden"></div>
        </div>
      </div>

      <div class="dtActions">
        <button class="btn" id="ndDelete" style="border-color:rgba(255,154,168,.45);">Delete</button>
        <span class="spacer"></span>
        <button class="btn" id="ndCancel">Cancel</button>
        <button class="btn btnSave" id="ndSave">Save</button>
      </div>
    </div>
    ${(!isFieldNode && node.children && node.children.length) ? `
    <div class="box detailSection collapsed">
      <h3 class="detailSectionHead"><span>Children</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${node.children.length}</span></h3>
      <div class="detailSectionBody" style="padding-top:8px;">
        ${node.children.map(ch => miniNodeCard(ch.id)).join('')}
      </div>
    </div>
    ` : ''}
    <div class="box detailSection${isFieldNode ? '' : ' collapsed'}">
      <h3 class="detailSectionHead"><span>Inbound mappings</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${inbound.length}</span></h3>
      <div class="detailSectionBody">
      ${inbound.length ? `<ul class="list">${inbound.map(e => ioItem(e,'in')).join('')}</ul>` : '<div class="empty">No inbound mappings for this selection.</div>'}
      ${isFieldNode ? `
      <div style="border-top:1px solid rgba(255,255,255,.10); padding-top:10px;">
        <div class="kv" style="grid-template-columns: 110px 1fr;">
          <div class="k">Add inbound mapping</div>
          <div class="v"><input class="inp" id="ndAddFrom" list="fieldDatalist" placeholder="source field id"/></div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
          <button class="btn" id="ndAddInboundMap">Add inbound mapping</button>
        </div>
      </div>
      ` : ''}
      </div>
    </div>

    <div class="box detailSection${isFieldNode ? '' : ' collapsed'}">
      <h3 class="detailSectionHead"><span>Outbound mappings</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${outbound.length}</span></h3>
      <div class="detailSectionBody">
      ${outbound.length ? `<ul class="list">${outbound.map(e => ioItem(e,'out')).join('')}</ul>` : '<div class="empty">No outbound mappings for this selection.</div>'}
      ${isFieldNode ? `
      <div style="border-top:1px solid rgba(255,255,255,.10); padding-top:10px;">
        <div class="kv" style="grid-template-columns: 110px 1fr;">
          <div class="k">Add outbound mapping</div>
          <div class="v"><input class="inp" id="ndAddTo" list="fieldDatalist" placeholder="target field id"/></div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
          <button class="btn" id="ndAddMap">Add outbound mapping</button>
        </div>
      </div>
      ` : ''}
      </div>
    </div>
  `;

  // Wire collapsible section toggles
  detailsBody.querySelectorAll('.detailSectionHead').forEach(h => {
    h.addEventListener('click', () => {
      h.closest('.detailSection').classList.toggle('collapsed');
    });
  });

  // Wire children jump links



  // Select an edge when clicking a mapping row (v11 behavior)
  detailsBody.querySelectorAll('[data-edge]').forEach(li=>{
    // Action buttons inside the mapping row (do not steal the row click).
    li.querySelectorAll('button[data-act]').forEach(btn=>{
      btn.addEventListener('click', async (ev)=>{
        ev.stopPropagation();
        const act = btn.dataset.act;
        const eid = li.dataset.edge;
        const jump = li.dataset.jumpId;
        // Guard unsaved node edits before navigation
        if(nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        if(act==='editMap'){ selectEdge(eid); return; }
        if(act==='goTo' && jump){
          lockSelection(jump);
          scrollIntoView(jump);
          return;
        }
        if(act==='delMap'){
          deleteMappingByEdgeId(eid);
          return;
        }
      });
    });

    li.addEventListener('click', async ()=>{
      const eid = li.dataset.edge;
      // Guard unsaved node edits before switching to edge
      if(nodeEditIsDirty()){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      state.selectedEdgeId = eid;
      // force rerender details to show selected edge context
      renderAll();
      applyHighlight();
    });
  });

  if(isFieldNode){
    document.getElementById('ndAddMap')?.addEventListener('click', async ()=>{
      const toId = (document.getElementById('ndAddTo')?.value || '').trim();
      if(!toId) return;
      if(!IDX.fieldIds.has(toId)) { customAlert('Unknown target field: '+toId); return; }
      if(toId===nodeId) return;
      // Guard unsaved node edits before adding mapping
      if(nodeEditIsDirty()){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      if(typeof ensureMapping==='function') ensureMapping(nodeId, toId);
      else { state.data.mappings = state.data.mappings || []; state.data.mappings.push({from: nodeId, to: toId}); }
      renderAll();
      const edge = IDX.edges.find(e=>e.from===nodeId && e.to===toId);
      if(edge) state.selectedEdgeId=edge.id;
      state.lockedId=nodeId;
      applyHighlight();
      scheduleArrowsUpdate();
    });

    document.getElementById('ndAddInboundMap')?.addEventListener('click', async ()=>{
      const fromId = (document.getElementById('ndAddFrom')?.value || '').trim();
      if(!fromId) return;
      if(!IDX.fieldIds.has(fromId)) { customAlert('Unknown source field: '+fromId); return; }
      if(fromId===nodeId) return;
      // Guard unsaved node edits before adding mapping
      if(nodeEditIsDirty()){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      if(typeof ensureMapping==='function') ensureMapping(fromId, nodeId);
      else { state.data.mappings = state.data.mappings || []; state.data.mappings.push({from: fromId, to: nodeId}); }
      renderAll();
      const edge = IDX.edges.find(e=>e.from===fromId && e.to===nodeId);
      if(edge) state.selectedEdgeId=edge.id;
      state.lockedId=nodeId;
      applyHighlight();
      scheduleArrowsUpdate();
    });
  }

  // Jump interactions (like normal details)
  detailsBody.querySelectorAll('[data-jump-id]').forEach(li=>{
    li.addEventListener('click', async ()=>{
      if(li.dataset.edge) return;
      const id = li.dataset.jumpId;
      if(nodeEditIsDirty() && __editSnapshot?.id !== id){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      lockSelection(id);
      scrollIntoView(id);
    });
  });

  // Tags wiring
  const ndTagChips = document.getElementById('ndTagChips');
  const ndTagSel = document.getElementById('ndTagSel');
  const ndTagNew = document.getElementById('ndTagNew');
  
    function rebuildValOptions(aid){
    // rebuild the single-select value dropdown from catalog values
    const selId = aid || (ndAttrSel ? ndAttrSel.value : '');
    const def = customAttrById(selId);
    const vals = (def && Array.isArray(def.values)) ? def.values : [];
    if(!ndAttrValSel) return;
    ndAttrValSel.innerHTML = '';
    const opt0 = document.createElement('option');
    opt0.value=''; opt0.textContent='(choose value)';
    ndAttrValSel.appendChild(opt0);
    vals.forEach(v=>{
      const vid = v && v.id ? String(v.id) : '';
      if(!vid) return;
      const o = document.createElement('option');
      o.value = vid;
      o.textContent = (v.label||v.id);
      ndAttrValSel.appendChild(o);
    });
  }

function renderMultiVals(aid){
    // Keep the attribute selector focused on this attribute while interacting with multi values.
    if(state) state.nodeEditorAttrFocus = aid || state.nodeEditorAttrFocus || '';

    const a = customAttrById(aid);
    const vals = (a && Array.isArray(a.values)) ? a.values : [];
    const isMulti = customAttrIsMulti(aid);

    const multiValsWrap = document.getElementById('multiValsWrap');
    if(!multiValsWrap) return;
    multiValsWrap.innerHTML = '';

    const inline = document.getElementById('ndAttrInlineControls');
    inline?.classList.toggle('hidden', isMulti);
    multiValsWrap.classList.toggle('hidden', !isMulti);
    if(!isMulti) return;

    const curRaw = (node.customAttributes||{})[aid];
    const cur = Array.isArray(curRaw) ? curRaw.map(String) : (curRaw ? [String(curRaw)] : []);

    // checkboxes
    vals.forEach(v=>{
      const lab = (v && (v.label||v.id)) ? (v.label||v.id) : '';
      const vid = v && v.id ? String(v.id) : '';
      if(!vid) return;
      const lbl = document.createElement('label');
      const cb = document.createElement('input');
      cb.type='checkbox';
      cb.checked = cur.includes(vid);
      cb.addEventListener('change', ()=>{
        node.customAttributes = node.customAttributes || {};
        let arr = Array.isArray(node.customAttributes[aid]) ? node.customAttributes[aid].map(String) : (node.customAttributes[aid] ? [String(node.customAttributes[aid])] : []);
        if(cb.checked){ if(!arr.includes(vid)) arr.push(vid); }
        else { arr = arr.filter(x=>x!==vid); }
        if(arr.length===0) delete node.customAttributes[aid];
        else if(arr.length===1) node.customAttributes[aid] = arr[0];
        else node.customAttributes[aid] = arr;
        renderAttrChips();
        renderAll();
      });
      lbl.appendChild(cb);
      lbl.appendChild(document.createTextNode(' '+lab));
      multiValsWrap.appendChild(lbl);
    });

    // actions under the list
    const actions = document.createElement('div');
    actions.className = 'multiValsActions';

    const btnAll = document.createElement('button');
    btnAll.type='button'; btnAll.className='linkBtn'; btnAll.textContent='Select all';
    const btnNone = document.createElement('button');
    btnNone.type='button'; btnNone.className='linkBtn'; btnNone.textContent='Clear all';
    const btnAddOpt = document.createElement('button');
    btnAddOpt.type='button'; btnAddOpt.className='linkBtn'; btnAddOpt.textContent='Add new option';

    actions.appendChild(btnAll);
    actions.appendChild(btnNone);
    actions.appendChild(btnAddOpt);
    multiValsWrap.appendChild(actions);

    // Move the main Attributes catalog button (big button) below the multi-select actions row.
    // This avoids having two buttons and keeps the control close to multi-select operations.
    const catBtn = document.getElementById('ndAttrCatalog');
    if(catBtn){
      catBtn.textContent = 'Attributes';
      const catRow = document.createElement('div');
      catRow.className = 'multiValsActions';
      catRow.appendChild(catBtn);
      multiValsWrap.appendChild(catRow);
    }


    btnAll.addEventListener('click', async ()=>{
      node.customAttributes = node.customAttributes || {};
      const allIds = vals.map(v=>v && v.id ? String(v.id) : '').filter(Boolean);
      if(allIds.length===0) return;
      node.customAttributes[aid] = allIds.length===1 ? allIds[0] : allIds;
      renderMultiVals(aid);
      renderAttrChips();
      renderAll();
    });
    btnNone.addEventListener('click', async ()=>{
      node.customAttributes = node.customAttributes || {};
      delete node.customAttributes[aid];
      renderMultiVals(aid);
      renderAttrChips();
      renderAll();
    });
    btnAddOpt.addEventListener('click', async ()=>{
      if(!a) return;
      if(!Array.isArray(a.values)) a.values = [];
      const taken = new Set((a.values||[]).map(v=>v && v.id).filter(Boolean));
      openCreateModal({
        kind:'customAttrValue',
        title:`Add value to ${a.label||a.id}`,
        placeholder:'Value label',
        hint:'ID is generated from the value label and made unique.',
        taken,
        onCommit: ({label,id,note,abbr,_autoId,_autoAbbr})=>{
          let maxVP = 0;
          a.values.forEach(v=>{ if(v && typeof v.priority==='number' && v.priority > maxVP) maxVP = v.priority; });
          const vObj = {id, label, note: (note||''), priority: maxVP + 1, _autoId, _autoAbbr};
          if(abbr) vObj.abbr = abbr;
          a.values.push(vObj);
          node.customAttributes = node.customAttributes || {};
          const cur = node.customAttributes[aid];
          if(cur===undefined) node.customAttributes[aid] = id;
          else if(Array.isArray(cur)){ if(!cur.map(String).includes(String(id))) cur.push(id); }
          else { if(String(cur)!==String(id)) node.customAttributes[aid] = [cur, id]; }
          renderMultiVals(aid);
          renderAttrChips();
          renderAll();
        }
      });
    });
  }

function rebuildTagOptions(){
    const cat = ensureTagCatalog();
    const sorted = [...cat].sort((a,b)=>{
      const pa = typeof a.priority==='number' ? a.priority : 9999;
      const pb = typeof b.priority==='number' ? b.priority : 9999;
      return pa - pb;
    });
    ndTagSel.innerHTML = '<option value="">Add tag</option>' + sorted.map(t=>{
      const lbl = (t.abbr ? (t.abbr+'  ') : '') + (t.label||t.id);
      return `<option value="${escapeHtml(t.id)}">${escapeHtml(lbl)}</option>`;
    }).join('\n') + '<option value="__new__">+ New tag</option>';
  }
  function renderTagChips(){
    ndTagChips.innerHTML='';
    const arr = sortTagIdsByPriority(normalizeNodeTags(node));
    if(!arr.length){ ndTagChips.innerHTML='<span class="empty">No tags.</span>'; return; }
    arr.forEach(tid=>{
      const td = tagById(tid) || {id:tid,label:tid,abbr:''};
      const chip=document.createElement('span');
      chip.className='tagChip';
      chip.style.setProperty('--c', tagColor(td));
      chip.setAttribute('data-color','1');
      chip.textContent = tagAbbr(td) || tid;
      chip.title = (td.label||td.id) + (td.note?('  '+td.note):'');
      const x=document.createElement('span');
      x.textContent=' '; x.style.cursor='pointer'; x.style.opacity='.85';
      x.addEventListener('click',(e)=>{ e.stopPropagation(); node.tags = (node.tags||[]).filter(v=>v!==tid); renderTagChips(); renderAll(); });
      chip.appendChild(x);
      ndTagChips.appendChild(chip);
    });
  }
  ndTagSel.addEventListener('change', ()=>{
    const v=(ndTagSel.value||'').trim();
    if(!v) return;
    if(v==='__new__'){
      ndTagSel.value='';
      openTagCreateModal({attachNodeId: nodeId, afterCreate: null});
      return;
    }
    node.tags = node.tags || [];
    if(!node.tags.includes(v)) node.tags.push(v);
    ndTagSel.value='';
    renderTagChips();
  });
  ndTagNew.addEventListener('click', async ()=>{
    openTags();
  });
  rebuildTagOptions();
  renderTagChips();

  // Color toggle
  {
    const ndColorOn = document.getElementById('ndColorOn');
    const ndColor = document.getElementById('ndColor');
    const ndSaveBtn = document.getElementById('ndSave');
    if(ndColorOn && ndColor){
      // Build preset swatches
      buildColorSwatches(document.getElementById('ndColorSwatches'), ndColor);
      const triggerDirty = ()=>{ if(ndSaveBtn && ndSaveBtn.__dirtyUpdate) ndSaveBtn.__dirtyUpdate(); };
      ndColorOn.addEventListener('change', ()=>{
        ndColor.style.opacity = ndColorOn.checked ? '1' : '.3';
        triggerDirty();
      });
      ndColor.addEventListener('input', triggerDirty);
      ndColor.addEventListener('change', triggerDirty);
    }
  }

  // Attributes wiring
  const ndAttrChips = document.getElementById('ndAttrChips');
  const ndAttrSel = document.getElementById('ndAttrSel');
  const ndAttrValSel = document.getElementById('ndAttrValSel');
  const ndAttrCatalog = document.getElementById('ndAttrCatalog');

  function rebuildAttrOptions(){
    const cat = ensureCustomAttributeCatalog();
    // Preserve current attribute selection (especially for multi-select workflows).
    const keep = (state && typeof state.nodeEditorAttrFocus==='string' && state.nodeEditorAttrFocus) ? state.nodeEditorAttrFocus : (ndAttrSel.value||'');
    ndAttrSel.innerHTML = '<option value="">Attribute</option>' + cat.map(a=>{
      const lbl = (a.abbr ? (a.abbr+'  ') : '') + (a.label||a.id);
      return `<option value="${escapeHtml(a.id)}">${escapeHtml(lbl)}</option>`;
    }).join('') + '<option value="__new__">+ New attribute</option>';
    // Restore selection if still present.
    if(keep){
      ndAttrSel.value = keep;
      if(ndAttrSel.value !== keep){
        // option no longer exists; clear
        ndAttrSel.value = '';
      }
    }
  }
  function rebuildValOptions(aid){
    if(!aid){ ndAttrValSel.innerHTML = '<option value="">Value</option>'; return; }
    const a = customAttrById(aid);
    const vals = (a && Array.isArray(a.values)) ? a.values : [];
    ndAttrValSel.innerHTML = '<option value="">Value</option>' + vals.map(v=>{
      return `<option value="${escapeHtml(v.id)}">${escapeHtml(v.label||v.id)}</option>`;
    }).join('\n') + '<option value="__new__">+ New value</option>';
  }
  function renderAttrChips(){
    ndAttrChips.innerHTML='';
    const ca = normalizeCustomAttributes(node);
    const keys = Object.keys(ca||{});
    if(!keys.length){ ndAttrChips.innerHTML='<span class="empty">No custom attributes.</span>'; return; }
    keys.sort().forEach(aid=>{
      const raw = ca[aid];
      const a = customAttrById(aid) || {id:aid,label:aid,abbr:''};
      const vals = Array.isArray(raw) ? raw : [raw];
      vals.forEach(vid=>{
        const v = customValueById(aid, vid) || {id:vid,label:vid};
        const chip=document.createElement('span');
        chip.className='tagChip';
        chip.textContent = (customAttrAbbr(a)||aid) + ': ' + (v.label||v.id);
        chip.title = (a.label||a.id) + ' = ' + (v.label||v.id);
        const x=document.createElement('span');
        x.textContent=' '; x.style.cursor='pointer'; x.style.opacity='.85';
        x.addEventListener('click',(e)=>{
          e.stopPropagation();
          const cur = node.customAttributes[aid];
          if(Array.isArray(cur)){
            const next = cur.filter(z=>String(z) !== String(vid));
            if(next.length===0) delete node.customAttributes[aid];
            else if(next.length===1) node.customAttributes[aid] = next[0];
            else node.customAttributes[aid] = next;
          } else {
            delete node.customAttributes[aid];
          }
          renderAttrChips();
          renderAll();
        });
        chip.appendChild(x);
        ndAttrChips.appendChild(chip);
      });
    });
  }

  ndAttrSel.addEventListener('change', ()=>{
    // Remember selected attribute to keep focus stable during multi-select edits.
    state.nodeEditorAttrFocus = ndAttrSel.value || '';

    const aid = ndAttrSel.value;
    if(aid==='__new__'){
      const cat = ensureCustomAttributeCatalog();
      normalizeCatalogMultiFlag();
      const taken = new Set((cat||[]).map(a=>a && a.id).filter(Boolean));
      ndAttrSel.value='';
      openCreateModal({
        kind:'customAttr',
        title:'Add custom attribute',
        placeholder:'Attribute label',
        hint:'ID is generated from the attribute label and made unique.',
        taken,
        onCommit: ({label,id,abbr,note,multi,_autoId,_autoAbbr})=>{
          cat.push({ id, label, abbr: (abbr||'').trim() || (label||'').replace(/\s+/g,'').slice(0,2).toUpperCase(), note: (note||''), multi:!!multi, values:[], _autoId, _autoAbbr});
          rebuildAttrOptions();
          ndAttrSel.value = id;
          rebuildValOptions(id);
  if(state) state.nodeEditorAttrFocus = id;
          const inline = document.getElementById('ndAttrInlineControls');
          inline?.classList.remove('hidden');
          ndAttrValSel.classList.remove('hidden');
          renderMultiVals(id);
          renderAll();
        }
      });
      return;
    }
    rebuildValOptions(aid);
    const isM = customAttrIsMulti(aid);
    const inline = document.getElementById('ndAttrInlineControls');
    inline?.classList.toggle('hidden', isM);
    ndAttrValSel.classList.toggle('hidden', isM);
    renderMultiVals(aid);
    const cur = (node.customAttributes||{})[aid];
    if(!isM){ ndAttrValSel.value = cur ? String(cur) : ''; }
  });

  ndAttrCatalog.addEventListener('click', openCustomAttrs);

  rebuildAttrOptions();
  // initialize values UI
  rebuildValOptions(ndAttrSel.value);
  ndAttrValSel.classList.toggle('hidden', customAttrIsMulti(ndAttrSel.value));
  renderMultiVals(ndAttrSel.value);

  ndAttrValSel.addEventListener('change', ()=>{
    const aid = (ndAttrSel.value||'').trim();
    const vid = (ndAttrValSel.value||'').trim();
    if(!aid || aid==='__new__') return;
    const isM = customAttrIsMulti(aid);
    if(isM) return;
    if(!vid) return;

    if(vid==='__new__'){
      const a = customAttrById(aid);
      if(!a){  return; }
      if(!Array.isArray(a.values)) a.values=[];
      const taken = new Set(a.values.map(v=>v && v.id).filter(Boolean));
      openCreateModal({
        kind:'customAttrValue',
        title:`Add value to ${a.label||a.id}`,
        placeholder:'Value label',
        hint:'ID is generated from the value label and made unique.',
        taken,
        onCommit: ({label,id,note,abbr,_autoId,_autoAbbr})=>{
          let maxVP = 0;
          a.values.forEach(v=>{ if(v && typeof v.priority==='number' && v.priority > maxVP) maxVP = v.priority; });
          const vObj = {id, label, note: (note||''), priority: maxVP + 1, _autoId, _autoAbbr};
          if(abbr) vObj.abbr = abbr;
          a.values.push(vObj);
          rebuildValOptions(aid);
          node.customAttributes = node.customAttributes || {};
          node.customAttributes[aid] = id;
          // Single-select UX (new value): reset selectors after commit.
          if(state) state.nodeEditorAttrFocus = '';
          try{ ndAttrSel.value = ''; ndAttrValSel.value = ''; }catch(e){}
          try{ rebuildValOptions(''); }catch(e){}
          renderAttrChips();
          renderAll();
        }
      });
      return;
    }

    node.customAttributes = node.customAttributes || {};
    node.customAttributes[aid] = vid;
    // Single-select UX: after choosing a value, reset the Attribute/Value selectors.
    if(state) state.nodeEditorAttrFocus = '';
    try{ ndAttrSel.value = ''; ndAttrValSel.value = ''; }catch(e){}
    try{ rebuildValOptions(''); }catch(e){}
    renderAttrChips();
    renderAll();
  });

  

  rebuildAttrOptions();
  rebuildValOptions(ndAttrSel.value);
  renderAttrChips();

  // Save / Cancel
  document.getElementById('ndSave').addEventListener('click', async ()=>{
    const newLabel = (document.getElementById('ndLabel')?.value || '').trim() || node.label;
    const newLocalSeg = sanitizeManualId(document.getElementById('ndId')?.value || '') || localIdSegment(node.id);
    const oldId = node.id;
    const prefix = idPathPrefix(oldId);
    const newId = prefix + newLocalSeg;
    recordChange();

    // Update label (independent of ID)
    node.label = newLabel;
    node.note = (document.getElementById('ndNote')?.value || '');

    // Update color  always remember the picker value
    const colorOn = document.getElementById('ndColorOn')?.checked;
    const pickerVal = document.getElementById('ndColor')?.value || '';
    if(colorOn){
      node.color = pickerVal;
      delete node._pendingColor;
    } else {
      delete node.color;
      // Remember the picked color so it survives save/reload
      if(pickerVal && pickerVal !== '#3b82f6') node._pendingColor = pickerVal;
      else delete node._pendingColor;
    }

    // Persist auto-ID state
    node._autoId = __editorAutoId;

    // Update ID if changed
    let finalId = oldId;
    if(newId !== oldId){
      const colId = columnOf(oldId) || oldId;
      const result = reIdNodeInData(state.data, oldId, newId, colId);
      if(result === oldId){
        setGlobalStatus('Node ID conflict  ID not changed (duplicate).');
      } else {
        finalId = result;
      }
    }

    __editSnapshot = null;
    // Stay on the node after save (use finalId in case ID was changed)
    state.lockedId = finalId; state.hoverId = null; state.selectedEdgeId = null; state.selectedColumnId = null;
    state.__hoverCooldownUntil = Date.now() + 400; // suppress hover for 400ms after save
    renderAll();
    setGlobalStatus('Node saved.');
  });
  document.getElementById('ndCancel').addEventListener('click', async ()=>{
    const stayId = state.lockedId; // remember which node we're on
    revertEditSnapshot();
    __editSnapshot = null;
    state.lockedId = stayId; // stay selected
    state.hoverId = null;
    state.__hoverCooldownUntil = Date.now() + 400;
    checkDirtyState();
    renderAll();
    setGlobalStatus('Cancelled changes.');
  });

  const ndDelBtn = document.getElementById('ndDelete');
  if(ndDelBtn){
    const colId = columnOf(nodeId);
    const hasParent = !!IDX.parentById.get(nodeId);
    if(!hasParent){
      ndDelBtn.disabled = true;
      ndDelBtn.title = 'Cannot delete root node';
    }
    ndDelBtn.addEventListener('click', ()=>{
      if(!hasParent) return;
      // Clear snapshot before delete so we don't revert afterward
      __editSnapshot = null;
      deleteNodeInline(nodeId, colId);
    });
  }

  wireDirtyHighlight(detailsBody, document.getElementById('ndSave'), nodeEditIsDirty);
  // Node labelid auto-fill (local segment)
  {
    const _ndLabelInp = document.getElementById('ndLabel');
    const _ndIdInp = document.getElementById('ndId');
    const _ndIdAutoTag = document.getElementById('ndIdAuto');
    if(_ndLabelInp && _ndIdInp){
      const _slugNd = (raw)=> idPartFromLabel(raw, {lower:false});
      const initLabel = _ndLabelInp.value.trim();
      const initIdAuto = _slugNd(initLabel) || '';
      let _lastAutoId = node._autoId ? initIdAuto : '';
      __editorAutoId = _lastAutoId !== '';
      const _refreshTag = ()=>{ if(_ndIdAutoTag) _ndIdAutoTag.style.display = _lastAutoId !== '' ? '' : 'none'; };
      _refreshTag();
      _ndLabelInp.addEventListener('input', ()=>{
        const cur = _ndIdInp.value.trim();
        if(!cur || cur === _lastAutoId){ const ai = _slugNd(_ndLabelInp.value.trim())||''; _ndIdInp.value = ai; _lastAutoId = ai; }
        __editorAutoId = _lastAutoId !== '';
        _refreshTag();
      });
      _ndIdInp.addEventListener('input', ()=>{
        if(!_ndIdInp.value.trim()){ const ai = _slugNd(_ndLabelInp.value.trim())||''; _ndIdInp.value = ai; _lastAutoId = ai; }
        else _lastAutoId = '';
        __editorAutoId = _lastAutoId !== '';
        _refreshTag();
      });
    }
  }
  return true;
}

function addBelowNode(nodeId, colId, isFieldNew){
  if(!state.editorMode) return;
  if(!IDX.parentById.get(nodeId)) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || loc.idx===null || !loc.siblings) return;
  const taken = collectNodeIds(col);
  const parentId = (loc.parent.id===colId ? colId : loc.parent.id);
  openCreateModal({
    kind: 'node',
    title: `Insert ${isFieldNew?'field':'group'} below`,
    placeholder: isFieldNew ? 'Field label' : 'Group label',

    hint: 'ID is generated from the label under the same parent and made unique.',
    colId,
    parentId,
    taken,
    onCommit: ({label, id, note, tags, customAttributes, _autoId})=>{
      const newNode = { id, label, _autoId, type: isFieldNew?'field':'group' }; if(note) newNode.note = note;
      if(tags && tags.length) newNode.tags = tags;
      if(customAttributes) newNode.customAttributes = customAttributes;
      if(!isFieldNew) newNode.children=[];
      loc.siblings.splice(loc.idx+1, 0, newNode);
      recordChange(); // Node added
      renderAll();
      lockSelection(id);
    }
  });
}

function addAboveNode(nodeId, colId, isFieldNew){
  if(!state.editorMode) return;
  if(!IDX.parentById.get(nodeId)) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || loc.idx===null || !loc.siblings) return;
  const taken = collectNodeIds(col);
  const parentId = (loc.parent.id===colId ? colId : loc.parent.id);
  openCreateModal({
    kind: 'node',
    title: `Insert ${isFieldNew?'field':'group'} above`,
    placeholder: isFieldNew ? 'Field label' : 'Group label',

    hint: 'ID is generated from the label under the same parent and made unique.',
    colId,
    parentId,
    taken,
    onCommit: ({label, id, note, tags, customAttributes, _autoId})=>{
      const newNode = { id, label, _autoId, type: isFieldNew?'field':'group' }; if(note) newNode.note = note;
      if(tags && tags.length) newNode.tags = tags;
      if(customAttributes) newNode.customAttributes = customAttributes;
      if(!isFieldNew) newNode.children=[];
      loc.siblings.splice(loc.idx, 0, newNode);
      recordChange(); // Node added
      renderAll();
      lockSelection(id);
    }
  });
}

function duplicateNode(nodeId, colId, withMappings){
  if(!state.editorMode) return;
  if(!IDX.parentById.get(nodeId)) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || loc.idx===null || !loc.siblings) return;
  const taken = collectNodeIds(col);

  // Deep clone the node
  const clone = JSON.parse(JSON.stringify(loc.node));

  // Build oldnew ID map while rewriting IDs
  const idMap = new Map();
  function rewriteIds(n, parentPrefix){
    const oldId = n.id;
    const localSeg = n.id.includes('.') ? n.id.split('.').pop() : n.id;
    let candidate = parentPrefix ? parentPrefix + '.' + localSeg : localSeg;
    let suffix = 1;
    while(taken.has(candidate)){
      candidate = (parentPrefix ? parentPrefix + '.' : '') + localSeg + '_copy' + (suffix > 1 ? suffix : '');
      suffix++;
    }
    taken.add(candidate);
    n.id = candidate;
    n.label = (n.label || localSeg) + (suffix > 1 || candidate.includes('_copy') ? '' : '');
    idMap.set(oldId, candidate);
    if(Array.isArray(n.children)){
      for(const ch of n.children) rewriteIds(ch, candidate);
    }
  }

  const parentId = loc.parent.id === colId ? colId : loc.parent.id;
  rewriteIds(clone, parentId === colId ? colId : parentId);

  // Append a visual indicator to the top-level label
  if(clone.label && !clone.label.endsWith(' (copy)')) clone.label += ' (copy)';

  loc.siblings.splice(loc.idx + 1, 0, clone);

  // Copy mappings if requested
  if(withMappings && state.data.mappings){
    const newMappings = [];
    for(const m of state.data.mappings){
      if(!m || typeof m !== 'object') continue;
      const fromMapped = idMap.get(m.from);
      const toMapped = idMap.get(m.to);
      // Clone mapping if either endpoint was in the duplicated subtree
      if(fromMapped || toMapped){
        const mc = JSON.parse(JSON.stringify(m));
        if(fromMapped) mc.from = fromMapped;
        if(toMapped) mc.to = toMapped;
        newMappings.push(mc);
      }
    }
    state.data.mappings.push(...newMappings);
  }

  recordChange();
  renderAll();
  lockSelection(clone.id);
}

function moveNode(nodeId, colId, dir){
  if(!state.editorMode) return;
  if(!IDX.parentById.get(nodeId)) return; // cannot move root
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || !loc.siblings || loc.idx===null) return;
  const i = loc.idx;
  const j = i + dir;
  if(j < 0 || j >= loc.siblings.length) return;
  recordChange(); // Save BEFORE move
  const tmp = loc.siblings[i];
  loc.siblings[i] = loc.siblings[j];
  loc.siblings[j] = tmp;
  renderAll();
  // keep the moved node selected
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.lockedId = nodeId;
  state.hoverId = null;
  applyHighlight();
  scrollIntoView(nodeId);
}

function inlineIndent(nodeId, colId){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || !loc.siblings || loc.idx===null) return;
  if(loc.idx<=0) return;
  const prev = loc.siblings[loc.idx-1];
  if(!prev || prev.type==='field') return;
  recordChange(); // Save BEFORE indent
  ensureGroup(prev);
  const node = loc.siblings.splice(loc.idx,1)[0];
  if(!prev.children) prev.children=[];
  prev.children.push(node);
  // re-id to reflect new parent path
  { const moved=node; const taken=collectNodeIds(col); const base=(prev.id===col.id?col.id:prev.id)+'.'+localIdSegment(moved.id); const idMap={}; const old=moved.id; const newid=ensureUniqueId(base, taken); buildSubtreeIdMap(moved, old, newid, idMap); replaceIdsInMappings(state.data, idMap); }
  renderAll();
  lockSelection(node.id);
}

function inlineOutdent(nodeId, colId){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent) return;
  const parentLoc = locateNode(col.schema, loc.parent.id);
  if(!parentLoc || !parentLoc.parent || !parentLoc.siblings || parentLoc.idx===null) return;
  const idx = (loc.parent.children||[]).findIndex(n=>n && n.id===nodeId);
  if(idx<0) return;
  recordChange(); // Save BEFORE outdent
  const node = loc.parent.children.splice(idx,1)[0];
  parentLoc.siblings.splice(parentLoc.idx+1, 0, node);
  // re-id to reflect new parent path (grandparent)
  { const moved=node; const newPar = parentLoc.parent ? parentLoc.parent.id : col.schema.id; const taken=collectNodeIds(col); const base=(newPar===col.id?col.id:newPar)+'.'+localIdSegment(moved.id); const idMap={}; const old=moved.id; const newid=ensureUniqueId(base, taken); buildSubtreeIdMap(moved, old, newid, idMap); replaceIdsInMappings(state.data, idMap); }
  renderAll();
  lockSelection(node.id);
}

async function deleteNodeInline(nodeId, colId){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || !loc.siblings || loc.idx===null) return;
  const nodeType = loc.node.type === 'field' ? 'field' : 'group';
  const nodeLabel = loc.node.label || localIdSegment(nodeId);
  const fieldsToRemove = collectFieldIdsFromNode(loc.node);
  // Count descendants for groups
  let childInfo = '';
  if(nodeType === 'group'){
    let fieldCount = 0, groupCount = 0;
    (function walk(n){ if(!n) return; if(n.type==='field') fieldCount++; else if(n.type==='group') groupCount++; (n.children||[]).forEach(walk); })(loc.node);
    // Don't count the group itself
    groupCount = Math.max(0, groupCount - 1);
    const parts = [];
    if(fieldCount) parts.push(fieldCount + ' field' + (fieldCount>1?'s':''));
    if(groupCount) parts.push(groupCount + ' sub-group' + (groupCount>1?'s':''));
    if(parts.length) childInfo = `\n\nThis will also delete ${parts.join(' and ')} inside it.`;
  }
  // Count affected mappings
  const kill = new Set(fieldsToRemove);
  const mapCount = (state.data.mappings||[]).filter(m => m && (kill.has(m.from) || kill.has(m.to))).length;
  const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
  if(!await customConfirm(`Delete ${nodeType} "${nodeLabel}" (${nodeId})?${childInfo}${mapInfo}`)) return;
  recordChange(); // Save BEFORE deletion
  removeMappingsReferencingInState(fieldsToRemove);
  loc.siblings.splice(loc.idx,1);
  // Clear selection after delete
  state.lockedId = null;
  state.hoverId = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  renderAll();
}



function addChildNode(nodeId, colId, isFieldNew, atTop=false){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.node) return;
  if(loc.node.type==='field') return;
  if(!loc.node.children) loc.node.children=[];
  const taken = collectNodeIds(col);
  openCreateModal({
    kind: 'node',
    title: `Add ${isFieldNew?'field':'group'} (${atTop?'top':'bottom'})`,
    placeholder: isFieldNew ? 'Field label' : 'Group label',

    hint: 'ID is generated from the label under the selected parent and made unique.',
    colId,
    parentId: nodeId===colId ? colId : nodeId,
    taken,
    onCommit: ({label, id, note, tags, customAttributes, _autoId})=>{
      recordChange(); // Save BEFORE adding
      const newNode = { id, label, _autoId, type: isFieldNew?'field':'group' }; if(note) newNode.note = note;
      if(tags && tags.length) newNode.tags = tags;
      if(customAttributes) newNode.customAttributes = customAttributes;
      if(!isFieldNew) newNode.children=[];
      if(atTop) loc.node.children.unshift(newNode);
      else loc.node.children.push(newNode);
      renderAll();
      lockSelection(id);
    }
  });
}


// --- Context menu (vertical, viewport-anchored; avoids clipping) ---
let __ctxMenuEl = null;
let __ctxOwnerEl = null;
let __ctxMenuColId = null;

let __ctxCleanup = null;
function closeCtxMenu(){
  if(__ctxCleanup){ try{ __ctxCleanup(); }catch{} __ctxCleanup=null; }
  if(__ctxMenuEl){ __ctxMenuEl.remove(); __ctxMenuEl=null; }
  if(__ctxOwnerEl){ try{ __ctxOwnerEl.classList.remove('menuOpen'); }catch{} __ctxOwnerEl=null; }
  __ctxMenuColId = null;
}
function openCtxMenu(items, anchorEl){
  closeCtxMenu();
  // Keep the originating row/header in an active-hover state while the context menu is open
  try{
    if(__ctxOwnerEl) __ctxOwnerEl.classList.remove('menuOpen');
    __ctxOwnerEl = anchorEl?.closest('.row') || anchorEl?.closest('.panelHeader') || null;
    if(__ctxOwnerEl) __ctxOwnerEl.classList.add('menuOpen');
  }catch{}

  const menu = document.createElement('div');
  menu.className = 'ctxMenu';
  items.forEach(it=>{
    if(!it) return;
    if(it.type==='sep'){
      const sep=document.createElement('div'); sep.className='ctxSep';
      menu.appendChild(sep); return;
    }
    const btn=document.createElement('button');
    btn.type='button';
    btn.className = 'ctxItem' + (it.danger ? ' danger' : '');
    btn.disabled = !!it.disabled;
    btn.innerHTML = `<span class="ico">${it.icon||''}</span><span class="lbl">${escapeHtml(it.label||'')}</span>`;
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(btn.disabled) return;
      closeCtxMenu();
      try{ it.onClick && it.onClick(); }catch(err){ console.error(err); }
    });
    menu.appendChild(btn);
  });
  document.body.appendChild(menu);

  // position near anchor, clamp to viewport, flip if needed
  const r = anchorEl.getBoundingClientRect();
  const pad = 8;
  const gap = 6;
  let x = r.left;
  let y = r.bottom + gap;
  const mr = menu.getBoundingClientRect();
  if(x + mr.width > window.innerWidth - pad) x = window.innerWidth - pad - mr.width;
  if(x < pad) x = pad;
  if(y + mr.height > window.innerHeight - pad){
    y = r.top - gap - mr.height;
  }
  if(y < pad) y = pad;
  menu.style.left = `${Math.round(x)}px`;
  menu.style.top  = `${Math.round(y)}px`;

  const onDocClick = (e)=>{
    if(menu.contains(e.target)) return;
    // Let miniBtn handlers deal with their own toggle logic
    if(e.target.closest && e.target.closest('.miniBtn')) return;
    closeCtxMenu();
  };
  const onKey = (e)=>{ if(e.key==='Escape') closeCtxMenu(); };
  const onAnyScroll = ()=> closeCtxMenu();

  document.addEventListener('click', onDocClick, true);
  document.addEventListener('keydown', onKey, true);
  window.addEventListener('resize', onAnyScroll, true);
  // Delay scroll listener to avoid false triggers from layout changes that precede menu open
  let _scrollTimer = setTimeout(()=>{
    window.addEventListener('scroll', onAnyScroll, true);
    _scrollTimer = null;
  }, 80);

  __ctxMenuEl = menu;
  __ctxCleanup = ()=>{
    document.removeEventListener('click', onDocClick, true);
    document.removeEventListener('keydown', onKey, true);
    window.removeEventListener('scroll', onAnyScroll, true);
    window.removeEventListener('resize', onAnyScroll, true);
    if(_scrollTimer) clearTimeout(_scrollTimer);
  };
}

function addRowActions(){
  if(!state.editorMode) return;

  // one-time global closer for mini menus (legacy; keep harmless)
  if(!document.__msMenuClose){
    document.__msMenuClose = true;
    document.addEventListener('click', async ()=>{
      document.querySelectorAll('.miniMenu.active').forEach(m=>m.classList.remove('active'));
    });
  }

  for(const [nodeId,row] of IDX.rowById.entries()){
    if(row.querySelector('.rowActions')) continue;
    const node = IDX.nodeById.get(nodeId);
    const colId = row.dataset.columnId;
    const hasParent = !!IDX.parentById.get(nodeId);

    function lockCurrent(e){
      if(e) e.stopPropagation();
      // Toggle: if already locked on this node, unlock it
      if(state.lockedId===nodeId){
        state.lockedId = null;
        state.hoverId = null;
        applyHighlight();
      } else {
        state.selectedColumnId = null;
        state.selectedEdgeId = null;
        state.lockedId = nodeId;
        state.hoverId = null;
        applyHighlight();
      }
    }

    // Compute sibling position
    let loc=null;
    if(hasParent){
      const col = findColumnById(colId);
      if(col) loc = locateNode(col.schema, nodeId);
    }
    const canMoveUp = !!(loc && loc.siblings && loc.idx!==null && loc.idx>0);
    const canMoveDown = !!(loc && loc.siblings && loc.idx!==null && loc.idx < loc.siblings.length-1);

    // Indent into previous sibling group
    const canIndent = !!(loc && loc.siblings && loc.idx!==null && loc.idx>0 && loc.siblings[loc.idx-1] && loc.siblings[loc.idx-1].type==='group');

    // Outdent to parent (requires grandparent)
    let canOutdent = false;
    if(loc && loc.parent){
      const col = findColumnById(colId);
      const parentLoc = col ? locateNode(col.schema, loc.parent.id) : null;
      canOutdent = !!(parentLoc && parentLoc.parent && parentLoc.siblings && parentLoc.idx!==null);
    }

    const actions=document.createElement('div');
    actions.className='rowActions';
    actions.style.position='relative';

    // For groups: add "+" menu for Add child (unchanged options; icon changed)
    if(node && node.type==='group'){
      const addChildItems = [
        {label:'Add field on top', icon:'', onClick: ()=> addChildNode(nodeId, colId, true, true)},
        {label:'Add field at bottom', icon:'', onClick: ()=> addChildNode(nodeId, colId, true, false)},
        {type:'sep'},
        {label:'Add group on top', icon:'', onClick: ()=> addChildNode(nodeId, colId, false, true)},
        {label:'Add group at bottom', icon:'', onClick: ()=> addChildNode(nodeId, colId, false, false)},
      ];
      const btnPlus=document.createElement('button');
      btnPlus.className='miniBtn';
      btnPlus.title='Add child';
      btnPlus.textContent='\u21B3';
      btnPlus.addEventListener('click', async (e)=>{ 
        e.stopPropagation();
        const row = btnPlus.closest('.row') || btnPlus.closest('.panelHeader');
        if(__ctxMenuEl && __ctxOwnerEl === row){
          closeCtxMenu();
          return;
        }
        closeCtxMenu();
        if(state.lockedId !== nodeId){
          if(nodeEditIsDirty()){
            if(!await guardNodeAbandon()) return;
            revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
          }
          state.selectedColumnId = null;
          state.selectedEdgeId = null;
          state.lockedId = nodeId;
          state.hoverId = null;
          applyHighlight();
        }
        openCtxMenu(addChildItems, btnPlus);
      });
      actions.appendChild(btnPlus);
    }

    // Build  menu for both fields and groups
    const menuItems = [];
    menuItems.push({ label: node.type==='field' ? 'Edit field' : 'Edit group', icon:'', onClick: ()=>{ lockSelection(nodeId); scrollIntoView(nodeId); }});
    if(hasParent) menuItems.push({ type:'sep' });
    // Insert siblings (above/below)
    if(hasParent){
      menuItems.push({ label:'Insert field above', icon:'', onClick: ()=> addAboveNode(nodeId, colId, true) });
      menuItems.push({ label:'Insert field below', icon:'', onClick: ()=> addBelowNode(nodeId, colId, true) });
      menuItems.push({ type:'sep' });
      menuItems.push({ label:'Insert group above', icon:'', onClick: ()=> addAboveNode(nodeId, colId, false) });
      menuItems.push({ label:'Insert group below', icon:'', onClick: ()=> addBelowNode(nodeId, colId, false) });
    }
    if(hasParent) menuItems.push({ type:'sep' });
    // Move
    menuItems.push({ label:'Move up', icon:'', disabled:!canMoveUp, onClick: ()=> moveNode(nodeId, colId, -1) });
    menuItems.push({ label:'Move down', icon:'', disabled:!canMoveDown, onClick: ()=> moveNode(nodeId, colId, +1) });
    if(hasParent) menuItems.push({ type:'sep' });
    // Indent/Outdent
    menuItems.push({ label:'Indent', icon:'', disabled:!canIndent, onClick: ()=> inlineIndent(nodeId, colId) });
    menuItems.push({ label:'Outdent', icon:'', disabled:!canOutdent, onClick: ()=> inlineOutdent(nodeId, colId) });
    if(hasParent) menuItems.push({ type:'sep' });
    // Duplicate
    menuItems.push({ label:'Duplicate', icon:'', disabled:!hasParent, onClick: ()=> duplicateNode(nodeId, colId, false) });
    menuItems.push({ label:'Duplicate+', icon:'', disabled:!hasParent, onClick: ()=> duplicateNode(nodeId, colId, true) });
    if(hasParent) menuItems.push({ type:'sep' });
    // Delete
    menuItems.push({ label: 'Delete', icon:'', danger:true, disabled:!hasParent, onClick: ()=> deleteNodeInline(nodeId, colId) });

    const btnMenu=document.createElement('button');
    btnMenu.className='miniBtn';
    btnMenu.title='Actions';
    btnMenu.textContent='';
    btnMenu.addEventListener('click', async (e)=>{ 
      e.stopPropagation();
      const row = btnMenu.closest('.row') || btnMenu.closest('.panelHeader');
      if(__ctxMenuEl && __ctxOwnerEl === row){
        closeCtxMenu();
        return;
      }
      closeCtxMenu();
      if(state.lockedId !== nodeId){
        if(nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        state.selectedColumnId = null;
        state.selectedEdgeId = null;
        state.lockedId = nodeId;
        state.hoverId = null;
        applyHighlight();
      }
      openCtxMenu(menuItems, btnMenu);
    });
    actions.appendChild(btnMenu);

    row.appendChild(actions);

    // Drag & drop mapping creation (fields only)  unchanged
    if(!window.__ENHANCED_DND && node && node.type==='field'){
      row.draggable = true;
      row.addEventListener('dragstart', (e)=>{
        if(!state.editorMode) return;
        try{ e.dataTransfer.setData('text/plain', nodeId); e.dataTransfer.effectAllowed='copy'; }catch{}
      });
    }

    if(!window.__ENHANCED_DND) row.addEventListener('dragover', (e)=>{
      if(!state.editorMode) return;
      const src = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
      if(!src) return;
      const srcNode = IDX.nodeById.get(src);
      if(!(srcNode && srcNode.type==='field' && node && node.type==='field')) return;
      if(row.dataset.columnId === (IDX.rowById.get(src)?.dataset.columnId)) return;
      e.preventDefault();
      row.classList.add('dropTarget');
    });
    if(!window.__ENHANCED_DND) row.addEventListener('dragleave', ()=> row.classList.remove('dropTarget'));
    if(!window.__ENHANCED_DND) row.addEventListener('drop', (e)=>{
      if(!state.editorMode) return;
      const src = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
      if(!src) return;
      const srcNode = IDX.nodeById.get(src);
      if(!(srcNode && srcNode.type==='field' && node && node.type==='field')) return;
      if(row.dataset.columnId === (IDX.rowById.get(src)?.dataset.columnId)) return;
      e.preventDefault();
      ensureMapping(src, nodeId);
      renderAll();
      const edge = IDX.edges.find(e=>e.from===src && e.to===nodeId);
      if(edge) state.selectedEdgeId = edge.id;
      state.lockedId = nodeId;
      applyHighlight();
      scheduleArrowsUpdate();
    });
  }
}


function setEditorMode(on){
  state.editorMode = !!on;
  // Preserve column selection across mode toggle, just clear edit sessions
  state.hoverEdgeId = null;
  // Clear edit sessions (already guarded before reaching here)
  __editSnapshot = null;
  __edgeEditSession = null;
  if(typeof updateColumnHeaderSelectionStyles==='function') updateColumnHeaderSelectionStyles();

  document.body.classList.toggle('editorMode', state.editorMode);
  if(!state.editorMode){
    if(editorOverlay) editorOverlay.innerHTML='';
  }
  
  // Show/hide editor-only buttons
  if(undoBtn) undoBtn.style.display = state.editorMode ? '' : 'none';
  if(redoBtn) redoBtn.style.display = state.editorMode ? '' : 'none';
  const addTagBtn = document.getElementById('addTagBtn');
  const addTransformBtn = document.getElementById('addTransformBtn');
  const addCustomAttrBtn = document.getElementById('addCustomAttrBtn');
  if(addTagBtn) addTagBtn.style.display = state.editorMode ? '' : 'none';
  if(addTransformBtn) addTransformBtn.style.display = state.editorMode ? '' : 'none';
  if(addCustomAttrBtn) addCustomAttrBtn.style.display = state.editorMode ? '' : 'none';
  const addFilterBtn2 = document.getElementById('addFilterBtn');
  if(addFilterBtn2) addFilterBtn2.style.display = state.editorMode ? '' : 'none';
  
  // Re-render catalogs for read-only vs edit mode
  if(typeof renderTagsManager==='function') renderTagsManager();
  if(typeof renderTransformsManager==='function') renderTransformsManager();
  if(typeof renderCustomAttrsManager==='function') renderCustomAttrsManager();
  if(typeof renderFiltersManager==='function') renderFiltersManager();
  if(typeof buildColumnsMenu==='function') buildColumnsMenu();
  
  renderAll();
  
  addRowActions();
  attachColumnHeaderActions();
  setGlobalStatus(state.editorMode ? 'Editor mode: ON' : 'Editor mode: OFF');
}

function attachSvgEdgeInteractions(){
  if(!edgesLayer) return;
  if(edgesLayer.__edgeSelectBound) return;
  edgesLayer.__edgeSelectBound = true;

  // Click selects an edge in both Viewer & Editor
  edgesLayer.addEventListener('click', (e)=>{
    const path = e.target?.closest?.('path.edge');
    if(!path) return;
    const eid = path.dataset?.edgeId; if(!eid) return;

    // Cache consolidated metadata from the SVG path BEFORE selectEdge/renderAll
    // destroys it. drawArrows() stores collapsed-group consolidation info on path
    // elements, which is lost when the SVG is cleared and arrows redrawn via RAF.
    state._consolidatedEdgeCache = null;
    if(path.__consolidated){
      state._consolidatedEdgeCache = {
        edgeId: eid,
        consolidated: path.__consolidated,
        isBidirectional: path.__isBidirectional,
        fromId: path.__fromId,
        toId: path.__toId
      };
    }

    selectEdge(eid);
  });

  // Hover previews an edge when nothing is locked/selected
  edgesLayer.addEventListener('mouseover', (e)=>{
    const path = e.target?.closest?.('path.edge');
    if(!path) return;
    if(state.panMode) return;
    if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
    const eid = path.dataset?.edgeId; if(!eid) return;
    state.hoverEdgeId = eid; applyHighlight();
  });
  edgesLayer.addEventListener('mouseout', (e)=>{
    const path = e.target?.closest?.('path.edge');
    if(!path) return;
    if(state.panMode) return;
    if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
    state.hoverEdgeId = null; applyHighlight();
  });
}

function renderSelectedEdgeEditor(){
  if(!state.editorMode) return false;
  const edgeId = state.selectedEdgeId || state.hoverEdgeId;
  if(!edgeId) return false;
  
  // Find the edge object first
  const edge = IDX.edges.find(e => e.id === edgeId);
  if(!edge) return false;
  
  // Check the SVG path element for consolidated metadata (set during drawing)
  const pathEl = Array.from(edgesLayer.querySelectorAll('path.edge')).find(p => p.dataset.edgeId === edgeId);
  
  // Use path metadata if available (handles collapsed groups), otherwise check cache
  // (cached by SVG click handler before renderAll destroys paths), then edge metadata
  const cache = (state._consolidatedEdgeCache && state._consolidatedEdgeCache.edgeId === edgeId) ? state._consolidatedEdgeCache : null;
  const consolidated = pathEl?.__consolidated || cache?.consolidated || edge.__consolidated;
  const isBidirectional = pathEl?.__isBidirectional || cache?.isBidirectional || edge.__isBidirectional;
  const fromId = pathEl?.__fromId || cache?.fromId || edge.__fromId || edge.from;
  const toId = pathEl?.__toId || cache?.toId || edge.__toId || edge.to;
  
  // Check if this edge IS the representative of a consolidated arrow
  const isRepresentative = consolidated && consolidated.length > 1 && consolidated[0].id === edgeId;
  
  // Check if user explicitly wants to view individual mapping (clicked Edit button)
  const forceIndividual = state._showIndividualMapping;
  
  
  if(isRepresentative && !forceIndividual){
    // Check if this is collapsed groups or bidirectional fields
    const isCollapsedGroups = fromId !== edge.from || toId !== edge.to;
    
    if(isCollapsedGroups){
      // Collapsed groups - show all consolidated mappings with click-to-edit
      detailsMeta.textContent = `consolidated  ${consolidated.length} mappings`;
      
      const edges = consolidated;
      const mappings = state.data.mappings || [];
      
      // Build HTML for all mappings as clickable boxes
      const htmlParts = edges.map(edgeItem => {
        // Find the rule for this edge
        let rule = null;
        for(const m of mappings){
          if(!m || typeof m!=='object') continue;
          if(m.from !== edgeItem.from) continue;
          const tos = Array.isArray(m.to) ? m.to : [m.to];
          if(tos.includes(edgeItem.to)) { rule = m; break; }
        }
        
        const tLabels = (rule?.transforms && rule.transforms.length)
          ? rule.transforms.map(formatTransformRef).join('  ')
          : '';
        
        return `
          <div class="box clickable" data-edge-id="${edgeItem.id}">
            <div class="dtEditorHead">
              <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
              <span class="dtEditorLabel">click to edit</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.from)}</code></span></div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.to)}</code></span></div>
            ${rule?.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(rule.cardinality)}</span></div>` : ''}
            ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
            ${(rule?.default!=='' && rule?.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(rule.default))}</span></div>` : ''}
            ${rule?.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(rule.note)}</div>` : ''}
          </div>
        `;
      });
      
      // Join with dividers
      detailsBody.innerHTML = htmlParts.join('<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 24px 0;"></div>');
      
      // Attach click handlers to edit mappings
      detailsBody.querySelectorAll('.box.clickable').forEach(box => {
        box.addEventListener('click', () => {
          const clickedEdgeId = box.dataset.edgeId;
          
          // Find the edge to get from/to fields
          const clickedEdge = consolidated.find(e => e.id === clickedEdgeId);
          if(clickedEdge){
            // Expand both groups that contain the from/to fields
            const fromParent = findCollapsedParent(clickedEdge.from);
            const toParent = findCollapsedParent(clickedEdge.to);
            if(fromParent) toggleCollapse(fromParent, false);
            if(toParent) toggleCollapse(toParent, false);
          }
          
          state._showIndividualMapping = true;
          try{ clearEdgeEditSession({clearSelection:false}); }catch(e){}
          try{ if(typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'){ revertEditSnapshot(); } }catch(e){}
          __editSnapshot = null;
          state.selectedColumnId = null;
          state.lockedId = null;
          state.hoverId = null;
          state.selectedEdgeId = clickedEdgeId;
          state.hoverEdgeId = null;
          // Update highlights, details, and arrows
          applyHighlight(); // includes updateDetails + scheduleArrowsUpdate
        });
      });
      
      return true;
    } else if(isBidirectional){
      // Bidirectional field mappings - show both in standard format with click-to-edit
      const isHoverOnly = !state.selectedEdgeId && state.hoverEdgeId;
      detailsMeta.textContent = isHoverOnly ? 'bidirectional  hover' : 'bidirectional  2 mappings';
      
      const edges = consolidated;
      const mappings = state.data.mappings || [];
      
      // Build HTML for both mappings using standard box styling
      const htmlParts = edges.map(edgeItem => {
        // Find the rule for this edge
        let rule = null;
        for(const m of mappings){
          if(!m || typeof m!=='object') continue;
          if(m.from !== edgeItem.from) continue;
          const tos = Array.isArray(m.to) ? m.to : [m.to];
          if(tos.includes(edgeItem.to)) { rule = m; break; }
        }
        
        const tLabels = (rule?.transforms && rule.transforms.length)
          ? rule.transforms.map(formatTransformRef).join('  ')
          : '';
        
        return `
          <div class="box clickable" data-edge-id="${edgeItem.id}">
            <div class="dtEditorHead">
              <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
              <span class="dtEditorLabel">click to edit</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.from)}</code></span></div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.to)}</code></span></div>
            ${rule?.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(rule.cardinality)}</span></div>` : ''}
            ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
            ${(rule?.default!=='' && rule?.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(rule.default))}</span></div>` : ''}
            ${rule?.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(rule.note)}</div>` : ''}
          </div>
        `;
      });
      
      // Join with a visual divider
      detailsBody.innerHTML = htmlParts.join('<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 24px 0;"></div>');
      
      // Attach click handlers to edit mappings
      detailsBody.querySelectorAll('.box.clickable').forEach(box => {
        box.addEventListener('click', () => {
          const clickedEdgeId = box.dataset.edgeId;
          state._showIndividualMapping = true;
          // Manually select edge without calling renderAll()
          try{ clearEdgeEditSession({clearSelection:false}); }catch(e){}
          try{ if(typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'){ revertEditSnapshot(); } }catch(e){}
          __editSnapshot = null;
          state.selectedColumnId = null;
          state.lockedId = null;
          state.hoverId = null;
          state.selectedEdgeId = clickedEdgeId;
          state.hoverEdgeId = null;
          // Update highlights, details, and arrows
          applyHighlight(); // includes updateDetails + scheduleArrowsUpdate
        });
      });
      
      return true;
    }
  }
  
  // Edge already found at the top, continue with regular edge editing
  const mappings = state.data.mappings || [];
  let rule = null;
  for(const m of mappings){
    if(!m || typeof m!=='object') continue;
    if(m.from !== edge.from) continue;
    const tos = Array.isArray(m.to) ? m.to : (typeof m.to==='string' ? [m.to] : []);
    if(tos.includes(edge.to)) { rule = m; break; }
  }
  if(!rule) return false;

  // Start/reuse edit session; draft holds unsaved edits.
  // Only create edit session for selected edges, not hovered ones
  if(state.selectedEdgeId && (!__edgeEditSession || __edgeEditSession.edgeId !== state.selectedEdgeId)){
    // Normalize: fill defaults so draft comparison doesn't flag empty-vs-undefined as dirty
    const snap = deepClone(rule);
    if(snap.cardinality === undefined) snap.cardinality = '';
    if(snap.default === undefined) snap.default = '';
    if(snap.note === undefined) snap.note = '';
    if(!Array.isArray(snap.transforms)) snap.transforms = normalizeTransforms(snap.transforms);
    if(!snap.color) delete snap.color;
    __edgeEditSession = { edgeId: state.selectedEdgeId, from: edge.from, to: edge.to, ruleRef: snap, draft: deepClone(snap) };
  }
  
  // For hover, use the actual rule; for selected, use draft
  const draft = (state.selectedEdgeId && __edgeEditSession) ? __edgeEditSession.draft : rule;
  const isHoverOnly = !state.selectedEdgeId && state.hoverEdgeId;

  const card = (draft.cardinality||'');
  const defv = (draft.default!==undefined && draft.default!==null) ? String(draft.default) : '';
  const note = (draft.note||'');

  detailsMeta.textContent = isHoverOnly ? 'mapping (hover)' : 'mapping';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="${isHoverOnly ? 'dtEditorHead' : 'dtEditorHead'}">
        <span class="dtType mapping">Mapping</span>
        <span class="dtEditorLabel">${isHoverOnly ? 'Preview' : 'Editor'}</span>
      </div>
      <div class="kv" style="grid-template-columns: 80px 1fr;">
        <div class="k">From</div><div class="v"><code>${escapeHtml(edge.from)}</code></div>
        <div class="k">To</div><div class="v"><code>${escapeHtml(edge.to)}</code></div>
        <div class="k">Card.</div><div class="v" style="display:flex;align-items:center;gap:0;"><input class="inp" id="edCardL" value="${escapeHtml((card.split(':')[0]||'').trim())}" placeholder="1" style="width:44px;text-align:center;border-radius:8px 0 0 8px;border-right:none;" ${isHoverOnly ? 'disabled' : ''}/><span style="font-size:13px;font-weight:700;opacity:.45;padding:0 1px;user-select:none;flex-shrink:0;">:</span><input class="inp" id="edCardR" value="${escapeHtml((card.split(':')[1]||'').trim())}" placeholder="1" style="width:44px;text-align:center;border-radius:0 8px 8px 0;border-left:none;" ${isHoverOnly ? 'disabled' : ''}/><span style="font-size:10px;opacity:.3;margin-left:8px;white-space:nowrap;">source : target</span></div>
        <div class="k">Default</div><div class="v"><input class="inp" id="edDef" value="${escapeHtml(defv)}" placeholder="optional" ${isHoverOnly ? 'disabled' : ''}/></div>
        <div class="k">Transforms</div>
        <div class="v">
          <div id="edTrChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
          ${!isHoverOnly ? `<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <select class="inp" id="edTrSel" style="max-width:280px;flex:0 0 auto;">
              <option value="">Add transform</option>
            </select>
            <button class="btn" id="edTrNew" type="button">Transforms</button>
          </div>
          <div class="dtHint" style="padding:4px 0;">Edits are saved only when you click <b>Save</b>.</div>` : '<div class="dtHint" style="padding:4px 0;opacity:0.7;">Click the arrow to edit this mapping</div>'}
        </div>
        <div class="k">Note</div><div class="v"><input class="inp" id="edNote" value="${escapeHtml(note)}" placeholder="optional" ${isHoverOnly ? 'disabled' : ''}/></div>
        <div class="k">Color</div><div class="v" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
          <div id="edColorSwatches" style="display:flex;gap:3px;flex-wrap:wrap;"></div>
          <input type="color" id="edColor" value="${escapeHtml((draft||rule).color||(draft||rule)._pendingColor||'#3b82f6')}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${(draft||rule).color?'':'opacity:.3;'}" ${isHoverOnly ? 'disabled' : ''}/>
          <label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" id="edColorOn" ${(draft||rule).color?'checked':''} ${isHoverOnly ? 'disabled' : ''}/> Apply</label>
        </div>
      </div>
      ${!isHoverOnly ? `<div class="dtActions">
        <button class="btn" id="edDel" style="border-color: rgba(255,154,168,.45);">Delete</button>
        <span class="spacer"></span>
        <button class="btn" id="edCancel">Cancel</button>
        <button class="btn btnSave" id="edSave">Save</button>
      </div>` : ''}
    </div>
  `;

  const edCardL = document.getElementById('edCardL');
  const edCardR = document.getElementById('edCardR');
  const edDef  = document.getElementById('edDef');
  const edNote = document.getElementById('edNote');
  const edTrChips = document.getElementById('edTrChips');
  const edTrSel = document.getElementById('edTrSel');
  const edTrNew = document.getElementById('edTrNew');

  function syncDraftFromInputs(){
    const cl = (edCardL?.value||'').trim();
    const cr = (edCardR?.value||'').trim();
    draft.cardinality = (cl || cr) ? (cl + ':' + cr) : '';
    draft.default = edDef?.value;
    draft.note = (edNote?.value||'').trim();
    const colorOn = document.getElementById('edColorOn')?.checked;
    if(colorOn) draft.color = document.getElementById('edColor')?.value || '';
    else delete draft.color;
  }

  function rebuildEdgeTransformOptions(){
    const cat = ensureTransformCatalog();
    if(!edTrSel) return;
    edTrSel.innerHTML = '<option value="">Add transform</option>' + cat.map(t=>{
      const lbl = (t.abbr ? (t.abbr+'  ') : '') + (t.label||t.id);
      return `<option value="${escapeHtml(t.id)}">${escapeHtml(lbl)}</option>`;
    }).join('\n') + '<option value="__new__">+ New transform</option>';
  }


  function triggerEdgeDirty(){
    const _sb = document.getElementById('edSave');
    if(_sb && _sb.__dirtyUpdate) _sb.__dirtyUpdate();
  }

  function renderEdgeTransformChips(){
    if(!edTrChips) return;
    edTrChips.innerHTML = '';
    const arr = Array.isArray(draft.transforms) ? draft.transforms : [];
    if(!arr.length){
      const sp=document.createElement('span');
      sp.className='empty';
      sp.textContent='No transforms.';
      edTrChips.appendChild(sp);
      return;
    }
    let dragIdx = null;
    arr.forEach((inst, i)=>{
      const rid = transformRefId(inst);
      const td = transformById(rid) || {id:rid,label:rid,abbr:''};
      const catParams = Array.isArray(td.params) ? td.params : [];
      const instParams = (typeof inst === 'object' && inst.params) ? inst.params : {};
      const chip = document.createElement('span');
      chip.className='tagChip';
      chip.style.cursor='grab';
      chip.draggable = true;
      chip.dataset.trIdx = i;

      // Build tooltip
      let tipParts = [(td.label||td.id||rid)];
      if(td.note) tipParts.push(td.note);
      if(catParams.length){
        tipParts.push('Params: ' + catParams.map(p => `${p.label||p.id}=${instParams[p.id]!==undefined ? instParams[p.id] : (p.default||'')}`).join(', '));
      }
      tipParts.push('Drag to reorder');
      if(!isHoverOnly) tipParts.push('Click to edit params');
      chip.title = tipParts.join('\n');

      // Number badge
      const num = document.createElement('span');
      num.textContent = (i+1) + ' ';
      num.style.opacity = '.45';
      num.style.fontSize = '9px';
      chip.appendChild(num);

      const lbl = document.createElement('span');
      lbl.textContent = formatTransformAbbr(inst);
      chip.appendChild(lbl);

      // Click to edit params (if catalog defines params and not hover-only)
      if(!isHoverOnly && catParams.length > 0){
        chip.style.cursor = 'pointer';
        chip.addEventListener('click', (e)=>{
          if(e.target.closest('[data-act="rm"]')) return; // don't trigger on  click
          showTransformParamsEditor(i, inst, td, catParams);
        });
      }

      if(!isHoverOnly){
        const x=document.createElement('span');
        x.textContent=' ';
        x.dataset.act = 'rm';
        x.style.opacity='.85';
        x.style.cursor='pointer';
        x.addEventListener('click', (e)=>{
          e.stopPropagation();
          draft.transforms.splice(i, 1); // remove by index
          renderEdgeTransformChips();
          triggerEdgeDirty();
        });
        chip.appendChild(x);
      }

      // DnD
      chip.addEventListener('dragstart', (e)=>{
        dragIdx = i;
        chip.style.opacity = '0.4';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', '');
      });
      chip.addEventListener('dragend', ()=>{
        chip.style.opacity = '';
        edTrChips.querySelectorAll('.tagChip').forEach(c=>c.style.borderColor='');
        dragIdx = null;
      });
      chip.addEventListener('dragover', (e)=>{
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        edTrChips.querySelectorAll('.tagChip').forEach(c=>c.style.borderColor='');
        chip.style.borderColor = 'rgba(59,130,246,.7)';
      });
      chip.addEventListener('dragleave', ()=>{
        chip.style.borderColor = '';
      });
      chip.addEventListener('drop', (e)=>{
        e.preventDefault();
        chip.style.borderColor = '';
        if(dragIdx === null || dragIdx === i) return;
        const moved = draft.transforms.splice(dragIdx, 1)[0];
        draft.transforms.splice(i, 0, moved);
        renderEdgeTransformChips();
        triggerEdgeDirty();
      });

      edTrChips.appendChild(chip);
    });
  }

  // Inline params editor: shows below chips when a parameterized chip is clicked
  function showTransformParamsEditor(idx, inst, catDef, catParams){
    let paramsDiv = document.getElementById('edTrParamsEditor');
    if(paramsDiv) paramsDiv.remove();
    paramsDiv = document.createElement('div');
    paramsDiv.id = 'edTrParamsEditor';
    paramsDiv.style.cssText = 'margin-top:8px;padding:10px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);';
    const title = document.createElement('div');
    title.style.cssText = 'font-size:11px;font-weight:700;margin-bottom:8px;opacity:.7;';
    title.textContent = `Parameters: ${catDef.label||catDef.id}`;
    paramsDiv.appendChild(title);

    const instParams = (typeof inst === 'object' && inst.params) ? { ...inst.params } : {};

    catParams.forEach(p => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;gap:8px;margin-bottom:6px;';
      const label = document.createElement('label');
      label.style.cssText = 'font-size:12px;min-width:80px;';
      label.textContent = p.label || p.id;
      row.appendChild(label);

      const input = document.createElement('input');
      input.className = 'inp';
      input.type = p.type === 'number' ? 'number' : 'text';
      input.value = instParams[p.id] !== undefined ? instParams[p.id] : (p.default || '');
      input.placeholder = p.default !== undefined ? String(p.default) : '';
      input.style.cssText = 'flex:1;';
      input.dataset.paramId = p.id;
      row.appendChild(input);
      paramsDiv.appendChild(row);
    });

    const btnRow = document.createElement('div');
    btnRow.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;margin-top:8px;';
    const applyBtn = document.createElement('button');
    applyBtn.className = 'btn';
    applyBtn.textContent = 'Apply';
    applyBtn.addEventListener('click', ()=>{
      if(!inst.params) inst.params = {};
      paramsDiv.querySelectorAll('input[data-param-id]').forEach(inp => {
        const pid = inp.dataset.paramId;
        const pDef = catParams.find(cp => cp.id === pid);
        const val = inp.value.trim();
        if(pDef && pDef.type === 'number' && val !== ''){
          inst.params[pid] = Number(val);
        } else if(val !== ''){
          inst.params[pid] = val;
        } else {
          delete inst.params[pid];
        }
      });
      paramsDiv.remove();
      renderEdgeTransformChips();
      triggerEdgeDirty();
    });
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.addEventListener('click', ()=> {
      paramsDiv.remove();
      triggerEdgeDirty();
    });
    btnRow.appendChild(cancelBtn);
    btnRow.appendChild(applyBtn);
    paramsDiv.appendChild(btnRow);

    edTrChips.parentElement.insertBefore(paramsDiv, edTrChips.nextSibling);
  }

  // Only set up interactive elements when actually selected (not just hovering)
  if(!isHoverOnly){
    [edCardL, edCardR, edDef, edNote].forEach(el=>{
      el?.addEventListener('change', syncDraftFromInputs);
      el?.addEventListener('blur', syncDraftFromInputs);
    });

    edTrSel?.addEventListener('change', ()=>{
      const v = (edTrSel.value||'').trim();
      if(!v) return;
      if(v==='__new__'){
        edTrSel.value='';
        openTransformCreateModal({afterCreate: (createdId)=>{
          rebuildEdgeTransformOptions();
          if(createdId){
            draft.transforms = Array.isArray(draft.transforms) ? draft.transforms : [];
            const td = transformById(createdId);
            const inst = { ref: createdId };
            // Initialize params from catalog defaults
            if(td && Array.isArray(td.params) && td.params.length){
              inst.params = {};
              td.params.forEach(p => { if(p.default !== undefined) inst.params[p.id] = p.default; });
            }
            draft.transforms.push(inst);
          }
          renderEdgeTransformChips();
          triggerEdgeDirty();
        }});
        return;
      }
      draft.transforms = Array.isArray(draft.transforms) ? draft.transforms : [];
      const td = transformById(v);
      const inst = { ref: v };
      // Initialize params from catalog defaults
      if(td && Array.isArray(td.params) && td.params.length){
        inst.params = {};
        td.params.forEach(p => { if(p.default !== undefined) inst.params[p.id] = p.default; });
      }
      draft.transforms.push(inst); // allow duplicates
      edTrSel.value='';
      renderEdgeTransformChips();
    });

    edTrNew?.addEventListener('click', async ()=>{
      openTransforms();
    });

    rebuildEdgeTransformOptions();
    renderEdgeTransformChips();

    // Edge color checkbox toggle
    {
      const edColorOn = document.getElementById('edColorOn');
      const edColor = document.getElementById('edColor');
      if(edColorOn && edColor){
        // Build preset swatches
        if(!isHoverOnly) buildColorSwatches(document.getElementById('edColorSwatches'), edColor);
        edColorOn.addEventListener('change', ()=>{
          edColor.style.opacity = edColorOn.checked ? '1' : '.3';
          syncDraftFromInputs();
        });
        edColor.addEventListener('input', syncDraftFromInputs);
        edColor.addEventListener('change', syncDraftFromInputs);
      }
    }

    const saveBtn = document.getElementById('edSave');
    const cancelBtn = document.getElementById('edCancel');
    const delBtn = document.getElementById('edDel');

  if(saveBtn) saveBtn.addEventListener('click', async ()=>{
    syncDraftFromInputs();
    recordChange(); // Save BEFORE modifying
    rule.cardinality = (draft.cardinality||'').trim();
    rule.default = (draft.default!==undefined && draft.default!==null) ? draft.default : '';
    rule.note = (draft.note||'').trim();
    rule.transforms = Array.isArray(draft.transforms) ? draft.transforms.map(t => typeof t === 'object' ? {...t, params: t.params ? {...t.params} : undefined} : t) : [];
    // Save color  always remember the picker value
    const __saveColorOn = document.getElementById('edColorOn')?.checked;
    const __savePickerVal = document.getElementById('edColor')?.value || '';
    if(__saveColorOn){
      rule.color = __savePickerVal;
      delete rule._pendingColor;
    } else {
      delete rule.color;
      if(__savePickerVal && __savePickerVal !== '#3b82f6') rule._pendingColor = __savePickerVal;
      else delete rule._pendingColor;
    }
    if('transform' in rule) delete rule.transform;

    const stayEdgeId = state.selectedEdgeId;
    clearEdgeEditSession({clearSelection:false});
    state.selectedEdgeId = stayEdgeId; // stay on edge
    state._showIndividualMapping = true; // keep showing individual editor (not consolidated picker)
    state.hoverEdgeId = null;
    renderAll(); // includes applyHighlight + scheduleArrowsUpdate
    setGlobalStatus('Mapping saved.');
  });

  if(cancelBtn) cancelBtn.addEventListener('click', async ()=>{
    const stayEdgeId = state.selectedEdgeId;
    clearEdgeEditSession({clearSelection:false});
    state.selectedEdgeId = stayEdgeId; // stay on edge
    state._showIndividualMapping = true; // keep showing individual editor (not consolidated picker)
    state.hoverEdgeId = null;
    renderAll(); // includes applyHighlight + scheduleArrowsUpdate
    setGlobalStatus('Mapping edit cancelled.');
  });

  if(delBtn) delBtn.addEventListener('click', async ()=>{
    const fromLabel = IDX.nodeById.get(edge.from)?.label || edge.from;
    const toLabel = IDX.nodeById.get(edge.to)?.label || edge.to;
    if(!await customConfirm(`Delete mapping "${fromLabel}  ${toLabel}"?`)) return;
    recordChange(); // Save BEFORE delete
    const tos = Array.isArray(rule.to) ? rule.to.slice() : (typeof rule.to==='string' ? [rule.to] : []);
    const kept = tos.filter(t=>t!==edge.to);
    if(kept.length===0){
      const idx = mappings.indexOf(rule);
      if(idx>=0) mappings.splice(idx,1);
    } else {
      rule.to = kept.length===1 ? kept[0] : kept;
    }
    clearEdgeEditSession({clearSelection:true});
    renderAll(); // includes applyHighlight + scheduleArrowsUpdate
    setGlobalStatus('Mapping deleted.');
  });
  wireDirtyHighlight(detailsBody, saveBtn, ()=>{
    if(!__edgeEditSession || !__edgeEditSession.ruleRef || !__edgeEditSession.draft) return false;
    // Sync DOM values into draft before comparing
    const _cl = (edCardL?.value||'').trim();
    const _cr = (edCardR?.value||'').trim();
    __edgeEditSession.draft.cardinality = (_cl || _cr) ? (_cl + ':' + _cr) : '';
    __edgeEditSession.draft.default = edDef?.value;
    __edgeEditSession.draft.note = (edNote?.value||'').trim();
    const __edColorOn = document.getElementById('edColorOn')?.checked;
    if(__edColorOn) __edgeEditSession.draft.color = document.getElementById('edColor')?.value || '';
    else delete __edgeEditSession.draft.color;
    if(JSON.stringify(__edgeEditSession.ruleRef) !== JSON.stringify(__edgeEditSession.draft)) return true;
    // Detect picker change OR checkbox toggle independently of Apply state
    const origColor = __edgeEditSession.ruleRef.color || '';
    const origPickerVal = origColor || __edgeEditSession.ruleRef._pendingColor || '#3b82f6';
    const curPickerVal = document.getElementById('edColor')?.value || '#3b82f6';
    if(__edColorOn !== !!origColor) return true;       // checkbox toggled
    if(curPickerVal !== origPickerVal) return true;     // picker value changed
    return false;
  });
  } // end if(!isHoverOnly)
  
  // For hover, still show transform chips (read-only)
  if(isHoverOnly){
    renderEdgeTransformChips();
  }

  // Clear the force individual flag at the END after showing the editor
  if(state._showIndividualMapping){
    delete state._showIndividualMapping;
  }

  return true;
}


const __renderColumns_base = renderColumns;
renderColumns = function(){
  __renderColumns_base();
  /* attachSvgEdgeInteractions disabled */
  if(state.editorMode){
    
    addRowActions();
    attachColumnHeaderActions();
  }
};

const __updateDetails_base = updateDetails;
updateDetails = function(nodeId, selectedFieldsSet){
  // Edge editor only for selected (locked) edges, not hover
  if(state.selectedEdgeId && renderSelectedEdgeEditor()) return;
  if(renderSelectedColumnEditor()) return;
  if(renderSelectedColumnViewer()) return;
  if(renderSelectedNodeEditor(nodeId)) return;
  // If column is selected but we got here, don't show root node  skip
  if(state.selectedColumnId && state.lockedId === state.selectedColumnId && nodeId === state.selectedColumnId) return;
  __updateDetails_base(nodeId, selectedFieldsSet);
};

columnsScroller.addEventListener('scroll', ()=>{ if(state.editorMode){/* no-op while editing */} }, {passive:true});
window.addEventListener('resize', ()=>{ if(state.editorMode){/* no-op while editing */} }, {passive:true});

if(editorModeToggle) editorModeToggle.addEventListener('change', async ()=>{
  const wantOn = editorModeToggle.checked;
  // Guard: if turning off editor mode with unsaved changes, prompt
  if(!wantOn){
    if(nodeEditIsDirty()){
      if(!await guardNodeAbandon()){
        editorModeToggle.checked = true; // revert checkbox
        return;
      }
      revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
    }
    if(edgeEditIsDirty()){
      if(!await guardAbandonEdit('mapping', __edgeEditSession?.edgeId || '')){
        editorModeToggle.checked = true;
        return;
      }
    }
  }
  setEditorMode(wantOn);
});

/* =========================
   Rendering pipeline
========================= */
function refreshViewer(){
  if(!state.data) return;
  applyVisibility();
  applyHighlight();
  refreshEdgeColorScheme();
  scheduleArrowsUpdate();
}



function renderSelectedEdgeViewer(edgeId){
  if(!edgeId) return false;
  
  // Find the edge object first - check real edges, then virtual edges
  let edge = IDX.edges.find(e => e.id === edgeId);
  let isVirtual = false;
  if(!edge && edgeId.startsWith('virtual:')){
    const virtualEdges = findChainsThoughHiddenColumns();
    edge = virtualEdges.find(x => x.id === edgeId);
    isVirtual = true;
  }
  if(!edge) return false;
  
  // Virtual/indirect edge: show chain info in details panel
  if(isVirtual && edge.chain){
    const selected = (state.selectedEdgeId === edgeId);
    detailsMeta.textContent = selected ? 'indirect link  selected' : 'indirect link  hover';
    
    // Gather hidden column names
    const hiddenCols = [];
    for(const chainEdge of edge.chain){
      const fromCol = columnOf(chainEdge.from);
      const toCol = columnOf(chainEdge.to);
      if(fromCol && state.hiddenColumns.has(fromCol)){
        const ci = IDX.columnIndex.get(fromCol);
        const col = (ci !== undefined) ? IDX.columns[ci] : null;
        const name = col ? (col.label || col.id) : fromCol;
        if(!hiddenCols.includes(name)) hiddenCols.push(name);
      }
      if(toCol && state.hiddenColumns.has(toCol)){
        const ci = IDX.columnIndex.get(toCol);
        const col = (ci !== undefined) ? IDX.columns[ci] : null;
        const name = col ? (col.label || col.id) : toCol;
        if(!hiddenCols.includes(name)) hiddenCols.push(name);
      }
    }
    
    function colLabel(colId){
      const i = IDX.columnIndex.get(colId);
      return (i!==undefined && IDX.columns[i]) ? (IDX.columns[i].label||colId) : colId;
    }
    
    // Build chain steps display
    const chainSteps = edge.chain.map(ce => {
      const fromNode = IDX.nodeById.get(ce.from);
      const toNode = IDX.nodeById.get(ce.to);
      const fromLabel = fromNode ? (fromNode.label || ce.from) : ce.from;
      const toLabel = toNode ? (toNode.label || ce.to) : ce.to;
      const fromCol = columnOf(ce.from) || '';
      const toCol = columnOf(ce.to) || '';
      const fromHidden = state.hiddenColumns.has(fromCol);
      const toHidden = state.hiddenColumns.has(toCol);
      return `<div style="display:flex;align-items:center;gap:6px;padding:4px 0;">
        <code style="opacity:${fromHidden ? '0.5' : '1'}">${escapeHtml(fromLabel)}</code>
        <span style="color:var(--muted);"></span>
        <code style="opacity:${toHidden ? '0.5' : '1'}">${escapeHtml(toLabel)}</code>
        ${fromHidden||toHidden ? '<span class="pill" style="font-size:10px;opacity:.7;">hidden</span>' : ''}
      </div>`;
    }).join('');
    
    detailsBody.innerHTML = `
      <div class="box" style="border-color: rgba(59,130,246,.35);">
        <div class="dtEditorHead">
          <span class="dtType" style="font-size:8px;padding:2px 6px;">Indirect link</span>
          <span class="dtEditorLabel">${edge.chain.length} steps</span>
        </div>
        <div class="dtHint" style="padding:2px 0 8px;">Passes through ${hiddenCols.length} hidden column${hiddenCols.length>1?'s':''}: <b style="color:var(--text);opacity:1;">${escapeHtml(hiddenCols.join(', '))}</b></div>
        <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edge.from)}</code></span></div>
        <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edge.to)}</code></span></div>
        <div style="margin-top:10px;padding-top:8px;border-top:1px solid var(--border);">
          <div style="font-size:11px;color:var(--muted);margin-bottom:4px;text-transform:uppercase;letter-spacing:.4px;font-weight:700;">Full chain</div>
          ${chainSteps}
        </div>
      </div>
      <button class="btn" id="revealChainBtn" style="margin-top:10px;width:100%;">Reveal hidden columns & select first edge</button>
    `;
    
    // Wire up reveal button
    const revealBtn = document.getElementById('revealChainBtn');
    if(revealBtn){
      revealBtn.addEventListener('click', ()=>{
        // Unhide all columns in the chain
        for(const chainEdge of edge.chain){
          const fromCol = columnOf(chainEdge.from);
          const toCol = columnOf(chainEdge.to);
          if(fromCol && state.hiddenColumns.has(fromCol)) state.hiddenColumns.delete(fromCol);
          if(toCol && state.hiddenColumns.has(toCol)) state.hiddenColumns.delete(toCol);
        }
        renderAll();
        applyHighlight();
        scheduleArrowsUpdate();
        if(edge.chain.length > 0){
          setTimeout(() => selectEdge(edge.chain[0].id), 100);
        }
      });
    }
    
    return true;
  }
  
  // Check the SVG path element for consolidated metadata (set during drawing)
  const pathEl = Array.from(edgesLayer.querySelectorAll('path.edge')).find(p => p.dataset.edgeId === edgeId);
  
  
  // Use path metadata if available (handles collapsed groups), otherwise use edge metadata
  const consolidated = pathEl?.__consolidated || edge.__consolidated;
  const isBidirectional = pathEl?.__isBidirectional || edge.__isBidirectional;
  const fromId = pathEl?.__fromId || edge.__fromId || edge.from;
  const toId = pathEl?.__toId || edge.__toId || edge.to;
  
  
  // Check if this edge IS the representative of a consolidated arrow
  const isRepresentative = consolidated && consolidated.length > 1 && consolidated[0].id === edgeId;
  
  
  // Check if user explicitly wants to view individual mapping (clicked VIEW button)
  const forceIndividual = state._showIndividualMapping;
  
  
  if(isRepresentative && !forceIndividual){
    // Check if this is collapsed groups or bidirectional fields
    const isCollapsedGroups = fromId !== edge.from || toId !== edge.to;
    
    if(isCollapsedGroups){
      // Collapsed groups - show all consolidated mappings
      detailsMeta.textContent = `consolidated  ${consolidated.length} mappings`;
      
      const edges = consolidated;
      
      // Helper functions
      function colLabel(colId){
        const i = IDX.columnIndex.get(colId);
        return (i!==undefined && IDX.columns[i]) ? (IDX.columns[i].label||colId) : colId;
      }
      function miniFieldBox(fieldId, title){
        const node = IDX.nodeById.get(fieldId);
        if(!node) return '';
        const colId = columnOf(fieldId)||'';
        const inout = (IDX.edgesByField.get(fieldId)||[]);
        let inbound=0,outbound=0; inout.forEach(e=>{ if(e.to===fieldId) inbound++; if(e.from===fieldId) outbound++; });
        const label = node.label||fieldId;
        return `
          <div class="box clickable" data-jump-id="${escapeHtml(fieldId)}" style="cursor:pointer;">
            <div class="dtHero" style="padding-bottom:6px;">
              <div class="dtName" style="font-size:14px;">${escapeHtml(label)}</div>
              <span class="dtType" style="font-size:8px;padding:2px 6px;">${escapeHtml(title)}</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;">
              <span class="dtRowK" style="min-width:28px;">ID</span>
              <span class="dtRowV"><span class="dtId">${escapeHtml(fieldId)}${isLikelyAutoId(node) ? '<span class="autoTag" style="font-size:7px;padding:0 3px;">auto</span>' : ''}</span></span>
            </div>
            <div class="dtStatRow" style="padding:3px 0;">
              <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${inbound}</span><span class="dtStatL">in</span></span>
              <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${outbound}</span><span class="dtStatL">out</span></span>
            </div>
          </div>`;
      }
      
      // Build HTML for all mappings
      const htmlParts = edges.map(edgeItem => {
        const tLabels = (edgeItem.transforms && edgeItem.transforms.length)
          ? edgeItem.transforms.map(formatTransformRef).join('  ')
          : '';
        const srcBox = miniFieldBox(edgeItem.from, 'Source field');
        const tgtBox = miniFieldBox(edgeItem.to, 'Target field');
        
        return `
          <div class="box clickable" data-mapping-from="${escapeHtml(edgeItem.from)}" data-mapping-to="${escapeHtml(edgeItem.to)}">
            <div class="dtEditorHead">
              <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
              <span class="dtEditorLabel">click to expand</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.from)}</code></span></div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.to)}</code></span></div>
            ${edgeItem.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(edgeItem.cardinality)}</span></div>` : ''}
            ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
            ${(edgeItem.default!=='' && edgeItem.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(edgeItem.default))}</span></div>` : ''}
            ${edgeItem.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(edgeItem.note)}</div>` : ''}
          </div>
          ${srcBox}
          ${tgtBox}
        `;
      });
      
      // Join with dividers
      detailsBody.innerHTML = htmlParts.join('<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 24px 0;"></div>');
      
      // Attach click handlers for mapping boxes
      detailsBody.querySelectorAll('.box.clickable[data-mapping-from]').forEach(box => {
        box.addEventListener('click', () => {
          const fromId = box.getAttribute('data-mapping-from');
          const toId = box.getAttribute('data-mapping-to');
          
          // Find the edge ID for this mapping
          const mappingEdge = edges.find(e => e.from === fromId && e.to === toId);
          
          if(mappingEdge){
            // Expand both groups
            const fromParent = findCollapsedParent(fromId);
            const toParent = findCollapsedParent(toId);
            if(fromParent) toggleCollapse(fromParent, false);
            if(toParent) toggleCollapse(toParent, false);
            
            // Manually set selection
            state.lockedId = null;
            state.hoverId = null;
            state.selectedEdgeId = mappingEdge.id;
            state.hoverEdgeId = null;
            
            // Update highlights and redraw arrows
            applyHighlight();
            scheduleArrowsUpdate();
            // Use setTimeout to wait for arrows to redraw before updating details
            setTimeout(() => updateDetails(null, null), 50);
          }
        });
      });
      
      // Attach click handlers for field boxes
      detailsBody.querySelectorAll('[data-jump-id]').forEach(el=>{
        el.addEventListener('click', async ()=>{
          const id = el.getAttribute('data-jump-id');
          if(id){ 
            // Find which mapping this field belongs to and expand the other end too
            for(const edgeItem of edges){
              if(edgeItem.from === id || edgeItem.to === id){
                // Expand both ends of this mapping
                const fromParent = findCollapsedParent(edgeItem.from);
                const toParent = findCollapsedParent(edgeItem.to);
                if(fromParent) toggleCollapse(fromParent, false);
                if(toParent) toggleCollapse(toParent, false);
                break;
              }
            }
            lockSelection(id); 
            scrollIntoView(id); 
          }
        });
      });
      
      return true;
    } else if(isBidirectional){
      // Bidirectional field mappings - show both in standard format
      const selected = (state.selectedEdgeId === edgeId);
      detailsMeta.textContent = selected ? 'bidirectional  2 mappings' : 'bidirectional  hover';
      
      const edges = consolidated;
      
      // Helper functions (from regular edge viewer)
      function colLabel(colId){
        const i = IDX.columnIndex.get(colId);
        return (i!==undefined && IDX.columns[i]) ? (IDX.columns[i].label||colId) : colId;
      }
      function miniFieldBox(fieldId, title){
        const node = IDX.nodeById.get(fieldId);
        if(!node) return '';
        const colId = columnOf(fieldId)||'';
        const inout = (IDX.edgesByField.get(fieldId)||[]);
        let inbound=0,outbound=0; inout.forEach(e=>{ if(e.to===fieldId) inbound++; if(e.from===fieldId) outbound++; });
        const label = node.label||fieldId;
        return `
          <div class="box clickable" data-jump-id="${escapeHtml(fieldId)}" style="cursor:pointer;">
            <div class="dtHero" style="padding-bottom:6px;">
              <div class="dtName" style="font-size:14px;">${escapeHtml(label)}</div>
              <span class="dtType" style="font-size:8px;padding:2px 6px;">${escapeHtml(title)}</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;">
              <span class="dtRowK" style="min-width:28px;">ID</span>
              <span class="dtRowV"><span class="dtId">${escapeHtml(fieldId)}${isLikelyAutoId(node) ? '<span class="autoTag" style="font-size:7px;padding:0 3px;">auto</span>' : ''}</span></span>
            </div>
            <div class="dtStatRow" style="padding:3px 0;">
              <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${inbound}</span><span class="dtStatL">in</span></span>
              <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${outbound}</span><span class="dtStatL">out</span></span>
            </div>
          </div>`;
      }
      
      // Build HTML for both mappings
      const htmlParts = edges.map(edgeItem => {
        const tLabels = (edgeItem.transforms && edgeItem.transforms.length)
          ? edgeItem.transforms.map(formatTransformRef).join('  ')
          : '';
        const srcBox = miniFieldBox(edgeItem.from, 'Source field');
        const tgtBox = miniFieldBox(edgeItem.to, 'Target field');
        
        return `
          <div class="box">
            <div class="dtEditorHead">
              <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
              <span class="dtEditorLabel">View</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.from)}</code></span></div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.to)}</code></span></div>
            ${edgeItem.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(edgeItem.cardinality)}</span></div>` : ''}
            ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
            ${(edgeItem.default!=='' && edgeItem.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(edgeItem.default))}</span></div>` : ''}
            ${edgeItem.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(edgeItem.note)}</div>` : ''}
          </div>
          ${srcBox}
          ${tgtBox}
        `;
      });
      
      // Join with a visual divider
      detailsBody.innerHTML = htmlParts.join('<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 24px 0;"></div>');
      
      // Attach click handlers for field boxes
      detailsBody.querySelectorAll('[data-jump-id]').forEach(el=>{
        el.addEventListener('click', async ()=>{
          const id = el.getAttribute('data-jump-id');
          if(id){ lockSelection(id); scrollIntoView(id); }
        });
      });
      
      return true;
    }
  }
  
  // Edge already found at the top, no need to lookup again
  const selected = (state.selectedEdgeId===edgeId);
  detailsMeta.textContent = selected ? 'mapping  selected' : 'mapping  hover';
  const tLabels = (edge.transforms && edge.transforms.length)
    ? edge.transforms.map(formatTransformRef).join('  ')
    : '';
  
  // Clear the force individual flag after showing the details
  if(state._showIndividualMapping){
    delete state._showIndividualMapping;
  }
  function colLabel(colId){
    const i = IDX.columnIndex.get(colId);
    return (i!==undefined && IDX.columns[i]) ? (IDX.columns[i].label||colId) : colId;
  }
  function renderAttrChips(node){
    if(!node || !node.customAttributes) return '';
    const keys = Object.keys(node.customAttributes||{});
    if(!keys.length) return '';
    return keys.sort().map(aid=>{
      const raw = node.customAttributes[aid];
      const a = customAttrById(aid)||{id:aid,label:aid};
      const vals = Array.isArray(raw) ? raw : [raw];
      const valueTags = vals.map(vid=>{
        const v = customValueById(aid, vid)||{id:vid,label:vid};
        return `<span class="dtAttrVal">${escapeHtml(v.label||v.id)}</span>`;
      }).join('');
      return `<div class="dtAttrGroup"><span class="dtAttrLabel">${escapeHtml(a.label||a.id)}</span>${valueTags}</div>`;
    }).join('');
  }
  function renderTagChips(node){
    if(!node) return '';
    const ids = sortTagIdsByPriority(normalizeNodeTags(node));
    if(!ids.length) return '';
    const chips = ids.slice(0,5).map(tid=>{
      const td = tagById(tid)||{id:tid,label:tid,abbr:tid.slice(0,1).toUpperCase(),color:'#3b82f6'};
      return `<span class="tagChip" data-color="1" style="--c:${tagColor(td)};">${escapeHtml(tagAbbr(td)||td.id)}</span>`;
    }).join(' ');
    return chips;
  }
  function miniFieldBox(fieldId, title){
    const node = IDX.nodeById.get(fieldId);
    if(!node) return '';
    const colId = columnOf(fieldId)||'';
    const inout = (IDX.edgesByField.get(fieldId)||[]);
    let inbound=0,outbound=0; inout.forEach(e=>{ if(e.to===fieldId) inbound++; if(e.from===fieldId) outbound++; });
    const label = node.label||fieldId;
    const note = (node.note||'').trim();
    const tags = renderTagChips(node);
    const attrs = renderAttrChips(node);
    return `
      <div class="box clickable" data-jump-id="${escapeHtml(fieldId)}" style="cursor:pointer;">
        <div class="dtHero" style="padding-bottom:6px;">
          <div class="dtName" style="font-size:14px;">${escapeHtml(label)}</div>
          <span class="dtType" style="font-size:8px;padding:2px 6px;">${escapeHtml(title)}</span>
        </div>
        <div class="dtRow" style="padding:3px 2px;">
          <span class="dtRowK" style="min-width:28px;">ID</span>
          <span class="dtRowV"><span class="dtId">${escapeHtml(fieldId)}${isLikelyAutoId(node) ? '<span class="autoTag" style="font-size:7px;padding:0 3px;">auto</span>' : ''}</span></span>
        </div>
        <div class="dtRow" style="padding:3px 2px;">
          <span class="dtRowK" style="min-width:28px;">Col</span>
          <span class="dtRowV">${escapeHtml(colLabel(colId))}${colLabel(colId) !== colId ? ` <span style="font-family:var(--mono);font-size:10px;opacity:.35;">  ${escapeHtml(colId)}</span>` : ''}</span>
        </div>
        <div class="dtStatRow" style="padding:3px 0;">
          <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${inbound}</span><span class="dtStatL">in</span></span>
          <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${outbound}</span><span class="dtStatL">out</span></span>
        </div>
        ${note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(note)}</div>` : ''}
        ${attrs ? `<div style="padding:1px 0;">${attrs}</div>` : ''}
        ${tags ? `<div class="dtChipWrap" style="padding:2px 0;">${tags}</div>` : ''}
      </div>`;
  }
  const srcBox = miniFieldBox(edge.from, 'Source field');
  const tgtBox = miniFieldBox(edge.to, 'Target field');
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtHero" style="padding-bottom:6px;">
        <div style="font-size:10px;opacity:.35;">View</div>
        <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
      </div>
      <div class="dtRow" style="padding:3px 2px;">
        <span class="dtRowK">From</span>
        <span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edge.from)}</code></span>
      </div>
      <div class="dtRow" style="padding:3px 2px;">
        <span class="dtRowK">To</span>
        <span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edge.to)}</code></span>
      </div>
      ${edge.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(edge.cardinality)}</span></div>` : ''}
      ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
      ${(edge.default!=='' && edge.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(edge.default))}</span></div>` : ''}
      ${edge.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(edge.note)}</div>` : ''}
      ${edge.color ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Color</span><span class="dtRowV"><span class="dtColorSwatch" style="background:${escapeHtml(edge.color)};"></span> <span style="font-family:var(--mono);font-size:11px;opacity:.55;">${escapeHtml(edge.color)}</span></span></div>` : ''}
    </div>
    ${srcBox}
    ${tgtBox}
  `;
  // clicking a field box jumps to that node
  detailsBody.querySelectorAll('[data-jump-id]').forEach(el=>{
    el.addEventListener('click', async ()=>{
      const id = el.getAttribute('data-jump-id');
      if(id){ lockSelection(id); scrollIntoView(id); }
    });
  });
  return true;
}

function renderAll(){
  // Save collapse state before rebuild
  const collapsedIds = new Set();
  if(IDX && IDX.elementById){
    for(const [id, el] of IDX.elementById.entries()){
      if(el.classList.contains('group') && el.classList.contains('collapsed')){
        collapsedIds.add(id);
      }
    }
  }

  // rebuild indexes + render columns
  buildIndexes(state.data);
  // Mark bidirectional/consolidated edges
  markConsolidatedEdges();
  // keep mapping target dropdowns in sync with latest schema
  rebuildFieldDatalist();
  renderColumns();

  // Restore collapse state
  for(const id of collapsedIds){
    const el = IDX.elementById.get(id);
    if(el && el.classList.contains('group')){
      el.classList.add('collapsed');
      const children = el.querySelector(':scope > .children');
      if(children) children.style.display = 'none';
    }
  }

  applyVisibility();
  applyHighlight();

  // Restore highlight colors from project data
  if(typeof restoreHlColors === 'function') restoreHlColors();

  // Refresh edge color scheme (must run after buildIndexes so edges exist)
  refreshEdgeColorScheme();
  rebuildEdgeSchemeOptions();
  
  // Sync project title
  const titleInput = document.getElementById('projectTitle');
  if(titleInput && state.data) {
    titleInput.value = state.data.title || 'New Project';
  }

  // quick meta in status
  setViewerStatus(`Loaded: ${IDX.columns.length} columns  ${IDX.fieldIds.size} fields  ${IDX.edges.length} mappings`);

  // Refresh filter chips (catalogs may have changed)
  renderActiveFilterChips();
}

/* =========================
   Docs content
========================= */
function buildDocs(){
  const docs = `
<div style="text-align:center;padding:18px 0 20px;margin-bottom:16px;border-bottom:1px solid var(--border);">
<div style="font-size:20px;font-weight:800;letter-spacing:1.2px;text-transform:uppercase;">Dunnode</div>
<div style="font-size:12px;font-weight:600;opacity:.5;letter-spacing:.4px;margin-top:2px;">Done. Now.</div>
<div style="font-size:11.5px;opacity:.45;margin-top:6px;">A lightweight mapping studio for complex flows.</div>
</div>
<h2>Overview</h2>
<p>Dunnode is a single-file, zero-dependency tool for visualizing, editing, and documenting field-level data mappings across multiple systems. It runs entirely in the browser &mdash; nothing is uploaded or stored on a server.</p>
<p>Key capabilities: multi-column schema trees, bezier arrow visualization, inline editing with drag-and-drop, tag/transform/attribute catalogs, undo/redo, project save/load, CSV and HTML export.</p>

<h2>Getting started</h2>
<ol>
  <li>Open the HTML file in any modern browser.</li>
  <li>Click <b>Load example</b> to explore the sample project, or <b>New mapping</b> to start from scratch.</li>
  <li>To load your own data, click <b>Open project</b> and select a <code>.json</code> file.</li>
  <li>Use <b>Save project</b> to download your work as JSON (the file includes all columns, mappings, catalogs, and metadata).</li>
</ol>

<h2>Viewer</h2>
<p>The viewer displays each system as a column of collapsible tree nodes. Mappings appear as highlighted connections between fields.</p>
<ul>
  <li><b>Hover</b> a field or group to preview all connected mappings across the entire chain.</li>
  <li><b>Click</b> a field or group to lock the selection &mdash; you can then scroll and inspect distant matches.</li>
  <li><b>Ctrl/Cmd+click</b> to add or remove nodes from a multi-selection. Works across columns. The details panel shows a combined summary with bulk action buttons in editor mode.</li>
  <li><b>Shift+click</b> to select a range of visible nodes within the same column (from last clicked to current click).</li>
  <li><b>Alt+click</b> for chain select: if the clicked node is connected to the current selection, adds it plus the path between them; otherwise adds its full chain. <b>Alt+Shift</b>=upstream only, <b>Alt+Ctrl/Cmd</b>=downstream only.</li>
  <li><b>Drag on empty space</b> to draw a selection rectangle &mdash; all intersecting nodes are selected. Hold <b>Alt</b> while dragging for a freeform lasso shape. Hold Shift to add to existing selection, Ctrl/Cmd to subtract.</li>
  <li><b>Click an arrow</b> to select a specific mapping and view/edit its properties.</li>
  <li><b>Esc</b> (or the <b></b> toolbar button) clears selection and search.</li>
  <li><b>Collapse/expand groups</b> by clicking the &#9656;/&#9662; toggle on any group node.</li>
</ul>

<h3>Search &amp; filter</h3>
<ul>
  <li><b>Search</b> ( toolbar) filters nodes across all columns matching label or id text. Matching groups auto-expand. Search is always ANDed with active filters.</li>
  <li><b>Only mapped</b> hides fields that have no inbound or outbound mappings.</li>
  <li><b>Columns&hellip;</b> lets you show, hide, and drag-reorder columns. In editor mode, also includes <b>+ Add left</b> / <b>+ Add right</b> buttons to create new columns.</li>
</ul>

<h3>Filters</h3>
<p>Rule-based filters apply visual highlights to matching nodes. Open the <b>Filters</b> catalog from the  toolbar group to create and manage filters.</p>
<ul>
  <li><b>Conditions</b>: each filter has one or more conditions (e.g. "tag has Active", "label contains mission", "has outbound mapping"). Conditions can be combined with AND/OR.</li>
  <li><b>Groups</b>: nest conditions inside <code>( )</code> groups for complex logic like "(tag=Active AND has mapping) OR (label contains legacy)".</li>
  <li><b>Priority</b>: filters are evaluated in priority order. Higher-priority filter styles override lower ones. Drag-reorder or use / buttons in the catalog.</li>
  <li><b>Highlight styles</b>: each filter can set background tint, left border stripe, arrow color, frame outline, bold text, and an emoji prefix. Each channel has an enable/disable checkbox.</li>
  <li><b>Color palette</b> (): click the palette button in the filter editor to reveal preset swatches. Click a swatch to apply it to all enabled channels; drag it onto a specific color picker to set just that one.</li>
  <li><b>Activation</b>: toggle individual filters with the checkbox in the catalog. Active filters appear as chips in the filter bar.</li>
</ul>

<h3>Display modes</h3>
<p>The display mode selector in the filter bar has three options:</p>
<ul>
  <li><b>Hide</b> (default): non-matching nodes are hidden entirely.</li>
  <li><b>Dim</b>: non-matching nodes stay visible but dimmed (reduced opacity).</li>
  <li><b>Highlight</b>: all nodes remain visible at full opacity. Only the highlight styles (background, border, bold, etc.) are applied to matches.</li>
</ul>
<p>The <b>AND / OR</b> selector controls whether nodes must match ALL active filters (AND) or ANY (OR). Note: search text is always ANDed with filter results regardless of this setting.</p>

<h3>Arrows &amp; highlighting</h3>
<p>By default, arrows draw only for the current selection. The highlight follows the <b>entire chain</b> of connected mappings, not just immediate neighbors.</p>
<ul>
  <li><b>Arrow mode</b> (Graph menu): a 3-way selector  <b>Selected</b> shows arrows only for hovered/selected nodes (default), <b>All</b> draws every arrow at once (best for small graphs), <b>Off</b> hides all arrows.</li>
  <li><b>Arrow scope</b> (Graph menu): two independent toggles control which arrow types are drawn. <b>Same-column</b> controls arrows between nodes within the same column. <b>Distant</b> controls arrows that cross non-adjacent columns. Adjacent-column arrows are always shown when arrows are on. Uncheck either to reduce clutter.</li>
  <li><b>Color mappings by</b> (Graph menu): automatic arrow coloring by a shared property  cardinality, first transform, source/target tag, or source/target custom attribute. A legend appears in the Graph popover. Hover any scheme button to preview its legend without switching.</li>
  <li><b>Color priority (mappings)</b>: Selection/hover highlight  Filter color  Color-by scheme  Per-mapping manual color  default. The scheme overrides individual mapping colors, so "Color mappings by" gives a consistent palette when active. See the <b>Colors</b> section below for full details on each layer.</li>
  <li><b>Dim mode</b> (Selection menu): choose how unselected nodes and mappings appear  <b>All</b> dims everything, <b>Parents</b> keeps parent groups visible, <b>Off</b> disables dimming entirely. Colored mappings (scheme, filter, or manual) properly dim alongside nodes.</li>
  <li><b>Dim unselected</b> (Selection menu): <b>All</b> dims everything except directly connected fields. <b>Parents</b> also keeps ancestor groups visible with a subtle highlight. <b>Off</b> disables dimming. Collapsed groups always stay highlighted regardless of mode.</li>
  <li><b>Highlight mode</b> (Selection menu): choose between <b>Chain</b> (follow full mapping chain across all columns, default), <b>Direct</b> (show only immediate/adjacent mappings), and <b>Selected</b> (highlight only the selected node(s), no connected fields). Applies to both single and multi-selections.</li>
  <li><b>Highlight colors</b> (Selection  Highlight colors): customize the Selected / Hovered and Connected highlight colors with a picker and preset swatches. Includes a live preview tester with interactive source  target nodes. Per-row  reset to defaults. Colors are saved as <code>_highlightColors</code> in the project JSON and travel with the file. Editable only in Editor mode; read-only in Viewer mode. Save / Cancel / Delete workflow with unsaved-changes guard.</li>
</ul>
<p>Tip: for large graphs, keep arrow mode on <b>Selected</b> and use hover/click to explore connections contextually. Disable <b>Same-column</b> and <b>Distant</b> arrows to focus on adjacent mappings only.</p>

<h3>Details pane</h3>
<p>The details panel shows contextual information. It can be docked <b>left, right, bottom</b>, used as a <b>floating</b> window (drag to reposition, resize from corner), or <b>hidden</b>. Press <b>D</b> to toggle visibility. Use the mode buttons in the panel header or drag the float panel to a screen edge to dock.</p>
<ul>
  <li><b>No selection</b>: project metadata summary (title, author, description, etc.).</li>
  <li><b>Field/group selected</b>: node label, ID, tags, custom attributes, note, and inbound/outbound mapping lists. Groups additionally show a <b>Children</b> section with rich detail cards (type, summary, tags, attributes) for each child node.</li>
  <li><b>Edge selected</b>: mapping details including from/to, cardinality, transforms, default, and note.</li>
  <li><b>Column selected</b>: column header properties.</li>
  <li>Inbound, Outbound, and Children sections are <b>collapsible</b> (click the  caret). Groups default to collapsed sections; fields default to expanded.</li>
</ul>

<h3>Layout controls</h3>
<ul>
  <li><b>Column width</b> and <b>Column gap</b> sliders adjust the visual layout.</li>
  <li><b>Wrap columns</b>: stacks columns vertically instead of side-by-side (useful for screenshots or narrow screens).</li>
  <li><b>Bright mode</b>: toggles between dark and light themes.</li>
  <li><b>Zoom / density</b>: scales the entire viewer (50&ndash;150%). Use the slider in the Layout popover to fit more on screen or zoom in for detail.</li>
  <li><b>Display tags / Display attributes</b>: toggles tag and attribute pills on tree nodes.</li>
  <li><b>Node color mode</b>: controls which color inheritance levels are active for node background tints. Four modes:
    <ul>
      <li><b>All</b> (default): full inheritance chain &mdash; node &rarr; group &rarr; column.</li>
      <li><b>Groups</b>: column + group colors only. Field-level color overrides are suppressed (groups still override their parent).</li>
      <li><b>Column</b>: only column colors are applied. All group and field colors are suppressed.</li>
      <li><b>Off</b>: no background tinting at all. Column headers still show their color.</li>
    </ul>
  </li>
  <li><b>Pan mode</b>: press <b>P</b> or click the <b>&#x229e;</b> toolbar button to enter pan mode &mdash; drag anywhere to scroll the viewer. Press P, Esc, or click &#x229e; again to exit.</li>
  <li><b>Clear selection</b>: press <b>Esc</b> or click the <b>&#x2298;</b> toolbar button to deselect the current node, mapping, or column.</li>
</ul>

<h2>Editor mode</h2>
<p>Toggle <b>Editor mode</b> in the toolbar to edit the model directly in the viewer. All changes are tracked by undo/redo (<b>Ctrl+Z</b> / <b>Ctrl+Y</b>, or <b>Cmd</b> on Mac).</p>

<h3>Columns</h3>
<ul>
  <li><b>Add columns</b>: open <b>Columns&hellip;</b> and use the <b>+ Add left</b> / <b>+ Add right</b> buttons (editor mode), or hover between column headers to reveal a &ldquo;+&rdquo; insertion zone.</li>
  <li><b>Rename columns</b>: click the column header label (in editor mode) to edit it.</li>
  <li><b>Column context menu</b>: click the &#x2AF6; button on a column header to access rename, delete, move, and add options.</li>
  <li><b>Column notes</b>: editable in the details pane when a column is selected.</li>
  <li><b>Column colors</b>: optional per-column color with swatch picker and Apply checkbox. When applied, the column header name is tinted and a colored bottom border appears. The color acts as the final fallback in the node color inheritance chain &mdash; all descendant nodes without their own applied color (or an ancestor group color) inherit the column color as a subtle background tint.</li>
</ul>

<h3>Nodes (fields &amp; groups)</h3>
<ul>
  <li><b>Add nodes</b>: hover a row to reveal action buttons &mdash; &#x21B3; (add child inside group), &#x2AFA; (context menu with insert, move, indent, duplicate/duplicate+, delete).</li>
  <li><b>Context menu</b>: click the  button on any node for insert above/below, move, indent/outdent, duplicate (without mappings) and duplicate+ (with mappings), and delete.</li>
  <li><b>Edit node properties</b>: click a field to select it, then edit label, ID, note, color, tags, custom attributes, and mappings in the details pane.</li>
  <li><b>Drag-and-drop nodes</b>: drag a field or group to reorder, move between groups, or move to another column. Hold modifier keys during drag for different operations:
    <ul>
      <li><b>No modifier</b> &mdash; <em>Move</em>: relocates the node (removes from source).</li>
      <li><b>Alt / Option</b> &mdash; <em>Map</em>: creates a mapping between the dragged field and the drop target.</li>
      <li><b>Ctrl / Cmd</b> &mdash; <em>Copy</em>: duplicates the node to the drop location (original stays).</li>
      <li><b>Ctrl / Cmd + Alt / Option</b> &mdash; <em>Copy+</em>: duplicates the node and copies all its mappings to the new copy.</li>
    </ul>
  </li>
  <li><b>Node IDs</b>: hierarchical path structure. The path prefix is auto-calculated from the parent hierarchy; the local segment is editable.</li>
  <li><b>Node colors</b>: optional per-node color shown as a subtle background tint. Use the preset swatches or the color picker in the editor. Check <b>Apply</b> to activate; uncheck to stage a color without applying it.</li>
  <li><b>Column colors</b>: optional per-column color that tints the column header and acts as the final fallback in the inheritance chain for all descendant nodes.</li>
  <li><b>Attribute value colors</b>: each value can have a color with an Apply checkbox. If a value's color is not applied, it inherits from the attribute-level color. For &ldquo;Color mappings by&rdquo;, disabled value colors fall back to the default palette.</li>
  <li><b>Color priority (node background)</b>: multiple systems can color a node. From highest to lowest priority: <b>Selection/hover highlight</b> &rarr; <b>Filter highlight</b> &rarr; <b>Node color</b> (applied) &rarr; <b>Nearest ancestor group color</b> (applied) &rarr; <b>Column color</b> &rarr; none. Selection and filter highlights completely override the inheritance chain. Within the inheritance chain, groups with color applied cascade to all descendants until a child overrides with its own applied color.</li>
  <li><b>Color priority (mappings)</b>: multiple systems can color an arrow. From highest to lowest priority:
    <ol style="margin:4px 0 2px 18px;font-size:12px;line-height:1.7;">
      <li><b>Selection/hover highlight</b> &mdash; when a mapping is part of the active selection or hover chain, the highlight color (blue for connected, gold for selected) always wins. This is why "Color mappings by" is most useful in <b>All</b> arrow mode, where drawn arrows aren&rsquo;t highlighted.</li>
      <li><b>Filter mapping color</b> &mdash; if a filter has <b>mapping color</b> enabled in its highlight style, arrows matching the filter get that color. Evaluated per-arrow: both endpoints must match the filter.</li>
      <li><b>Color-by scheme</b> &mdash; when "Color mappings by" is active in the Graph menu (Cardinality, Transform, Source/Target tag, or custom attribute), all arrows are colored by the chosen property using a consistent palette. Custom colors defined on tags or attribute values take priority over the auto-palette when the value&rsquo;s color is enabled (Apply checked).</li>
      <li><b>Manual per-mapping color</b> &mdash; individual color set on the mapping itself via the editor. This is the lowest priority, meaning "Color mappings by" overrides it when active. To see manual colors, set the scheme to <b>Off</b>.</li>
      <li><b>Default</b> &mdash; no coloring; the arrow uses the standard line color (light gray in dark mode, dark gray in bright mode).</li>
    </ol>
    <p style="margin:4px 0 0;font-size:12px;opacity:.7;">When a selection is active and <b>Dim mode</b> is not Off, unrelated arrows dim to the background regardless of their color  filter, scheme, and manual colors all respect dimming.</p>
  </li>
  <li><b>Color priority (attribute pills)</b>: <b>Value color</b> (Apply checked) &rarr; <b>Attribute color</b> (Apply checked) &rarr; none (default chip style).</li>
</ul>

<h3>Mappings</h3>
<ul>
  <li><b>Create by drag</b>: hold <b>Alt / Option</b> and drag a field onto a field in another column. Alternatively, drag without modifiers between columns to create a mapping when the drop indicator shows the link icon.</li>
  <li><b>Create from details pane</b>: when a field is selected, use "Add outbound" or "Add inbound".</li>
  <li><b>Edit mapping properties</b>: click an arrow to select the mapping, then edit cardinality, transforms, default value, color, and note.</li>
  <li><b>Bidirectional mappings</b>: if two mappings exist between the same pair in both directions, they are consolidated into a single arrow with a &#x2194; indicator.</li>
  <li><b>Delete mappings</b>: select a mapping and click the delete button in the details pane.</li>
</ul>

<h3>Multi-select &amp; bulk actions</h3>
<p>Select multiple nodes to perform bulk operations. The details panel shows a combined summary with action buttons.</p>
<ul>
  <li><b>Ctrl/Cmd+click</b>: toggle individual nodes in/out of the multi-selection. Works across columns.</li>
  <li><b>Shift+click</b>: select a range of visible nodes within the same column (from last clicked node to current).</li>
  <li><b>Alt+click</b>: chain select. If the clicked node is connected to the current selection, adds it and all nodes on the shortest path back to the selection. If it&rsquo;s already selected or not connected, adds its entire mapping chain instead.</li>
  <li><b>Alt+Shift+click</b>: upstream chain select &mdash; follows mappings backwards to find all sources that map <em>to</em> the clicked node.</li>
  <li><b>Alt+Ctrl/Cmd+click</b>: downstream chain select &mdash; follows mappings forwards to find all targets the clicked node maps <em>to</em>.</li>
  <li><b>Marquee &amp; lasso select</b>: drag on empty viewer background to draw a selection rectangle. Hold Alt while dragging for a freeform lasso shape instead. All nodes inside the shape are selected. Hold Shift to add, Ctrl/Cmd to subtract. Modifiers combine: Alt+Shift = freeform add, Alt+Ctrl = freeform subtract.</li>
  <li><b>Bulk delete</b>: remove all selected nodes and their mappings. Supports undo.</li>
  <li><b>Bulk set tags</b>: add or remove tags across all selected nodes. The dialog shows each tag&rsquo;s current state (checked, unchecked, or indeterminate for partial application).</li>
  <li><b>Bulk set attribute</b>: set a custom attribute value on all selected nodes, or remove an attribute entirely.</li>
  <li><b>Bulk map to&hellip;</b>: search for a target field and create mappings from all selected fields to that target in one click.</li>
  <li><b>Multi-select drag-and-drop</b>: when multiple nodes are selected, dragging any selected node performs the operation on all selected nodes simultaneously. The drag ghost shows a &times;N count badge. Same modifier keys apply:
    <ul>
      <li><b>No modifier (Move)</b>: moves all selected root nodes to the drop position, maintaining their original relative order.</li>
      <li><b>Alt / Option (Map)</b>: maps all selected fields to the drop target field. The selection then switches to the target.</li>
      <li><b>Ctrl / Cmd (Copy)</b>: duplicates all selected root nodes to the drop position.</li>
      <li><b>Ctrl / Cmd + Alt / Option (Copy+)</b>: duplicates all selected root nodes and their mappings.</li>
    </ul>
  </li>
  <li><b>Deduplication</b>: when a group and some of its children are both selected, only the group is processed &mdash; children travel implicitly with their parent, avoiding duplicates.</li>
  <li><b>Drop target validation</b>: you cannot drop onto or inside any selected node during Move. You cannot Map to any selected field. Invalid targets show a &ldquo;not allowed&rdquo; cursor.</li>
  <li><b>Multi bin delete</b>: drag the multi-selection to the &ldquo; Delete&rdquo; zone during a Move drag to bulk-delete all selected root nodes (with confirmation).</li>
</ul>

<h3>Save / Cancel behavior</h3>
<p>Catalog editors (tags, transforms, attributes, filters) and node/column/mapping editors use a click-to-edit pattern:</p>
<ul>
  <li>Click an item to enter edit mode. Only one item is editable at a time &mdash; other items are greyed out.</li>
  <li><b>Save</b>: commits all changes as a single undo entry. The button turns <span style="color:#f59e0b;font-weight:700;">yellow</span> when there are pending unsaved changes.</li>
  <li><b>Cancel</b>: reverts to the state before editing &mdash; no undo entry is created, no confirmation prompt.</li>
  <li><b>Delete</b>: prompts for confirmation, then removes the item with cascading cleanup.</li>
  <li><b>Abandon guard</b>: navigating away from unsaved edits (clicking another node, switching modes, closing a catalog, undo/redo) prompts "Abandon unsaved changes?" The prompt only appears when actual changes are detected vs. the snapshot. Manually reverting all changes back to original values clears the dirty state.</li>
</ul>

<h2>Catalogs</h2>
<p>Four catalogs are managed via modal panels (accessible from the CATALOGS toolbar group). All catalog editors share a unified editing pattern:</p>
<ul>
  <li><b>Inline creation</b>: clicking <b>Add</b> inserts a blank editor card at the top of the list. No popup  edit in place.</li>
  <li><b>Auto-ID &amp; abbreviation</b>: as you type a label, the ID and abbreviation auto-generate in real time. A blue <b>auto</b> badge indicates the field is linked to the label. Edit the field to override (badge disappears); clear it to re-link (badge reappears).</li>
  <li><b>Save / Cancel / Delete</b>: the Save button is disabled until changes are detected. New items have no Delete button. Cancel on a new item discards it (with a confirmation prompt if dirty). Label is required to save.</li>
  <li><b>Click to edit</b>: click any existing item to open its inline editor. A dirty guard prompts before abandoning unsaved changes.</li>
</ul>

<h3>Tags</h3>
<p>Tags are colored labels attached to nodes (fields and groups). They appear as small pills in the viewer and indicate status, ownership, or workflow stage.</p>
<ul>
  <li>Each tag has: <b>id</b>, <b>label</b>, <b>abbreviation</b>, <b>color</b>, <b>note</b>, and <b>priority</b>.</li>
  <li><b>Priority</b> determines display order everywhere. Drag tags in the manager to reorder, or use the arrow buttons.</li>
  <li>Tags are assigned to nodes in the node editor (details pane).</li>
  <li>Up to 3 tags are shown per field in the viewer; the rest are visible on hover or in the details pane.</li>
</ul>

<h3>Transforms</h3>
<p>Transforms describe data conversion operations applied to mappings (e.g. trim, uppercase, type cast). They are an ordered sequence per mapping.</p>
<ul>
  <li>Each transform has: <b>id</b>, <b>label</b>, <b>abbreviation</b>, <b>note</b>, and optional <b>params</b> (parameter schema).</li>
  <li>Params define per-instance configuration: each param has an <b>id</b>, <b>label</b>, <b>type</b> (text or number), and optional <b>default</b>. Param IDs also auto-generate from the label.</li>
  <li>The same transform can be added <b>multiple times</b> to a mapping&rsquo;s chain &mdash; each instance can have different parameter values (e.g. two REPLACE transforms with different substitutions).</li>
  <li>Transforms are assigned to mappings in the mapping editor. Their <b>order matters</b> &mdash; drag to reorder. Click a parameterized chip to edit its parameters.</li>
  <li>Transforms appear as numbered chips (1, 2, 3&hellip;) on mapping details. Parameterized transforms show <code>(&hellip;)</code> in their abbreviation.</li>
</ul>

<h3>Custom attributes</h3>
<p>Custom attributes add domain-specific metadata to nodes (e.g. data type, sensitivity classification).</p>
<ul>
  <li>Each attribute has: <b>id</b>, <b>label</b>, <b>abbreviation</b>, <b>note</b>, a list of <b>values</b>, a <b>multi</b> flag, and an optional <b>color</b> with Apply checkbox. Each value can have an optional <b>color</b> (hex) with its own <b>Apply</b> checkbox.</li>
  <li>If <b>multi</b> is true, fields can have multiple values for that attribute (checkboxes). Otherwise, single-select (radio).</li>
  <li>Attribute values can have their own notes.</li>
  <li><b>Attribute-level color</b>: the attribute itself can have a color with an Apply checkbox. When enabled, values that don&rsquo;t have their own color applied will inherit the attribute&rsquo;s color for node pills.</li>
  <li><b>Value color Apply</b>: each value&rsquo;s color has an explicit Apply toggle. When unchecked, the color is stored but not used &mdash; the value inherits from the attribute color instead. For &ldquo;Color mappings by&rdquo;, values with disabled colors fall back to the default palette rather than using their stored color.</li>
  <li>The catalog overview shows a colored dot next to each value that has a custom color. Values with disabled colors appear slightly dimmed. Attributes with an applied color show a dot next to the attribute name.</li>
  <li><b>Value color editing</b>: inline color picker with &#x1f3a8; swatch toggle (10 presets), Apply checkbox, and &#x21ba; reset per value row. Colors are also available when creating new values.</li>
  <li>Attributes appear as compact pills in the viewer and as full details in the details pane.</li>
</ul>

<h3>Filters</h3>
<p>Filters are rule-based visual highlights. They follow the same inline creation and editing pattern as other catalogs, with additional controls for highlight style (background, stripe, mapping color, frame, bold, emoji) and condition rules.</p>

<h2>Project properties</h2>
<p>Click the <b>&#x24D8;</b> button next to the project title to open the Project Properties modal. Available fields:</p>
<ul>
  <li><b>Title</b>, <b>Subtitle</b>, <b>Description</b> (multiline), <b>Author</b>, <b>Organization</b>, <b>Contact</b>, <b>URL</b>, <b>Version</b>, <b>Date</b>.</li>
  <li>The title is also editable by clicking it directly in the header.</li>
  <li>App version and last-saved timestamp are shown as read-only metadata.</li>
</ul>

<h2>Undo / Redo</h2>
<ul>
  <li><b>Ctrl+Z</b> / <b>Ctrl+Y</b> (or Cmd on Mac) to undo and redo.</li>
  <li>Toolbar buttons are also available in the top bar.</li>
  <li>Each meaningful action creates exactly one undo entry (no duplicates from intermediate steps).</li>
  <li>Undo history is cleared when loading a new project or starting a new mapping.</li>
</ul>

<h2>Dirty state &amp; saving</h2>
<p>The <b>Save project</b> button shows a blue highlight when there are unsaved changes. The dirty indicator tracks all edits and resets on save, load, or undo-back-to-clean-state.</p>
<ul>
  <li><b>Save project</b>: downloads the complete JSON with app metadata (<code>_app</code>), timestamp (<code>_savedAt</code>), and custom highlight colors (<code>_highlightColors</code>) if set.</li>
  <li><b>Open project</b>: loads a JSON file, validates it, and resets undo history.</li>
  <li>Files are saved and loaded locally &mdash; nothing is sent to a server.</li>
  <li><b>Editor dirty guards</b>: navigating away from an unsaved editor (catalog item, filter, node, or create modal) prompts for confirmation. Bulk edit modals track whether changes were made before enabling Apply.</li>
</ul>

<h2>Export</h2>
<ul>
  <li><b>Export CSV</b>: exports all currently visible mappings as a CSV file (from, to, cardinality, transforms, default, note).</li>
  <li><b>Export report</b>: generates a self-contained HTML snapshot with all mapping details, suitable for sharing with stakeholders who don't have the tool.</li>
</ul>

<h2>JSON format</h2>
<p>The project file is a single JSON object:</p>
<pre><code>{
  "title": "Project title",
  "subtitle": "...",
  "description": "...",
  "author": "...",
  "organization": "...",
  "contact": "...",
  "url": "...",
  "projectVersion": "1.0",
  "date": "2026-01-15",
  "_app": { "name": "Dunnode", "version": "1.3.7", "schema": 1 },
  "_savedAt": "2026-02-19T12:00:00.000Z",
  "columns": [
    {
      "id": "mc",
      "label": "Mission Control",
      "note": "Source of truth for mission parameters.",
      "color": "#3b82f6",
      "schema": {
        "id": "mc",
        "label": "Mission Control",
        "type": "group",
        "children": [
          {
            "id": "mc.mission",
            "label": "Mission",
            "type": "group",
            "children": [
              {
                "id": "mc.mission.missionId",
                "label": "MissionId",
                "type": "field",
                "tags": ["active"],
                "customAttributes": { "format": "string" },
                "note": "Primary mission identifier."
              }
            ]
          }
        ]
      }
    }
  ],
  "mappings": [
    {
      "from": "mc.mission.missionId",
      "to": "sat.vehicle.vehicleCode",
      "cardinality": "1:1",
      "transforms": ["trim", "upper"],
      "default": "",
      "note": "Mission ID becomes vehicle code."
    }
  ],
  "tagCatalog": [
    { "id": "active", "label": "Active", "abbr": "A",
      "color": "#22c55e", "note": "...", "priority": 1 }
  ],
  "transformCatalog": [
    { "id": "trim", "label": "Trim whitespace",
      "abbr": "TR", "note": "..." }
  ],
  "customAttributeCatalog": [
    { "id": "format", "_autoId": true, "_autoAbbr": true, "label": "Format", "abbr": "FM",
      "note": "...", "multi": false,
      "color": "#6b7280", "colorEnabled": false,
      "values": [
        { "id": "string", "label": "String", "note": "...",
          "color": "#22c55e", "colorEnabled": true }
      ] }
  ],
  "filterCatalog": [
    { "id": "f1", "label": "Critical & Unmapped",
      "priority": 1,
      "rules": [{ "field": "tag", "op": "has", "value": "active" }],
      "highlight": { "bg": "#f43f5e", "border": "#f43f5e",
        "edgeColor": "#f43f5e", "frameColor": "#f43f5e",
        "bgEnabled": true, "borderEnabled": true,
        "edgeEnabled": false, "bold": true,
        "frame": false, "emoji": "" } }
  ]
}</code></pre>

<h3>Schema tree nodes</h3>
<ul>
  <li><code>type: "group"</code> &mdash; container node with <code>children: []</code>.</li>
  <li><code>type: "field"</code> &mdash; leaf node, no children.</li>
  <li>Each node must have a unique <code>id</code>.</li>
  <li>Optional properties: <code>label</code> (display name), <code>tags</code> (array of tag ids), <code>customAttributes</code> (object mapping attribute id to value id), <code>color</code> (hex color string for custom tint), <code>note</code> (free text).</li>
  <li><b>Color inheritance:</b> a node&rsquo;s effective background tint follows the hierarchy: own <code>color</code> (applied) &rarr; nearest ancestor group with <code>color</code> &rarr; column <code>color</code> &rarr; none. Groups with color cascade to all descendants until overridden.</li>
  <li><b>ID convention:</b> field ids should start with <code>&lt;columnId&gt;.</code> (e.g. <code>lab.experiment.payload_mass</code>) so the tool can infer column membership.</li>
</ul>

<h3>Column object</h3>
<ul>
  <li><code>id</code> &mdash; unique column identifier.</li>
  <li><code>label</code> &mdash; display name.</li>
  <li><code>note</code> &mdash; optional free text.</li>
  <li><code>color</code> &mdash; optional hex color. When present, tints the column header and acts as the fallback color for all descendant nodes without their own applied color.</li>
  <li><code>schema</code> &mdash; root group node containing the tree.</li>
</ul>

<h3>Mapping object</h3>
<ul>
  <li><code>from</code> &mdash; field id (source).</li>
  <li><code>to</code> &mdash; field id (target). In v4 this is always a single string.</li>
  <li><code>cardinality</code> &mdash; one of: <code>1:1</code>, <code>1:n</code>, <code>n:1</code>, <code>n:n</code>, or empty.</li>
  <li><code>transforms</code> &mdash; ordered array of transform catalog ids.</li>
  <li><code>default</code> &mdash; default value when source is null/empty.</li>
  <li><code>note</code> &mdash; free text annotation.</li>
  <li><code>color</code> &mdash; optional hex color for custom arrow coloring.</li>
</ul>

<h2>Command palette</h2>
<p>Press <b>Ctrl+K</b> (Cmd+K on Mac) or click the <b></b> button in the header to open the command palette.</p>
<ul>
  <li>Type to fuzzy-search all available commands (open catalogs, toggle modes, change views, undo/redo, etc.).</li>
  <li>The palette also searches all <b>nodes and fields</b> by name or ID  selecting one expands parent groups, selects the node, and scrolls it into view.</li>
  <li>Use <b></b> to navigate, <b>Enter</b> to execute, <b>Escape</b> to close.</li>
</ul>

<h2>Keyboard shortcuts</h2>
<ul>
  <li><b>Ctrl+K</b> (Cmd+K on Mac) &mdash; Open command palette  search commands, nodes, and documentation</li>
  <li><b>Ctrl+A</b> (Cmd+A on Mac) &mdash; Select all visible nodes</li>
  <li><b>Ctrl+Shift+I</b> (Cmd+Shift+I on Mac) &mdash; Invert current selection</li>
  <li><b>Ctrl+Z</b> (Cmd+Z on Mac) &mdash; Undo</li>
  <li><b>Ctrl+Y</b> (Cmd+Y / Cmd+Shift+Z on Mac) &mdash; Redo</li>
  <li><b>Esc</b> &mdash; Clear selection and search / cancel edit / close modal</li>
  <li><b>?</b> &mdash; Open quick help</li>
  <li><b>D</b> &mdash; Toggle details panel (cycles: show  hide  show)</li>
  <li><b>P</b> &mdash; Toggle pan mode (drag to scroll the viewer). Press P or Esc to exit</li>
</ul>
<p><b>Drag-and-drop modifiers</b> (hold during drag in Editor mode):</p>
<ul>
  <li><b>No modifier</b> &mdash; Move node (removes from source)</li>
  <li><b>Alt / Option</b> &mdash; Create mapping between source and target</li>
  <li><b>Ctrl / Cmd</b> &mdash; Copy node to drop location</li>
  <li><b>Ctrl / Cmd + Alt / Option</b> &mdash; Copy node and duplicate all its mappings</li>
</ul>
<p>When multiple nodes are selected, dragging any selected node applies the same modifiers to the entire selection (bulk Move, Map, Copy, or Copy+). The drag ghost shows a &times;N count badge.</p>

<h2>Glossary</h2>
<ul>
  <li><b>Column</b> &mdash; a system or data source, rendered as a vertical tree.</li>
  <li><b>Field</b> &mdash; a leaf node in a schema tree. Mappings connect fields.</li>
  <li><b>Group</b> &mdash; a container node with children (can be nested).</li>
  <li><b>Edge / Mapping</b> &mdash; a connection from one field to another, with optional metadata (cardinality, transforms, default, note).</li>
  <li><b>Tag</b> &mdash; a colored label attached to nodes for categorization.</li>
  <li><b>Transform</b> &mdash; a data conversion step attached to a mapping.</li>
  <li><b>Custom attribute</b> &mdash; domain-specific metadata attached to nodes (fields and groups).</li>
  <li><b>Filter</b> &mdash; a rule-based condition set that visually highlights matching nodes with colors, borders, bold text, and emojis. Managed via the filter catalog.</li>
  <li><b>Bidirectional mapping</b> &mdash; when two mappings exist between the same pair in both directions, shown as a single arrow with a direction indicator.</li>
  <li><b>Non-adjacent mapping</b> &mdash; a mapping that skips one or more columns (shown as a long bezier curve).</li>
  <li><b>Virtual mapping</b> &mdash; when a column in the middle of a chain is hidden, the tool draws a dashed arrow connecting visible endpoints.</li>
</ul>

<h2>Tips &amp; best practices</h2>
<ul>
  <li>Start in viewer mode to explore data, switch to editor mode to make changes.</li>
  <li>Use tags to track mapping status (e.g. Active, Draft, Retired).</li>
  <li>Use custom attributes for domain metadata (e.g. data types, sensitivity flags).</li>
  <li>For large projects, hide columns you are not working on to reduce visual noise.</li>
  <li>Use "Only mapped" to focus on fields that participate in the integration.</li>
  <li>Save frequently &mdash; the dirty-state indicator (blue Save button) reminds you of unsaved changes. Individual editor Save buttons turn yellow when there are pending changes.</li>
  <li>Create filters for common review tasks (e.g. "unmapped critical fields") and toggle them on/off via filter bar chips.</li>
  <li>Use <b>Highlight</b> display mode when you want to see filter matches in context without hiding anything.</li>
  <li>Use Export Report to share a read-only snapshot with reviewers who don't have the tool.</li>
</ul>

<h2>Known limitations</h2>
<ul>
  <li>Very large graphs (thousands of mappings) can be slow with arrow mode set to <b>All</b>. Use <b>Selected</b> mode instead.</li>
  <li>Bezier arrow routing is simple &mdash; dense non-adjacent mappings may overlap. Use filtering, arrow scope toggles, or hide intermediate columns.</li>
  <li>All data is local &mdash; no collaboration, versioning, or server-side storage. Use your own file management for team workflows.</li>
  <li><b>Safari</b>: drag-and-drop operations (reorder, move, copy, map nodes) are not supported due to Safari&rsquo;s non-standard handling of the HTML Drag and Drop API. Use a Chromium-based browser (Chrome, Edge, Arc, etc.) for full functionality.</li>
</ul>

<h2>License</h2>
<p>MIT License</p>
<p style="font-size:11.5px;opacity:.7;line-height:1.7;">Copyright &copy; 2026 Oliv&eacute;r B&aacute;n</p>
<p style="font-size:11px;opacity:.6;line-height:1.7;">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &ldquo;Software&rdquo;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p style="font-size:11px;opacity:.6;line-height:1.7;">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p style="font-size:11px;opacity:.6;line-height:1.7;">THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<div style="margin-top:16px;padding:12px 16px;background:rgba(255,255,255,.03);border:1px solid var(--border);border-radius:var(--radius);font-size:12px;line-height:1.6;opacity:.7;">
Dunnode runs entirely in your browser.<br/>
No project data is uploaded or stored on any server.
</div>

<div style="margin-top:28px;padding-top:16px;border-top:1px solid var(--border);text-align:center;">
<div style="font-size:12px;font-weight:700;opacity:.5;letter-spacing:.3px;">Dunnode. Done. Now.</div>
<div style="font-size:10px;opacity:.3;margin-top:4px;">v` + APP_VERSION + `</div>
</div>
  `.trim();

  docsBody.innerHTML = docs;

  // Generate table of contents  group h3s under their parent h2
  const headings = docsBody.querySelectorAll('h2, h3');
  headings.forEach(h => {
    h.id = 'doc-' + h.textContent.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/,'');
  });
  const sections = [];
  Array.from(headings).forEach(h => {
    if(h.tagName === 'H2') sections.push({ el: h, subs: [] });
    else if(sections.length) sections[sections.length - 1].subs.push(h);
  });
  const sectionHtml = sections.map(s => {
    const subsHtml = s.subs.length
      ? '<div class="tocSubs">' + s.subs.map(sub => '<a href="#' + sub.id + '">' + sub.textContent + '</a>').join('') + '</div>'
      : '';
    return '<div class="tocSection"><a class="main" href="#' + s.el.id + '">' + s.el.textContent + '</a>' + subsHtml + '</div>';
  }).join('');
  const tocHtml = '<div class="docsToc"><div class="tocTitle">Contents</div><div class="tocGrid">' + sectionHtml + '</div></div>';
  const docsLogoHeader = docsBody.firstElementChild;
  if(docsLogoHeader) docsLogoHeader.insertAdjacentHTML('afterend', tocHtml);
  else docsBody.insertAdjacentHTML('afterbegin', tocHtml);

  // Smooth scroll for TOC links
  docsBody.querySelectorAll('.docsToc a').forEach(a => {
    a.addEventListener('click', e => {
      e.preventDefault();
      const target = docsBody.querySelector(a.getAttribute('href'));
      if(target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });
  });
}


/* =========================
   Boot
========================= */
function init(){
  // Start with a blank project
  const blankData = createBlankMappingData();
  jsonArea.value = JSON.stringify(blankData, null, 2);
  validateEditor();

  state.data = blankData;
  // build structured editor list
  rebuildStructuredList();
  renderAll();
  markClean(); // Fresh on load (after renderAll normalizes data)


  // default UI state
  svgOverlay.style.display = "block";
  setTab("viewer");
}

init();


/* =========================
 v19  Drag & Drop for nodes + Cross-column mapping via drag
  - Reorder within same column (before/after)
  - Nest into a group (indent)
  - Move whole groups with children
  - Drag a field onto a field in another column to create a mapping (from = dragged, to = dropped)
  - Clear visual intent while hovering (status line + drop caret)
========================= */
(function(){
  window.__ENHANCED_DND = true;

  // runtime guard: only add once
  if(window.__MS_V19_DND_INSTALLED__) return; 
  window.__MS_V19_DND_INSTALLED__ = true;

  const DROP_LINE_ID = 'ms_drop_line_v19';
  let DND = { dragging: null, overId: null, intent: null, overEl: null };

  function ensureDropLine(){
    let el = document.getElementById(DROP_LINE_ID);
    if(!el){
      el = document.createElement('div');
      el.id = DROP_LINE_ID;
      el.style.position = 'fixed';
      el.style.zIndex = '2000';
      el.style.pointerEvents = 'none';
      el.style.height = '2px';
      el.style.background = 'rgba(59,130,246,.95)';
      el.style.boxShadow = '0 0 0 1px rgba(59,130,246,.55)';
      el.style.display = 'none';
      (document.getElementById('dndOverlay')||document.body).appendChild(el);
    }
    return el;
  }
  function hideDropLine(){
    const el = ensureDropLine();
    el.style.display = 'none';
  }
  function showDropLineAt(row, pos){
    const el = ensureDropLine();
    const r = row.getBoundingClientRect();
    const y = (pos==='before') ? r.top : (r.bottom);
    el.style.left = (r.left) + 'px';
    el.style.width = (r.width) + 'px';
    el.style.top = (Math.round(y)-1) + 'px';
    el.style.display = 'block';
  }

  function clearHoverClasses(){
    if(DND.overEl){ DND.overEl.classList.remove('dropTarget'); }
    hideDropLine();
  }

  function computeIntent(src, targetRow, clientX, clientY){
    if(!targetRow) return null;
    const tid = targetRow.dataset.nodeId;
    const tcol = targetRow.dataset.columnId;
    const tnode = IDX?.nodeById?.get(tid);
    if(!tid || !tcol || !tnode) return null;

    if(src.colId !== tcol){
      // Cross-column: only fieldfield mapping
      if(src.type==='field' && tnode.type==='field') return { kind:'map', targetId: tid, targetColId: tcol };
      return null;
    }

    // Same column: move operations
    const r = targetRow.getBoundingClientRect();
    const y = clientY - r.top; // 0..h
    const h = r.height || 1;
    const third = h/3;
    if(y < third){ return { kind:'before', targetId: tid, targetColId: tcol }; }
    if(y > 2*third){ return { kind:'after', targetId: tid, targetColId: tcol }; }
    // middle zone: into (only if target is a group)
    if(tnode.type !== 'field'){ return { kind:'into', targetId: tid, targetColId: tcol }; }
    // If middle but field, fall back to after
    return { kind:'after', targetId: tid, targetColId: tcol };
  }

  function beginDrag(row){
    const id = row?.dataset?.nodeId;
    const colId = row?.dataset?.columnId;
    if(!id || !colId) return false;
    const node = IDX?.nodeById?.get(id);
    if(!node) return false;
    DND.dragging = { id, colId, type: node.type };
    row.classList.add('dragging');
    setViewerStatus('Dragging: ' + id + '  modifiers: Alt=Map, Ctrl=Copy, Ctrl+Alt=COPY+');
    return true;
  }
  function endDrag(){
    const rows = document.querySelectorAll('.row.dragging');
    rows.forEach(r=>r.classList.remove('dragging'));
    clearHoverClasses();
    DND.dragging = null; DND.overId = null; DND.intent = null; DND.overEl = null;
  }

  function describeIntent(intent){
    if(!intent) return '';
    const t = intent.targetId;
    if(intent.kind==='map') return 'Create mapping: ' + (DND.dragging?.id||'') + '  ' + t;
    if(intent.kind==='before') return 'Move before: ' + t;
    if(intent.kind==='after') return 'Move after: ' + t;
    if(intent.kind==='into') return 'Nest into group: ' + t;
    return '';
  }

  function performMove(srcId, intent){
    // If nothing is selected, lock the dragged node so the undo snapshot captures it
    if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
      state.lockedId = srcId;
    }
    recordChange(); // Save state BEFORE move
    
    const colId = columnOf(srcId);
    const col = findColumnById(colId);
    if(!col || !col.schema) return;
    const srcLoc = locateNode(col.schema, srcId);
    const tgtLoc = locateNode(col.schema, intent.targetId);
    if(!srcLoc || !tgtLoc) return;
    if(srcLoc.node.id === tgtLoc.node.id) return;

    // Remove src from its current siblings (unless root)
    let nodeToMove = srcLoc.node;
    if(srcLoc.parent && srcLoc.siblings && srcLoc.idx!=null){
      srcLoc.siblings.splice(srcLoc.idx, 1);
    } else {
      // Moving the root is not supported
      return;
    }

    if(intent.kind==='into'){
      // Ensure group and append as last child
      ensureGroup(tgtLoc.node);
      (tgtLoc.node.children = tgtLoc.node.children || []).push(nodeToMove);
    } else {
      const parent = tgtLoc.parent;
      const siblings = tgtLoc.siblings;
      const idx = tgtLoc.idx;
      if(!parent || !siblings || idx==null){
        // target is root  append as last child of root
        ensureGroup(tgtLoc.node);
        (tgtLoc.node.children = tgtLoc.node.children || []).push(nodeToMove);
      } else {
        const insertAt = intent.kind==='before' ? idx : (idx+1);
        siblings.splice(Math.max(0, Math.min(insertAt, siblings.length)), 0, nodeToMove);
      }
    }
  }

  function performDrop(){
    // v19.5: legacy performDrop disabled when enhanced DND is available
    if(window.__ENHANCED_DND){ try{ hideDropLine && hideDropLine(); }catch(e){} return; }
    const src = DND.dragging; const intent = DND.intent;
    if(!src || !intent) return;

    if(intent.kind==='map'){
      ensureMapping(src.id, intent.targetId);
      // Re-render to get fresh edges and select the new edge
      renderAll();
      // Find edge id
      const ee = (IDX && IDX.edges) ? IDX.edges.find(e => e.from===src.id && e.to===intent.targetId) : null;
      if(ee){
        selectEdge(ee.id);
        setViewerStatus('Created mapping: ' + ee.from + '  ' + ee.to);
      } else {
        applyHighlight();
      }
      return;
    }

    // Moves apply only within same column
    performMove(src.id, intent);
    // Sync editor JSON textarea if present
    if(typeof syncJsonAreaFromObj==='function'){
      try { syncJsonAreaFromObj(); } catch(e){}
    }
    // Re-render and keep selection on moved node
    renderAll();
    lockSelection(src.id);
    scrollIntoView(src.id);
    setViewerStatus(describeIntent(intent));
  }

  function onDragStart(e){
    if(!state.editorMode) { e.preventDefault(); return; }
    const row = e.target.closest('.row');
    if(!row) return;
    if(!beginDrag(row)) { e.preventDefault(); return; }
    try{ e.dataTransfer.setData('text/plain', row.dataset.nodeId||''); }catch(err){}
    try{ e.dataTransfer.effectAllowed = 'move'; }catch(err){}
  }
  function onDragEnd(){ endDrag(); }

  function onDragOver(e){
    if(!state.editorMode || !DND.dragging) return;
    const row = e.target.closest('.row');
    if(!row) return;
    const src = DND.dragging;
    const intent = computeIntent(src, row, e.clientX, e.clientY);
    if(!intent){ clearHoverClasses(); return; }
    e.preventDefault(); // allow drop

    // Visuals
    if(DND.overEl !== row){
      if(DND.overEl) DND.overEl.classList.remove('dropTarget');
      DND.overEl = row;
    }
    row.classList.add('dropTarget');

    if(intent.kind==='before' || intent.kind==='after'){
      showDropLineAt(row, intent.kind);
    } else {
      hideDropLine();
    }

    DND.intent = intent;
    setViewerStatus(describeIntent(intent));
  }
  function onDrop(e){
    if(!state.editorMode || !DND.dragging) return;
    const row = e.target.closest('.row');
    if(!row) return;
    const src = DND.dragging;
    const intent = computeIntent(src, row, e.clientX, e.clientY);
    if(!intent) return;
    e.preventDefault();
    performDrop();
    endDrag();
  }

  // Attach DnD handlers after each render
  const __orig_createNodeElement = createNodeElement;
  window.createNodeElement = function(node, columnId){
    const el = __orig_createNodeElement(node, columnId);
    const row = el.querySelector(':scope > .row');
    if(row){
      // draggable rows only when editorMode (we still set attribute; we gate in dragstart)
      /* v19.5 disabled draggable */;
      /* v19.5 disabled */
      /* v19.5 disabled */
      /* v19.5 disabled */
      /* v19.5 disabled */
    }
    return el;
  };
})();

/* =========================
 v19.2  Drag & Drop (Move / Map / Copy) with Ghost, Tooltip, Samecolumn map
  - Default drag action is configurable: Move | Map | Copy
  - Modifiers always work to override default:
      Alt  Map,  Ctrl  Copy,  Shift  Move
  - Move supports crosscolumn (IDs rewritten to target prefix)
  - Copy duplicates node (deep) and rewrites IDs; mappings are not duplicated
  - Samecolumn map: hold Alt while dragging a field over another field
  - Visuals: colored intent outlines, ghost preview with fade, floating tooltip
========================= */
(function(){
  window.__ENHANCED_DND = true;

  if(window.__MS_V192_DND_INSTALLED__) return; window.__MS_V192_DND_INSTALLED__ = true;

  // --- Styles (ghost + outlines + tooltip) ---
  const style = document.createElement('style');
  style.textContent = `
  .row.dropTarget.moveIntent{outline: 2px solid rgba(59,130,246,.85)!important; background: rgba(59,130,246,.14)!important;}
  .row.dropTarget.mapIntent {outline: 2px solid rgba(255,208,92,.92)!important; background: rgba(255,208,92,.20)!important;}
  .row.dropTarget.copyIntent{outline: 2px solid rgba(34,197,94,.90)!important; background: rgba(34,197,94,.18)!important;}
  .row.dropTarget.copyPlusIntent{outline: 2px solid rgba(132,204,22,.95)!important; background: rgba(132,204,22,.20)!important;}
  .dndGhost{position:fixed; left:-2000px; top:-2000px; z-index:9999; pointer-events:none; opacity:0; transform: scale(.98);
            box-shadow:0 12px 40px rgba(0,0,0,.45); transition: opacity .12s ease, transform .12s ease;}
  .dragTip{position:fixed; z-index:99999; pointer-events:none; font: 11px/1.2 var(--sans);
           color:#0b1020; background: rgba(255,255,255,.96); border:1px solid rgba(0,0,0,.15);
           border-radius:10px; padding:6px 8px; box-shadow:0 10px 30px rgba(0,0,0,.35); opacity:0;
           transform: translateY(4px); transition: opacity .08s ease, transform .08s ease;}
  .dragTip.show{opacity:1; transform: translateY(0);} 
  `;
  document.head.appendChild(style);

  // Floating tooltip element
  const tip = document.createElement('div'); tip.className='dragTip'; (document.getElementById('dndOverlay')||document.body).appendChild(tip);
  function showTip(txt, x, y){ tip.textContent = txt; tip.style.left=(x+14)+'px'; tip.style.top=(y+10)+'px'; tip.classList.add('show'); }
  function hideTip(){ tip.classList.remove('show'); }

  // Detect macOS for drag-and-drop workarounds
  const isMacOS = /Mac|iPhone|iPad|iPod/.test(navigator.platform) || /Mac|iPhone|iPad|iPod/.test(navigator.userAgent);

  const DROP_LINE_ID = 'ms_drop_line_v192';
  let DND = { dragging: null, overEl: null, intent: null, ghost: null, dropHandled: false, lastModifiers: null,
    multiIds: null,   // Set of deduped root node IDs for multi-select drag (or null for single)
    multiFields: null  // Set of field-only IDs for MAP during multi-select (or null)
  };
  // Expose multi-select state for ghost IIFE
  window.__DND_MULTI = DND;

  function ensureDropLine(){
    let el = document.getElementById(DROP_LINE_ID);
    if(!el){ el = document.createElement('div'); el.id = DROP_LINE_ID; el.style.position='fixed'; el.style.zIndex='2000'; el.style.pointerEvents='none'; el.style.height='2px'; el.style.background='rgba(59,130,246,.95)'; el.style.boxShadow='0 0 0 1px rgba(59,130,246,.55)'; el.style.display='none'; (document.getElementById('dndOverlay')||document.body).appendChild(el);} 
    return el;
  }
  function hideDropLine(){ ensureDropLine().style.display='none'; }
  function showDropLineAt(row, pos){ const el=ensureDropLine(); const r=row.getBoundingClientRect(); const y=(pos==='before')?r.top:r.bottom; el.style.left=r.left+'px'; el.style.width=r.width+'px'; el.style.top=(Math.round(y)-1)+'px'; el.style.display='block'; }

  // --- Cancel and Bin drop zones ---
  let cancelZone = null;
  let binZone = null;
  
  function ensureDropZones(){
    // Use pre-existing HTML elements in #dndOverlay  no DOM insertion during drag
    if(!cancelZone){
      cancelZone = document.getElementById('cancelZone');
      if(!cancelZone) return;
      
      cancelZone.addEventListener('dragover', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        cancelZone.classList.add('dragover');
        clearHover();
        DND.intent = null;
        DND.overEl = null;
        try{ e.dataTransfer.dropEffect = 'none'; }catch(_){}
      });
      
      cancelZone.addEventListener('dragleave', ()=>{
        cancelZone.classList.remove('dragover');
      });
      
      cancelZone.addEventListener('drop', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        DND.dropHandled = true;
        const ghostEl = document.getElementById('dragGhost');
        if(ghostEl) ghostEl.style.display = 'none';
        endDrag();
        setViewerStatus('Drop cancelled');
      });
    }
    
    if(!binZone){
      binZone = document.getElementById('binZone');
      if(!binZone) return;
      
      binZone.addEventListener('dragover', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        binZone.classList.add('dragover');
        // Clear intent and overEl so dragend fallback doesn't execute
        clearHover();
        DND.intent = null;
        DND.overEl = null;
        try{ e.dataTransfer.dropEffect = 'move'; }catch(_){}
      });
      
      binZone.addEventListener('dragleave', ()=>{
        binZone.classList.remove('dragover');
      });
      
      binZone.addEventListener('drop', async (e)=>{
        e.preventDefault();
        e.stopPropagation();
        DND.dropHandled = true;
        
        // Manually hide visual ghost since stopPropagation prevents document handler
        const ghostEl = document.getElementById('dragGhost');
        if(ghostEl) ghostEl.style.display = 'none';
        
        if(!DND.dragging){
          console.error('Delete failed: DND.dragging is null');
          endDrag();
          return;
        }
        
        const isMulti = !!(DND.multiIds && DND.multiIds.size >= 2);
        
        if(isMulti){
          // --- Multi-select bin delete ---
          const rootIds = DND.multiIds;
          // Collect all field IDs in subtrees for mapping cleanup
          const allFieldIds = new Set();
          for(const nid of rootIds){
            const node = IDX?.nodeById?.get(nid);
            if(node) for(const f of collectFieldIdsFromNode(node)) allFieldIds.add(f);
          }
          const mapCount = (state.data?.mappings||[]).filter(m => m && (allFieldIds.has(m.from) || allFieldIds.has(m.to))).length;
          const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
          if(!await customConfirm(`Delete ${rootIds.size} selected node${rootIds.size>1?'s':''}?${mapInfo}\n\nThis action can be undone with Ctrl+Z.`)){
            endDrag();
            return;
          }
          pushUndo();
          removeMappingsReferencingInState(allFieldIds);
          for(const nid of rootIds){
            const colId = nid.split('.')[0] || nid;
            const col = findColumnById(colId);
            if(!col || !col.schema) continue;
            const loc = locateNode(col.schema, nid);
            if(loc && loc.siblings && loc.idx != null){
              loc.siblings.splice(loc.idx, 1);
            }
          }
          state.multiSelection.clear();
          state.lockedId = null;
          state.hoverId = null;
          state.selectedEdgeId = null;
          markDirty();
          renderAll();
          showToast(`Deleted ${rootIds.size} nodes`);
          setViewerStatus(`Deleted ${rootIds.size} nodes`);
          endDrag();
          return;
        }
        
        // --- Single node bin delete (original) ---
        const srcId = DND.dragging.id;
        if(!srcId){
          console.error('Delete failed: srcId is null');
          endDrag();
          return;
        }
        
        // Show confirmation dialog
        const srcNode = IDX?.nodeById?.get(srcId);
        const srcType = srcNode?.type === 'field' ? 'field' : 'group';
        const srcLabel = srcNode?.label || srcId;
        if(!await customConfirm(`Delete ${srcType} "${srcLabel}" (${srcId})? This will remove related mappings too.`)){
          endDrag();
          return;
        }
        
        try{
          // If nothing is selected, lock the dragged node so the undo snapshot captures it
          if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
            state.lockedId = srcId;
          }
          recordChange(); // Save state before delete
          
          // Delete the node - get colId with fallback
          let srcColId = null;
          if(DND.dragging && DND.dragging.colId){
            srcColId = DND.dragging.colId;
          } else {
            // Fallback: derive from node ID (format: colId.rest)
            const dotIndex = srcId.indexOf('.');
            srcColId = dotIndex > 0 ? srcId.substring(0, dotIndex) : srcId;
          }
          
          if(!srcColId){
            console.error('Delete failed: Could not determine srcColId from', srcId);
            endDrag();
            return;
          }
          
          const srcCol = findColumnById(srcColId);
          if(srcCol && srcCol.schema){
            const loc = locateNode(srcCol.schema, srcId);
            if(loc && loc.siblings && loc.idx != null){
              loc.siblings.splice(loc.idx, 1);
              // Remove any mappings involving this node
              if(state.data && Array.isArray(state.data.mappings)){
                state.data.mappings = state.data.mappings.filter(m => 
                  m && m.from !== srcId && m.to !== srcId && 
                  (!Array.isArray(m.to) || !m.to.includes(srcId))
                );
              }
              // Clear selection
              state.lockedId = null;
              state.hoverId = null;
              state.selectedEdgeId = null;
              
              try{ syncJsonAreaFromObj(); }catch(e){}
              renderAll();
              if(typeof applyHighlight==='function') applyHighlight();
              setViewerStatus('Deleted: ' + srcId);
            } else {
              console.error('Delete failed: Could not locate node', srcId);
            }
          } else {
            console.error('Delete failed: Could not find column', srcColId);
          }
        }catch(err){ 
          console.error('Delete failed:', err);
          console.error('Stack:', err.stack);
        }
        
        endDrag();
      });
    }
  }
  
  function showDropZones(isMove){
    ensureDropZones();
    cancelZone.classList.add('visible');
    if(isMove){
      binZone.classList.add('visible');
    } else {
      binZone.classList.remove('visible');
    }
  }
  
  function hideDropZones(){
    if(cancelZone) cancelZone.classList.remove('visible', 'dragover');
    if(binZone) binZone.classList.remove('visible', 'dragover');
  }

  function clearHover(){ if(DND.overEl){ DND.overEl.classList.remove('dropTarget','moveIntent','mapIntent','copyIntent','illegal'); } hideDropLine(); hideTip(); }

  function beginDrag(row, e){
    const id = row?.dataset?.nodeId; const colId = row?.dataset?.columnId; if(!id||!colId) return false; const n=IDX?.nodeById?.get(id); if(!n) return false;
    DND.dragging = { id, colId, type: n.type };
    DND.dropHandled = false;
    DND.multiIds = null;
    DND.multiFields = null;
    row.classList.add('dragging');

    // --- Multi-select drag detection ---
    if(state.multiSelection.size >= 2 && state.multiSelection.has(id)){
      // Compute deduplicated root set: exclude nodes whose parent is also selected
      const selSet = state.multiSelection;
      const roots = new Set();
      const fields = new Set();
      for(const nid of selSet){
        const node = IDX?.nodeById?.get(nid);
        if(!node) continue;
        // Walk up: if any ancestor is in the selection, skip (it's implicitly included)
        let dominated = false;
        let p = IDX.parentById?.get(nid);
        while(p){
          if(selSet.has(p)){ dominated = true; break; }
          p = IDX.parentById.get(p);
        }
        if(!dominated) roots.add(nid);
        if(node.type === 'field') fields.add(nid);
      }
      if(roots.size >= 2 || (roots.size === 1 && fields.size >= 2)){
        DND.multiIds = roots;
        DND.multiFields = fields;
      }
    }

    // Build ghost
    try{
      const ghost = row.cloneNode(true); ghost.classList.add('dndGhost');
      ghost.style.width = row.getBoundingClientRect().width + 'px'; (document.getElementById('dndOverlay')||document.body).appendChild(ghost); DND.ghost = ghost;
      requestAnimationFrame(()=>{ ghost.style.opacity='1'; ghost.style.transform='scale(1)'; });
      e.dataTransfer.setDragImage(ghost, Math.min(24, ghost.getBoundingClientRect().width*0.15), 12);
    }catch(err){}
    // Show drop zones (bin only for move initially, will update in dragover)
    showDropZones(false);
    const multiInfo = DND.multiIds ? ` (${DND.multiIds.size} nodes)` : '';
    setViewerStatus('Dragging: ' + id + multiInfo + '  modifiers: Alt=Map, Ctrl=Copy, Ctrl+Alt=COPY+');
    return true;
  }
  function endDrag(){ document.querySelectorAll('.row.dragging').forEach(r=>r.classList.remove('dragging')); try{ if(DND.ghost && DND.ghost.parentNode){ DND.ghost.style.opacity='0'; DND.ghost.style.transform='scale(.98)'; setTimeout(()=>{ try{DND.ghost.remove();}catch(e){} }, 120);} }catch(err){}
    DND.ghost=null; clearHover(); DND.dragging=null; DND.intent=null; DND.overEl=null; DND.multiIds=null; DND.multiFields=null; hideTip(); hideDropZones(); }

  // Utilities for moves/copies between columns
  function findColumnById(colId){ return (state.data?.columns||[]).find(c=>c&&c.id===colId); }
  function locateNode(root, targetId, parent=null){ if(!root) return null; if(root.id===targetId) return { node: root, parent, idx:null, siblings:null}; const kids=root.children||[]; for(let i=0;i<kids.length;i++){ const ch=kids[i]; if(ch&&ch.id===targetId) return { node: ch, parent: root, idx:i, siblings:kids}; const deep=locateNode(ch, targetId, root); if(deep) return deep; } return null; }
  function ensureGroup(node){ if(!node.children) node.children=[]; node.type = (node.type!=='field') ? 'group' : node.type; return node; }
  function idPartFromLabel(label){ let s=String(label||'').trim(); s=s.replace(/\s+/g,'_').replace(/[^A-Za-z0-9_]/g,'').replace(/_+/g,'_'); if(!s) s='node'; if(/^\d/.test(s)) s='n_'+s; return s; }
  function ensureUniqueId(base, taken){ let id=base, i=2; while(taken.has(id)){ id=base+'_'+i; i++; } return id; }

  function collectNodeIds(col){ const ids=new Set(); (function walk(n){ if(!n||typeof n!=='object') return; if(n.id) ids.add(n.id); (n.children||[]).forEach(walk); })(col.schema); return ids; }
  function buildSubtreeIdMap(node, oldPrefix, newPrefix, out){ if(!node||typeof node!=='object') return; const oldId=node.id; const newId=(oldId===oldPrefix)?newPrefix:(newPrefix+oldId.slice(oldPrefix.length)); out[oldId]=newId; node.id=newId; (node.children||[]).forEach(ch=>buildSubtreeIdMap(ch, oldPrefix, newPrefix, out)); }
  function replaceIdsInMappings(idMap){ if(!state.data||!Array.isArray(state.data.mappings)) return; state.data.mappings.forEach(m=>{ if(!m||typeof m!=='object') return; if(typeof m.from==='string' && idMap[m.from]) m.from=idMap[m.from]; if(typeof m.to==='string' && idMap[m.to]) m.to=idMap[m.to]; }); }

  
  // --- Toast helpers ---
  function ensureToast(){
    let t = document.getElementById('ms_toast');
    if(!t){
      t = document.createElement('div'); t.id='ms_toast';
      t.style.position='fixed'; t.style.right='16px'; t.style.bottom='16px';
      t.style.zIndex='99999'; t.style.maxWidth='46vw'; t.style.padding='10px 12px';
      t.style.border='1px solid rgba(255,255,255,.14)'; t.style.borderRadius='12px';
      t.style.background='rgba(11,16,32,.96)'; t.style.color='rgba(232,238,252,.96)';
      t.style.font='12px var(--sans)'; t.style.boxShadow='0 18px 55px rgba(0,0,0,.55)';
      t.style.opacity='0'; t.style.transform='translateY(6px)';
      t.style.transition='opacity .16s ease, transform .16s ease';
      (document.getElementById('dndOverlay')||document.body).appendChild(t);
    }
    return t;
  }
  function showToast(msg){
    try{
      const t = ensureToast();
      t.textContent = msg;
      requestAnimationFrame(()=>{ t.style.opacity='1'; t.style.transform='translateY(0)'; });
      clearTimeout(window.__ms_toast_timer);
      window.__ms_toast_timer = setTimeout(()=>{ try{ t.style.opacity='0'; t.style.transform='translateY(6px)'; }catch(e){} }, 2200);
    }catch(e){}
  }

  // --- Copy edges preference & helper ---
  const COPY_EDGES_PREF_KEY = 'ms_v192_copy_edges'; // 'structure' | 'structure_edges' | 'ask'
  function getCopyEdgesPref(){
    try{ const v = localStorage.getItem(COPY_EDGES_PREF_KEY); return (v==='structure' || v==='structure_edges' || v==='ask') ? v : 'structure'; }catch(e){ return 'structure'; }
  }
  function setCopyEdgesPref(v){ try{ localStorage.setItem(COPY_EDGES_PREF_KEY, v); }catch(e){} }
  function duplicateEdgesByIdMap(idMap){
    if(!state || !state.data || !Array.isArray(state.data.mappings)) return 0;
    const out = [];
    const hasPair = (from,to)=> (state.data.mappings||[]).some(m=>m && m.from===from && m.to===to);
    for(const m of (state.data.mappings||[])){
      if(!(m && typeof m==='object')) continue;
      const nf = idMap[m.from] || null; const nt = idMap[m.to] || null;
      if(!nf && !nt) continue; // mapping not touching subtree
      const from2 = nf || m.from; const to2 = nt || m.to;
      if(from2===m.from && to2===m.to) continue;
      if(hasPair(from2,to2)) continue;
      const clone = Object.assign({}, m, { from: from2, to: to2 });
      out.push(clone);
    }
    if(out.length){ (state.data.mappings = state.data.mappings || []).push(...out); }
    return out.length;
  }
function cloneNodeDeep(node){ return JSON.parse(JSON.stringify(node)); }

  function performMoveOrCopy({kind, srcId, targetId, targetColId, where, copyEdges=false}){
  // If nothing is selected, lock the dragged node so the undo snapshot captures it
  // (otherwise undoing a drag on an unselected node leaves nothing selected)
  if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
    state.lockedId = srcId;
  }
  // Save state BEFORE any modifications
  recordChange();
  
  // Block dropping into any descendant of self (all actions)
  { let p=IDX.parentById?.get(targetId); while(p){ if(p===srcId) return null; p = IDX.parentById?.get(p); } }
  if(!state||!state.data) return;
  if(!srcId||!targetId) return;
  // Self-drop: move always blocked; copy allowed before/after but not into
  if(srcId===targetId){
    if(kind==='copy'){
      if(where==='into') return null;
    } else {
      return null;
    }
  }
  const srcColId = (srcId.split('.')[0]||srcId);
  const srcCol = findColumnById(srcColId); const tgtCol = findColumnById(targetColId);
  if(!srcCol||!tgtCol) return;
  const srcLoc = locateNode(srcCol.schema, srcId); const tgtLoc0 = locateNode(tgtCol.schema, targetId);
  if(!srcLoc||!tgtLoc0) return;
  const movingNode = (kind==='copy') ? cloneNodeDeep(srcLoc.node) : srcLoc.node;
  const oldParentId = srcLoc.parent ? srcLoc.parent.id : null;
  // Remove source first for MOVE so target indices are computed on the final array
  if(kind!=='copy'){ if(srcLoc.parent && srcLoc.siblings && srcLoc.idx!=null) srcLoc.siblings.splice(srcLoc.idx,1); }
  // Recompute target AFTER possible removal to avoid index drift
  const tgtLoc = locateNode(tgtCol.schema, targetId); if(!tgtLoc) return;
  // Insert node at target
  if(where==='into'){
    ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(movingNode);
  } else {
    const sib=tgtLoc.siblings, idx=tgtLoc.idx;
    if(!sib||idx==null){ ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(movingNode); }
    else { let insertIndex = idx + (where==='after'?1:0); if(insertIndex<0) insertIndex=0; if(insertIndex>sib.length) insertIndex=sib.length; sib.splice(insertIndex,0,movingNode); }
  }
  // Determine new parent after insertion
  let newParentId;
  if(where==='into'){ newParentId = tgtLoc.node.id; }
  else { newParentId = tgtLoc.parent ? tgtLoc.parent.id : tgtCol.schema.id; }
  // If parent changed, column changed, or we created a copy, recompute IDs for subtree to match new location
  const parentChanged = (srcColId!==targetColId) || (oldParentId!==newParentId) || (kind==='copy');
  if(parentChanged){
    // Build taken set from siblings under the new parent (sibling-scope, not whole column)
    const __parentNode = (where==='into') ? tgtLoc.node : (tgtLoc.parent ? tgtLoc.parent : tgtCol.schema);
    const __siblings = Array.isArray(__parentNode.children) ? __parentNode.children : [];
    const taken = new Set(__siblings.map(n => n && n.id).filter(Boolean));
    // If this is a MOVE, the original node has already been removed from its old siblings;
    // do not remove the id on COPY (original still exists), otherwise we would allow a collision.
    if(kind !== 'copy') taken.delete(movingNode.id);
    const baseId = (newParentId===tgtCol.id?tgtCol.id:newParentId) + '.' + localIdSegment(movingNode.id);
    const newId = ensureUniqueId(baseId, taken);
    const idMap = {};
    const oldId = movingNode.id;
    buildSubtreeIdMap(movingNode, oldId, newId, idMap);
    if(kind!=='copy'){ replaceIdsInMappings(idMap); } else {
      if(copyEdges){ const __n = duplicateEdgesByIdMap(idMap); if(__n) try{ showToast('Cloned '+__n+' mapping'+(__n===1?'':'s')+'.'); }catch(e){} }
    }
  }
  return movingNode && movingNode.id;
}



  function describeIntent(src, intent){
    if(!intent) return '';
    const act = (intent.action==='copy_plus' ? 'COPY+' : intent.action.toUpperCase());
    const isMulti = !!(DND.multiIds && DND.multiIds.size >= 2);
    const srcLabel = isMulti ? `[${DND.multiIds.size} nodes]` : src.id;
    if(intent.kind==='map'){
      const mapCount = isMulti ? (DND.multiFields ? DND.multiFields.size : 0) : 1;
      return `${srcLabel}  ${intent.targetId}   MAP${isMulti ? ' '+mapCount : ''}`;
    }
    if(intent.kind==='before'||intent.kind==='after') return `${act} ${srcLabel} ${intent.kind} ${intent.targetId}`;
    if(intent.kind==='into') return `${act} ${srcLabel} into ${intent.targetId}`;
    return '';
  }

  function computeAction(mod){
    if(mod && (mod.ctrlKey||mod.metaKey) && mod.altKey) return 'copy_plus';
    if(mod && mod.altKey) return 'map';
    if(mod && (mod.ctrlKey||mod.metaKey)) return 'copy';
    return 'move';
  }

  function computeIntent(src, targetRow, clientX, clientY, mod){
    if(!targetRow) return null; const tid=targetRow.dataset.nodeId; const tcol=targetRow.dataset.columnId; const tnode = IDX?.nodeById?.get(tid); if(!tid||!tcol||!tnode) return null;
    const action = computeAction(mod);
    const isMulti = !!(DND.multiIds && DND.multiIds.size >= 2);

    // --- Multi-select validity checks ---
    if(isMulti){
      const selSet = state.multiSelection;
      if(action === 'map'){
        // MAP: target must not be in the selected set
        if(selSet.has(tid)) return null;
        // Only fields can be mapped
        if(tnode.type !== 'field') return null;
        // Need at least one field in selection
        if(!DND.multiFields || DND.multiFields.size === 0) return null;
        return { action, kind:'map', targetId: tid, targetColId: tcol };
      }
      // MOVE / COPY / COPY+: target must not be inside any selected subtree
      // Walk up from target: if a proper ancestor is selected, always block (inside subtree)
      { let p = IDX.parentById?.get(tid);
        while(p){
          if(selSet.has(p)) return null; // target is inside a selected node's subtree
          p = IDX.parentById?.get(p);
        }
      }
      // Determine landing position
      const r = targetRow.getBoundingClientRect(); const y=clientY - r.top; const h=r.height||1; const third=h/3;
      let kind; if(y<third) kind='before'; else if(y>2*third) kind='after'; else kind = (tnode.type!=='field') ? 'into' : 'after';
      // If target itself is a selected node:
      // Move: block entirely. Copy/Copy+: allow before/after, block into.
      if(selSet.has(tid)){
        if(action === 'copy' || action === 'copy_plus'){
          if(kind === 'into') return null;
        } else {
          return null;
        }
      }
      return {action, kind, targetId: tid, targetColId: tcol};
    }

    // --- Single-node validity checks ---
    // Block dropping into any descendant of self (all actions)
    { let p = IDX.parentById?.get(tid); while(p){ if(p === src.id) return null; p = IDX.parentById?.get(p); } }

    // Mapping (fieldfield only)
    if(action==='map'){
      if(src.type==='field' && tnode.type==='field' && src.id!==tid) return {action, kind:'map', targetId: tid, targetColId: tcol};
      return null;
    }

    // Moving/copying nodes
    // Decide landing position based on vertical thirds
    const r = targetRow.getBoundingClientRect(); const y=clientY - r.top; const h=r.height||1; const third=h/3;
    let kind; if(y<third) kind='before'; else if(y>2*third) kind='after'; else kind = (tnode.type!=='field') ? 'into' : 'after';

    // Self-drop rules:
    // Move onto self: always blocked
    // Copy/Copy+ before/after self: allowed (duplicate in place)
    // Copy/Copy+ into self: blocked (recursive)
    if(src.id === tid){
      if(action === 'copy' || action === 'copy_plus'){
        if(kind === 'into') return null; // block copy into self
      } else {
        return null; // block move onto self entirely
      }
    }

    return {action, kind, targetId: tid, targetColId: tcol};
  }

  function performDrop(src, intent){
    if(!src || !intent) return;
    const isMulti = !!(DND.multiIds && DND.multiIds.size >= 2);

    // === MULTI-SELECT DROP ===
    if(isMulti){
      // --- Multi MAP ---
      if(intent.action==='map' && intent.kind==='map'){
        const fieldIds = DND.multiFields;
        if(!fieldIds || fieldIds.size === 0) return;
        pushUndo();
        let created = 0;
        for(const fid of fieldIds){
          const exists = (state.data.mappings||[]).some(m=> m && m.from===fid && m.to===intent.targetId);
          if(!exists){
            state.data.mappings = state.data.mappings || [];
            state.data.mappings.push({ from: fid, to: intent.targetId, cardinality:'', transforms:[], note:'', default:'' });
            created++;
          }
        }
        markDirty();
        renderAll();
        // Switch selection to the target
        state.multiSelection.clear();
        state.lockedId = intent.targetId;
        state.hoverId = null;
        state.selectedColumnId = null;
        state.selectedEdgeId = null;
        applyHighlight();
        scrollIntoView(intent.targetId);
        savePostSelection(); // Remember post-action selection for redo
        showToast(`Mapped ${created} field${created===1?'':'s'}  ${intent.targetId}`);
        setViewerStatus(`Created ${created} mapping${created===1?'':'s'}  ${intent.targetId}`);
        return;
      }

      // --- Multi MOVE / COPY / COPY+ ---
      const op = (intent.action==='copy' || intent.action==='copy_plus') ? 'copy' : 'move';
      const wantCopyEdges = (intent.action==='copy_plus');
      const rootIds = DND.multiIds;

      // Sort roots in visual/tree order: collect from all columns in order
      const orderedRoots = [];
      for(const col of (state.data?.columns||[])){
        if(!col || !col.schema) continue;
        (function walk(n){
          if(!n) return;
          if(rootIds.has(n.id)) orderedRoots.push(n.id);
          (n.children||[]).forEach(walk);
        })(col.schema);
      }

      pushUndo();
      const newIds = [];
      // For MOVE: process in reverse order to avoid index shift issues during removal,
      // then insert in forward order at the target position
      if(op === 'move'){
        // Phase 1: Remove all source nodes (reverse order)
        const removedNodes = new Map(); // id  { node, colId }
        for(let i = orderedRoots.length - 1; i >= 0; i--){
          const nid = orderedRoots[i];
          const srcColId = nid.split('.')[0] || nid;
          const srcCol = findColumnById(srcColId);
          if(!srcCol) continue;
          const loc = locateNode(srcCol.schema, nid);
          if(loc && loc.siblings && loc.idx != null){
            const removed = loc.siblings.splice(loc.idx, 1)[0];
            removedNodes.set(nid, { node: removed, colId: srcColId });
          }
        }
        // Phase 2: Insert at target in forward order
        for(const nid of orderedRoots){
          const entry = removedNodes.get(nid);
          if(!entry) continue;
          // Re-locate target after previous insertions
          const tgtCol = findColumnById(intent.targetColId);
          if(!tgtCol) continue;
          const tgtLoc = locateNode(tgtCol.schema, intent.targetId);
          if(!tgtLoc) continue;
          const movingNode = entry.node;
          const oldParentId = entry.colId; // approximate
          if(intent.kind==='into'){
            ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(movingNode);
          } else {
            const sib=tgtLoc.siblings, idx=tgtLoc.idx;
            if(!sib||idx==null){ ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(movingNode); }
            else {
              // Insert after previous insertions: first root goes before/after target, subsequent go after each previous
              let insertIndex;
              if(newIds.length === 0){
                insertIndex = idx + (intent.kind==='after'?1:0);
              } else {
                // Find last inserted node and place after it
                const lastInserted = newIds[newIds.length-1];
                const lastIdx = sib.findIndex(n => n && n.id === lastInserted);
                insertIndex = lastIdx >= 0 ? lastIdx + 1 : idx + (intent.kind==='after'?1:0);
              }
              if(insertIndex<0) insertIndex=0; if(insertIndex>sib.length) insertIndex=sib.length;
              sib.splice(insertIndex, 0, movingNode);
            }
          }
          // Rewrite IDs to new location
          const newParentId = (intent.kind==='into') ? tgtLoc.node.id : (tgtLoc.parent ? tgtLoc.parent.id : tgtCol.schema.id);
          const srcColId = entry.colId;
          if(srcColId !== intent.targetColId || true){
            // Get siblings for uniqueness check
            const __parentNode = (intent.kind==='into') ? tgtLoc.node : (tgtLoc.parent ? tgtLoc.parent : tgtCol.schema);
            const __siblings = Array.isArray(__parentNode.children) ? __parentNode.children : [];
            const taken = new Set(__siblings.map(n => n && n.id).filter(Boolean));
            taken.delete(movingNode.id);
            const baseId = (newParentId===tgtCol.id?tgtCol.id:newParentId) + '.' + localIdSegment(movingNode.id);
            const newId = ensureUniqueId(baseId, taken);
            const idMap = {};
            buildSubtreeIdMap(movingNode, movingNode.id, newId, idMap);
            replaceIdsInMappings(idMap);
          }
          newIds.push(movingNode.id);
        }
      } else {
        // COPY / COPY+: clone and insert in forward order
        for(const nid of orderedRoots){
          const srcColId = nid.split('.')[0] || nid;
          const srcCol = findColumnById(srcColId);
          if(!srcCol) continue;
          const srcLoc = locateNode(srcCol.schema, nid);
          if(!srcLoc) continue;
          const clone = cloneNodeDeep(srcLoc.node);
          // Re-locate target after previous insertions
          const tgtCol = findColumnById(intent.targetColId);
          if(!tgtCol) continue;
          const tgtLoc = locateNode(tgtCol.schema, intent.targetId);
          if(!tgtLoc) continue;
          if(intent.kind==='into'){
            ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(clone);
          } else {
            const sib=tgtLoc.siblings, idx=tgtLoc.idx;
            if(!sib||idx==null){ ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(clone); }
            else {
              let insertIndex;
              if(newIds.length === 0){
                insertIndex = idx + (intent.kind==='after'?1:0);
              } else {
                const lastInserted = newIds[newIds.length-1];
                const lastIdx = sib.findIndex(n => n && n.id === lastInserted);
                insertIndex = lastIdx >= 0 ? lastIdx + 1 : idx + (intent.kind==='after'?1:0);
              }
              if(insertIndex<0) insertIndex=0; if(insertIndex>sib.length) insertIndex=sib.length;
              sib.splice(insertIndex, 0, clone);
            }
          }
          // Rewrite IDs
          const newParentId = (intent.kind==='into') ? tgtLoc.node.id : (tgtLoc.parent ? tgtLoc.parent.id : tgtCol.schema.id);
          const __parentNode = (intent.kind==='into') ? tgtLoc.node : (tgtLoc.parent ? tgtLoc.parent : tgtCol.schema);
          const __siblings = Array.isArray(__parentNode.children) ? __parentNode.children : [];
          const taken = new Set(__siblings.map(n => n && n.id).filter(Boolean));
          const baseId = (newParentId===tgtCol.id?tgtCol.id:newParentId) + '.' + localIdSegment(clone.id);
          const newId = ensureUniqueId(baseId, taken);
          const idMap = {};
          buildSubtreeIdMap(clone, clone.id, newId, idMap);
          if(wantCopyEdges){
            const __n = duplicateEdgesByIdMap(idMap);
            if(__n) try{ showToast('Cloned '+__n+' mapping'+(__n===1?'':'s')+'.'); }catch(e){}
          }
          newIds.push(clone.id);
        }
      }

      // Finalize
      markDirty();
      try{ syncJsonAreaFromObj(); }catch(e){}
      renderAll();
      // Update multi-selection to the new nodes
      state.multiSelection.clear();
      if(newIds.length === 1){
        state.lockedId = newIds[0];
      } else {
        for(const nid of newIds) state.multiSelection.add(nid);
        state.lockedId = null;
      }
      state.hoverId = null;
      applyHighlight();
      if(newIds.length > 0) scrollIntoView(newIds[0]);
      savePostSelection(); // Remember post-action selection for redo
      const opLabel = op==='copy' ? (wantCopyEdges ? 'Copied+' : 'Copied') : 'Moved';
      showToast(`${opLabel} ${orderedRoots.length} node${orderedRoots.length===1?'':'s'}`);
      setViewerStatus(`${opLabel} ${orderedRoots.length} node${orderedRoots.length===1?'':'s'}: ${describeIntent(src,intent)}`);
      return;
    }

    // === SINGLE-NODE DROP (original logic) ===
    // If nothing is selected, lock the dragged node so the undo snapshot captures it
    if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
      state.lockedId = src.id;
    }
    if(intent.action==='map' && intent.kind==='map'){ hideDropLine && hideDropLine(); ensureMapping(src.id, intent.targetId); renderAll(); const ee=(IDX&&IDX.edges)?IDX.edges.find(e=>e.from===src.id && e.to===intent.targetId):null; if(ee){ selectEdge(ee.id); } else { applyHighlight(); } return; }
    if(!src || !intent) return;
    if(intent.action==='map' && intent.kind==='map'){
      ensureMapping(src.id, intent.targetId);
      renderAll(); const ee = (IDX && IDX.edges) ? IDX.edges.find(e=>e.from===src.id && e.to===intent.targetId) : null; if(ee){ selectEdge(ee.id); setViewerStatus('Created mapping: '+ee.from+'  '+ee.to);} else { applyHighlight(); }
      return;
    }
    // Move or Copy
    const wantCopyEdges = (intent.action==='copy_plus');
    const op = (intent.action==='copy' || intent.action==='copy_plus') ? 'copy' : 'move';
    const __newId = performMoveOrCopy({kind: op, srcId: src.id, targetId: intent.targetId, targetColId: intent.targetColId, where: intent.kind, copyEdges: wantCopyEdges});
    try{ syncJsonAreaFromObj(); }catch(e){}
    renderAll(); const __focus = __newId || src.id; lockSelection(__focus); scrollIntoView(__focus); savePostSelection(); setViewerStatus((op==='copy'?'Copied':'Moved')+': '+describeIntent(src,intent));
  }

  function onDragStart(e){ if(!state.editorMode){ e.preventDefault(); return; } const row=e.target.closest('.row'); if(!row) return; if(!beginDrag(row,e)){ e.preventDefault(); return; } try{ e.dataTransfer.setData('text/plain', row.dataset.nodeId||''); e.dataTransfer.effectAllowed='all'; }catch(err){} }
  function onDragEnd(){ 
    // macOS fallback: if drop wasn't handled but we have a valid intent, perform it now
    // (macOS blocks drop event when Cmd is held, but dragend still fires)
    if(isMacOS && !DND.dropHandled && DND.dragging && DND.intent && DND.overEl){
      try{
        performDrop(DND.dragging, DND.intent);
      }catch(err){ console.error('Fallback drop failed:', err); }
    }
    endDrag(); 
  }
  function onDragOver(e){ if(!state.editorMode || !DND.dragging) return; const row=e.target.closest('.row'); if(!row) return; 
    // Store modifier state for macOS compatibility (modifiers may not be available in drop event)
    if(isMacOS) DND.lastModifiers = {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, shiftKey:e.shiftKey};
    const modifiers = isMacOS && DND.lastModifiers ? DND.lastModifiers : {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, shiftKey:e.shiftKey};
    const intent=computeIntent(DND.dragging, row, e.clientX, e.clientY, modifiers); 
    // Update bin zone visibility based on modifier keys (not intent validity  bin should show
    // even when hovering illegal targets so the user can still drag to the bin)
    const actionFromKeys = computeAction(modifiers);
    const isMove = (actionFromKeys !== 'copy' && actionFromKeys !== 'copy_plus' && actionFromKeys !== 'map');
    if(binZone) binZone.classList.toggle('visible', isMove);
    if(!intent){ try{e.dataTransfer.dropEffect='none';}catch(err){} if(DND.overEl){ DND.overEl.classList.add('illegal'); } return; } e.preventDefault(); if(DND.overEl!==row){ if(DND.overEl) DND.overEl.classList.remove('dropTarget','moveIntent','mapIntent','copyIntent','illegal'); DND.overEl=row; }
    row.classList.remove('illegal'); row.classList.add('dropTarget'); row.classList.toggle('mapIntent', intent.action==='map'); row.classList.toggle('moveIntent', intent.action!=='map' && intent.action!=='copy' && intent.action!=='copy_plus'); row.classList.toggle('copyIntent', intent.action==='copy'); row.classList.toggle('copyPlusIntent', intent.action==='copy_plus');
    if(intent.action==='map'){ hideDropLine(); } else if(intent.kind==='before'||intent.kind==='after'){ showDropLineAt(row, intent.kind); } else { hideDropLine(); }
    DND.intent=intent; setViewerStatus(describeIntent(DND.dragging, intent)); }
  function onDrop(e){ if(!state.editorMode || !DND.dragging) return; const row=e.target.closest('.row'); if(!row) return; 
    // Use stored modifiers from dragover on macOS (may not be available in drop event)
    const modifiers = (isMacOS && DND.lastModifiers) ? DND.lastModifiers : {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, shiftKey:e.shiftKey};
    const intent=computeIntent(DND.dragging, row, e.clientX, e.clientY, modifiers); if(!intent) return; e.preventDefault(); 
    DND.dropHandled = true;
    DND.intent=intent; performDrop(DND.dragging, intent); endDrag(); }

  // Hook createNodeElement to make rows draggable
  const __orig_createNodeElement = window.createNodeElement;
  window.createNodeElement = function(node, columnId){ const el = __orig_createNodeElement(node, columnId); const row = el.querySelector(':scope > .row'); if(row){ row.setAttribute('draggable','true'); row.addEventListener('dragstart', onDragStart); row.addEventListener('dragend', onDragEnd); row.addEventListener('dragover', onDragOver); row.addEventListener('drop', onDrop); } return el; };

  // Document-level dragover: show bin zone when cursor is outside any row during move drag
  document.addEventListener('dragover', (e)=>{
    if(!DND.dragging) return;
    const row = e.target.closest('.row');
    if(row) return; // row-level handler manages bin in this case
    // Outside any row  show/hide bin based on modifier keys
    const mod = {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, shiftKey:e.shiftKey};
    const action = computeAction(mod);
    const isMove = (action !== 'copy' && action !== 'copy_plus' && action !== 'map');
    if(binZone) binZone.classList.toggle('visible', isMove);
    // Clear any stale row hover styling
    if(DND.overEl){ DND.overEl.classList.remove('dropTarget','moveIntent','mapIntent','copyIntent','copyPlusIntent','illegal'); DND.overEl = null; }
    hideDropLine();
  });

})();

;


/* === Custom drag ghost with action chip (visual-only)  disables native badge === */
(function(){
  function markRowsDraggable(on){
    try{ columnsRow.querySelectorAll('.node .row')
      .forEach(r=>r.setAttribute('draggable', on?'true':'false')); }catch(e){}
  }
  if(editorModeToggle && !editorModeToggle.__ghostWired3){
    editorModeToggle.__ghostWired3 = true;
    editorModeToggle.addEventListener('change', ()=>markRowsDraggable(!!editorModeToggle.checked));
    markRowsDraggable(!!editorModeToggle.checked);
  }
  try{
    const mo = new MutationObserver(()=>{
      if(editorModeToggle && editorModeToggle.checked) markRowsDraggable(true);
    });
    mo.observe(columnsRow, {childList:true, subtree:true});
  }catch(e){}

  let ghostEl=null, ghostRow=null, savedTitle=null, dragging=false;
  function ensureGhost(){
    if(!ghostEl){
      ghostEl = document.createElement('div');
      ghostEl.id='dragGhost';
      ghostEl.innerHTML = '<div class="top"><span class="chip move" id="ghostOp">MOVE</span><span class="multiBadge" id="ghostMulti"></span><span class="label" id="ghostLabel"></span></div><div class="body" id="ghostBody"></div>';
      (document.getElementById('dndOverlay')||document.body).appendChild(ghostEl);
    }
    return ghostEl;
  }
  function setOpChip(evt){
    const op = ((evt.ctrlKey||evt.metaKey) && evt.altKey) ? 'copyPlus' : (evt.altKey ? 'map' : ((evt.ctrlKey||evt.metaKey) ? 'copy':'move'));
    const chip = document.getElementById('ghostOp'); if(!chip) return;
    chip.className = 'chip ' + op;
    chip.textContent = (op==='copyPlus' ? 'COPY+' : (op==='map' ? 'MAP' : op.toUpperCase()));
    // Update multi badge
    const multiBadge = document.getElementById('ghostMulti');
    if(multiBadge){
      const dnd = window.__DND_MULTI || null;
      const isMulti = dnd && dnd.multiIds && dnd.multiIds.size >= 2;
      if(isMulti){
        const count = (op === 'map' && dnd.multiFields) ? dnd.multiFields.size : dnd.multiIds.size;
        multiBadge.textContent = '' + count;
        multiBadge.style.display = '';
      } else {
        multiBadge.textContent = '';
        multiBadge.style.display = 'none';
      }
    }
  }
  function showGhostFromRow(row, evt){
    const el = ensureGhost();
    const labelEl = row.querySelector('.label .text') || row.querySelector('.label') || row;
    document.getElementById('ghostLabel').textContent = (labelEl.textContent||'').trim();
    const bodyEl = document.getElementById('ghostBody');
    // Show multi-select summary in ghost body
    const dnd = window.__DND_MULTI || null;
    if(dnd && dnd.multiIds && dnd.multiIds.size >= 2){
      const others = dnd.multiIds.size - 1;
      bodyEl.innerHTML = `<span style="font-size:10px;opacity:.55;">+ ${others} more node${others===1?'':'s'}</span>`;
    } else {
      bodyEl.innerHTML = '';
    }
    setOpChip(evt);
    el.style.display='block';
  }
  function moveGhost(x,y){ if(!ghostEl) return; ghostEl.style.left=(x-18)+'px'; ghostEl.style.top=(y-36)+'px'; }
  function hideGhost(){ if(!ghostEl) return; ghostEl.style.display='none'; }

  function transparentDragImage(){
    const c=document.createElement('canvas'); c.width=1; c.height=1; c.getContext('2d').clearRect(0,0,1,1); return c;
  }
  function stripTitle(row){ if(!row) return; if(row.hasAttribute('title')){ savedTitle=row.getAttribute('title'); row.removeAttribute('title'); } else savedTitle=null; }
  function restoreTitle(row){ if(!row) return; if(savedTitle!==null) row.setAttribute('title', savedTitle); savedTitle=null; }

  document.addEventListener('dragstart', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const row = e.target?.closest?.('.node .row'); if(!row) return;
    try{ if(e.dataTransfer){ e.dataTransfer.setDragImage(transparentDragImage(), 0, 0); e.dataTransfer.effectAllowed='all'; } }catch(_){ }
    dragging=true; ghostRow=row; showGhostFromRow(row, e); stripTitle(row); moveGhost(e.clientX, e.clientY);
  }, {passive:true});

  document.addEventListener('dragover', (e)=>{
    if(!dragging) return; e.preventDefault(); moveGhost(e.clientX, e.clientY); setOpChip(e);
  }, {passive:false});

  function endDrag(e){ if(!dragging) return; dragging=false; hideGhost(); restoreTitle(ghostRow); ghostRow=null; }
  document.addEventListener('drop', endDrag, {passive:false});
  document.addEventListener('dragend', endDrag, {passive:true});
})();



// --- v20.5.1: Copy behavior helpers ---
if (typeof window.getCopyEdgesPref !== 'function') {
  window.getCopyEdgesPref = function(){
    try { return localStorage.getItem('ms_copy_edges_pref') || 'structure'; }
    catch(e){ return 'structure'; }
  };
}
if (typeof window.setCopyEdgesPref !== 'function') {
  window.setCopyEdgesPref = function(v){
    try { localStorage.setItem('ms_copy_edges_pref', v); } catch(e){}
    state.copyEdgesPref = v;
  };
}
async function shouldCopyEdgesForThisCopy() {
  const pref = (typeof getCopyEdgesPref==='function' ? getCopyEdgesPref() : 'structure');
  if (pref === 'structure') return false;
  if (pref === 'structure_edges') return true;
  return await customConfirm('Also copy mappings for the copied nodes?');
}
function duplicateEdgesForSubtree(idMap, data) {
  if (!data || !Array.isArray(data.mappings)) return;
  const out = [];
  const seen = new Set(data.mappings.map(m => `${m.from}${Array.isArray(m.to)?m.to[0]:m.to}`));
  for (const m of data.mappings) {
    if (!m || typeof m!=='object') continue;
    const toVal = Array.isArray(m.to) ? m.to[0] : m.to;
    const newFrom = idMap[m.from];
    const newTo   = idMap[toVal];
    if (!newFrom && !newTo) continue;
    const nm = { ...m, from: newFrom || m.from, to: newTo || toVal };
    const key = `${nm.from}${nm.to}`;
    if (!seen.has(key)) { out.push(nm); seen.add(key); }
  }
  data.mappings.push(...out);
}
// === v20.5: Empty-column placeholder (Move/Copy only) ===
(function(){
  if(window.__MS_EMPTY_DROP_INSTALLED__) return; window.__MS_EMPTY_DROP_INSTALLED__ = true;
  function colRootById(colId){ try{ return (state.data && Array.isArray(state.data.columns)) ? (state.data.columns.find(c=>c&&c.id===colId)?.schema||null) : null; }catch(_){ return null; } }
  function updateEmptyPlaceholders(){
    try{
      const panels = Array.from(document.querySelectorAll('.columnsRow .panel'));
      panels.forEach(p=>{
        const tree = p.querySelector(':scope > .tree');
        const isEmpty = !(tree && tree.querySelector('.node'));
        if(isEmpty){
          p.setAttribute('data-empty','1');
          if(tree && !tree.querySelector(':scope > .emptyDrop')){
            const ph = document.createElement('div'); ph.className='emptyDrop'; ph.textContent='Drop here to place at root';
            tree.appendChild(ph);
          }
        } else {
          p.removeAttribute('data-empty');
          const ph = tree && tree.querySelector(':scope > .emptyDrop'); if(ph) ph.remove();
        }
      });
    }catch(_){ }
  }
  // Run after renders
  const _mo = new MutationObserver(()=>{ updateEmptyPlaceholders(); });
  try{ _mo.observe(document.getElementById('columnsRow'), {childList:true, subtree:true}); }catch(_){}
  document.addEventListener('DOMContentLoaded', updateEmptyPlaceholders, {once:true});
  // Populate contact email (split to avoid Cloudflare email obfuscation)
  const _ce = document.getElementById('dunnodeContact');
  if(_ce){ _ce.textContent = 'hello' + '\x40' + 'dunnode.com'; _ce.addEventListener('click', ()=>{ location.href = 'mai' + 'lto:' + _ce.textContent; }); }

  // Global ESC key handler to reset selection
  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape'){
      // Reset edge and node selection
      if(state.selectedEdgeId || state.hoverEdgeId || state.lockedId || state.hoverId){
        state.selectedEdgeId = null;
        state.hoverEdgeId = null;
        state.lockedId = null;
        state.hoverId = null;
        // Clear any edit session in editor mode
        if(state.editorMode){
          try{ clearEdgeEditSession({clearSelection:true}); }catch(e){}
        }
        renderAll();
        applyHighlight();
      }
    }
  });

  // Helper: get current intent from modifiers
  function currentIntent(e){ return e.altKey ? 'map' : ((e.ctrlKey||e.metaKey) ? 'copy' : 'move'); }
  
  // Detect macOS for drag-and-drop workarounds
  const isMacOSEmpty = /Mac|iPhone|iPad|iPod/.test(navigator.platform) || /Mac|iPhone|iPad|iPod/.test(navigator.userAgent);
  
  // Store last modifier state for macOS compatibility
  let lastEmptyPanelModifiers = null;

  // Ensure we always set a node id on dragstart for rows
  document.addEventListener('dragstart', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const row = e.target && e.target.closest && e.target.closest('.node .row'); if(!row) return;
    const nodeId = row.dataset.nodeId || '';
    try{ if(e.dataTransfer){ e.dataTransfer.setData('text/x-node-id', nodeId); if(!e.dataTransfer.getData('text/plain')) e.dataTransfer.setData('text/plain', nodeId); e.dataTransfer.effectAllowed='all'; } }catch(_){ }
  });

  // Show placeholder on empty panel for move/copy; hide for map
  document.addEventListener('dragover', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const panel = e.target && e.target.closest && e.target.closest('.panel'); if(!panel) return;
    if(panel.getAttribute('data-empty') !== '1') return;
    // Store modifier state for macOS compatibility
    if(isMacOSEmpty) lastEmptyPanelModifiers = {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, metaKey:e.metaKey};
    const intent = currentIntent(e);
    if(intent==='map'){ panel.classList.remove('dropOpen'); return; }
    panel.classList.add('dropOpen');
    const tree = panel.querySelector(':scope > .tree'); const ph = tree && tree.querySelector(':scope > .emptyDrop'); if(ph){ ph.classList.remove('move','copy'); ph.classList.add(intent); }
    try{ if(e.dataTransfer){ e.dataTransfer.dropEffect = (intent==='copy' ? 'copy' : 'move'); } }catch(_){ }
    e.preventDefault();
  }, {passive:false});

  function getDraggedNodeId(e){
    let id = '';
    try{ id = e.dataTransfer && (e.dataTransfer.getData('text/x-node-id') || e.dataTransfer.getData('text/plain')) || ''; }catch(_){ id=''; }
    return (id||'').trim();
  }
  
  // Helper to get intent with fallback to stored modifiers (for macOS)
  function getIntentWithFallback(e){
    if(isMacOSEmpty && lastEmptyPanelModifiers){
      return lastEmptyPanelModifiers.altKey ? 'map' : ((lastEmptyPanelModifiers.ctrlKey||lastEmptyPanelModifiers.metaKey) ? 'copy' : 'move');
    }
    return currentIntent(e);
  }

  // Perform move/copy into empty column root on drop
  document.addEventListener('drop', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const panel = e.target && e.target.closest && e.target.closest('.panel'); if(!panel) return;
    if(panel.getAttribute('data-empty') !== '1') return;
    const intent = getIntentWithFallback(e);
    if(intent==='map') return; // not supported into empty
    const targetColId = panel.dataset.columnId; if(!targetColId) return;
    const srcId = getDraggedNodeId(e); if(!srcId) return;
    e.preventDefault();

    try{
      // If nothing is selected, lock the dragged node so the undo snapshot captures it
      if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
        state.lockedId = srcId;
      }
      recordChange(); // Save state BEFORE move to empty column
      
      const data = state.data; if(!data) return;
      const srcColId = (function(){ const i=srcId.indexOf('.'); return i>0 ? srcId.slice(0,i) : srcId; 
// --- v20.5.1: Auto-scroll while dragging (horizontal + vertical) ---
(function(){
  const sc = document.getElementById('columnsScroller');
  if(!sc) return;
  const H_MARGIN = 32;      // px from left/right edge
  const H_SPEED  = 16;      // px per event
  const V_MARGIN = 28;      // px from top/bottom inside a tree
  const V_SPEED  = 14;      // px per event

  sc.addEventListener('dragover', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const r = sc.getBoundingClientRect();
    if(e.clientX > r.right - H_MARGIN) sc.scrollLeft += H_SPEED;
    else if(e.clientX < r.left + H_MARGIN) sc.scrollLeft -= H_SPEED;
  }, {passive:false});

  // Vertical autoscroll inside individual column trees
  document.addEventListener('dragover', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const tree = e.target && e.target.closest && e.target.closest('.panel .tree');
    if(!tree) return;
    const rt = tree.getBoundingClientRect();
    if(e.clientY > rt.bottom - V_MARGIN) tree.scrollTop += V_SPEED;
    else if(e.clientY < rt.top + V_MARGIN) tree.scrollTop -= V_SPEED;
  }, {passive:false});
})();
})();
      const srcCol = data.columns.find(c=>c&&c.id===srcColId); if(!srcCol||!srcCol.schema) return;
      const targetCol = data.columns.find(c=>c&&c.id===targetColId); if(!targetCol||!targetCol.schema) return;
      const targetRoot = targetCol.schema; if(!Array.isArray(targetRoot.children)) targetRoot.children=[];

      // locate source node in its column
      function locateNode(root, targetId, parent=null){ if(!root) return null; if(root.id===targetId) return {node:root,parent,idx:null,siblings:null}; const kids=root.children||[]; for(let i=0;i<kids.length;i++){ const ch=kids[i]; if(ch&&ch.id===targetId) return {node:ch,parent:root,idx:i,siblings:kids}; const deep=locateNode(ch,targetId,root); if(deep) return deep; } return null; }

      // Unique id helpers from file scope (fallbacks if not found)
      function idPartFromLabel(label){ try{ return (label||'').toString().trim().replace(/\s+/g,'_').replace(/[^A-Za-z0-9_]/g,'').replace(/_+/g,'_')||'node'; }catch(_){ return 'node'; } }
      function ensureUniqueId(base, taken){ let id=base, i=2; while(taken.has(id)) { id = base+'_'+i++; } return id; }
      function collectIds(n, set){ if(!n) return set; set.add(n.id); (n.children||[]).forEach(ch=>collectIds(ch,set)); return set; }
      function buildSubtreeIdMap(node, oldPrefix, newPrefix, out){ if(!node) return; const oldId=node.id; const newId=(oldId===oldPrefix)?newPrefix:(newPrefix+oldId.slice(oldPrefix.length)); out[oldId]=newId; node.id=newId; (node.children||[]).forEach(ch=>buildSubtreeIdMap(ch, oldPrefix, newPrefix, out)); }
      function replaceIdsInMappings(data, idMap){ if(!data||!Array.isArray(data.mappings)) return; data.mappings.forEach(m=>{ if(!m||typeof m!=='object') return; if(typeof m.from==='string' && idMap[m.from]) m.from=idMap[m.from]; if(Array.isArray(m.to)) m.to = m.to.map(t=> (typeof t==='string' && idMap[t]) ? idMap[t] : t); else if(typeof m.to==='string' && idMap[m.to]) m.to=idMap[m.to]; }); }

      // Compute node to insert
      let nodeToInsert=null;
      if(intent==='copy'){
        const srcLoc = locateNode(srcCol.schema, srcId); if(!srcLoc||!srcLoc.node) return;
        nodeToInsert = JSON.parse(JSON.stringify(srcLoc.node));
      } else { // move
        const srcLoc = locateNode(srcCol.schema, srcId); if(!srcLoc||!srcLoc.node||!srcLoc.siblings) return;
        nodeToInsert = srcLoc.node;
        const idx = srcLoc.idx; if(idx!=null && idx>=0) srcLoc.siblings.splice(idx,1);
      }

      // Re-id subtree for target root uniqueness
      const taken = collectIds(targetRoot, new Set());
      const base = targetRoot.id + '.' + idPartFromLabel(nodeToInsert.label||'node');
      const newId = ensureUniqueId(base, taken);
      const idMap = {}; buildSubtreeIdMap(nodeToInsert, nodeToInsert.id, newId, idMap);
      if(intent==='move'){ replaceIdsInMappings(data, idMap); } else { if(shouldCopyEdgesForThisCopy()) duplicateEdgesForSubtree(idMap, data); }

      targetRoot.children.push(nodeToInsert);

      // Sync UI
      try{ if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2); }catch(_){}
      if(typeof renderAll==='function') renderAll();
      if(typeof applyHighlight==='function') applyHighlight();
      try{ if(typeof lockSelection==='function') lockSelection(newId); if(typeof scrollIntoView==='function') scrollIntoView(newId); if(typeof applyHighlight==='function') applyHighlight(); }catch(_){ }
      if(typeof setGlobalStatus==='function') setGlobalStatus((intent==='copy'?'Copied ':'Moved ') + newId + ' into empty column ' + targetColId);
    }catch(err){ console.error(err); }
  }, {passive:false});

  // Cleanup placeholder state on dragend
  document.addEventListener('dragend', ()=>{
    document.querySelectorAll('.panel.dropOpen').forEach(p=>p.classList.remove('dropOpen'));
  }, {passive:true});
})();




// --- Project title inline handler ---
(function(){
  const titleInput = document.getElementById('projectTitle');
  if(!titleInput) return;
  let __snap = '';

  function updateEditability(){
    const isEd = editorModeToggle && editorModeToggle.checked;
    titleInput.readOnly = !isEd;
    titleInput.style.cursor = isEd ? 'text' : 'default';
    titleInput.style.opacity = isEd ? '1' : '0.6';
    titleInput.title = isEd ? 'Project title (click to edit)' : 'Enable Editor mode to edit title';
  }
  if(editorModeToggle) editorModeToggle.addEventListener('change', updateEditability);
  updateEditability();

  titleInput.addEventListener('focus', ()=>{
    __snap = titleInput.value;
    titleInput.style.background = 'rgba(255,255,255,.12)';
    titleInput.style.borderColor = 'rgba(59,130,246,.55)';
  });
  titleInput.addEventListener('blur', ()=>{
    titleInput.style.background = 'rgba(255,255,255,.08)';
    titleInput.style.borderColor = 'rgba(255,255,255,.15)';
    const newVal = (titleInput.value||'').trim() || 'New Project';
    if(state.data && newVal !== __snap){
      recordChange();
      state.data.title = newVal;
      titleInput.value = newVal;
      try{ if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2); }catch(e){}
    }
  });
  titleInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){ e.preventDefault(); titleInput.blur(); }
    if(e.key === 'Escape'){ e.preventDefault(); titleInput.value = __snap; titleInput.blur(); }
  });

  // Sync __snap when undo/redo updates the input externally
  const origUndo = window.__origUndo = undo;
  const origRedo = window.__origRedo = redo;
  undo = function(){
    // Blur to commit/discard any pending inline edit before undo changes data
    if(document.activeElement === titleInput) titleInput.blur();
    origUndo();
    __snap = titleInput.value; // sync after undo updated the input
  };
  redo = function(){
    if(document.activeElement === titleInput) titleInput.blur();
    origRedo();
    __snap = titleInput.value;
  };
})();

// --- Command palette (Ctrl/Cmd+K) ---
(function(){
  const mask = document.getElementById('cmdPaletteMask');
  const palette = document.getElementById('cmdPalette');
  const input = document.getElementById('cmdPaletteInput');
  const results = document.getElementById('cmdPaletteResults');
  const openBtn = document.getElementById('cmdPaletteBtn');
  if(!mask || !input || !results) return;

  let _activeIdx = 0;
  let _flatItems = []; // current rendered items [{el, action}]

  // --- Command registry ---
  const isMac = /Mac|iPhone|iPad/.test(navigator.platform||'');
  const mod = isMac ? '' : 'Ctrl';

  const COMMANDS = [
    // Project
    { cat:'Project', icon:'', label:'New project',           action:()=> document.getElementById('newMappingBtn')?.click(), hint:'Start blank' },
    { cat:'Project', icon:'', label:'Open project',          action:()=> document.getElementById('openProjectBtn')?.click() },
    { cat:'Project', icon:'', label:'Save project',           action:()=> document.getElementById('saveProjectBtn')?.click() },
    { cat:'Project', icon:'',  label:'Project properties',    action:()=> document.getElementById('projectInfoBtn')?.click() },
    { cat:'Project', icon:'', label:'Load example project',   action:()=> document.getElementById('loadExampleBtn')?.click() },

    // Catalogs
    { cat:'Catalogs', icon:'', label:'Tag manager',           action:()=> openTags() },
    { cat:'Catalogs', icon:'', label:'Transform library',     action:()=> openTransforms() },
    { cat:'Catalogs', icon:'', label:'Attributes catalog',    action:()=> openCustomAttrs() },
    { cat:'Catalogs', icon:'', label:'Filters',               action:()=> openFilters() },
    { cat:'Catalogs', icon:'', label:'Highlight colors',      action:()=> document.getElementById('hlColorsBtn')?.click() },

    // View
    { cat:'View', icon:'', label:'Expand all groups',      action:()=> setAllGroupsCollapsed(false) },
    { cat:'View', icon:'', label:'Collapse all groups',    action:()=> setAllGroupsCollapsed(true) },
    { cat:'View', icon:'', label:'Toggle bright/dark mode', action:()=> document.getElementById('brightModeBtn')?.click() },
    { cat:'View', icon:'', label:'Toggle pan mode',         action:()=> document.getElementById('panToggleBtn')?.click(), kbd:'P' },
    { cat:'View', icon:'', label:'Clear selection',           action:()=> document.getElementById('clearSelBtn')?.click(), kbd:'Esc' },
    { cat:'View', icon:'', label:'Select all visible nodes',  action:()=> selectAllNodes(), kbd:mod+'+A' },
    { cat:'View', icon:'', label:'Invert selection',          action:()=> invertSelection(), kbd:mod+'+Shift+I' },

    // Details panel
    { cat:'View', icon:'', label:'Details panel: Left',    action:()=> setTab('left') },
    { cat:'View', icon:'', label:'Details panel: Right',   action:()=> setTab('right') },
    { cat:'View', icon:'', label:'Details panel: Bottom',  action:()=> setTab('bottom') },
    { cat:'View', icon:'', label:'Details panel: Float',   action:()=> setTab('float') },
    { cat:'View', icon:'', label:'Details panel: Hidden',  action:()=> setTab('hidden'), kbd:'D' },

    // Edit
    { cat:'Edit', icon:'', label:'Toggle editor mode',     action:()=> document.getElementById('editorModeToggle')?.click() },
    { cat:'Edit', icon:'', label:'Undo',                   action:()=> undo(), kbd:mod+'+Z' },
    { cat:'Edit', icon:'', label:'Redo',                   action:()=> redo(), kbd:mod+'+Y' },

    // Help
    { cat:'Help', icon:'', label:'Quick Start Guide',      action:()=> openHelp(), kbd:'?' },
    { cat:'Help', icon:'', label:'Documentation',          action:()=> openDocs() },
    { cat:'Help', icon:'', label:'Release notes',           action:()=> openReleaseNotes() },
    { cat:'Help', icon:'', label:'About Dunnode',           action:()=> document.getElementById('aboutBtn')?.click() },
  ];

  // --- Fuzzy match ---
  function fuzzyMatch(query, text){
    const q = query.toLowerCase();
    const t = text.toLowerCase();
    if(!q) return { match:true, score:0, ranges:[] };
    // Substring match first (stronger)
    const subIdx = t.indexOf(q);
    if(subIdx >= 0) return { match:true, score: 100 - subIdx, ranges:[[subIdx, subIdx+q.length]] };
    // Char-by-char fuzzy
    let qi = 0, score = 0;
    const ranges = [];
    let rangeStart = -1;
    for(let ti = 0; ti < t.length && qi < q.length; ti++){
      if(t[ti] === q[qi]){
        if(rangeStart < 0) rangeStart = ti;
        qi++;
        score += (ti === 0 || t[ti-1] === ' ' || t[ti-1] === '.') ? 10 : 1;
      } else {
        if(rangeStart >= 0){ ranges.push([rangeStart, ti]); rangeStart = -1; }
      }
    }
    if(rangeStart >= 0) ranges.push([rangeStart, ranges.length ? ranges[ranges.length-1][1] : rangeStart + qi]);
    if(qi < q.length) return { match:false, score:0, ranges:[] };
    return { match:true, score, ranges };
  }

  function highlightText(text, ranges){
    if(!ranges.length) return escapeHtml(text);
    let out = '', last = 0;
    for(const [s,e] of ranges){
      if(s > last) out += escapeHtml(text.slice(last, s));
      out += '<mark>' + escapeHtml(text.slice(s, e)) + '</mark>';
      last = e;
    }
    if(last < text.length) out += escapeHtml(text.slice(last));
    return out;
  }

  // --- Node search ---
  function searchNodes(query, max){
    if(!IDX || !IDX.nodeById) return [];
    const found = [];
    for(const [id, node] of IDX.nodeById.entries()){
      const label = node.label || node.id || id;
      const matchLabel = fuzzyMatch(query, label);
      const matchId = fuzzyMatch(query, id);
      const best = matchLabel.score >= matchId.score ? matchLabel : matchId;
      if(!best.match) continue;
      const colId = IDX.nodeColumnById?.get(id) || '';
      const col = IDX.columns?.find(c=>c.id===colId);
      const colLabel = col ? (col.label || col.id) : colId;
      const isField = IDX.fieldIds?.has(id);
      found.push({
        id, label, nodeId: id,
        icon: isField ? '' : '',
        hint: colLabel,
        score: best.score,
        ranges: matchLabel.score >= matchId.score ? best.ranges : [],
        labelText: label,
        idText: id,
        idRanges: matchId.score > matchLabel.score ? matchId.ranges : [],
      });
    }
    found.sort((a,b) => b.score - a.score);
    return found.slice(0, max || 20);
  }

  function selectNode(nodeId){
    if(!nodeId) return;
    // Expand all parent groups so node is visible
    let cur = nodeId;
    const toExpand = [];
    while(IDX.parentById?.has(cur)){
      cur = IDX.parentById.get(cur);
      toExpand.push(cur);
    }
    for(const gid of toExpand){
      const g = IDX.nodeById?.get(gid);
      if(g && g.__collapsed) g.__collapsed = false;
    }
    state.lockedId = nodeId;
    state.hoverId = nodeId;
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    renderAll();
    applyHighlight();
    // Scroll into view
    requestAnimationFrame(()=>{
      const el = document.querySelector(`.row[data-node-id="${CSS.escape(nodeId)}"]`);
      if(el) el.scrollIntoView({ behavior:'smooth', block:'center', inline:'center' });
    });
  }

  // --- Documentation search ---
  let _docSections = null;
  function getDocSections(){
    if(_docSections) return _docSections;
    _docSections = [];
    // Build docs if not yet built
    buildDocs();
    const body = document.getElementById('docsBody');
    if(!body) return _docSections;
    const headings = body.querySelectorAll('h2, h3');
    headings.forEach((h, i) => {
      // Collect text until next heading
      const level = h.tagName;
      const title = h.textContent.trim();
      // Generate a stable ID for scrolling
      const hId = 'doc-' + title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/,'');
      h.id = hId;
      let text = title;
      let el = h.nextElementSibling;
      while(el && el.tagName !== 'H2' && el.tagName !== 'H3'){
        text += ' ' + el.textContent.trim();
        el = el.nextElementSibling;
      }
      _docSections.push({ title, text: text.slice(0, 500), hId, level });
    });
    return _docSections;
  }

  function searchDocs(query, max){
    const sections = getDocSections();
    const found = [];
    for(const sec of sections){
      const m = fuzzyMatch(query, sec.text);
      if(!m.match) continue;
      // Find snippet around match
      const lowerText = sec.text.toLowerCase();
      const qi = lowerText.indexOf(query.toLowerCase());
      let snippet = '';
      if(qi >= 0){
        const start = Math.max(0, qi - 30);
        const end = Math.min(sec.text.length, qi + query.length + 60);
        snippet = (start > 0 ? '' : '') + sec.text.slice(start, end).trim() + (end < sec.text.length ? '' : '');
      } else {
        snippet = sec.text.slice(0, 80).trim() + (sec.text.length > 80 ? '' : '');
      }
      found.push({ ...sec, score: m.score + (sec.level === 'H2' ? 5 : 0), snippet });
    }
    found.sort((a,b) => b.score - a.score);
    return found.slice(0, max || 6);
  }

  // --- Render results ---
  function renderResults(query){
    const q = (query||'').trim();
    _flatItems = [];
    _activeIdx = 0;

    if(!q){
      // Show all commands grouped by category
      let html = '';
      let lastCat = '';
      COMMANDS.forEach((cmd, i)=>{
        if(cmd.cat !== lastCat){ html += `<div class="cmdCat">${escapeHtml(cmd.cat)}</div>`; lastCat = cmd.cat; }
        html += renderItem(cmd.icon, cmd.label, '', cmd.hint||'', cmd.kbd||'', i);
      });
      results.innerHTML = html;
      bindItems(COMMANDS.map(c => c.action));
      updateActive();
      return;
    }

    // Filter commands
    const cmdMatches = [];
    COMMANDS.forEach(cmd=>{
      const m = fuzzyMatch(q, cmd.label);
      // Also match category
      const cm = fuzzyMatch(q, cmd.cat + ' ' + cmd.label);
      const best = cm.score > m.score ? cm : m;
      if(best.match) cmdMatches.push({ ...cmd, score:best.score, ranges:m.match ? m.ranges : [] });
    });
    cmdMatches.sort((a,b) => b.score - a.score);

    // Search nodes
    const nodeMatches = searchNodes(q, 15);

    // Search documentation (only for queries of 3+ chars)
    const docMatches = q.length >= 3 ? searchDocs(q, 6) : [];

    let html = '';
    const actions = [];

    if(cmdMatches.length){
      html += '<div class="cmdCat">Commands</div>';
      cmdMatches.forEach(cmd=>{
        html += renderItem(cmd.icon, cmd.label, '', cmd.hint||'', cmd.kbd||'', actions.length, cmd.ranges);
        actions.push(cmd.action);
      });
    }

    if(nodeMatches.length){
      html += '<div class="cmdCat">Nodes & Fields</div>';
      nodeMatches.forEach(n=>{
        const displayLabel = highlightText(n.labelText, n.ranges);
        const idPart = n.idText !== n.labelText ? `<span style="opacity:.4;font-size:11px;margin-left:6px;">${highlightText(n.idText, n.idRanges)}</span>` : '';
        html += `<div class="cmdItem" data-idx="${actions.length}">
          <span class="cmdIcon" style="opacity:.4;">${n.icon}</span>
          <span class="cmdLabel">${displayLabel}${idPart}</span>
          <span class="cmdHint">${escapeHtml(n.hint)}</span>
        </div>`;
        actions.push(()=> selectNode(n.nodeId));
      });
    }

    if(docMatches.length){
      html += '<div class="cmdCat">Documentation</div>';
      docMatches.forEach(doc=>{
        const levelIcon = doc.level === 'H2' ? '' : '';
        html += `<div class="cmdItem" data-idx="${actions.length}">
          <span class="cmdIcon" style="opacity:.35;">${levelIcon}</span>
          <span class="cmdLabel">${escapeHtml(doc.title)}<br/><span style="font-size:10.5px;opacity:.45;font-weight:400;line-height:1.3;">${escapeHtml(doc.snippet)}</span></span>
        </div>`;
        actions.push(()=>{
          openDocs();
          requestAnimationFrame(()=>{
            const el = document.getElementById(doc.hId);
            if(el) el.scrollIntoView({ behavior:'smooth', block:'start' });
          });
        });
      });
    }

    results.innerHTML = html || '';
    bindItems(actions);
    updateActive();
  }

  function renderItem(icon, label, extra, hint, kbd, idx, ranges){
    const labelHtml = ranges && ranges.length ? highlightText(label, ranges) : escapeHtml(label);
    return `<div class="cmdItem" data-idx="${idx}">
      <span class="cmdIcon">${icon}</span>
      <span class="cmdLabel">${labelHtml}${extra}</span>
      ${hint ? `<span class="cmdHint">${escapeHtml(hint)}</span>` : ''}
      ${kbd ? `<span class="cmdKbd">${escapeHtml(kbd)}</span>` : ''}
    </div>`;
  }

  function bindItems(actions){
    _flatItems = [];
    results.querySelectorAll('.cmdItem').forEach(el=>{
      const idx = Number(el.dataset.idx);
      _flatItems.push({ el, action: actions[idx] });
      el.addEventListener('click', ()=>{ closePalette(); actions[idx]?.(); });
      el.addEventListener('mouseenter', ()=>{
        _activeIdx = _flatItems.indexOf(_flatItems.find(f=>f.el===el));
        updateActive();
      });
    });
  }

  function updateActive(){
    _flatItems.forEach((f,i) => f.el.classList.toggle('active', i === _activeIdx));
    const active = _flatItems[_activeIdx];
    if(active) active.el.scrollIntoView({ block:'nearest' });
  }

  // --- Open/close ---
  function openPalette(){
    input.value = '';
    renderResults('');
    mask.classList.add('active');
    requestAnimationFrame(()=> input.focus());
  }
  function closePalette(){
    mask.classList.remove('active');
    input.blur();
  }

  // Event wiring
  input.addEventListener('input', ()=> renderResults(input.value));
  input.addEventListener('keydown', (e)=>{
    if(e.key === 'ArrowDown'){ e.preventDefault(); _activeIdx = Math.min(_activeIdx+1, _flatItems.length-1); updateActive(); }
    else if(e.key === 'ArrowUp'){ e.preventDefault(); _activeIdx = Math.max(_activeIdx-1, 0); updateActive(); }
    else if(e.key === 'Enter'){ e.preventDefault(); closePalette(); _flatItems[_activeIdx]?.action?.(); }
    else if(e.key === 'Escape'){ e.preventDefault(); closePalette(); }
  });
  mask.addEventListener('click', (e)=>{ if(e.target === mask) closePalette(); });
  if(openBtn) openBtn.addEventListener('click', openPalette);

  // Global Ctrl/Cmd+K
  document.addEventListener('keydown', (e)=>{
    if((e.ctrlKey || e.metaKey) && e.key === 'k'){
      e.preventDefault();
      if(mask.classList.contains('active')) closePalette(); else openPalette();
    }
  });
})();

// --- Project properties modal ---
(function(){
  const PROJECT_FIELDS = [
    { key:'title',          label:'Title',        type:'text',     placeholder:'Project title' },
    { key:'subtitle',       label:'Subtitle',     type:'text',     placeholder:'Short subtitle' },
    { key:'author',         label:'Author',       type:'text',     placeholder:'Author name' },
    { key:'organization',   label:'Organization', type:'text',     placeholder:'Company or team' },
    { key:'contact',        label:'Contact',      type:'text',     placeholder:'Email or contact info' },
    { key:'url',            label:'URL',          type:'url',      placeholder:'https://' },
    { key:'projectVersion', label:'Version',       type:'text',     placeholder:'e.g. 1.0' },
    { key:'date',           label:'Date',         type:'date',     placeholder:'YYYY-MM-DD' },
    { key:'description',    label:'Description',  type:'textarea', placeholder:'Project description' },
  ];

  const modal = document.getElementById('projectPropsModal');
  const mask = document.getElementById('projPropsMask');
  const body = document.getElementById('projPropsBody');
  const saveBtn = document.getElementById('projPropsSave');
  const cancelBtn = document.getElementById('projPropsCancel');
  const openBtn = document.getElementById('projectInfoBtn');
  if(!modal || !body || !openBtn) return;

  let __propSnap = null;

  function propsDirty(){
    if(!__propSnap) return false;
    for(const f of PROJECT_FIELDS){
      const el = document.getElementById('pp_'+f.key);
      const v = el ? (el.value||'').trim() : '';
      if(v !== (__propSnap[f.key]||'')) return true;
    }
    return false;
  }

  async function guardedClose(){
    if(state.editorMode && propsDirty()){
      const ok = await customConfirm('Abandon unsaved changes to project properties?');
      if(!ok) return;
    }
    closeProjectProps();
  }

  function openProjectProps(){
    if(!state.data) return;
    const isEd = state.editorMode;
    // Capture snapshot of all fields
    __propSnap = {};
    PROJECT_FIELDS.forEach(f=>{ __propSnap[f.key] = state.data[f.key] || ''; });

    // Render form
    const ro = isEd ? '' : ' readonly disabled';
    const rows = PROJECT_FIELDS.map(f=>{
      const val = escapeHtml(state.data[f.key] || '');
      if(f.type==='textarea'){
        return `<div class="k">${f.label}</div><div class="v"><textarea id="pp_${f.key}" class="inp" rows="5" placeholder="${f.placeholder}" style="resize:vertical;font-size:12px;line-height:1.5;"${ro}>${val}</textarea></div>`;
      }
      return `<div class="k">${f.label}</div><div class="v"><input id="pp_${f.key}" class="inp" type="${f.type}" value="${val}" placeholder="${f.placeholder}"${ro}/></div>`;
    }).join('\n');

    body.innerHTML = `<div class="kv" style="grid-template-columns:100px 1fr;">${rows}</div>`;

    // Show read-only file metadata if present
    const appObj = state.data._app;
    const appN = (typeof appObj === 'object' && appObj) ? appObj.name : (typeof appObj === 'string' ? appObj : '');
    const appV = (typeof appObj === 'object' && appObj) ? appObj.version : (state.data._appVersion || '');
    const savedAt = state.data._savedAt || '';
    if(appN || appV || savedAt){
      const metaParts = [];
      if(appN) metaParts.push(`<span>${escapeHtml(appN)}${appV ? ' v'+escapeHtml(appV) : ''}</span>`);
      else if(appV) metaParts.push(`<span>App version: <strong>${escapeHtml(appV)}</strong></span>`);
      if(savedAt){
        let display = savedAt;
        try{ display = new Date(savedAt).toLocaleString(); }catch(e){}
        metaParts.push(`<span>Last saved: <strong>${escapeHtml(display)}</strong></span>`);
      }
      body.innerHTML += `<div style="margin-top:12px;padding-top:10px;border-top:1px solid var(--border);display:flex;gap:20px;flex-wrap:wrap;font-size:11px;opacity:.55;">${metaParts.join('')}</div>`;
    }

    // Show/hide Save button based on mode
    saveBtn.style.display = isEd ? '' : 'none';
    cancelBtn.textContent = isEd ? 'Cancel' : 'Close';

    modal.classList.add('active');
    if(mask) mask.classList.add('active');
    if(isEd){
      const first = document.getElementById('pp_title');
      if(first) setTimeout(()=> first.focus(), 100);
      wireDirtyHighlight(body, saveBtn, propsDirty);
    }
  }

  function closeProjectProps(){
    modal.classList.remove('active');
    if(mask) mask.classList.remove('active');
    __propSnap = null;
  }

  function saveProjectProps(){
    if(!state.data || !__propSnap) { closeProjectProps(); return; }
    // Read all form values
    const newVals = {};
    let changed = false;
    PROJECT_FIELDS.forEach(f=>{
      const el = document.getElementById('pp_'+f.key);
      const v = el ? (el.value||'').trim() : (__propSnap[f.key]||'');
      newVals[f.key] = v;
      if(v !== (__propSnap[f.key]||'')) changed = true;
    });
    if(changed){
      recordChange();
      PROJECT_FIELDS.forEach(f=>{ state.data[f.key] = newVals[f.key]; });
      // Sync title input in header
      const titleInput = document.getElementById('projectTitle');
      if(titleInput) titleInput.value = state.data.title || 'New Project';
      try{ if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2); }catch(e){}
      renderAll();
      setGlobalStatus('Project properties saved.');
    }
    closeProjectProps();
  }

  openBtn.addEventListener('click', openProjectProps);
  saveBtn.addEventListener('click', saveProjectProps);
  cancelBtn.addEventListener('click', guardedClose);
  if(mask) mask.addEventListener('click', guardedClose);

  // Allow Escape to cancel (with guard)
  modal.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){ e.preventDefault(); guardedClose(); }
  });
})();

</script>
</body>
</html>
