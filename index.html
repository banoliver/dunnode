<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Dunnode</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwMCIgem9vbUFuZFBhbj0ibWFnbmlmeSIgdmlld0JveD0iMCAwIDE1MDAgMTQ5OS45OTk5MzMiIGhlaWdodD0iMjAwMCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmVyc2lvbj0iMS4wIj48ZGVmcz48ZmlsdGVyIHg9IjAlIiB5PSIwJSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgaWQ9IjVmNDZiYjVkODMiPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAxIDAgMCAwIDAgMSAwIDAgMCAwIDEgMCAwIDAgMSAwIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiLz48L2ZpbHRlcj48ZmlsdGVyIHg9IjAlIiB5PSIwJSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgaWQ9ImE4ZDkzMWZlNGEiPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAxIDAgMCAwIDAgMSAwIDAgMCAwIDEgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiLz48L2ZpbHRlcj48Y2xpcFBhdGggaWQ9ImQ0ZGMxYjdjNGUiPjxwYXRoIGQ9Ik0gMCAwIEwgMTUwMCAwIEwgMTUwMCAxNTAwIEwgMCAxNTAwIFogTSAwIDAgIiBjbGlwLXJ1bGU9Im5vbnplcm8iLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0iYTM0NTRiYWVlOSI+PHJlY3QgeD0iMCIgd2lkdGg9IjE1MDAiIHk9IjAiIGhlaWdodD0iMTUwMCIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSIwMWRlZmRjZGMyIj48cGF0aCBkPSJNIDIzNC4zNzEwOTQgMjM0LjM3MTA5NCBMIDEyNjUuNjI4OTA2IDIzNC4zNzEwOTQgTCAxMjY1LjYyODkwNiAxMjY1LjYyODkwNiBMIDIzNC4zNzEwOTQgMTI2NS42Mjg5MDYgWiBNIDIzNC4zNzEwOTQgMjM0LjM3MTA5NCAiIGNsaXAtcnVsZT0ibm9uemVybyIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSI2MjgyNTY1YTg1Ij48cGF0aCBkPSJNIDAuMzcxMDk0IDAuMzcxMDk0IEwgMTAzMS42Mjg5MDYgMC4zNzEwOTQgTCAxMDMxLjYyODkwNiAxMDMxLjYyODkwNiBMIDAuMzcxMDk0IDEwMzEuNjI4OTA2IFogTSAwLjM3MTA5NCAwLjM3MTA5NCAiIGNsaXAtcnVsZT0ibm9uemVybyIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSIwZTMxZmMwNTJhIj48cmVjdCB4PSIwIiB3aWR0aD0iMTAzMiIgeT0iMCIgaGVpZ2h0PSIxMDMyIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9Ijg0M2M1YTMxODIiPjxwYXRoIGQ9Ik0gNTU3LjAwMzkwNiAzNjcuNSBMIDEzMjIuMDAzOTA2IDM2Ny41IEwgMTMyMi4wMDM5MDYgMTEzMi41IEwgNTU3LjAwMzkwNiAxMTMyLjUgWiBNIDU1Ny4wMDM5MDYgMzY3LjUgIiBjbGlwLXJ1bGU9Im5vbnplcm8iLz48L2NsaXBQYXRoPjxtYXNrIGlkPSIxODIzNGE3Y2Y3Ij48ZyBmaWx0ZXI9InVybCgjNWY0NmJiNWQ4MykiPjxnIGZpbHRlcj0idXJsKCNhOGQ5MzFmZTRhKSIgdHJhbnNmb3JtPSJtYXRyaXgoMS4wMDEzMDUsIDAsIDAsIDEuMDAxMzA1LCAwLCAwKSI+PGltYWdlIHg9IjAiIHk9IjAiIHdpZHRoPSI3NjYiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBdjRBQUFMK0NBQUFBQUR3RGs5bEFBQUFBbUpMUjBRQS80ZVB6TDhBQUJjRFNVUkJWSGljN2QxWmM1N2xmY2Z4QzF1YkIyekxiQWE4eVBzS0JHaE1Bc1RXQTJRQUV4WmpqQmVaZGpMVDZUQTliS2ZMUytnYjZVelBrMVp5VHpwVFM2TEVqMFJJbS9Rd00yaXhaV3V6WmNWeGJVdnFnUjJRWkYxNnR2dStyLy95L1J3bGdPMkxtZS8vYVN6OW9DRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZDTnRha2ZzTlQ2TmZkU1B3R09DTXUvL2MrYkpqZ0FGRVZZL25mLzZWajdJeHdBQ2lJcy83bTV2MzF6RndlQWdnakxQd3g5K3ZRdURnQUZrWmIvN2ZZM3cxb09BTVdRbG44WVBmZG80QUJRREhINVR4OThPUVFPQUlVUWwzOFk2Mm9PSVR3NGdEREpBU0EvOHZLLzBybjd3WDlhdSt2Tm5aczRBT1JIWHY0TE4wK3QrZE4vWHJ1YkEwQ081T1VmaGo3ZS9QMS80UUNRSTRINTMyMDYvc2lpLzdwMmQya1hCNEJjQ013L0RKM2RzT1MvTjNFQXlJZkUvR2UzdnJic2ozQUF5SVhFL01PVnJyYmxmK2orQWZCOUFHUktaUDdqUnc0Ky9BZWJkcGY0UmhpeUpUTC9NSGwycFhkeEFNaVl6UHhIMzl1NjRoL25BSkFwbWZuUDNUM3h5TXAvaGdOQWhtVG1INzQ5OVhqc1QzRUF5SXpRL0c4L1hvci9TUTRBR1JHYS8vM1pmeFFIZ0V4SXpYL3EwRXVyL3ZtbTNhVmQ3WHdmQUkyUm1uKzQrbUQySDlXMHU3U1RiNFNoSVdMenYxemFWZWt2NFFEUUlMSDVMNTc5UjNFQWFJalkvTVBRaWMyVi95SU9BSTJRbS8vZHB2Y2kzL3BhcW1sM2FTZS9DVVpkNU9iLzBPdy9pcThDb1U2Qzg1L2QvdU5xLzFJT0FIVVJuUDlLcy84by9pY1E2aUE1LzJ1dnJqRDdqMnJhd3dHZ1JwTHpqOHorb3pnQTFFaDAvaVBIVjU3OVIzRUFxSW5vL09mbVBxcnFhNStMY0FDb2dlajh3OGlwVFRYL0dBNEFWWk9kLzYwbk91djRVUndBcWlRNy96QjZmbDA5UDR3RFFGV0U1ei8xNG92MS9VQU9BRlVRbm44WU85OVU1NC9rQUZDUjlQeXZ2TFdqN2gvTEFhQUM2Zm5QLytGVXJWLzdYSVFEd0txazV4K0dUenpWeUEvbkFMQUs4Zm5mYVgyM3NaK0FBMENVK1B6RHlKa3FaLzlSVFh0S085c1hKdVl5ZVE0c2taLy9UTWVQR3Y0NW12YVVkclFIRGdETHlNOC9qSDNlMHZoUHdnRmdCUXJ5di9yYXZpeCtHZzRBRDFHUWY1ZzZrODByT1FBc295SC8wZU5iTXZxWk9BQXNvU0gvZTdYUC9xTTRBQ3lpSWY4d1hNZnNQNG9Ed0hkVTVIL3JxV05aL25RY0FCNVFrWCs5cy84b0RnQWhCQzM1VC83Z2hZeC9SZzRBUVV2KzRWcFh2YlAvS0E0QVd2Sy8zTURzUDRvRGNFOUovdk8zUHMzc2E1K0xjQURPS2NtLzBkbC9GQWZnbXBiODc3UTFPUHVQYXRwVDJyR1JPYlJQV3ZJUHcyZlg1L1ZUTiswcDdlQ2ZCM0JKVGY0ek8xL043eWR2M3NzQnVLUW0vekIyUG9QWmZ4UUg0SktlL0RPYS9VZHhBQTdweVQ5TVp6VDdqK0lBM0ZHVS84ajd6K1g5UzNBQXppaksvOTc4aDNsODYyc3BEc0FWUmZtSDRjOHluUDFIY1FDT2FNby80OWwvRkFmZ2hxYjh3MmhYdHJQL0tBN0FDVlg1VDc2VTlldy9pZ053UVZYKzRkcTV6R2YvVVJ5QUE3cnl2L3oyamdKL05RN0FQRjM1NXpUN2o3cC9BT01jZ0ZXNjhnOURuK1F6KzQ5cTNsdmFzVEZ3QUVZcHkvOU8yenRGLzVMTmUwc2Q3UnlBVGNyeUQ4UG5jcHY5UjNFQVptbkxmMmJYa1FTL0tnZGdsTGI4YzU3OVIzRUFKdW5MLy9WOFovOVJISUJCNnZJUDA2ZFR2WmtETUVkZi9pTS95MzMySDlXOHQ5VEJOOElNMFpkL0liUC9LQTdBRkgzNWg2SFQ3U2wvK2VaOUhJQVpDdk8vdGZsbzJnZHdBR1lvekwrNDJYOFVCMkNFeHZ3bmlwdjlSM0VBSm1qTVA0d1hPUHVQNGdBTVVKbi82RTg3VWo4aEJBN0FBSlg1ei8veFpNS3ZmUzdTdksvVXdiOGRXakdWK1llaGswK21mc0lESElCcU92Ty9zNjd3Mlg4VUI2Q1l6dnpEVUlMWmZ4UUhvSmJTL0dmMi9ERDFFeGJqQUpSU21uOFk2MG95KzQvaUFGUlNtLzhiZTFNL1lSa09RQ0d0K1lmcnlXYi9VYzM3U2gwYjV6a0FSY1ExVkszaEQ1NU4vWVNITmU4cmRiUnpBSHFvemY5ZStFREd0NzZXNGdCVVVadC8rRGJ0N0QrS0ExQkViLzYzbnZsSjZpZEVjQUJxNk0wL1hQNjhMZlVUWWpnQUpSVG5QL0ZuaDFJL0lZNERVRUZ4L21HOFMvTHI3eC9BK0h6cWQyQVZrZ09xNVBJNzIxSS9ZVlgzdnhIR0FRaW1PZis1MjBKbS8xRWNnSENhOHcvREo1OUkvWVJLT0FEUlZPZC9lLzNicVo5UUdRY2dtT3I4dzhqNVIxTS9vUW9jZ0ZpNjg3KysvNVhVVDZnS0J5Q1U3dnpEbGZQTnFaOVFIUTVBSk9YNWp4M2JuZm9KMVhvd2grWUFKRkdlLzhLTno5YWtma1BWbXZlVnRyZHpBSklvenorTWZQaE02aWZVb0hrL0J5Q0s5dnp2cm4xZitMZStsdUlBUk5HZWZ4Zyt2VEgxRTJyREFRaWlQdi9aWjk5SS9ZUmFjUUJpcU04L1hEa3ZkdllmMWJ5L3RKMnZBZ21nUC8rSkh3cWUvVWMxNytmTG9BTG96eitNbjFQNU45SENBYVNuc3B5bExyOHJlL1lmeFFFa1p5RC91ZHVmcVByYTV5SWNRR0lHOHRjdys0L2lBSkt5a1AvdGpXK2xma0lET0lDRUxPUWZScnMwelA2ak9JQmtUT1EvZmVEbDFFOW9EQWVRaUluOHc1aVcyWDhVQjVDRWpmeXZkS3FaL1VlMThKM2c0dG5JZjJIbWxKN1pmeFFIVURnYitZZmhqelROL3FNNGdJSVp5Zi91MnVOYXYvVzFGQWRRS0NQNWgrRXp5bWIvVVMzN096bUFvbGpKZi9hNTExTS9JVE1jUUdHczVLOXk5aC9Wc3I5eis4WTUvclVvdVRPVC8vaVJnNm1ma0tYNy94ZUFBOGlabWZ6RGhNN1pmMVRMQVE0Z2QzYVNHWDF2YStvblpJd0R5SjJkL09mdW5MRHh0YzlGT0lDYzJjay9ESDJxZC9ZZnhRSGt5bEQrdDl2ZlRQMkVQSEFBT1RLVWZ4ZzlwM3IySDhVQjVNWlMvdE1IbGMvK296aUFuRmpLUDR4MWFaLzlSM0VBdVRDVnY0WFpmMVRMZ2M3dEd6aUFiSm5LMzhic1A2cmxRSWtEeUphcC9NUHd4NXRUUHlGWEhFREdiT1YvdDhuSTdEK0tBOGlVcmZ6RDBOa05xWitRTnc0Z1E4YnluOTM2V3VvbjVLL2xRR243aGpuK2VZQU1HTXMvWE9reU5QdVBhamxRMnJhUkEyaWN0ZnlOemY2ak9JQk1XTXMvVEo0MTk3ZTBNZzRnQStaYXNUZjdqK0lBR21ZdWY0dXoveWdPb0VIbThnOURweDVQL1lRQ2NRQU5zWmYvN2NkTHFaOVFLQTZnQWZieU56djdqK0lBNm1Zdy82bERMNlYrUXRGYURuUnU1d0RxWUREL2NOWHU3RCtxbFFPb2g4WDhMNWQycFg1Q0FoeEFIU3ptdjNEVDlPdy9pZ09vbWNYOHc5QUoyN1AvS0E2Z1JpYnpOL052KzY4ZEIxQVRrL2w3bVAxSHRSN29aQTVkTFp2NXoyNy9jZW9uSk5SNm9ITWJCMUFWbS9rN21mMUh0UjdrQUtwaU5QOXJyL3FZL1VkeEFGVXhtcitmMlg4VUIxQUZxNUdNSEhjeis0L2lBQ3F5bXIrcjJYOFVCMUNCMWZ6RHQ1OTVtdjFIY1FDck1wdi83U2M2VXo5Qmh0YURuVnY1UmxpRTJmekQ2UGwxcVo4Z0JBY1FaVGYvcVJkZlRQMEVNVGlBQ0x2NWg3SHpUYW1mSUFjSHNDTEQrVjk1YTBmcUowakNBYXpBY1A3emZ6akYxejRYNHdBZVlqai9NUHp4MDZtZklBd0hzSXpsL08rMHZwdjZDZUp3QUV0WXpqK01uUEU3KzQvaUFCWXhuZjlNeDQ5U1AwRWlEdUE3cHZNUFk1KzNwSDZDU0swSE83Y3loUWpXODcvNjJyN1VUeENLTFZBSXdYcitZZXFNOGIvQituRUF3WHorbzhlM3BINkNYQnlBOWZ6dnpYM0V0NzdpV2c5MmJ0dHdiOUx2QVJqUFB3eWYycFQ2Q2FLMUh1emM2dmdBck9kLzYwbG0vNnRyUGVUNEFLem56K3kvTXNjSFlENy95Uis4a1BvSjhyazlBUFA1aDJ0ZHpQNHJjM29BOXZPL3pPeS9LaTRQd0g3Kzg3Yys1V3VmVmJsL0FCTUxxZDlSSVB2NWgrRVRUNlYrZ2hhdGh6cTNicGh6ZEFBTzhyL1R4dXkvYXM0T3dFSCtZZmpzK3RSUFVNVFZBWGpJZjJibnE2bWZvSXFqQS9DUWZ4Zzd6K3kvSm00T3dFWCt6UDVyNXVRQVhPUWZwcG45MTh6RkFmaklZdVQ5NTFJL1FTRUgzd2Z3a2YrOStRLzUxbGNkekIrQWovekQ4R2ZNL3V0aS9BQ2M1SC9ycVdPcG42Q1Y2UU53a244WTdXTDJYeS9EQitBbC84bVhtUDNYci9WUTU5YjFGZy9BUy83aDJqbG0vdzB3ZWdCdThyLzg5bzdVVDlDdHplSUJ1TW1mMlgvRERCNkFtL3pEMENmTS9odGw3Z0Q4NUgrbjdaM1VUekRBMkFINHlUOE1uMlAybndGVEIrQW9mMmIvR1RGMEFJN3lEMWVZL1dmRXpBRjR5di9xNjh6K3MyTGtBRHpsSDZaUHUvcmJ6WmVKQTNEVnc4alBtUDFucU8xUTV4YmxXeUJYK1RQN3oxamI0V082eDNDdThnOURwOXRUUDhFWTVRZmdLLzlibTQrbWZvSTVxZy9BVi83TS92T2crQUNjNVQvQjdEOFBhZy9BV2Y1aG5ObC9MdG9PSDl1NjRlNmt0Z1B3bHYvb1R6dFNQOEdvdHNQSHRxeS9wK3dBdk9VLy84ZVRmTzB6SndvUHdGditZZWprazZtZllKZTZBM0NYLzUxMXpQNXpwT3dBM09VZmhwajk1MHJWQWZqTGYyYjNrZFJQTUU3UkFmakxQNHgxTWZ2UG1ab0Q4SmovRzN0VFA4RStKUWZnTVA5d25kbC9BVlFjZ01jUWhqOTROdlVUWEZCd0FCN3p2eGMrNEZ0ZmhSQi9BQjd6RDk4eSt5K0s4QU53bWYrdFozNlMrZ2wraUQ0QWwvbUh5K2VZL1JkSDhBSDR6SC9pNWVkVFA4R1Z0c1BIdHF5WE9JZjJtWDhZUCsvMGJ6eVZ0c1BIdGdqODV3R2NWakQ2N3JiVVQvQ203Zm1qOGc3QWFmN3orL2pOYitIV1BmL0s4RGR6cVYreGhOTi85Sy9wVU9vWE9EVDdkZjl2WmRYdk5mOFgza3I5QW5kbXYrNi8wQytzZnEvNS85V2pxVi9nak1qNFEvRDUzZitPcjU1Si9RUlhaZ2UvbEJpLzEwLy9zOVJmb05uQi9ndGZTb3pmYWY2Yi9pTDFDeHdSSEwvVC9OODVtUG9GYm9pTzMyZitiVi80L0IxUDhZVEg3elAvSTIra2ZvRVA0dU4zbWYrYUwvaEgzUXVnSUg2WCtlOTlQL1VMSEZBUnY4djhmNzRwOVF2TVV4Sy94L3czbjBuOUF1dlV4Tzh4L3hNN1VyL0FOa1h4Tzh6L3NiL2txNTQ1dXZtMW92Z2Q1bi8wbGRRdk1FeFovUDd5Yi9wcnAvK0FUd0hVeGU4dmY0YitlYms1MlAvdnl1TDNsejlELzN6Y0hPeS84Ri9hNG5lMzkyZm9ud3VsOGJ2NzlHZm9ud08xOFh2TG42Ri85aFRIN3kxL2h2NVpVeDIvcy93WittZE1lZnpPOG1mb255bjE4ZnZLbjZGL2xtNE85dmQ4cFR0K1gva3o5TStPaWZoOTVjL1FQeXRHNG5lVlAwUC9qSmlKMzFYK0RQMHpZU2grVC9rejlNK0NxZmc5NWMvUXYzRTNCNzYwRkwrai9CbjZOOHhjL0k3eVoramZJSVB4TzhxZm9YOURUTWJ2WisvUDBMOFJOd2Y2THhpTTM4K25QMFAvK3BtTjMwMytEUDNyWmpoK04va3o5SytUNmZpOTVNL1F2ejQzQi9wN2ZtVTNmaS81TS9TdmgvbjRuZVRQMEw4T0R1SjNrajlELzVxNWlOOUovZ3o5YStRa2ZoLzVNL1N2emN5Z2svaDk1TS9RdnhhTzRuZVJQMFAvR3N3TTlsMXdFNytML0JuNlYyMW1zTy9DVi9PcFgxRWcrL2t6OUsrV3UvZzk1TS9RdnpvTzQvZVFQMFAvYXJpTTM4SGVuNkYvRlp6RzcrRFRuNkYvUlRNRC9UN2p0NTgvUS85S1pnYjZlMzdsTTM3NytUUDBYNTNyK00zbno5Qi9WYzdqTjU4L1EvOVZ1SS9mZXY0TS9lT0lQMWpQbjZGL0RQR0hFS3puejlCL1pjVC9nT244R2ZxdmlQaS9ZenAvaHY0cklQNUZMT2ZQMFA5aHhMK0U1ZndaK2k5SC9Nc1l6cCtoL3pJM0JvbC9HY1A1TS9SZjRzWmczd1hpWDhady9nejlGeUgrRmRuOXpTRkQvKy9kR09nbi9wWFkvZlJuNlA4bk53YjZleTRSLzByTTVzL1Evd0hpWDRYWi9CbjZoeENJdndLcitUUDBENEg0SzdLYVAwTi80cStDMGZ3WitoTi9OWXptNzM3b2YyT2c3d0x4VjJRMGYrZEQveHNEZlQyWEZsSy9RZ0diK2ZzZStoTi8xV3ptNzNub1QvdzFNSm0vNDZFLzhkZkVaUDV1aC83RVh5T0wrWHNkK2hOL3pTem03M1BvVC94MXNKaS94NkUvOGRmRjRPOFJIUTc5aWI5T0JqLzkzUTM5Ynd6MFhpRCt1dGpMMzl2UW4vZ2JZQzkvWDBOLzRtK0l1ZnhkRGYySnYwSG04bmMwOUw5UjdpUCt4bGpMMzgvUS8wYTVyNmRNL0kyeGxyK1hvVC94WjhKYS9qNkcvc1NmRVdQNXV4ajZYeDhnL293WXk5L0IwSi80TTJRcmYvdERmK0xQbEszOHJRLzlpVDlqcHZJM1B2UW4vc3laeXQvMDBKLzRjMkFxZjhORGYrTFBoYVhmS3RvZCtoTi9UaXg5K2xzZCtoTi9iZ3psYjNUb1QvdzVNcFMveWFILzlYTGZCZUxQalozOExRNzlyNWY3ZWdhSVB6OTI4cmMzOUNmKzNKbkozOXpRbi9nTFlDWi9ZME4vNGkrRW1meE5EZjJKdnlCVzhyYzA5Q2Yrd2xqSjM4N1FuL2dMWkNSL00wUC82WUcrN2tIaUw0cVIvSTBNL1ltL1lEYnl0ekgwSi83QzJjamZ3dENmK0JPd2tiLytvVC94SjJIaWQ0enFoLzdFbjRpSlQzL2xRMy9pVDhaQy9ycUgvdFBsZnVKUHhVTCttb2YreEorVWdmd1ZELzJKUHpFRCthc2QraytYKzNxSVB5bjkrV3NkK2hPL0FQcnoxem4wSjM0UjlPZXZjZWhQL0VLb3oxL2gwSi80eFZDZnY3cWgvM1M1ci90cjRwZEJlLzdhaHY3RUw0cjIvSFVOL1lsZkdPWDVxeHI2VHcwUXZ6REs4MWMwOUNkK2daVG5yMmJvVC93aTZmcU40M0phaHY1VEE3MDl4QytRN2s5L0hVTi80aGRMZGY0cWh2N0VMNWpxL0JVTS9ZbGZOTTM1eXgvNkU3OXdtdk9YUHZRbmZ2RVU1eTk4NkUvOENpak9YL1RRZjZyY1IvenlLYzVmOE5CL3F0elgvV3ZpbDA5di9uS0gvc1N2aHQ3OHBRNzlpVjhSdGZrTEhmb1R2eXBxOHhjNTlDZCtaYlRtTDNIb1QvenFhTTFmM3RDZitCWFNtciswb2Y5VXViZUgrTlVSK2Z2SHlvUU4vWWxmS2FXZi9xS0cvc1N2bHM3OEpRMzlpVjh4bmZuTEdmb1R2Mm9xOHhjejlDZCs1VlRtTDJUb1AzV3BqL2gxMDVpL2pLSC8xS1crN20rSVh6ZU4rVXNZK2srV2lkOEFqZm1uSC9wUGxudDdpTjhBaGZrbkgvb1R2eGtLODA4ODlDZCtRL1RsbjNib1QveW02TXMvNWRDZitJMVJsMy9Db2Y5a3ViZjdOOFJ2aWJyOGt3MzlKOHU5M2Q4aytyV1JFM1g1SnhyNkU3OUpRc1l6VlVzejlKOHNYK3doZm9PMGZmcW5HUG9UdjFuSzhrOHc5Q2QrdzVUbFgvalFuL2hOMDVWLzBVTi80amRPVi83RkR2MkozenhWK1JjNjlDZCtCMVRsWCtEUW4vaGRVSlYvWVVQL2lRSGlkMEZUL2tVTi9ZbmZEVTM1RnpQMG55ajNFcjhYaXZJdlpPZy9VZTd0L2szK3Z3eGtVSlIvQVVOLzRuZEdULzc1RC8ySjN4MDkrZWM5OUNkK2gvVGtuKy9Rbi9oZFVyUDN6M1hvVC94T3FmbjB6M0hvUDFHKzJFUDhMbW5KUDcraFAvRTdwaVgvdkliK3hPK2Frdnh6R3ZvVHYzTks4czlsNkUvODd1bklQNCtoUC9GRFNmN1pELzJKSDBGTC9sa1AvY2NIaUI5QlNmNFpELzNIeTczRWp4Q1U1Si9wMEgrODNOdjkzeG4rZkZCTVEvNVpEdjJKSDR0b3lEKzdvVC94WXdrRitXYzI5Q2QrTEtNZy80eUcvc1NQaHlqSVA1T2hQL0ZqQmZMMy9sa00vWWtmSzVMLzZkLzQwSCs4ZkxIN2Y3SjRDcXdSbjMvRFEzL2lSNVQ0L0JzYytoTS9WaUU5LzhhRy9zU1BWVW5QdjVHaFAvR2pBdUg1TnpEMEozNVVKRHovdW9mKzQ1ZDZpUitWQ00rL3pxRS84YU1xc3ZPdmIraFAvS2lTN1B6ckdmb1RQNm9tT3Y4Nmh2N0VqeHFJenIvbW9UL3hveWFTODY5MTZFLzhxSkhrL0dzYitoTS9haVk1LzFxRy91T1hldi90dC9rOUJTaFl4NVdGYWwzOTEzOThQdlZ6b1pEZ1QvK3FoLzdYeWhlNytlU0hLWnQrViswbi96L3d5WS82eVAzMHIyN296eWMvR2lBMi82cUcvc1FQbTQ3K0gvK3pCM21UK3VsZmVlalBKei9NMmovRkp6OXlKL1hUZi9XaFA1LzhzR3p6NzFmOTVQOTdQdm1SQmFHZi9xc00vYStWLzdPSFQzNFk5dGdsUHZuaDF2RjdrZmgvU2Z5d3J1a1hzZmdQcDM0YWtMZVhaNGtmUlJENVc5OFZodjdYTGwzcy9sMkNwd0FGZTNqb1A4WW5QL0lnOGROLytkRC9hcGxQZm5peGJPalBKejg4T1ROUC9QQ3E3VCtJSDI1OVAvUW5mbml6NXArSkgyNDlHUG9UUHdvZzdndWZQOThVK0ZJbm5OcjgrNFdGc1YvK0haLzg4T2lMK2JGZkVEOEswc2ovMjlBY1BQWXZDeGU3L3pmMUs0QWtudjZiUTZtZkFLU3lMdlVEQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXgvdzlZZkdBZEJ2SWhQUUFBQUFCSlJVNUVya0pnZ2c9PSIgaGVpZ2h0PSI3NjYiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiLz48L2c+PC9nPjwvbWFzaz48Y2xpcFBhdGggaWQ9ImRhNzJjZTM0NzUiPjxyZWN0IHg9IjAiIHdpZHRoPSI3NjciIHk9IjAiIGhlaWdodD0iNzY3Ii8+PC9jbGlwUGF0aD48cGF0dGVybiBpZD0iYmVlMTM2YWRjMyIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgd2lkdGg9Ijc2NyIgcGF0dGVyblRyYW5zZm9ybT0ibWF0cml4KDAuOTk4Njk2LCAwLCAwLCAwLjk5ODY5NiwgLTIwOS4wMDAwNDksIDExMzIuOTE5OTQyKSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDc2NyA3NjciIGhlaWdodD0iNzY3IiB4PSIwIiB5PSIwIj48Zz48ZyBjbGlwLXBhdGg9InVybCgjZGE3MmNlMzQ3NSkiPjxnIG1hc2s9InVybCgjMTgyMzRhN2NmNykiPjxnIHRyYW5zZm9ybT0ibWF0cml4KDEuMDAxMzA1LCAwLCAwLCAxLjAwMTMwNSwgMCwgMCkiPjxpbWFnZSB4PSIwIiB5PSIwIiB3aWR0aD0iNzY2IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQXY0QUFBTCtDQUlBQUFCYUI0ZnVBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFnQUVsRVFWUjRuTzNkWDVOZTFYMG4rdC9hKytrL0dMcWhuVkdNRFdROFo4NEU1MXhGT0c4Z2RlNW1FdXpKaGEvSGY1TGN6V3ZRYXpoVk1BR0owVG54VkRsSFpUQUNaTWVuN0hReU9iazROdUM1U0kzRkRGaGdwRzVFZzRTNlcxTC8yWHYvemtVTGtJU0FsdFRkejdPZjUvT3BjaVZWdHNPcTdMWFgvdlozcjJldkNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUExV0dQUUIyNVptVEsyWG1DeEZSWnI3dzdUOTIxUURnRGxYREhnQzdVZzI2M0x4U1pyNFFhKy85OWJOblQ1eDRlOWdqQW9CZTBoLzB3L2RQL2pabnA3YzJzc3Z1Z2ExdW95NFJNZHZtdDc3MXlMQ0hCZ0I5b3ZYcGh6cWEyVXZ2WldSRVdadXBOK295MitaR1hUUkFBSEJidEQ3OWNPTEVQMStldlgrN3JVdUp5TXhTNmhKdHBnWUlBRzZMNk5NYngzN3liajA3MVg1d05YY3VtZ0FFQUxkUDlPbU40NHNYbS9XcjBYUlJybnROS1FBQndPMFFmZnJrNlIrOW5aRlZOWWk4OGQ4UWdBQmdkMnh6N3BPTXJFb2RtVGYvRzZXVWlLNjdZUlAwNXFENi9uTkxOa0VEd1BXMFBqM3o4MTljZUd0cHE0M3VVLzhUSHpaQVVkVnpWN2MyQjFWRW1XbGFEUkFBaE9qVE82LytldTN3MSs0Nzl2enk1MXk2ektoS0ZRSVFBTnhBOU9tWnpIenBsMnZuejYxbktYSHpscDliL0tjRklBQzRudWpUUDAvL2ZEWHZuNnZPTHUzMjhnbEFBUEFoMGFkL25ubzU0NzJWZXJPTmlQemtsdWZQVUVJQUFtRENpVDY5OUZjdnZ0MVd6ZlRXZEpUYnY0SUNFQUFUekkvYmU2bXRtcW50cVhKbmx5K2p5K2k2ZG0ybTNwb2F6RFR0bGRuNHp6OSs2L2ppbWIwZUpnQ01ISzFQWC8zZEx5Nit0YlRaWkhkWDEzQW5QYlZkdGJEZGJkUWxzOXpUZmZ1UC85VmVEUklBUm8zbzAxZS8rdlhhSCs3bVYrNjdrVkZLbEU0QUFtRDhpVDU5bFprLy9hL3ZuTDNRWmlsN2N4MEZJQUFtZ09qVFk5Ly80ZXN6M2NhbG1kKzV4ZEVXZDB3QUFtQ3NpVDQ5ZHVMRVAxK2VmYURwNnMvL3R1SHRFb0FBR0ZPaVQ3ODk4NU9WYW5iUVhOclkrL1FUQWhBQVkwajA2YmZqaXhmYjlZMXN1anY1d004dUNVQUFqQkhScC9lT1BuKzJsTXlvOTZQMytkaDFBU2czQnlVaVpob0JDSURlRVgxNjc5akp0ek9xa3BFSGNEVXpTb202cW1MdXFnQUVRQitKUHVQZ1o3KzhjR1o1SzdydVlQNXhPNU5HQUFLZ2owU2ZjZkRLNmJYSEhyM3YyTW5sZy95SENrQUE5SkhvTXc0eTg2V1gxOCsvY3lYYmJsOSs2dlhwQkNBQStrWDBHUk5QTDY3bjNMM1YyYVdoWEZNQkNJQytFSDNHeEZNdlo3eTNNdGphenF4eUR6L3VmRHRLUkZiVklFSUFBbUJraVQ3ajQ2a1hmOXRVN2ZUMnpEQUhVYUxreHdHbzJ4eEVSQ1VBQVRBeVJKL3g4Y1NwTTRObVVPMzNCMzUyNDhNQUZCRURBUWlBVVNMNmpKV2YvZkw5TTB0WG9xdEg0c0tXaUl3UWdBQVlKYVB3aEdUUHZITDYwbU9Qemgvd3I5dy9od0FFd0NnUmZjWktadjcwSDg4dlhZZzIydEc2dUFJUUFLTmhsSjZPN0lYLzh1eHZwdHNySDB3dmxCRzh1QUlRQU1NMmVrOUg3czZKRS8rOFBqWFhsdWtEL3JiaGJSQ0FBQmdlMFdjTVBYMXlLYXVvbXRHK3ZBSVFBTU13eXM5Rzd0QlRMeTVWVFdSbXFVYisrdDRVZ0RicXlLenU2UVFnQVBiSnlEOGF1U1BIbmwydXMyNEd6YkFIc2pzZkJhRHRadkRGYlFFSWdQMGorb3luNHo5OHQ2M2JMS082M2VlV0JDQUE5cC9vTTdiKzV0VEZLOXRiYll6NGxwOVBFSUFBMkUrOWVpaHlPNTc3eWZyQzdMMnZmM0F1U2pYc3NkdytBUWlBL1NINmpLM0Z4VHkzL3Y3VmRpT3pLajI5emdJUUFIdXRwNDlFZHVYWTg4dWxETnB1cS9RMSswVEVKd0xRMVRwQ0FBTGdEdlg1aWNqbmVlYmtTdGR0bHpLeUh6ZThIVHNCS0NPNmJ2REY3ZTByZGRmbFZyMzFILy90dnhuMnlBRG9FOUZuekIxOTdseGtSdDNEN1Q2M2xoRWxNdXBTclUrdlRUWFRwWVFBQk1EdWlUNWo3dWl6WjB0VlNpbmRzRWV5cDdLVTBuVXhFSUFBdUUyaXovajd1MSs4LzlhNXE5dWxqT0tCcG5kRkFBTGd0bzNaczVCYitOV3ZMLzNoMSthUFBiOFV2ZDdzL0trRUlBQnV3MWcrQzdsQlpwNzYrNVdsUzAyNXRsVjRMQWxBQU95SzZETVJqdjNndC9WRzIzeHhObkpjbzg4T0FRaUF6eUg2VElUang4ODA4OU5sVUdlTzEzYm5XN3NoQU5YTklFcTBkU01BQVJDaXorUjQrb1hsTEZsMTQvdks2MmJYQWxDV2RuTjZRd0FDWUlmb015bWVlbkdwWklrMngzT3Y4NmZLaUpJcEFBRnd6V1E5QmlmYzB5KzhFM1ZkdHJlSFBaQ0RKd0FCY0kzb00wR2VQclZTdHB2SmVlUDFDUUlRQUtMUGhQbkJTeGV1YkcxMFZVN3dwUmVBQUNiYXhENy9KdFJ6UDE1ZHVHZnU5VXZMd3g3STBBbEFBQk5LOUprc2k0dDU3dktGamZacTExVVR0dC81bGdRZ2dJbmo2VGR4anAxY0xqRm9jOXUxLzlBTkFXalFUcGNTMjVVUElRS01KNCsvaWZQTXlaV3UyNjZxNkNaMnUvT3Q3ZXgvcWtxZFYrcDFBUWhnWElrK2srallqODVsbDFIWEUveHJyMDlWU21RS1FBQmpTL1NaUkVlZlBSdFZLVldWWTM2azE1MFRnQURHbGVnem9YNyt5d3RubHE1MkdjVWMrSFFDRU1ENDhkaWJVSytjWG4zczBibGpMeXhGbWdPZlF3QUNHQ2NlZXhNcU0zLzhEeXZMbDVyTVlzZlBiZ2hBQU9OQjlKbGN6L3pOYjZ1cmJic3dJL2pzM2cwQnFKa3FrZHNEM3dFQzZKTnEyQU5nYUtxcmJUcy9WU3B6NERaa1JrUVhYZDZ6TlRmZDF0dURadEJNL2FjWHp2d2ZQLzZmd3g0YUFMdWk5WmxvUjE5WTdrcFc3YkRIMFUrWlhTbURrdHRYWmpZMFFBQjlJZnBNdEtkZVhLcTZVdnpHL1M0SVFBRDlJdnBNdW1QUHYxTkszZVgyc0FmU2J3SVFRRitJUHBQdW1aTXJYVGFSWFRqTzlLNEpRQUNqejlPTytNRkxGOWFialE4UHNlSnVDVUFBbzh5dmU0anBldkMvM3Y5bDN6YmNLNlZVRVYwWDVhTmZnWDFoYy83N1A3eDA0b1F0VlFERDUybEhMQzdtdWZVTFY1cXRpUFRXYTI5OTFBRE5iejk4dFZyTmlDOTA4OS82bHY4dkF3eU5KWmlJaUtQUG42OUsxWFhiWnNSK3lPd2lTaHZkN3doQUFNTm04U1ZpWjdOejEwUkVGQzlsOWtWR2xpaVpLUUFCREpkbGwydU9QbmN1TXFPMi9Xc2ZDVUFBUTJmQjVacWp6NTR0VllsU3BkTk05NWtBQkRCRWxsbys5dk5mWG5ocitXclRSVEV4OXA4QUJEQVVGbGsrOXVycDFjT1B6aDE5WWRtR253TWpBQUVjTU1zckg4dk1VLyt3c3JUYWxpN0NhNjhEZEZNQTJxalhvcFRaNWo0QkNHRFBXVmk1d2JHL2VidSsyalFMTThNZXlDVDZLQUJGWFQydzhhQUFCTEFmL0p5SEc5UlhtMlorcWxRcW55RzR0c1dxUkpYeHdkVFN4dFRsMmVhK2pYcnRyNTliOHlWb2dMM2lyMGx1OXZRTDU3S1UwcG9jdzVTUlZhbTZydE1BQWV3dHJRODN5MUtpeThodTJBT1phTmZlZkdtQUFQYWF2eUM1aGFkT25vdXFWTzJ3eDBGRWFJQUE5cFRXaDF1cFN1a0U0MUdoQVFMWVF4NXUzTm9QVGwyNDNHeGtwa2t5VWpSQUFIZkpjc210UGZ1M3ExK2NtWHZqMHJKV1lRVGRISUNxOWNpWVRRRUk0UE5aS0xtMXhjVThkL25pMVdZcnN5dW15VWphQ1VBUjBUWHhRQ3NBQWV5S0paSlBkZXo1ODZWVWJXNDUwbXZFNWM3dUxBRUlZQmNzam55cVowNnVkTjEyS2NWWjdyMGdBQUhzaG1XUnozTDB1WE9SR1hYdFNLKytFSUFBUHBzRmtjOXk5Tm16Y2s4ZkNVQUFuOFpTeU9mNDJTOC9PSE4rT3hzN2Z2cEhBQUw0SklzZ24rT1YxeTQvOXZ0Zk9IWnllZGdENFE1ZEg0QTI2N1dJbUdubkJDQmdZbG4rK0J5WitaTy9YemwvcVcwaXZQbnFyNTBBVkNMbk5yOHNBQUdUek1MSDV6ditnN2RqbzJrZW1ERmZlcStVRWlFQUFaUE1HVjdzd2tiVHpFME5leERzaGN6TTdLS3N6cnl6TlZpZmFlYzI2N1h2UDd2cUxEQmdjdmhyajExNSt1UlNWbEczM25pTkVRMFFNSkVzYyt6S1V5OHVsZFowR1VjQ0VEQmhMSERzMXRFZkxjWE9PZTVtemZnUmdJQ0pZYThQdTVZUmxkd3pwajZ4QitqeXZXdEgvMjcxcVplOTRRVEdqZWNZdCtILy9OR2IyNE9aYURzelo1eVZVcnF1VktWNTZNdGxkYTFFZFBOemYvbEhyamd3SnJRKzNJWXEyL3V2dmkvM2pMbk1qT2k2ck00dTFXdnIzZnhjV2RVQUFlUERNNHpiY09MRVAxKzU1NEVtQnRsMnd4NEwreTh6SXFKRVZUUkF3UGl3aEhGN252bnBTalU5YUQ2NEVzWGttUXdDRURCZUxGN2NudU9MRjlzcm05MVdKL2xNRmdFSUdCZVdMVzdic1JlWDZrRnB0dEwzRFNlT0FBVDBud1dMMjNiOEo4dk5ka1k2ekhSU0NVQkFuMW1xdUJNLysrV0YzeXh2bGs3Mm1XQTNCYUJMYXhHUjl3dEF3S2l6U0hFblhqNjk5dlZIN3p0NmNxbVlRaFB1d3dBVVdicEhCQ0NnQnl4UDNJbk1mT25sdGZQdlhNbldleThpTXFOVUVaMEFCSXcrQ3hOMzZPbkZ0Wnk3cnpxN1BPeUJNRElFSUtBUExFbmNvYWRlem54dnBkcllya3FWcWZqaFF3SVFNTm9zUnR5NS8vVENiN3U2bmQ2ZUdmWkFHRDBDRURDcW5PSEZuZXZxZHRCT0ZSODM1Sk5LaWNqSWlGS3FzMHRsZFQzdm55dXJhMC8vM0ZsZ3dKQjVhSEZYZnZiTGk3OVozaWh0bWtwOHFzd29WYWtpMit3ZStYSlpYWXZVQUFGRFkrbmhybHo3bGZ2enk2b2ZkcUVJUU1EUVdYUzRLNW41MDM4OGYrNWlkdG1aVHV4T2xxb1NnSUJoc2R4d3Q3Ny83QnN6N2RWTFV3dk9jdWQyQ0VEQWNOam16TjJhYWE5ZW1YMmdxZ2JESGdqOVVyTExLRmt2dlZNdTJRUU5IQngvWTdFSC92UGZ2bGRtNnViUzFXRVBoSjdTQUFFSHgrTENIamkrZUxGZDI4eW1VeU55RndRZzRDQllWdGdieDU1ZHJySzBVNTBUdmJnN0FoQ3d2L3lSenQ2b3NuUjFXd1FmN3BZOVFNRCs4cmNVZStibnYzai96TGtyV2VwaEQ0U3hvUUVDOXA1RmhEM3p5cTh2UGZhMStXUFBML21WTzN1b1JJWUFCT3dkeXdkN0pqTmZlbm50bmVXMTZLcnc1b3M5SlFBQmU4WEN3VjU2ZW5FMTUrYnFjOHNwK2JBUGJnaEFUb01IN29nbGc3MzAxTXNaNzYxVUc5dWxWQ24rc0Q5S1pFU1ZLUUFCZDhKaXdSNzdxeGQrMjlidDlQYk1zQWZDZUNzbE9nRUl1QU4rM000ZWErdDJhbnU2U05Yc3I4d29HVkZLMW1mZkthdnJlZi9jdlJmWG52dmIxY1ZGZFNQd1dUeWYySHMvLy84dW5qbTNtYVV6dnpnUTF4cWdxdXIrMWR4WExteXNsbElXWnViKytJL05QK0FXTEEzc3ZWZisrOXBqZjNEZnNlZVh6UzhPVUNrbHMrdnF1Z2hBd0dld0tMRDNNdk9uLzNoKzZZTm91OVljNDJBSlFNRG5zQnl3TC83TGM3K1picTVjbWw0d3h4Z0dBUWo0VkxZNXN5K21teXVYWisvUDlLUmhLREl6b3RSZGx0Yy9PSGRwZTMxaFp1N0N4cXBOMEVENGk1ejljK3duNzlhelUrMEhWK1VmaGtvREJOekF6YzkrT2I1NHNWbS9HazBYUmJuSTBOMFFnTjdmV0kxU2ZrY0Fnb25rdG1jZlBmMmp0ek95cWdaTzlHSTBYQXRBWFYxK1h3Q0NTZVhQY2ZaUlJsYWxEaWRhTUNxdTdRR3Fzcnord2JuM3Q5ZC9aMmJ1L1kzVkg5b0RCSlBFM3pyc3I1Ly80c0piUzF0dGRNTWVDTnlrUk1uNHNBRzZzTG1XRVJvZ21BUnVjdmJYcTc5ZU8vdzFuemRrWkpVb1dVVTBKUVVnbUJCdWIvWlhacDU2ZWYzZDVjdHRsMkhMRHlNcE0wb1ZBaEJNQ0RjMisrN280bG8zZDE5MWRzbDhZNVFKUURBaDNOTHN1NmRlem5odnBkNXM0OW91VXhoZEFoQ01QVGN6QitHdlhueTdyWnJwcmVrb3Bodzk4SWtBdEI1UnZqaHpyd0FFWThDUDJ6a0liZFZNYlU4Vjg0MmVLQ1VpbysyaXl2S2IxZVdMbTFlL09IUHZoYzMxWi85MjNjL2dvZS84QmNNQitidGZYSHhyYWJQSnpxU2pYeklqU3RRbE1nYi9ldjZRQmdqNnpxM0xBZm5WcjlmKzBLL2M2UzBCQ01hR201WURrcGsvL2Evdm5MM1FaaWttSGowbEFNRVljTHR5Y0w3L3c5ZG51bzFMMHdzbUhyMG1BRUd2MlhiS3dabnBOcTdNM2wvUzQ0RitLeVZLUk50Rmw0MU4wTkE3SGtJY3FHZCs4bTQxTzlWYzJ2QmxaOGJESnhxZ3RZajRvdThBd1FoemMzS2dqaTllYk5jM3N1bDg0SWR4Y2wwQXluODkveFVCQ0VhWjI1S0RkdlQ1czZWa1JxMzNZY3pzZkt1OHJnUWdHR2x1U0E3YXNaTnZaMVFsSTAwL3hsU21BQVNqeTYzSUVQenNseGZPTEc5RjF3MTdJTENQQkNBWVRXNUNodUNWMDJ1UFBYcmZzWlBMd3g0STdEc0JDRWFOMjQ4aHlNeVhYbDQvLzg2VmJEcy85V0lTQ0VBd090eDRETWZUaStzNWQyOTUrMXdwUGk3RnBCQ0FZQlM0NVJpT3AxN09lRytsM213aklsUHh3d1M1UGdCZDNMcGNTand3NVV2UWNIRGNiQXpOWDczNGRsczEwOXN6d3g0SURFRm1WSFZkMStXclh6Z2tBTUZCOHE2Qm9XbXJadEFNeEc4bVV5bVJYZHRzTjIrc3ZYdXB1ZkxBMUwwWHR5Ny82UDl4RkFic080OGRodWxudjN6L3pOS1Y2R296a1FsWEtnMFFIQkMzRnNQMHl1bExqejA2NzFmdXNFTUFnZ1BncG1LWU12T24vM2grNlVLMDBacU5zRU1BZ24zbGRtTEkvc3V6djVsdXIzd3d2VkRNUnJqT3h3Rm9jNzFVUlFDQ3ZlSkdZc2hPblBqbnkvZmMzOFFnV3JzNzRXWWxvcDRhZlBVTGh5NXVySlhJQjJibkJTQzRTMjRoaHUrWm42NVUwNFBtZzZ2bUk5eFNpYWl6KytvRER3bEFjUGZjUEF6ZjhjV0w3ZHBXMXpTbE1pSGgxa29wa1NrQXdkMXoyekFTamoyN1hHZmRESnBoRHdSR21nQUVkODhOdzBnNC9zTjMyN3JOWXJzUGZENEJDTzZHVzRWUjhUZW5MbDdaM21xak1TMWhOd1FndUROdUVrYkZjejlaWDVpOTkvVVB6b1d6M0dIWEJDQzRYVzRQUnNYaVlwNWJmLzlxdTVGWkZSTVRib2NBQkx2bnhtQ0VISHQrdVpSQm05dm1KZHlCNndQUWhZMjFqUHdkQVFnK3dTM0JDSG5tNUVyWGJaZU05TW9MN3RST0FPcXkremNDRU55S200SFJjdlRaY3hFWnRld0RkeWVqbEJDQTRKTThZQmcxV1NyN25PR3VsY2lJRXRVYmw1YmYzMWo5bmRuNTl6ZldmdmlUUzR1TFBpSEJwUE1YQUNQbjczN3gvbHZucm02WDRrQlQyQnNaVVZmWk52L21nWWZlMzFnTERSQ1R6ZFJuNVB6cTE1Zis4R3Z6eDU1ZkNqLzBnajJTRVVVQWdvZ1FmUmhCbVhucTcxZVdMalVsU29SeUh2YU1BQVFoK2pDYWp2M2d0L1ZHMjN4eE5sTDBnVDEyVXdDNnNMRmVzaXpjYzY4QXhJU3duWlJSVkcrMHpmeTB2VDZ3SDBwRWxNaXVLMUc5dm5iK2c2dFhGdTY1OThMRytuTS9YcmNKbWtuZzBjS0lldnFGNVN4Wk9kRUw5bE5HVkJGWlZWVlQvcGVGMzlVQU1RbTBQb3lvTEZteVJHWDloWDIwczU4dXV5NnJWZ1BFaFBCY1lYUTkvZUw1cUtxeXZUM3NnY0JFMEFBeElVeG9SdGZUcDFiS2R1TkhYbkNRQkNER25xbk1TUHZCU3hldWJHMTBWWnFyY0pBRUlNYVlTY3hJZSs3SHF3djN6TDErYVhuWUE0RkpkRk1BT3IrMnRyMlZNOTM4dDc3bDJVR1BtYjZNdE1YRlBIZjV3a1o3dGVzcTMzYUdvYmd1QURWenpVT2IxVnFFQUVTUG1iaU11bU1ubDBzTTJ0dzJXV0dJZGdKUUtSRnRKd0RSYTZZc28rNlpreXRkdDExVjBkbnVETU1tQURFR1RGWjY0TmlQem1XWFVSY3pGa2FCQUVTdm1hYjB3TkZuejBaVlNsV2xJNzFnWkFoQTlKUUpTai84L0pjWHppeGQ3VEljN0FValJRQ2lkMHhOK3VHVjA2dVBQVHAzN0lXbFNKTVdSbzRBUkkrWWxQUkRadjc0SDFhV0x6V1p4ZmVkWVRUZEhJRHE5WXd5Mjk0ckFERlNURWQ2NDVtLytXMTF0VzBYWmdRZkdHVWZCYUF1NnZzM2YxY0FZdFE0dVozZXFLNjI3ZnhVcVV4YUdHazd4V3liRWRtdXpTeHZESzdNdHZkdTF1dC8vZXo2aVJQK2NtSDRaSEQ2NU9nTHkxM0pxaDMyT0lEZDJUbCtyOUlBTVVwTVB2cmtxUmVYcWk3dGRJWitFWUFZS2FZZFBYUHMrWE9sUkNmOVFOL2NGSUEyNnZVUWdCZ0dFNDZlZWVia3VTNTNGbEd6Ri9wbkp3Q1ZxTElVQVlpaE1OWG9ueCs4ZEdHOTJmaHdDUVg2NnJvQXRCYVJzNjN2QUhFUVRETDY1OW1mckg1eGR1NzFENWJOWHhnREphb3MyL2R2UGl3QWNUQk1ML3BuY1RIUHJWKzQwbXhGcExkZU1CNEVJQTZNaVVVdkhYMytmRldxcnRzMmhXR2NDRUFjQUZPS1hucm01RXJYTlJFUnhSZlNZTndJUU93cms0bStPdnJjdWNqTXF2TE9DOGFTQU1RK2NTWUF2WlVaVlZVRUh4aFRHVjFrdlRwOWZuTndhYmFkMzZqWC92clpTNDdDNE81NWJOQmpQL3ZGQjI4dWIzVzVYY3hrR0dzYUlQYVFxVU9QdlhKNi9iRkg3ejM2d3JJTlB6QUpCQ0QyaEVsRGoyWG1xWDlZV1ZwdFN4Y1I0ZzlNaE9zQzBHcEVDRURjTHRPRmZqdjJOMi9YVjV0bVlXYllBd0VPVGlrbHNzdlNDVURjQWR1YzZiZjZhdFBNVDVWSzVRTVRKSFBuR0wvQjZ2VFM1bUIxdHAzZnFGZHRnbWFYWkdSNjcra1h6bVVwcFRXYlllS1VpTkFBY1p0TURucnZxUmVYb3N2U1pTbGFUSmhFQWhDM3hiUmdIRHgxOGx4VXBXcUhQUTVnZUFRZ2RzbUVZQnc4OWVKUzZhS0VuM25CcFB0RUFGckxLUGUwOXdsQWZNUlVZRXo4NE5TRnk4M0d6dWJIWVk4RkdMS1BBbEFiOWNMV2x6YnE5WXdRZ05oaEVqQW1udjNiMVMvT3pMMXhhVm52QSt3b0VWbEtWVXJUaFFERVIxeCt4c1RpWXA2N2ZQRnFzNVhaT2RjTCtJZ0F4RTFjZU1iSHNlZlBsMUsxdWVWSUwrQW1BaEFmY2NrWkg4K2NYT202N1ZKSzJ1ME0zTW9uQXBCTjBKUEl4V2FzSEgzdVhHUkdYZnV0Ri9CcGRnSlFsSzdyYWdGb0F2a0VIT01sTStyS1hoL2dNMlJFWkVZWFZjbExzMHRYNnl2M3RQZHQxS3YvbDZNd0pvTkhCT1BtWnk5Zk9QUE9SalpweHcrd0N4bWxpdEoxWGJldzlmQkd2Wm9SOS9nUTRsaHphUmszcjd5Mit0anZ6eDA3dVR6c2dRQTlrcEVSZFFoQWs4QkZaZHhrNWsvK2Z1WDhwYmFKc09NSHVCMEMwRVJ3T1JsRHgzL3dkbXcwelFNekpqaHcrd1NnTVdlYk0rTm9vMm5tcG9ZOUNLQ25TcFFTWFZSWlhacGR1bHF2M3RQTzJ3UTlUbVJZeHRQVEo1ZXlpcnIxeGd1NEd4cWdNZVRpTVo2ZWVuR3B0T1kzc0NjRW9MSGlzakcyanY1b0tkSkxYV0N2M0JpQUJtdWxsSmx0SDBMc0g0OEZ4bGRHS1ZHODhnTDJ4ZzE3Z0xhbXI4eHMzN2N4V1B2K2o5YnNBZW9YV1pWeDluK2Z1bmkxMmQ3T2JWTWQyRk1aVVVYVmxhcWV2L0lsRFZDL2FIMFlaOVAxMUwrY1B5VDNBSHV0UkdSMEpadjhxQUdLUThNZUZMc2orakRPSHBpNTk5MnJsNXhvQWV5YnpEYWl5ZmpmSWphSFBSWjJSL1JobkYzWXZQeTc5OXlmMFExN0lNRFlxcW9TSmVPL1I4d01leWpzanVqRE9OdHF0OTlZWGZIQ0M5Z1BwVVFwTWIvNTVabm12czE2TFZhR1BTQjJ4eU9Cc1hYczFGSTI1ZHJ2VVFIMlRpa1JFZk9iWDk2czF5SmlwcDJ6d2JsSEJzTWVBT3lYYkxNTUlyZUhQUTVnTE9ST3pSTVJINGFlelhwTjZPa2pGNHp4OU9STGI5VmRYYnBpanpOd2wzWkNUMlFWZys3K0s1cWUzdFA2TUo2cXJOdXFIWFFPTVFYdTNMV21KNnVvdS91dmZHbWpXOStZV3B2ZEZucjZ6Y1ZqREIwL2ZxYVpIOFQwVkxSKzJ3WGNpWnVhbm8zQmVwUVVlc2FEMW9jeDFNM1dnOVdtWFJqWTN3emNMazNQMkJOOUdEZEhqdVRHNXNyMFFoUFpYZnNaQnNBdUNEMFRRdlJoM013L2VHWGx6VU1QSFY3MlBoZllKYUZub29nK2pKdkI3UFlqaDkvcklrVWY0SE5sUkdTVUl2Uk1FSmVXc1hMMDVQbklEQ2RYQUovbjQ5QVQzZjFiTmpKUEVLMFBZeVd6SzZYeStXYmdNM3djZWtwMy85YVhOdXIxalhwdHRoRjZKb1hMelBoNDRzUzdnMEViVmRhbFpJby93TTF1Ym5ycTlZaWM5WEhDQ2FQMVlYd01CdEUwOWZSVTQ5UXU0Qk5LWnQ3YzlBZzlFOGtsWjB3c0x1Ylp0WXRiMFhSZE0reXhBQ05sSi9SRVJHaDZDSzBQWStQQzV1V0g1eFpldjdRazBBTWYyZ2s5V2NwTzZGblQ5QkNpRDJOanE5MStZM1ZGN2dFaVltY3BLRkdpcE5ERFRVd0N4c0d4VTB2WmxBaWJmSUJyb2FkMDNWenovMjdVWDQ4NEpQUndQYTBQNHlEYkxJUEk3V0dQQXhpbTYwUFBQMjVXdjdkWi9kNXMrOHEzdnZXdFlRK00wU0lGMDN0UHZ2UlczZFdsSzhWOGhnbDFROU96V2YxZVJNeDB2eFY2dUNXdEQ3MVhaZDFXN2FDYkd2WkFnSU4zaTZaSDZPR3orU3VaZmp0Ky9Fd3pQNGpwcVdnZFhnRVRSZFBESGRMNjBHL2RiRDFZYmRxRmdmM05NREUwUGR3VnJRODlkdVJJSHZycXl2UURUV1JHTVpsaElwU29ORDNjRGEwUFBUYi80SldWTnc4OWRIaFppSWNKVVVvOXYva1BtaDd1aHVoRGp3MW10eDg1L0Y0WEtmckEyTnNKUFJ2MTcyM1cvM0ttZlV2bzRZNTVZTkJYUjArZWo4d0l1NXRoekgwVWVrb1VvWWU3cC9XaHJ6SzdVaXFmYjRZeGRuM1RNeXYwc0VlMFB2VFNFeWZlSFF6YXFMSXVKVlA4Z1hHajZXSC9hSDNvcGNFZ21xYWVubXFjMmdWalJ0UERmdFA2MEQrTGkzbDI3ZUpXTkYzWERIc3N3QjRvcFdTbXBvZURvZldoZnk1c1huNTRidUgxUzB1eU8vUmR1ZmJPdXJ0LzY1ODBQUndNMFlmKzJXcTMzMWhka1h1ZzEyNE1QWTlzMW8vTXRyN1R3MEh3OEtCbmpwMWF5cVpFMk9RRGZmWGg2NjJjMy95bmpmcVJFakhUdmkzMGNHQzBQdlJNdGxrR2tkdkRIZ2R3KzBvcEVUYzFQVUlQQjAzclE1ODgrZEpiZFZlWHJoUlRGM3JsdzlDVDg1di90RmsvRXBvZWhrZnJRNTlVV2JkVk8raW1oajBRWUxjK2FucDJRczltL1lqUXczRDUwNW5lT0g3OFRETS9pT21wYUIxZUFUMVFydjFMMDhObzBmclFHOTFzUFZodDJvV0IvYzB3NG5aQ1Q1VjVuNmFIMGFQMW9SK09ITWxEWDEyWmZxQ0p6Q2ptTFl5b2owUFAxajl0MW8rVWlHbWhoeEdqOWFFZjVoKzhzdkxtb1ljT0w4dnJNSnB1YW5xMk5EMk1LdEdIZmhqTWJqOXkrTDB1VXZTQlVTUDAwQytlSXZUQTBaUG5JelBDN21ZWUxWNXYwVWRhSDNvZ3N5dWw4dmxtR0JIbHcvK2g2YUdQdEQ2TXVpZE92RHNZdEZGbGZlM0VIMkJvU2tRWFVXVlVSZE5EWDJsOUdIV0RRVFJOUFQzVk9MVUxobWduOUVTSnlKemYvcWZOU3RORFgybDlHR21MaTNsMjdlSldORjNYREhzc01LRjJRazhwa1psTDMvaktsLzd4Ti9ldXZPdnNMZnBMOUdHa1BmdTM2MStjdWZmMVMwdm1LaHk4bTBMUDNPbTFpRmo3MnR3UjM5YWl6N3p3WXFSdHRkdHZySzdJUFhEQXJuKzlkZTd4cjh5ZFhwczd2U2IwTUI1TVlrYlhzVk5MMlpRSW0zemc0R2g2R0h0YUgwWlh0bGtHa2R2REhnZE1CazBQRThLRVprUTkrZEpiZFZlWHJoU3pGUFpaaWNoU0lsTFR3eVRRK2pDaXFxemJxaDEwVThNZUNJeXpuZENUa1ZWVnZmMG52NnZwWVJLWTNJeWk0OGZQTlBPRG1KNksxdUVWc0M4eW9wUVNrVlZWdi8wbnZ6di8ybnFVc3ZyNzl3bzlqRDJ0RDZPb202MEhxMDI3TUxDL0dmYmNUdWdwSHpZOTg2K3R6LytQeTZ1UDNpZjBNQ0ZNZEViT2tTTjU2S3NyMHc4MGtSbldZbmJ4c3lvQUFCU0ZTVVJCVk5nN21oNElyUThqYVA3Qkt5dHZIbnJvOExKb0RudEYwd01mRVgwWU9ZUFo3VWNPdjlkRmlqNXc5NFFldUltcHoyZzVldko4Wk81OFhnUzRHMTV2d1MxcGZSZ3RtVjBwbGM4M3c5M0lpSktsVkpvZXVBVzNBU1BraVJQdkRnWnRWRm1Ya2luK3dHM2JDVDFSWmR0MjcvejdoelE5OEVsYUgwYklZQkJOVTA5UE5VN3RndHYxVWRQVGR1MDdqejkwMyttMSszNjl1dm9IODBJUDNNUXR3YWhZWE15emF4ZTNvdW02WnRoamdUNjVxZW01Ny9SYVpLNExQZkFwdEQ2TWlndWJseCtlVzNqOTBwSkVEcnRXSXVPbXBrZm9nYzhtK2pBcXR0cnROMVpYNUI3WW5SSVpwZTZhSm9VZXVDMXVFa2JDc1ZOTDJaUUltM3pnYzEwWGV2NzlRM09uVnpORDZJSGQwL293RXJMTk1vamNIdlk0WUtTVkVoRlYxelQ1enA4K05IZDY5YjVmcjY0SlBYQ2IzREFNMzVNdnZWVjNkZWxLTVNIaDFxNkZudHl1ei8zWmx6UTljRGUwUGd4ZmxYVmJ0WU51YXRnRGdSRjBYZWo1eGxmbVRxL04vWHBkMHdOM3c4M0RrQjAvZnFhWkg4VDBWTFFPcjREcjNkVDByRVdXdFQvd1JXYTRXMW9maHF5YnJRZXJUYnN3c0w4WlBuVExwbWRPNklFOTRVWmltSTRjeVVOZlhabCtvSW5Nc0t5RHBnZjJuOWFIWVpwLzhNckttNGNlT3J3c2hVT0pvdW1CQXlENk1FeUQyZTFIRHIvWFJZbytUTFlTcGN1bUVucmdBTGkxR0pxako4OUhab1RkelV5eUVxV3JzLzcyTjc3MDNPbTFONzNlZ3YybjlXRm9NcnRTS3A5dlpsTHRoSjdxMjQ5LzVkWFRhNzg2dmY1blg1c3JRZy9zUDdjWncvSEVpWGNIZ3phcXJFdkpGSCtZS0I4M1BhK2VYaXRSRG4vdFBxRUhEb3pXaCtFWURLSnA2dW1weHFsZFRKS2JtNTdITkQxdzROeHlETUhpWXA1ZHU3Z1ZUZGMxd3g0TEhBeE5ENHdLclE5RGNHSHo4c056QzY5ZldoSyttUUNhSGhndG9nOURzTlZ1djdHNkl2Y3c3akpLQ0Qwd2F0eUVITFJqcDVheUtSRTIrVERHTWtwMFdmK0YxMXN3ZXJRK0hMUnNzd3dpdDRjOUR0aHJtVkhLaDZIbjhTKzljbnJ0bGRQclg5ZjB3SWh4UTNLZ25uenByYnFyUzFlS3VjY1kyUWs5VmFtYUxIL3hqUys5Y25vdG9ueGQwd01qU2V2RGdhcXlicXQyMEUwTmV5Q3dOM1pDVDExVlRWYmZlL3hMcjU1ZTEvVEFpSE56Y25DT0h6L1R6QTlpZWlwYWgxZlFlemMxUGErZVhzOElUUStNUHEwUEI2ZWJyUWVyVGJzd3NMK1pYdnVVcGtmb2dYNXdvM0pBamh6SlExOWRtWDZnMlhsdURIczRjQ2QySm05VmlxWUgra3Zyd3dHWmYvREt5cHVISGpxOExIRFRSenVocDY1S2R2R2RienlvNllIK0VuMDRJSVBaN1VjT3Y5ZEZpajcweXlkRHo2dW4xeDhUZXFDMzNMb2NoS01uejBkbWhOM045TWxIcjdleWkrOSs4OEZYVDY5SGhOQURmYWYxNFNCa2RxVlVQdDlNZjJSRTBmVEFXSElicysrZU9QSHVZTkJHbFhVcG1lSVBJeTRqU2xVeXUwclRBMk5KNjhPK0d3eWlhZXJwcWNhcFhZeTJuZEFUMlpYdmZPUExyNTVlMC9UQVdISkxzNzhXRi9QczJzV3RhTHF1R2ZaWTROTmtSRlFsUG14NjFpS0swQVBqU3V2RC9ycXdlZm5odVlYWEx5M0oyWXlrajBKUDk1MXZQUHhoMCtNWUNoaG5vZy83YTZ2ZGZtTjFSZTVoOU53VWVsWmZQYjM2Mk5mbWhSNFllMjV5OXRHeFUwdlpsQWliZkJncEg0ZWU3Mzd6NFZkUHIwYUUwQU9UUSt2RFBzbzJ5eUJ5ZTlqamdHczBQWURXaDMzejVFdHYxVjFkdWxKTU00WlAwd05jby9WaHYxUlp0MVU3NkthR1BSQW1uS1lIdUlHYm4zMXgvUGlaWm40UTAxUFJPcnlDWWNsU1NtU0piRFE5d0VlMFB1eUxiclllckRidHdzRCtab1poSi9SVWRZbi84UGlEcjU1ZTAvUUFIN0VRc1BlT0hNbERYMTJaZnFDNWR2d2pISnhyVFU5ZHhYLzQwd2QvOWRwNmlmakRSMzJjRVBpWTFvZTlOLy9nbFpVM0R6MTBlRm0yNWdEZDBQVDg2clgxLy9iYSttR2hCL2dFMFllOU41amRmdVR3ZTEyazZNT0JFSHFBMjJCcFlJOGRQWGsrTWlQc2J1WUFlTDBGM0RhdEQzc3NzeXVsOHZsbTlwbW1CN2hEbGduMjBoTW4zaDBNMnFpeUxpVlQvR0UvWkdRcFJkTUQzQ0d0RDN0cE1JaW1xYWVuR3FkMnNTOHlTcWxLbGQvUjlBQjN5cExCbmxsY3pMTnJGN2VpNmJwbTJHTmg3R1NVVWtySjd6eis1VmRQcjVVU2h4K2RFM3FBTzZEMVljOWMyTHo4OE56QzY1ZVdSR3IyMGs3b3FmSTdqei80NnVtMVg3MjI5dGpYaEI3Z3pvays3Sm10ZHZ1TjFSVzVoejBqOUFEN3dDTEMzamgyYWltYkVtR1REM3ZCNnkxZzMyaDkyQnZaWmhsRWJnOTdIUFNkcGdmWVp4WVU5c0NUTDcxVmQzWHBTakdqdUdPYUh1QkFhSDNZQTFYV2JkVU91cWxoRDRSZUtoRVJtaDdnZ0ZoY3VGdkhqNTlwNWdjeFBSV3R3eXU0UFR1aHB5bjVsNW9lNEtCb2ZiaGIzV3c5V0czYWhZSDl6ZXplZGFIbndWZE9yNzM4MnRvZmFYcUFBMkdoNGE0Y09aS0h2cm95L1VBVG1lRzV4UzZVaUN5bGpmekx4Ny84eXVtMUxQRkhtaDdnQUdsOXVDdnpEMTVaZWZQUVE0ZVh4V2crMTA3b2FTTC84dkVIWDNsTjB3TU1oK2pEWFJuTWJqOXkrTDB1VXZUaE05d2k5R2g2Z0NHeDlIRG5qcDQ4SDVrUmRqZnpxVzU0dmZYYVdvYlhXOENRYVgyNGM1bGRLWlhQTjNOTG1oNWdORm1HdUVOUG5IaDNNR2lqeXJxVVRQR0hqKzJFbnFnSDMvdDMvMExUQTR3YXJROTNhRENJcHFtbnB4cW5kdkdSbmRDVDllQjcvKzVmdlByYTVWZi94NVd2Q3ozQWlMRWtjU2NXRi9QczJzV3RhTHF1R2ZaWUdBblhOejJ2dm5ZNVNubnM5NzhnOUFBalNPdkRuYml3ZWZuaHVZWFhMeTFKejN5eTZYbnMwWHVGSG1Ca2lUN2NpYTEyKzQzVkZibG53cFdJekM2blpvUWVvRWNzVXR5Mlk2ZVdzaWtSTnZsTXJwM1FFOWRDejNxVXl1c3RvQyswUHR5MmJMTU1JcmVIUFE2R0lUT2lpcWluZGtMUHEvL2p5bU9QM2lmMEFEMWl3ZUwyUFBuU1czVlhsNjRVazJmQzdJU2Uwc1gzdnZubFYxNWJMNW9lb0orMFB0eWVLdXUyYWdmZDFMQUh3c0c1Rm5veXZ2ZjRsMTg1dmZicTZiV3ZPM3NMNkMyTEY3ZmgrUEV6emZ3Z3BxZWlkWGpGUkxpaDZUbTlWaUllRTNxQW50UDZjQnU2MlhxdzJyUUxBL3VieDU2bUJ4aFhGakoyNjhpUlBQVFZsZWtIbXNnTWo4RHhwZWtCeHB2V2g5MmFmL0RLeXB1SEhqcThMREdQcDUyUEZXaDZnSEVuK3JCYmc5bnRSdzYvMTBXS1B1TW1JMHBrZENVcW9RY1llNVkyZHVYb3lmT1JHV0YzODNqWkNUM1pEZXJ5N1QvOWl0ZGJ3Q1RRK3JBcm1WMHBsYzgzajQ4UG01NUJWYjc5cHcrOWVucjFWNjlwZW9DSllKbmo4ejF4NHQzQm9JMHE2MUl5eForZXU3SHBlZlgwYWlubDhLTkNEekFwdEQ1OHZzRWdtcWFlbm1xYzJ0VnZ0MnA2SHZ2YXZOQURUQlJMSHA5amNUSFBybDNjaXFicm1tR1BoVHVsNlFINGtOYUh6M0ZoOC9MRGN3dXZYMW9TbEh0SjB3TndJOUdIejdIVmJyK3h1aUwzOUU5bWxDTDBBTnpFSXNobk9YWnFLWnZ5NGRmdTZJa1BQN2ZkdGZrWGYrYjFGc0FOdEQ1OGxteXpEQ0szaHowT2Rta245SlN5RTNwZStmWGFLNzllKy9vZmFIb0FQbVpCNUZNOStkSmJkVmVYcmhUelpQVGQyUFM4OHV1MWlQajZIMmg2QUc2bTllRlRWVm0zVlR2b3BvWTlFRDdUclpzZW9RZmcxaXlPM05yeDQyZWErVUZNVDBYcjhJcFJwZWtCdUgxYUgyNnRtNjBIcTAyN01MQy9lUlJwZWdEdWxJV1NXemh5SkE5OWRXWDZnZWFqWG9GUmtSbFZpZFQwQU53aHJRKzNNUC9nbFpVM0R6MTBlRms0SGlFN29TZEtpZnp1TnpROUFIZEk5T0VXQnJQYmp4eCtyOXY1RWpERFZpS3l4RWVoNTlYVGE2KytKdlFBM0NGTEp6Yzdldko4WkViWTNUeDhPNkduS3BHWjMzMzhLNitlWG9zU2ovazRJY0JkMFBwd3M4eXVsTXJubTRkckovU1VFcEg1blQvOXlxdXZyYjM2MnRwalh4TjZBTzZXWlpRYlBISGkzY0dnalNyclVqTEZueUc0dWVsNWJTMUMwd093WjdRKzNHQXdpS2FwcDZjYXAzWWR2RnMzUFVJUHdKNnlwUEt4eGNVOHUzWnhLNXF1YTRZOWxzbWk2UUU0TUZvZlBuWmg4L0xEY3d1dlgxcVNpUS9NVHVqSmpNRmc4Qi8rN1NGTkQ4QitFMzM0MkZhNy9jYnFpdHh6TUs0UFBWM2IvZDZYcHY3Yi83d3M5QURzTjlHSGE0NmRXbHB2TnNJV240T1FVY3BIb2FkcnU2cXUvdmMvV2hqMnFBQW1ndWpETmRsbUdVUnVEM3NjWXk2amxCS2x2aTcwZlB2Zi9lNndSd1V3UVZUclJFUTgrZEpiZFZlWHJoUlRZci9zaEo2b0I0T3U2eUtpcW9RZWdDSFEraEFSVVdYZFZ1MmdteHIyUU1iU2RVMVAxM1ZkSi9RQURKSG9ReHcvZnFiWnlucDZ4dUVWZXkwalNpbENEOEFJRVgySWJyWWVyRGJ0d3NBTzU3MXpMZlIwWFZkS0pmUUFqQTdSWjlJZE9aSWJteXZUQzAxa0YzNVd2UWMrRGoyWjEvNlh2L2pHVjRZOUtnQ3VFWDBtM2Z5RFYxYmVQUFRRNFdWNzN1L2F6YUVuTS8vOG13OFBlMVFBM0VEMG1YU0QyZTFIRHIvWFJZbytkMEhvQWVnTlQ3dUpkdlRrK2NpMHUva3VsUkpkMTBXVVVpSXovK0xmQ3owQW8wdnJNOUV5dTFJcUgzQytZNWtSb2VrQjZCUFJaM0k5Y2VMZDdOcXMycnFVVFBIbk5wUVNYUmNSWFVUWk9ZeEw2QUhvQzlGbmNnMEcwVFQxOUZTVGFwOWQyd2s5VlYyWGJETkxoTmRiQUQxanI4K0VXbHpNczJzWHQ2THB1bWJZWSttSG5kQlREK3JzdW95b3F1cTdmL3FsWVE4S2dOdW05WmxRRnpZdlB6eTM4UHFsSmZIM2MzM1U5RlJ4N1l2TTN4TjZBSHBMOUpsUVcrMzJHNnNyY3M5bkUzb0F4bzhuM3lRNmRtb3BteEpoazgrbjhub0xZRnhwZlNaUnRsa0drZHZESHNkSTB2UUFqRGV0ejhSNThxVzM2cTR1WFNtdS9vMUtpY3lvYWswUHdEalQra3ljS3V1MmFnZmQxTEFITWtKS1JwWW9WUjFkbDExWE5EMEE0MHYwbVN6SGo1OXB0cktlbm5GNHhZNXJvU2U3S05WTzZOSDBBSXczMFdleWRMUDFZTFZwRndiMk4zOGNlckprS2FYcnZ2dG5QazRJTVA1RW53bHk1RWh1Yks1TUx6U1JYWlRKM2VoemMrakovSzR2TWdOTURORm5nc3cvZUdYbHpVTVBIVjZlMk8zdFFnOEFvczhFR2N4dVAzTDR2UzV5QXFPUDBBUEFqb2w3QkU2c295ZlBSK2JFN1c0dXBYU1pKYXF1eXloUm9tVGEwd013eWJRK2t5S3pLNldhb004MzczeWxKMVBUQThEMXRENFQ0WWtUN3c0R2JWUlpsNUk1N3ZGbkovUkVSR21qS3lXS3BnZUFqMmg5SnNKZ0VFMVRUMDgxWTM1cTE0ZE5UNVEyc2tTV3FQSjczeEI2QVBpWTFtZjhMUzdtMmJXTFc5RjBYVFBzc2V5YjY1dWVMQkVSSmYvOEc0OE1kMUFBakNDdHovaTdzSG41NGJtRjF5OHRqV2ZTL1dUVEkvUUE4T2xFbi9HMzFXNi9zYm95aHJsSDZBSGc5bzNkNDVBYkhUdTFsRTJKR0s5TlBsNXZBWENudEQ1akx0c3NnOGp0WVk5anIreDhqbEhUQThDZDB2cU1zeWRmZXF2dTZ0S1ZNZ1lYT2lOS2xNZzY2amJhakJSNkFMZ0RXcDl4Vm1YZFZ1MmdteHIyUU83T1R1Z3BXVWZkUmRkRlYwZjk3VzgrT094aEFkQkxvcy9ZT243OFRMT1Y5ZlJNancrditFVG9xYUlTZWdDNEc2TFAyT3BtNjhGcTB5NE1lcm0vV2VnQllIK0lQdVBweUpIYzJGeVpYbWdpdXlpOTJ1Z2o5QUN3bjBTZjhUVC80SldWTnc4OWRIaTVUenZaaFI0QTlwL29NNTRHczl1UEhINnZ1L1piOEpHWFVVcUowZ2s5QU95M1Bqd1h1VTFIVDU2UHpIN3NidDRKUGRHMVVkZVJKVkxvQVdCZmFYM0dVR1pYU2pYcW4yL09LS1YwcGV1aUtsR1Y2TnFvL3ZLYlh4NzJzQUFZYzFxZmNmUEVpWGNIZ3phcXJFdkpITW40c3hONm9zdW9kMDdoaXFqK1V0TUR3SUhRK295YndTQ2FwcDZlYWtieDFLNGJtNTZJTGpVOUFCd3NyYzlZV1Z6TXMyc1h0NkxwdW1iWVk3bVJwZ2VBMGFEMUdTc1hOaTgvUExmdytxV2xFUXExbWg0QVJvbm9NMWEyMnUwM1ZsZEdKZmNJUFFDTW50RjRScklYanAxYXlxWkVqTUFtbnc5ZmIxV0R1bXN6MCtzdEFFYUYxbWQ4Wkp0bEVMazk1R0dVS0YzcHlxQXFYWlZkVjlYVjkvNUUwd1BBcU5ENmpJa25YM3FyN3VyU2xUSzhhMXFpdE5uVlUzVjJHWkdscXI3M0o1b2VBRWFMMW1kTVZGbTNWVHZvcG9ieVQvOHc5RlJWVzNXdHBnZUEwU1g2aklQang4ODBXMWxQenh6ODRSV2ZERDEvTHZRQU1NSkVuM0hRemRhRDFhWmRHQnprL21haEI0QStFbjE2NzhpUjNOaGNtVjVvSXJzb0I3SFJKeU15VStnQm9JOUVuOTZiZi9ES3lwdUhIanE4ZkFDYjFxK0ZucXk3cWhONkFPZ2owYWYzQnJQYmp4eCtyNHZjMStqemNlaUpyb3V1NnFydi9abGZid0hRUDM3YzNtOUhUNTZQekgzZDNYeDk2SW1JS29RZUFIcE02OU52bVYwcDFUNTl2amtqU2lsVlc2NDFQVUlQQVAybjllbXhKMDY4T3hpMFVXVmRTdVpleHArZDBGUGFraVVqb21RUmVnQVlEMXFmSGhzTW9tbnE2YWxtRDAvdCtxanB5WkpaVXVnQllNeG9mZnBxY1RIUHJsM2NpcWJybXIzNXYxaEtSR2g2QUJodldwKyt1ckI1K2VHNWhkY3ZMZTFCZmkwbElySkU2VUxUQThCNEUzMzZhcXZkZm1OMTVXNXp6NGVoSnpJaUk2djRpOGQ5cHdlQWNlYUZWeThkTzdXVVRZbTRpMDArMTRlZWlDaENEd0FUUWV2VFM5bG1HVVJ1My81L3MxejcxMGROajlBRHdFUVJmZnJueVpmZTZyb3MyMUZ1cTdTN0ZucTZMRVhvQVdCaWlUNzlVMlhkVnUyZ205cnRmK0dHMEZNaU0wb1JlZ0NZVEtKUHp4dy9mcWJaeW5wNlpsZUhWNVRZMmNzajlBREFEdEduWjdyWmVyRGF0QXVEejluZi9ISG9xU0pUNkFHQUhhSlBueHc1a2h1Yks5TUxUV1MzOHhPdFd4QjZBT0RUaVQ1OU12L2dsWlUzRHoxMGVQbldYeVVRZWdEZzg0ZytmVEtZM1g3azhIdmR6cSt6cmlmMEFNRHUrS1JoYnh3OWVUNHliN0c3dVZ3WGVpS0VIZ0Q0REZxZjNzanNTcWx1K0h4enlaSlZWNHFtQndCMlNmVHBoeWRPdkp2WlpyUjFLWm01Y3c1RlYwcGVPMjlVNkFHQVhSRjkrbUY2WnJDMUdkTXoyNW1sUktraTJvaVNrYVg4dWRBREFMc20rdlREVk5mTTNIL1AxdFdtaXVnaU1xS08rTTQzaEI0QXVEMmlUejlNVjJWdzZZT2NubXFpcTZKODU1dENEd0RjQ2RHbkh3YWJHeEZ4ejliMnQ3NzF5TERIQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIzNmY4SHVHQ01rVWdYY000QUFBQUFTVVZPUks1Q1lJST0iIGhlaWdodD0iNzY2IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCBtZWV0Ii8+PC9nPjwvZz48L2c+PC9nPjwvcGF0dGVybj48Y2xpcFBhdGggaWQ9ImI4MDRiZjUzZDEiPjxwYXRoIGQ9Ik0gMCA2NTUuNjQ4NDM4IEwgODg4LjYxMzI4MSA2NTUuNjQ4NDM4IEwgODg4LjYxMzI4MSA4NDQuMzQ3NjU2IEwgMCA4NDQuMzQ3NjU2IFogTSAwIDY1NS42NDg0MzggIiBjbGlwLXJ1bGU9Im5vbnplcm8iLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0iODljMmIzMTA1YSI+PHBhdGggZD0iTSAwIDAuNjQ4NDM4IEwgODg4LjYxMzI4MSAwLjY0ODQzOCBMIDg4OC42MTMyODEgMTg5LjM0NzY1NiBMIDAgMTg5LjM0NzY1NiBaIE0gMCAwLjY0ODQzOCAiIGNsaXAtcnVsZT0ibm9uemVybyIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSJmN2RiYjdmNGYyIj48cmVjdCB4PSIwIiB3aWR0aD0iODg5IiB5PSIwIiBoZWlnaHQ9IjE5MCIvPjwvY2xpcFBhdGg+PGNsaXBQYXRoIGlkPSJjZjUxMmZiNDI1Ij48cGF0aCBkPSJNIDY4MSA5NzYgTCAxNTAwIDk3NiBMIDE1MDAgMTUwMCBMIDY4MSAxNTAwIFogTSA2ODEgOTc2ICIgY2xpcC1ydWxlPSJub256ZXJvIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9IjAyZjhjZjdiM2MiPjxwYXRoIGQ9Ik0gNjgxLjYzNjcxOSAxMzMxLjMwODU5NCBMIDEzODcuMjU3ODEyIDk3Ni4wMjczNDQgTCAxNTAwIDExOTkuOTM3NSBMIDc5NC4zNzg5MDYgMTU1NS4yMjI2NTYgWiBNIDY4MS42MzY3MTkgMTMzMS4zMDg1OTQgIiBjbGlwLXJ1bGU9Im5vbnplcm8iLz48L2NsaXBQYXRoPjxjbGlwUGF0aCBpZD0iOGQ0Njk3NGJmOSI+PHBhdGggZD0iTSAwLjYwMTU2MiAwIEwgODE5IDAgTCA4MTkgNTI0IEwgMC42MDE1NjIgNTI0IFogTSAwLjYwMTU2MiAwICIgY2xpcC1ydWxlPSJub256ZXJvIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9IjkwNWMwZjdkNWEiPjxwYXRoIGQ9Ik0gMC42MzY3MTkgMzU1LjMwODU5NCBMIDcwNi4yNTc4MTIgMC4wMjczNDM4IEwgODE5IDIyMy45Mzc1IEwgMTEzLjM3ODkwNiA1NzkuMjIyNjU2IFogTSAwLjYzNjcxOSAzNTUuMzA4NTk0ICIgY2xpcC1ydWxlPSJub256ZXJvIi8+PC9jbGlwUGF0aD48Y2xpcFBhdGggaWQ9IjhhOWM3ZWE5YzEiPjxyZWN0IHg9IjAiIHdpZHRoPSI4MTkiIHk9IjAiIGhlaWdodD0iNTI0Ii8+PC9jbGlwUGF0aD48L2RlZnM+PHJlY3QgeD0iLTE1MCIgd2lkdGg9IjE4MDAiIGZpbGw9IiNmZmZmZmYiIHk9Ii0xNDkuOTk5OTkzIiBoZWlnaHQ9IjE3OTkuOTk5OTIiIGZpbGwtb3BhY2l0eT0iMSIvPjxyZWN0IHg9Ii0xNTAiIHdpZHRoPSIxODAwIiBmaWxsPSIjZmZmZmZmIiB5PSItMTQ5Ljk5OTk5MyIgaGVpZ2h0PSIxNzk5Ljk5OTkyIiBmaWxsLW9wYWNpdHk9IjEiLz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwLjAwMDAwMDAwMDAwMDExMjg2MSkiPjxnIGNsaXAtcGF0aD0idXJsKCNhMzQ1NGJhZWU5KSI+PGcgY2xpcC1wYXRoPSJ1cmwoI2Q0ZGMxYjdjNGUpIj48cmVjdCB4PSItMzMwIiB3aWR0aD0iMjE2MCIgZmlsbD0iIzliYjBlNiIgaGVpZ2h0PSIyMTU5Ljk5OTkwNCIgeT0iLTMyOS45OTk5ODUiIGZpbGwtb3BhY2l0eT0iMSIvPjwvZz48L2c+PC9nPjxnIGNsaXAtcGF0aD0idXJsKCMwMWRlZmRjZGMyKSI+PGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMSwgMjM0LCAyMzQpIj48ZyBjbGlwLXBhdGg9InVybCgjMGUzMWZjMDUyYSkiPjxnIGNsaXAtcGF0aD0idXJsKCM2MjgyNTY1YTg1KSI+PHBhdGggZmlsbD0iIzE3MWUzMSIgZD0iTSAwLjM3MTA5NCAwLjM3MTA5NCBMIDEwMzEuNjI4OTA2IDAuMzcxMDk0IEwgMTAzMS42Mjg5MDYgMTAzMS42Mjg5MDYgTCAwLjM3MTA5NCAxMDMxLjYyODkwNiBaIE0gMC4zNzEwOTQgMC4zNzEwOTQgIiBmaWxsLW9wYWNpdHk9IjEiIGZpbGwtcnVsZT0ibm9uemVybyIvPjwvZz48L2c+PC9nPjwvZz48ZyBjbGlwLXBhdGg9InVybCgjODQzYzVhMzE4MikiPjxwYXRoIGZpbGw9InVybCgjYmVlMTM2YWRjMykiIGQ9Ik0gNTU3LjAwMzkwNiAzNjcuNSBMIDEzMjIuMDAzOTA2IDM2Ny41IEwgMTMyMi4wMDM5MDYgMTEzMi41IEwgNTU3LjAwMzkwNiAxMTMyLjUgWiBNIDU1Ny4wMDM5MDYgMzY3LjUgIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PGcgY2xpcC1wYXRoPSJ1cmwoI2I4MDRiZjUzZDEpIj48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCA2NTUpIj48ZyBjbGlwLXBhdGg9InVybCgjZjdkYmI3ZjRmMikiPjxnIGNsaXAtcGF0aD0idXJsKCM4OWMyYjMxMDVhKSI+PHBhdGggZmlsbD0iIzliYjBlNiIgZD0iTSAwIDAuNjQ4NDM4IEwgODg4Ljk0OTIxOSAwLjY0ODQzOCBMIDg4OC45NDkyMTkgMTg5LjM0NzY1NiBMIDAgMTg5LjM0NzY1NiBaIE0gMCAwLjY0ODQzOCAiIGZpbGwtb3BhY2l0eT0iMSIgZmlsbC1ydWxlPSJub256ZXJvIi8+PC9nPjwvZz48L2c+PC9nPjxnIGNsaXAtcGF0aD0idXJsKCNjZjUxMmZiNDI1KSI+PGcgY2xpcC1wYXRoPSJ1cmwoIzAyZjhjZjdiM2MpIj48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCA2ODEsIDk3NikiPjxnIGNsaXAtcGF0aD0idXJsKCM4YTljN2VhOWMxKSI+PGcgY2xpcC1wYXRoPSJ1cmwoIzhkNDY5NzRiZjkpIj48ZyBjbGlwLXBhdGg9InVybCgjOTA1YzBmN2Q1YSkiPjxwYXRoIGZpbGw9IiM5YmIwZTYiIGQ9Ik0gMC42MzY3MTkgMzU1LjMwODU5NCBMIDcwNi40OTIxODggLTAuMDg5ODQzOCBMIDgxOS4yMzA0NjkgMjIzLjgyNDIxOSBMIDExMy4zNzg5MDYgNTc5LjIyMjY1NiBaIE0gMC42MzY3MTkgMzU1LjMwODU5NCAiIGZpbGwtb3BhY2l0eT0iMSIgZmlsbC1ydWxlPSJub256ZXJvIi8+PC9nPjwvZz48L2c+PC9nPjwvZz48L2c+PC9zdmc+"/>
<link rel="icon" type="image/png" href="data:image/png;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCAfQB9ADASIAAhEBAxEB/8QAHAABAQEBAQEBAQEAAAAAAAAAAAgHBQYCBAMB/8QAQhABAAAFAQIKCQQBAwMEAwEAAAECAwQGBRGUFiExNlZhcXWz0QcSExQXQVFUgRUyQoIiCGKRIyRSJXKSojNDRGT/xAAaAQEBAQEBAQEAAAAAAAAAAAAABAMFAQIG/8QAJREBAAIBBAIDAQEBAQEAAAAAAAECAxMUMVEEESEyYRIiQVJx/9oADAMBAAIRAxEAPwDTQH7JxwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEf5dkWQUsr1elS13VJJJL6tLLLLd1IQlhCpNshCG3kYZs0YoiZh90p/awBFfCbJOkGrb5U8zhNknSDVt8qeaffR000J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoIr4TZJ0g1bfKnmcJsk6QatvlTzN9HRoT2tQRXwmyTpBq2+VPM4TZJ0g1bfKnmb6OjQntagivhNknSDVt8qeZwmyTpBq2+VPM30dGhPa1BFfCbJOkGrb5U8zhNknSDVt8qeZvo6NCe1qCK+E2SdINW3yp5nCbJOkGrb5U8zfR0aE9rUEV8Jsk6QatvlTzOE2SdINW3yp5m+jo0J7WoI/xHIsgq5XpFKrruqTyT31GWaWa7qRhNCNSXbCMNvIsBRhzRliZiGd6fwAN3wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAei9HWqWOlZZaVNVt6FxplePu95TrSQmkjSm4oxjCP8A4x2Tf1a9m/oLsrmE93id57pUjx+6XE0ZqceqWfjjL+dvbBrTDa9fdXxa8Vn1Kfx1ckx3W8cvPdNa06vZ1P4xnhtln65ZocU0OyLlMpiYn1L75AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdbDeeGi94UPElWoivDeeGi94UPElWo6Pg/WU2fmABewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEV5lzw1rvCv4ky1EV5lzw1rvCv4kyDzuIb4OZckBzlIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq/0GZJwiwK1hWqeteWH/a19seOPqw/wm/Muzj+sIpQaR/p6yT9DzmSwr1PVtNVhC3m2x4oVOWnH/mMZf7KPFyfxk/8ArPLX+qqY1PT7HVLOey1G0oXdvP8Aup1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YNqHUyYqZI/1CWt5rwirJMd1vHLz3TWtOr2dT+MZ4bZZ+uWaHFNDsi5S4NT0+x1SznstRtKF3bz/up1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YOfl8O1fmvyormieU/jq5Jjut45ee6a1p1ezqfxjPDbLP1yzQ4podkXKRzExPqW3IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrYbzw0XvCh4kq1EV4bzw0XvCh4kq1HR8H6ymz8wAL2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAivMueGtd4V/EmWoivMueGtd4V/EmQedxDfBzLkgOcpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH1SqT0qslWlPNJPJNCaWaWOyMIw5IwfICyvR3kMmUYdp+sQjL7WrT9W4lh/GrLxTw2fLjhth1Rg9Anv/TDknuusXmMXFTZSvJfb20Ix/8A2yw/yhDtlht/ooR2sGTUpEoslf5t6AGz4fl1PT7HVLOey1G0oXdvP+6nWkhNLH8R+fWx/N/QXZ3HtLvFLv3Spy+6XE0ZqceqWfjml/O3tg2oZ5MVMkf6h9VvNeEVZJjut45ee6a1p1ezqfxjPDbLP1yzQ4podkXKXBqen2OqWc9lqNpQu7ef91OtJCaWP4j8+tj+b+guzuPaXeKXfulTl90uJozU49Us/HNL+dvbBz8vh2r81+VFc0Tyn8dXJMd1vHLz3TWtOr2dT+MZ4bZZ+uWaHFNDsi5SOYmJ9S25AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdbDeeGi94UPElWoivDeeGi94UPElWo6Pg/WU2fmABewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEV5lzw1rvCv4ky1EV5lzw1rvCv4kyDzuIb4OZckBzlIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD9uh6lc6PrFnqtnN6te1rS1ZPpGMI7dkeqPJFaGhanbazo1nqtnN61C7oy1ZPrCEYbdkeuHJHsREoP/AEw5J7zpF5jFxU21bOMbi2hGPLSmj/lCHZNHb/dZ4eT+bfzP/WOavuPbZwHUSgAAAPy6np9jqlnPZajaULu3n/dTrSQmlj+I/PrY/m/oLs7j2l3il37pU5fdLiaM1OPVLPxzS/nb2wbUM8mKmSP9Q+q3mvCKskx3W8cvPdNa06vZ1P4xnhtln65ZocU0OyLlLg1PT7HVLOey1G0oXdvP+6nWkhNLH8R+fWx/N/QXZ3HtLvFLv3Spy+6XE0ZqceqWfjml/O3tg5+Xw7V+a/KiuaJ5T+OrkmO63jl57prWnV7Op/GM8Nss/XLNDimh2RcpHMTE+pbcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOthvPDRe8KHiSrURXhvPDRe8KHiSrUdHwfrKbPzAAvYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAd/0e5BUxfMNP1iWM3sqVT1a8sP5UpuKeH/ABGMYdcIOAPYmaz7h5Me/hc9GpTrUpKtKeWenPLCaWaWO2EYR5IwfbNf9POSfreDyadXqetd6VGFCbbHjjSjx04/8QjL/VpTuY7xesWhDaPU+gB9vAAAAAAH5dT0+x1SznstRtKF3bz/ALqdaSE0sfxH59bH839Bdnce0u8Uu/dKnL7pcTRmpx6pZ+OaX87e2DahnkxUyR/qH1W814RVkmO63jl57prWnV7Op/GM8Nss/XLNDimh2RcpcGp6fY6pZz2Wo2lC7t5/3U60kJpY/iPz62P5v6C7O49pd4pd+6VOX3S4mjNTj1Sz8c0v529sHPy+HavzX5UVzRPKfx1ckx3W8cvPdNa06vZ1P4xnhtln65ZocU0OyLlI5iYn1LbkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPdeg7JODme2vtqnq2d/8A9rcbY8UPWjD1ZvxNs4/pGKsEKq99EmSQyjBrG/qVPXu6Uvu91x8ftJIQhGMe2Gyb+zoeFk5pKfPX/r1oDoJwAAAAAAAAAH5dT0+x1SznstRtKF3bz/up1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YNqGeTFTJH+ofVbzXhFWSY7reOXnumtadXs6n8Yzw2yz9cs0OKaHZFylwanp9jqlnPZajaULu3n/dTrSQmlj+I/PrY/m/oLs7j2l3il37pU5fdLiaM1OPVLPxzS/nb2wc/L4dq/NflRXNE8p/HVyTHdbxy8901rTq9nU/jGeG2WfrlmhxTQ7IuUjmJifUtuQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANX/015J+mZZV0K4qbLbVJP8Ap7Y8UK0kIxh2bYetDrj6rKH9rC6r2N9QvbWpGnXt6ktWlPDllmljthH/AJg+8d5paLPm1f6j0uQcnENaoZFjVhrVtshJdUYTzSwj+yfkml/E0Iw/DrO5ExMe4Qz8AD0AAAAAAAAAAAAfl1PT7HVLOey1G0oXdvP+6nWkhNLH8R+fWx/N/QXZ3HtLvFLv3Spy+6XE0ZqceqWfjml/O3tg2oZ5MVMkf6h9VvNeEVZJjut45ee6a1p1ezqfxjPDbLP1yzQ4podkXKXBqen2OqWc9lqNpQu7ef8AdTrSQmlj+I/PrY/m/oLs7j2l3il37pU5fdLiaM1OPVLPxzS/nb2wc/L4dq/NflRXNE8p/HVyTHdbxy8901rTq9nU/jGeG2WfrlmhxTQ7IuUjmJifUtuQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3X/AEvZJx32K3FT/wD1WsIx7IVJYf8A1js/9zdUVYhrVfHclsNattsZ7WtCeMsI7PXl5JpfzLGMPys6wuqF9Y0L21qQqULinLVpTw5JpZobYR/4i6nh5P6p/M/8S5q+p9v7gLGIAAAAAAAAAAAAAAAD8up6fY6pZz2Wo2lC7t5/3U60kJpY/iPz62P5v6C7O49pd4pd+6VOX3S4mjNTj1Sz8c0v529sG1DPJipkj/UPqt5rwirJMd1vHLz3TWtOr2dT+MZ4bZZ+uWaHFNDsi5S4NT0+x1SznstRtKF3bz/up1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YOfl8O1fmvyormieU/jq5Jjut45ee6a1p1ezqfxjPDbLP1yzQ4podkXKRzExPqW3IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrYbzw0XvCh4kq1EV4bzw0XvCh4kq1HR8H6ymz8wAL2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAivMueGtd4V/EmWoivMueGtd4V/EmQedxDfBzLkgOcpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFJf6a8k/U8Uq6FcVNtzpk/8A09vLGjPGMYduyPrQ6oeqm1630S5JHF85sb+pU9S0qze73XHxeznjCEYx7I7Jv6tvHyad4l8ZK/1VXoDtIgAAAAAAAAAAAAAAAAAAAH5dT0+x1SznstRtKF3bz/up1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YNqGeTFTJH+ofVbzXhFWSY7reOXnumtadXs6n8Yzw2yz9cs0OKaHZFylwanp9jqlnPZajaULu3n/dTrSQmlj+I/PrY/m/oLs7j2l3il37pU5fdLiaM1OPVLPxzS/nb2wc/L4dq/NflRXNE8p/HVyTHdbxy8901rTq9nU/jGeG2WfrlmhxTQ7IuUjmJifUtuQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArD0HZJwjwK19tU9a8sP+1r7Y8cfVhD1ZvzLs4/rCL3SX/wDTzkn6JnEmnV6nq2mqwhQmhGPFCrDjpx/5jGX+yoHY8bJ/eOPxHkr/ADYAUMwAAAAAAAAAAAAAAAAAAAAAH5dT0+x1SznstRtKF3bz/up1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YNqGeTFTJH+ofVbzXhFWSY7reOXnumtadXs6n8Yzw2yz9cs0OKaHZFylwanp9jqlnPZajaULu3n/AHU60kJpY/iPz62P5v6C7O49pd4pd+6VOX3S4mjNTj1Sz8c0v529sHPy+HavzX5UVzRPKfx1ckx3W8cvPdNa06vZ1P4xnhtln65ZocU0OyLlI5iYn1LbkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPulUno1ZKtKeaSpJNCaWaWOyMIw5IwWR6Pcgp5Rh+n6xLGX2tWn6teWH8asvFPDZ8uOG2HVGCNGz/wCmHJPdtXvMYuKmyleSxuLaEY8lWWH+UIdssNv9FXiZP5v67ZZq+6+1BgOskAAAAAAAAAAAAAAAAAAAAAAAAAAfl1PT7HVLOey1G0oXdvP+6nWkhNLH8R+fWx/N/QXZ3HtLvFLv3Spy+6XE0ZqceqWfjml/O3tg2oZ5MVMkf6h9VvNeEVZJjut45ee6a1p1ezqfxjPDbLP1yzQ4podkXKXBqen2OqWc9lqNpQu7ef8AdTrSQmlj+I/PrY/m/oLs7j2l3il37pU5fdLiaM1OPVLPxzS/nb2wc/L4dq/NflRXNE8p/HVyTHdbxy8901rTq9nU/jGeG2WfrlmhxTQ7IuUjmJifUtuQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP26FqVzo2s2eq2c3q17StLVk+kYwjt2R6o8ke1+IIn0Ld0PUrbWNGs9Vs5vWoXVGWrJ9YQjDbsj1w5Iv2sZ/0w5J71o95jFxU21bOPt7aEY//AKpo/wCUIdk0dv8AdszuYr6lIshtX+Z9ADR8gAAAAAAAAAAAAAAAAAAAAAAAAAAAPy6np9jqlnPZajaULu3n/dTrSQmlj+I/PrY/m/oLs7j2l3il37pU5fdLiaM1OPVLPxzS/nb2wbUM8mKmSP8AUPqt5rwirJMd1vHLz3TWtOr2dT+MZ4bZZ+uWaHFNDsi5S4NT0+x1SznstRtKF3bz/up1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YOfl8O1fmvyormieU/jq5Jjut45ee6a1p1ezqfxjPDbLP1yzQ4podkXKRzExPqW3IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrYbzw0XvCh4kq1EV4bzw0XvCh4kq1HR8H6ymz8wAL2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAivMueGtd4V/EmWoz6/8AQ/hV9f3F7cWt5GtcVZqtSMLmaEIzTRjGPF2xS+ThtliP5a4rxWflKwqP4K4J9pe71MfBXBPtL3epkmyyfjXWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqlwVH8FcE+0vd6mPgrgn2l7vUxssn4a1UuCo/grgn2l7vUx8FcE+0vd6mNlk/DWqnz0d5DPi+Y6frEIzeypVPVuJYfypTcU8Nnz4o7YdcILIpVJKtKSrSnlnknlhNLNLHbCMI8kYM6+CuCfaXu9TPd6Np9DSdKttMtZqs1C2pwpUvaT+tNCWHFCG3qhxfhX42K+OJi3DLJatvmH7AFTIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+XU9PsdUs57LUbShd28/7qdaSE0sfxH59bH839Bdnce0u8Uu/dKnL7pcTRmpx6pZ+OaX87e2DahnkxUyR/qH1W814RVkmO63jl57prWnV7Op/GM8Nss/XLNDimh2RcpcGp6fY6pZz2Wo2lC7t5/3U60kJpY/iPz62P5v6C7O49pd4pd+6VOX3S4mjNTj1Sz8c0v529sHPy+HavzX5UVzRPKfx1ckx3W8cvPdNa06vZ1P4xnhtln65ZocU0OyLlI5iYn1LbkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+XU9PsdUs57LUbShd28/7qdaSE0sfxH59bH839Bdnce0u8Uu/dKnL7pcTRmpx6pZ+OaX87e2DahnkxUyR/qH1W814RVkmO63jl57prWnV7Op/GM8Nss/XLNDimh2RcpcGp6fY6pZz2Wo2lC7t5/wB1OtJCaWP4j8+tj+b+guzuPaXeKXfulTl90uJozU49Us/HNL+dvbBz8vh2r81+VFc0Tyn8dXJMd1vHLz3TWtOr2dT+MZ4bZZ+uWaHFNDsi5SOYmJ9S25AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdbDeeGi94UPElWoivDeeGi94UPElWo6Pg/WU2fmABewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfl1PT7HVLOey1G0oXdvP+6nWkhNLH8R+fWx/N/QXZ3HtLvFLv3Spy+6XE0ZqceqWfjml/O3tg2oZ5MVMkf6h9VvNeEVZJjut45ee6a1p1ezqfxjPDbLP1yzQ4podkXKXBqen2OqWc9lqNpQu7ef91OtJCaWP4j8+tj+b+guzuPaXeKXfulTl90uJozU49Us/HNL+dvbBz8vh2r81+VFc0Tyn8dXJMd1vHLz3TWtOr2dT+MZ4bZZ+uWaHFNDsi5SOYmJ9S25AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdbDeeGi94UPElWoivDeeGi94UPElWo6Pg/WU2fmABewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfl1PT7HVLOey1G0oXdvP+6nWkhNLH8R+fWx/N/QXZ3HtLvFLv3Spy+6XE0ZqceqWfjml/O3tg2oZ5MVMkf6h9VvNeEVZJjut45ee6a1p1ezqfxjPDbLP1yzQ4podkXKXBqen2OqWc9lqNpQu7ef8AdTrSQmlj+I/PrY/m/oLs7j2l3il37pU5fdLiaM1OPVLPxzS/nb2wc/L4dq/NflRXNE8p/HVyTHdbxy8901rTq9nU/jGeG2WfrlmhxTQ7IuUjmJifUtuQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH5dT0+x1SznstRtKF3bz/up1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YNqGeTFTJH+ofVbzXhFWSY7reOXnumtadXs6n8Yzw2yz9cs0OKaHZFylwanp9jqlnPZajaULu3n/dTrSQmlj+I/PrY/m/oLs7j2l3il37pU5fdLiaM1OPVLPxzS/nb2wc/L4dq/NflRXNE8p/HVyTHdbxy8901rTq9nU/jGeG2WfrlmhxTQ7IuUjmJifUtuQAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH5dT0+x1SznstRtKF3bz/up1pITSx/Efn1sfzf0F2dx7S7xS790qcvulxNGanHqln45pfzt7YNqGeTFTJH+ofVbzXhFWSY7reOXnumtadXs6n8Yzw2yz9cs0OKaHZFylwanp9jqlnPZajaULu3n/AHU60kJpY/iPz62P5v6C7O49pd4pd+6VOX3S4mjNTj1Sz8c0v529sHPy+HavzX5UVzRPKfx1ckx3W8cvPdNa06vZ1P4xnhtln65ZocU0OyLlI5iYn1LbkAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+XU9PsdUs57LUbShd28/7qdaSE0sfxH59bH839Bdnce0u8Uu/dKnL7pcTRmpx6pZ+OaX87e2DahnkxUyR/qH1W814RVkmO63jl57prWnV7Op/GM8Nss/XLNDimh2RcpcGp6fY6pZz2Wo2lC7t5/3U60kJpY/iPz62P5v6C7O49pd4pd+6VOX3S4mjNTj1Sz8c0v529sHPy+HavzX5UVzRPKfx1ckx3W8cvPdNa06vZ1P4xnhtln65ZocU0OyLlI5iYn1LbkAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+XU9PsdUs57LUbShd28/7qdaSE0sfxH59bH839Bdnce0u8Uu/dKnL7pcTRmpx6pZ+OaX87e2DahnkxUyR/qH1W814RVkmO63jl57prWnV7Op/GM8Nss/XLNDimh2RcpcGp6fY6pZz2Wo2lC7t5/wB1OtJCaWP4j8+tj+b+guzuPaXeKXfulTl90uJozU49Us/HNL+dvbBz8vh2r81+VFc0Tyn8dXJMd1vHLz3TWtOr2dT+MZ4bZZ+uWaHFNDsi5SOYmJ9S25AAAAAAAAAAAAAAdbDeeGi94UPElWoivDeeGi94UPElWo6Pg/WU2fmABewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfl1PT7HVLOey1G0oXdvP+6nWkhNLH8R+fWx/N/QXZ3HtLvFLv3Spy+6XE0ZqceqWfjml/O3tg2ieaWSSaeeaEsssNsYxjshCH1Zpm/plxvQ/XttKj+s3sOLZRm2UZY9dT5/129sGGauKY/2+6Tb3/lO+SY7reOXnumtadXs6n8Yzw2yz9cs0OKaHZFynqM3zzJMvqerqt56trLN60lpRh6lKWPyjs5Yx64xjF5dyL/z7/zwsj36+QB8vQAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfM80skk0880JZZYbYxjHZCEPqzTN/TLjeh+vbaVH9ZvYcWyjNsoyx66nz/rt7YPi960j3aXsVm3DS55pZJJp55oSyyw2xjGOyEIfVmmb+mXG9D9e20qP6zew4tlGbZRlj11Pn/Xb2wYZmmf5Plk80mpX8adpGO2FpQ2yUodsOWbtmjF5VBl82Z+KKK4e3qs0z/J8snmk1K/jTtIx2wtKG2SlDthyzds0YvKgitabT7ltERHAA8egAAAAAAAAAAAOthvPDRe8KHiSrURXhvPDRe8KHiSrUdHwfrKbPzAAvYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+Z5pZJJp55oSyyw2xjGOyEIfVmmb+mXG9D9e20qP6zew4tlGbZRlj11Pn/AF29sHxe9aR7tL2Kzbhpc80skk0880JZZYbYxjHZCEPqzTN/TLjeh+vbaVH9ZvYcWyjNsoyx66nz/rt7YMMzTP8AJ8snmk1K/jTtIx2wtKG2SlDthyzds0YvKoMvmzPxRRXD29Vmmf5Plk80mpX8adpGO2FpQ2yUodsOWbtmjF5UEVrTafctoiI4AHj0AAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHzPNLJJNPPNCWWWG2MYx2QhD6s0zf0y43ofr22lR/Wb2HFsozbKMseup8/67e2D4vetI92l7FZtw0ueaWSSaeeaEsssNsYxjshCH1Zpm/plxvQ/XttKj+s3sOLZRm2UZY9dT5/129sGGZpn+T5ZPNJqV/GnaRjthaUNslKHbDlm7ZoxeVQZfNmfiiiuHt6rNM/yfLJ5pNSv407SMdsLShtkpQ7Ycs3bNGLyoIrWm0+5bRERwAPHoAAAAAAAAAAAAAAAAAAADrYbzw0XvCh4kq1EV4bzw0XvCh4kq1HR8H6ymz8wAL2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPmeaWSSaeeaEsssNsYxjshCH1Zpm/plxvQ/XttKj+s3sOLZRm2UZY9dT5/129sHxe9aR7tL2Kzbhpc80skk0880JZZYbYxjHZCEPqzTN/TLjeh+vbaVH9ZvYcWyjNsoyx66nz/AK7e2DDM0z/J8snmk1K/jTtIx2wtKG2SlDthyzds0YvKoMvmzPxRRXD29Vmmf5Plk80mpX8adpGO2FpQ2yUodsOWbtmjF5UEVrTafctoiI4AHj0AAAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHzPNLJJNPPNCWWWG2MYx2QhD6s0zf0y43ofr22lR/Wb2HFsozbKMseup8/67e2D4vetI92l7FZtw0ueaWSSaeeaEsssNsYxjshCH1Zpm/plxvQ/XttKj+s3sOLZRm2UZY9dT5/129sGGZpn+T5ZPNJqV/GnaRjthaUNslKHbDlm7ZoxeVQZfNmfiiiuHt6rNM/yfLJ5pNSv407SMdsLShtkpQ7Ycs3bNGLyoIrWm0+5bRERwAPHoAAAAAAAAAAAAAAAAAAAAAAAAAAADrYbzw0XvCh4kq1EV4bzw0XvCh4kq1HR8H6ymz8wAL2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPmeaWSSaeeaEsssNsYxjshCH1Zpm/plxvQ/XttKj+s3sOLZRm2UZY9dT5/129sHxe9aR7tL2Kzbhpc80skk0880JZZYbYxjHZCEPqzTN/TLjeh+vbaVH9ZvYcWyjNsoyx66nz/rt7YMMzTP8nyyeaTUr+NO0jHbC0obZKUO2HLN2zRi8qgy+bM/FFFcPb1WaZ/k+WTzSalfxp2kY7YWlDbJSh2w5Zu2aMXlQRWtNp9y2iIjgAePQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfM80skk0880JZZYbYxjHZCEPqzTN/TLjeh+vbaVH9ZvYcWyjNsoyx66nz/AK7e2D4vetI92l7FZtw0ueaWSSaeeaEsssNsYxjshCH1Zpm/plxvQ/XttKj+s3sOLZRm2UZY9dT5/wBdvbBhmaZ/k+WTzSalfxp2kY7YWlDbJSh2w5Zu2aMXlUGXzZn4oorh7eqzTP8AJ8snmk1K/jTtIx2wtKG2SlDthyzds0YvKgitabT7ltERHAA8egAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOthvPDRe8KHiSrURXhvPDRe8KHiSrUdHwfrKbPzAAvYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADPr/0wYVY39xZXF1eQrW9WalUhC2mjCE0sYwjx9sGgorzLnhrXeFfxJkvk5rYoj+WuKkWn5Ub8asE+7vd1mPjVgn3d7usyXBJvcn410aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zHxqwT7u93WZLgb3J+GjVUfxqwT7u93WY+NWCfd3u6zJcDe5Pw0aqj+NWCfd3u6zPb49q1rrujW+rWMKsLa4ljNSjVk9SaMNsYbdkflHYjzDtEr5Hk9hotDbCa6rQlmmhD9kkOOab8SwjH8LNsrahZ2dCztqcKdChTlp05IcksssNkIf8QVeNlvl9zbhllpWvD+wCtkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD5nmlkkmnnmhLLLDbGMY7IQh9WaZv6Zcb0P17bSo/rN7Di2UZtlGWPXU+f8AXb2wfF71pHu0vYrNuGlzzSySTTzzQlllhtjGMdkIQ+rNM39MuN6H69tpUf1m9hxbKM2yjLHrqfP+u3tgwzNM/wAnyyeaTUr+NO0jHbC0obZKUO2HLN2zRi8qgy+bM/FFFcPb1WaZ/k+WTzSalfxp2kY7YWlDbJSh2w5Zu2aMXlQRWtNp9y2iIjgAePQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw3nhoveFDxJVqIrw3nhoveFDxJVqOj4P1lNn5gAXsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/Rp1pcahqFvY2lONS4uKstKlLD+U00dkIf8xBt/+l7G/Vp32U3FPjm/7W1jGHy4ozzQ/wDrDb1TNzcvFNGt8exuw0W22Rp2lGEnrbNnrTcs035mjGP5dR28OPTpFUN7f1PsAavkAAAAAAAAAAAAAAAAAAAAAAAAAAAAHzPNLJJNPPNCWWWG2MYx2QhD6s0zf0y43ofr22lR/Wb2HFsozbKMseup8/67e2D4vetI92l7FZtw0ueaWSSaeeaEsssNsYxjshCH1Zpm/plxvQ/XttKj+s3sOLZRm2UZY9dT5/129sGGZpn+T5ZPNJqV/GnaRjthaUNslKHbDlm7ZoxeVQZfNmfiiiuHt6rNM/yfLJ5pNSv407SMdsLShtkpQ7Ycs3bNGLyoIrWm0+5bRERwAPHoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrYbzw0XvCh4kq1EV4bzw0XvCh4kq1HR8H6ymz8wAL2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAivMueGtd4V/EmWoivMueGtd4V/EmQedxDfBzLkgOcpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGtf6acb/Ucpr6/cU9tvpkmylthxRrTwjCH/ABLtj2xlZNCEYx2QhtjFX/opxuGLYPYabPJ6t1PL7e6+vtZ+OMI9kNkv9VPiY/7v76ZZbeqvVAOukAAAAAAAAAAAAAAAAAAAAAAAAAAB8zzSySTTzzQlllhtjGMdkIQ+rNM39MuN6H69tpUf1m9hxbKM2yjLHrqfP+u3tg+L3rSPdpexWbcNLnmlkkmnnmhLLLDbGMY7IQh9WaZv6Zcb0P17bSo/rN7Di2UZtlGWPXU+f9dvbBhmaZ/k+WTzSalfxp2kY7YWlDbJSh2w5Zu2aMXlUGXzZn4oorh7eqzTP8nyyeaTUr+NO0jHbC0obZKUO2HLN2zRi8qCK1ptPuW0REcADx6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHvfQVjfCHPbaatT9az0//uq+2HFGMsf8JfzNs4vpCKrWcf6fMb/QsFp31en6t3qsYXE+2HHCns2U4f8AG2b+7R3X8XH/ABj/APqPLb+rAClmAAAAAAAAAAAAAAAAAAAAAAD5nmlkkmnnmhLLLDbGMY7IQh9WaZv6Zcb0P17bSo/rN7Di2UZtlGWPXU+f9dvbB8XyVpHu0vYrNuGlzzSySTTzzQlllhtjGMdkIQ+rNM39MuN6H69tpUf1m9hxbKM2yjLHrqfP+u3tgwzNM/yfLJ5pNSv407SMdsLShtkpQ7Ycs3bNGLyqDL5sz8UUVw9vVZpn+T5ZPNJqV/GnaRjthaUNslKHbDlm7ZoxeVBFa02n3LaIiOAB49AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdbDeeGi94UPElWoivDeeGi94UPElWo6Pg/WU2fmABewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEV5lzw1rvCv4ky1EV5lzw1rvCv4kyDzuIb4OZckBzlIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9D6OcenyjMtP0jZN7GpU9e4jD+NKXjm4/lxQ2Q64weeUN/pixv3TRLvJrinsq303sLeMYclKWP+UYds0Nn9GuDHqXiHxkt/NfbYqcklOnLTpyyySSQhLLLLDZCEIckIPoHbRAAAAAAAAAAAAAAAAAAAAA+Z5pZJJp55oSyyw2xjGOyEIfVmmb+mXG9D9e20qP6zew4tlGbZRlj11Pn/Xb2wfF8laR7tL2Kzbhpc80skk0880JZZYbYxjHZCEPqzTN/TLjeh+vbaVH9ZvYcWyjNsoyx66nz/rt7YMMzTP8AJ8snmk1K/jTtIx2wtKG2SlDthyzds0YvKoMvmzPxRRXD29Vmmf5Plk80mpX8adpGO2FpQ2yUodsOWbtmjF5UEVrTafctoiI4AHj0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP3aBplzrWtWek2cu2vd1paUn0htjyx6ocsexaGi6dbaRpFppdnL6tva0ZaVOHz2Qhs2x648sWFf6YMb941S8yi4p/9O1hG3toxhy1Jof5xh2SxhD+6gXT8PH/ADX+p/6lzW9z6AFrEAAAAAAAAAAAAAAAAHzPNLJJNPPNCWWWG2MYx2QhD6s0zf0y43ofr22lR/Wb2HFsozbKMseup8/67e2D4vkrSPdpexWbcNLnmlkkmnnmhLLLDbGMY7IQh9WaZv6Zcb0P17bSo/rN7Di2UZtlGWPXU+f9dvbBhmaZ/k+WTzSalfxp2kY7YWlDbJSh2w5Zu2aMXlUGXzZn4oorh7eqzTP8nyyeaTUr+NO0jHbC0obZKUO2HLN2zRi8qCK1ptPuW0REcADx6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB90aVStWko0pJp6lSaEskssNsZox4oQg+Gl/6d8b/Ws3l1KvT9a00mWFeO2HFGrHipw/5hGb+r6x0m9orDy0+o9qB9H+P08YxDT9GkhL7SjShGvND+VWbjnj/zGOzqhB3gd2IiI9QgmffyAPQAAAAAAAAAAAAHzPNLJJNPPNCWWWG2MYx2QhD6s0zf0y43ofr22lR/Wb2HFsozbKMseup8/wCu3tg+L5K0j3aXsVm3DS55pZJJp55oSyyw2xjGOyEIfVmmb+mXG9D9e20qP6zew4tlGbZRlj11Pn/Xb2wYZmmf5Plk80mpX8adpGO2FpQ2yUodsOWbtmjF5VBl82Z+KKK4e3qs0z/J8snmk1K/jTtIx2wtKG2SlDthyzds0YvKgitabT7ltERHAA8egAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOthvPDRe8KHiSrURXhvPDRe8KHiSrUdHwfrKbPzAAvYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVj6EMb4OYFaS1qfqXl9/3VxthxwjNCHqy/iXZxfXanz0R43wozqxsalP17SjH3i64uL2ckYR2R7Y7Jf7K8X+Fj5vKfPb/gA6KcAAAAAAAAAAHzPNLJJNPPNCWWWG2MYx2QhD6s0zf0y43ofr22lR/Wb2HFsozbKMseup8/67e2D4vkrSPdpexWbcNLnmlkkmnnmhLLLDbGMY7IQh9WaZv6Zcb0P17bSo/rN7Di2UZtlGWPXU+f9dvbBhmaZ/k+WTzSalfxp2kY7YWlDbJSh2w5Zu2aMXlUGXzZn4oorh7eqzTP8nyyeaTUr+NO0jHbC0obZKUO2HLN2zRi8qCK1ptPuW0REcADx6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA62G88NF7woeJKtRFeG88NF7woeJKtR0fB+sps/MAC9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHWw/RK+R5NYaLb7YTXVaEs00Ifsk5ZpvxLCMfwREzPqCfhv3+mzG/0vEquuXFPZc6pPtk2w44UZYxhL/zH1o9cPVas/jY2tCysqFna04U6FCnLSpSQ5JZZYbIQ/wCIP7O5jpFKxVDa39T7AGj5AAAAAAB8zzSySTTzzQlllhtjGMdkIQ+rNM39MuN6H69tpUf1m9hxbKM2yjLHrqfP+u3tg+L5K0j3aXsVm3DS55pZJJp55oSyyw2xjGOyEIfVmmb+mXG9D9e20qP6zew4tlGbZRlj11Pn/Xb2wYZmmf5Plk80mpX8adpGO2FpQ2yUodsOWbtmjF5VBl82Z+KKK4e3qs0z/J8snmk1K/jTtIx2wtKG2SlDthyzds0YvKgitabT7ltERHAA8egAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOthvPDRe8KHiSrURXhvPDRe8KHiSrUdHwfrKbPzAAvYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbt/pexvZLfZVcU+OP/AGtrth8uKNSaH/1ht/8AcxDT7S4v7+3sbWnGpcXFWWlSkh/KaaOyEP8AmKz8S0a3x7G7DRbbZGS1owkjNCGz15uWab8zRjH8q/Dx/wBX/qf+Mc1vUenUAdVKAAAAD5nmlkkmnnmhLLLDbGMY7IQh9WaZv6Zcb0P17bSo/rN7Di2UZtlGWPXU+f8AXb2wfF8laR7tL2Kzbhpc80skk0880JZZYbYxjHZCEPqzTN/TLjeh+vbaVH9ZvYcWyjNsoyx66nz/AK7e2DDM0z/J8snmk1K/jTtIx2wtKG2SlDthyzds0YvKoMvmzPxRRXD29Vmmf5Plk80mpX8adpGO2FpQ2yUodsOWbtmjF5UEVrTafctoiI4AHj0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AYQjGOyHHEGsf6acb/Usqra/cU9tvpkmylthxRrTwjCHbsl9aPVGMqkXlPRPjfBbB7HTqlP1LqpL7e6+vtZ+OMI9kNkv9Xq3Z8fHp0iEWS39WAG74B8zzSySTTzzQlllhtjGMdkIQ+rNM39MuN6H69tpUf1m9hxbKM2yjLHrqfP8Art7YPi+StI92l7FZtw0ueaWSSaeeaEsssNsYxjshCH1Zpm/plxvQ/XttKj+s3sOLZRm2UZY9dT5/129sGGZpn+T5ZPNJqV/GnaRjthaUNslKHbDlm7ZoxeVQZfNmfiiiuHt6rNM/yfLJ5pNSv407SMdsLShtkpQ7Ycs3bNGLyoIrWm0+5bRERwAPHoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrYbzw0XvCh4kq1EV4bzw0XvCh4kq1HR8H6ymz8wAL2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAivMueGtd4V/EmWoivMueGtd4V/EmQedxDfBzLkgOcpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHvPQXjfCLPbWNan61np//AHVfbDijGWP+Ev5m2cXzhCLwaov9PeN/oeDSX9en6t3qsYXE+2HHCns/6cP+Ns39m/jY/wC8kfjPJb+atIHzPNLJJNPPNCWWWG2MYx2QhD6s0zf0y43ofr22lR/Wb2HFsozbKMseup8/67e2DrXyVpHu0pIrNuGlzzSySTTzzQlllhtjGMdkIQ+rNM39MuN6H69tpUf1m9hxbKM2yjLHrqfP+u3tgwzNM/yfLJ5pNSv407SMdsLShtkpQ7Ycs3bNGLyqDL5sz8UUVw9vVZpn+T5ZPNJqV/GnaRjthaUNslKHbDlm7ZoxeVBFa02n3LaIiOAB49AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdbDeeGi94UPElWoivDeeGi94UPElWo6Pg/WU2fmABewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEV5lzw1rvCv4ky1EV5lzw1rvCv4kyDzuIb4OZckBzlIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADv+j3QI5Ll1jpU0fVt55/aXM+3ZCSjL/lPHb8uKGzb9Ywb5mfphxjHqcbHRpZdXuqcPUllt5oS0KezihCM/JHslhHtgmenVq05Z5adSeSFSX1Z4SzRhCaG2EdkfrDbCEfw+G2PPOOsxXmXxakWn5eqzTP8nyyeaTUr+NO0jHbC0obZKUO2HLN2zRi8qDK1ptPuX1ERHAA8egAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOthvPDRe8KHiSrURXhvPDRe8KHiSrUdHwfrKbPzAAvYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOthvPDRe8KHiSrURXhvPDRe8KHiSrUdHwfrKbPzAAvYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1sN54aL3hQ8SVaiK8N54aL3hQ8SVajo+D9ZTZ+YAF7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/ra29e6uKdta0aletUmhLJTpyxmmmj9IQhxxi1bBvQjrWp+zu8jrfpNrHZH2Euya4nhxfiT87Yw+cr7pjtefVYfNrRXlnmEU6lXM9FkpSTTzRv6GyWWG2P/5ILScHEcQx7Fbb2WjadTozxl2VK83+VWp2zx49nFt2Q2Q+kHedTx8M4on2lyX/ALn4AFLMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/pb0a1xXkoW9KerVqTQlkkkljNNNGPJCEIcsWqYP6Etd1X2d1kFX9ItI7I+y2QmuJ4cXy5JPzxw/8X3THa8+qw+bWivLK7ahWubiS3tqNStWqTQlkp05YzTTRjyQhCHHGLVcH9CWt6p7O7yKt+kWkdkfYwhCa4nhxfLkk/O2MP/FuGH4bjuKW8Kej6fTp1Yy7J7if/OtP9ds0ePZxckNkOp6Ffi8KI+bsLZpnhwMQw7HsVtvZaNp1OlUjLsnuJ/8AKtU5OWePHs4tuyGyHU74LYiKx6hjM++QB68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEV5lzw1rvCv4ky1EV5lzw1rvCv4kyDzuIb4OZckBzlIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPujSqVq0lGjTnqVJ4wlkkkl2zTRjyQhCHLFqOD+hXX9Y9nda7P8Ao9nHZH1JoetcTw/9vJL/AG44fSL7pjtefVYfNrRXll1CjVuK0lChSnq1ak0JZJJJYzTTRjyQhCHLFqeD+hPXtW9nda/U/R7SOyPs4w9a4nh/7eST+3HD/wAW44dhON4nRhLpGnyS1/V2T3VX/OtP9ds0eSHVDZDqejXYvCiPm7C2af8AjzuH4XjmKUISaPp0klaMuye5qf51p/rtmjyQ4uSGyHU9EC2KxWPUMZn3yAPp4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfVOSepUlp05Jp55o7JZZYbYxj9IQafg/oXyLWvUutaj+i2ceP1aku2vNDqk/j/AG2R6ovqmO159Vh5NoryzClTqVastKlJNUqTxhLLLLDbGaMeSEINRwf0LZDrPqXWuTfo1nHj9SeX1q88OqT+P9uOH0i3HDMFxrE6cP0nT5fedmya6rf51pv7fLslhCHU9MvxeFEfN09s0/8AHm8NwfG8TpQhpGnywuNmye6q/wCdaf8At8odUuyHU9IC2tYrHqGMzM8gD6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH+ySzTzyySSxmmmjshCENsYxabhHoZyTXPUudW/9Fso8f/Wk215odVP5f2jDsi+qY7Xn1WHk2ivLM5JJqk8skks0000dkssIbYxj9Gm4R6GMj1v1LrWI/otnHj2VZdteaHVJ/H+0YR6otzwvAsZxOSWbS7CWa6hDZNd19k9aP9v49ksIQeoX4vCiPm6e2bp5jDMExnEqcI6VYSxudmya7r7J6039v49ksIQenBbWsVj1DGZmeQB9PAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AGWEZpoSywjGMY7IQh82lYR6HMm171LnU5f0Wyjx+tXk21podVPijD+2zl2w2vqlLXn1WHk2iOWayyzTzQllljNNGOyEIQ2xjFpeEehrJdd9S51WH6LZR49teTbWmh1U+WH9tnLt2RbnhXo/xjEpZZ9NsYVLyENkbu42T1Y9keSXl2f4wh17Xq1+Lwoj5untm/8ALy2F4BjGJySz6ZYQnu4Q2Ru7jZPWj2R2bJeXklhDa9SC2tYrHqGMzM8gD6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH+whGMYQhDbGLRsI9D+T5B6lzfyfo1jNx+0uJI+1mh/tp8Uf/ls6tr6pS159Vh5NojlnMIRjGEIQjGMeKEINIwf0O5Nr/qXOoy/otjHj9e4kjGrND/bT4o//AC2cvFtbnhPo7xjE5ZathZQr3sOW8udk9X+vFsl5f4wh17Xrl+Lwo5uwtm/8vJ4T6PcYxOEtTT7L215CHHeXGyer+I8kvL/GEOva9YC2tYrHqIYTMzyAPp4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGiYR6IsoyL1Li7pfo9hNx+1uZI+0mh/tp8sfzshH5RfVKWvPqsPJtEcs8hCMY7IQ2xaJhHogyjIfUuL2n+j2M3H7S5kj7SaH+2nxR/52Q+m1umEejfF8UhJWtLP3q+l//rudk9SEf9vyk/ENv1jF7Fdi8L/t2Fs3/l5DCfRzi+Jwkq2VlC5vpeW8udk9Tb/t+Uv4hDr2vXgurWKx6iGEzM8gD6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoODeibKMl9nc16P6Tp82yPt7qWMJpofWSnyx4uPbHZCP1fVaWvPqsPJmI5Z80LB/RJlGR+zuLmj+kWE3H7a5kj680P9tPlj2x2Qj9W6YP6M8XxT2de3tPfb+Xj97utk08I/WSHJJ+IbeuL2i7F4X/bsLZv/AC8ZhHo1xfFPUr2tn73fy8fvd1snnhH6yw5JPxDb1xezBdWsVj1EMJmZ5AH08AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEV5lzw1rvCv4ky1EV5lzw1rvCv4kyDzuIb4OZckBzlIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3uD+inKcm9ncVLf8AS9Pm2R94upYwjNDi45JOWbijthHihH6vqtLXn1WHkzEcvBPf4P6J8oyX2dzVofpWnzbI+8XUsYTTQ+sknLNxR2wjHZCP1bpg/owxfFvZ3FO19/1CXZH3u6hCaMseLjkl5JOPkjDj64vbrsXhf9uwtm/8vE4P6MsXxX2deja+/ahLsj73dQhNNLH6yQ5JOPkjDj64vbAurStY9RDCZmeQB9PAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA91g/otyjKPZ3ELb9O0+bZH3q6ljL60OLjkl5ZuLkjxQ631WlrT6rDyZiOXhXvMH9FeU5P7O4jb/AKZp82yPvN1LGHrQ4uOSTlm4o7YR4oR+rc8H9FmLYx7O492/UtQl2R95uoQm9WPFxySckvHDijxxh9Xu12Lwv+3YWzf+XhsH9F2LYv7O4ltv1DUJdkferqEJoyx4uOSXkl44cUeOPW9yC6tK1j1WGEzM8gD6eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK8y54a13hX8SZaiK8y54a13hX8SZB53EN8HMuSA5ykAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB7fB/RhlGVezuKVr7hp83H73dQjLLND6yS8s3bDi64Pa0tafUQ8mYjl4h7jBvRflGU+zuJLb9P0+bZH3q6hGWE0PrJLyzcXJHk626YP6KMXxn2dxUofqmoS7I+8XUsIwlj9ZJOSXt44w+r3y7F4X/bsLZv/LweD+irF8Y9ncTW/wCp6hLsj7zdSwjCWP1kk5JePkjxxh9XvAX1pWkeqwwmZnkAfTwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPZ4R6NMpyv1K9tZ+52E3H73dbZJIw/2w5Z/xDZ9Ywe1rNp9RDyZiOXjHtcH9GWU5V7OvQtPcrCbj97uoRllmh9ZYcs34hs64N0wj0S4tjfqXFxR/V7+Xj9vdSwjJLH/bT5IfnbGH1aCuxeF/27C2b/y8Bg/onxfGvZ3Fah+rX8vH7xdSwjLLH6yU+SHbHbGH1e/BdWlaR6rDCZmeQB9vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFeZc8Na7wr+JMtRFeZc8Na7wr+JMg87iG+DmXJAc5SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9hhHo4yjLIyVrOz92sZv8A+y52yU4w/wBvzn5PlCMPrGD2tZtPqIeTMRy8e9lhHo2yjK4yVrSz90sZuP3u52yU4w/2w5Z/xDZ9YwbphHohxfHfUubyn+sX0vH7W5kh7OWP+2nxwh+fWjxcUYNEXYvC/wC3YWzf+WeYR6I8Wx31Li6pfrF/Lx+2upIepLH/AG0+OEPz60YfKMGhgupStI9VhhNpnkAfbwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARXmXPDWu8K/iTLURXmXPDWu8K/iTIPO4hvg5lyQHOUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPW4T6O8nyyMtWwsvYWUY8d5c7ZKX4+c3J/GEevY9rWbT6iHkzEcvJPX4T6OcoyyMtWxsvd7KPLeXO2Sn/AF+c3J/GEevY3PCPQ9jGP+pcahJ+s30OP17iSHspY/7afHD/AOW3k4tjR4QhCEIQhshDkguxeFPN2Fs3/lnWEeiDGMe9S5vqf6zfS8ftLmSHspY/7afHD/5etHi4tjRocUNkAXUpWkeqwwm0zyAPt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHqsK9H+T5ZPLPptjGnaRjsjd3G2SlDsjyzf1hF7Ws2n1DyZiOXlXrMK9HuT5ZNLU06xjRs4x47u42yUvxHZtm5P4wj17G54R6G8Z0L1LnU5f1q9hx7a8myjLHqp8cI/22/hpUsssssJZYQllhDZCEIcUILcXhTPzdhbN/5ZvhHodxnQfUudSk/Wr6HH61xJD2Msf9tPjhH+23k2w2NIlhCWEJZYQhCHFCEPk/0X0pWkeqwwm0zyAPt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHqMLwPJstqQjpdhGW127Jruv/AIUZf7fy7JYRi9rWbT6h5MxHLy71OFYDk2WzyzaZYxktIx2TXdfbJRh2R5ZuyWEYtzwf0M45ofs7rV//AFq9hx7KsuyhJHqk/l/bbDqg0ySWWSSWSSWEsssNkssIbIQh9FuLwpn5uxtm6ZphHoaxvQ/UudVh+tXsOP8A60uyjLHqp/P+23sg0ySWWSWEkksJZZYbIQhDZCEH+i+mOtI9VhPNptyAPt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHpcMwbJcsqw/SdPm939bZNdVv8KMv1/y+cYfSXbHqe1rNp9Q8mYjl5p6bDMEyXLakP0qwmhbbdk13W/woy/X/L5xh9JYRj1Nywf0L49o3s7rW4/rN7DZH1akuyhJHqk/l/bbCP0g1ClTp0qUtKlJLTpyQhLLLLDZCWEOSEIfKC3F4Uz83Y2zdMxwf0MY7onqXWsx/Wr2GyOyrLsoSR6pP5f22wj9INOpySU6ctOnJLJJLCEssssNkIQhyQhB9C+mOtI9VhPNptyAPt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIrzLnhrXeFfxJlqIrzLnhrXeFfxJkHncQ3wcy5IDnKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHo8OwnI8srwl0jT55qHrbJ7qr/hRk+u2aPLGG3khtj1PYrNp9Q8mYjl5x6TDcIyTLK0IaRp88bf1tk91V/woyfX/ACjyxht5IbY9TccH9CmgaR7O616f9YvIbI+zmh6tvJHi/jyz/P8AdxR/8WpUaVKhRko0aclOnJLCWSSSWEJZYQ5IQhDkgtxeFM/N2Ns0f8Zfg/oVx/R/Z3WuTfrN5DZH1J5fVt5I8X8P5fP93FH/AMYNQo06dGlJRo05KdOSWEskkkNkJYQ5IQhDkg+xfTHWkeqwntabcgD7eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACP8ux3IKuV6vVpaFqk8k99WmlmltKkYTQjUm2RhHZyLAGGbDGWIiZfdL/wivgzknR/VtzqeRwZyTo/q251PJagn2MdtNeekV8Gck6P6tudTyODOSdH9W3Op5LUDYx2a89Ir4M5J0f1bc6nkcGck6P6tudTyWoGxjs156RXwZyTo/q251PI4M5J0f1bc6nktQNjHZrz0ivgzknR/VtzqeRwZyTo/q251PJagbGOzXnpFfBnJOj+rbnU8jgzknR/VtzqeS1A2MdmvPSK+DOSdH9W3Op5HBnJOj+rbnU8lqBsY7NeekV8Gck6P6tudTyODOSdH9W3Op5LUDYx2a89Ir4M5J0f1bc6nkcGck6P6tudTyWoGxjs156RXwZyTo/q251PI4M5J0f1bc6nktQNjHZrz0ivgzknR/VtzqeRwZyTo/q251PJagbGOzXnpFfBnJOj+rbnU8jgzknR/VtzqeS1A2MdmvPSK+DOSdH9W3Op5HBnJOj+rbnU8lqBsY7NeekV8Gck6P6tudTyODOSdH9W3Op5LUDYx2a89Ir4M5J0f1bc6nkcGck6P6tudTyWoGxjs156RXwZyTo/q251PI4M5J0f1bc6nktQNjHZrz0ivgzknR/VtzqeRwZyTo/q251PJagbGOzXnpFfBnJOj+rbnU8jgzknR/VtzqeS1A2MdmvPSK+DOSdH9W3Op5HBnJOj+rbnU8lqBsY7NeekV8Gck6P6tudTyODOSdH9W3Op5LUDYx2a89Ir4M5J0f1bc6nkcGck6P6tudTyWoGxjs156RXwZyTo/q251PI4M5J0f1bc6nktQNjHZrz0ivgzknR/VtzqeRwZyTo/q251PJagbGOzXnpFfBnJOj+rbnU8jgzknR/VtzqeS1A2MdmvPSK+DOSdH9W3Op5HBnJOj+rbnU8lqBsY7NeekV8Gck6P6tudTyODOSdH9W3Op5LUDYx2a89Ir4M5J0f1bc6nkcGck6P6tudTyWoGxjs156RXwZyTo/q251PI4M5J0f1bc6nktQNjHZrz0ivgzknR/VtzqeRwZyTo/q251PJagbGOzXnpFfBnJOj+rbnU8jgzknR/VtzqeS1A2MdmvPSK+DOSdH9W3Op5HBnJOj+rbnU8lqBsY7NeekV8Gck6P6tudTyODOSdH9W3Op5LUDYx2a89Ir4M5J0f1bc6nkcGck6P6tudTyWoGxjs156RXwZyTo/q251PI4M5J0f1bc6nktQNjHZrz0ivgzknR/VtzqeRwZyTo/q251PJagbGOzXnpFfBnJOj+rbnU8jgzknR/VtzqeS1A2MdmvPSK+DOSdH9W3Op5HBnJOj+rbnU8lqBsY7NeekV8Gck6P6tudTyODOSdH9W3Op5LUDYx2a89Ir4M5J0f1bc6nkcGck6P6tudTyWoGxjs156RXwZyTo/q251PI4M5J0f1bc6nktQNjHZrz0ivgzknR/VtzqeRwZyTo/q251PJagbGOzXnpFfBnJOj+rbnU8jgzknR/VtzqeS1A2MdmvPSK+DOSdH9W3Op5HBnJOj+rbnU8lqBsY7NeekV8Gck6P6tudTyODOSdH9W3Op5LUDYx2a89Ir4M5J0f1bc6nkcGck6P6tudTyWoGxjs156RXwZyTo/q251PI4M5J0f1bc6nktQNjHZrz0ivgzknR/VtzqeRwZyTo/q251PJagbGOzXnpFfBnJOj+rbnU8nTx30e5hrl7LbW2h3lCWP7q11Smo05IfWM00OPshtj1LBHseDX/smvPTKMH9CehaT7O71+p+sXkNkfZRh6tvJHi/jyz/P93FH/wAWqUKNK3oyUKFKSlSpywlkkklhLLLCHJCEIckH2K6Y60j1WGVrTbkAfb5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/9k="/>
<style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,.045);
      --panel2: rgba(0,0,0,.14);
      --text: #e8eefc;
      --muted: #9bb0e6;
      --border: rgba(255,255,255,.10);

      --active-bg: rgba(255, 208, 92, 0.26);
      --active-br: rgba(255, 208, 92, 0.78);

      --hl-bg: rgba(59, 130, 246, 0.22);
      --hl-br: rgba(59, 130, 246, 0.88);

      --dim: 0.22;

      --line: rgba(255,255,255,.15);
      --line-hl: rgba(59,130,246,.92);
      --line-active: rgba(255,208,92,.95);

      --radius: 12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    /* Bright mode overrides */
    body.brightMode{
      --bg: #e8eaef;
      --panel: rgba(0,0,0,.05);
      --panel2: rgba(0,0,0,.08);
      --text: #111827;
      --muted: #475569;
      --border: rgba(0,0,0,.18);
      --active-bg: rgba(234,179,8,0.18);
      --active-br: rgba(160,110,0,0.85);
      --hl-bg: rgba(59,130,246,0.14);
      --hl-br: rgba(30,80,200,0.85);
      --dim: 0.40;
      --line: rgba(0,0,0,.18);
      --line-hl: rgba(30,80,200,.88);
      --line-active: rgba(160,110,0,.90);
    }
    body.brightMode{
      background: radial-gradient(1200px 600px at 10% 0%, rgba(59,130,246,.07), transparent 60%),
        radial-gradient(900px 500px at 90% 20%, rgba(255,208,92,.06), transparent 60%),
        var(--bg);
    }
    body.brightMode header{
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(225,228,235,.96), rgba(225,228,235,.82));
      border-bottom-color: rgba(0,0,0,.12);
    }
    body.brightMode .panel{
      background: linear-gradient(to bottom, rgba(255,255,255,.92), rgba(255,255,255,.78));
      border-color: rgba(0,0,0,.14);
    }
    body.brightMode .columnsWrap{
      background: linear-gradient(to bottom, rgba(255,255,255,.55), rgba(245,247,250,.4));
      border-color: rgba(0,0,0,.14);
    }
    body.brightMode .columnsHeader{ background: rgba(0,0,0,.05); }
    body.brightMode .vcGroup{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.08); }
    body.brightMode .vcBtn:hover{ background: rgba(0,0,0,.08); }
    body.brightMode .vcBtn:active{ background: rgba(0,0,0,.12); }
    body.brightMode .vcBtn.active{ background: rgba(59,130,246,.12); }
    body.brightMode .tbBtn{ color: #64748b; }
    body.brightMode .tbBtn:hover{ background: rgba(0,0,0,.06); border-color: rgba(0,0,0,.14); color: #1e293b; }
    body.brightMode .tbBtn.active{ background: rgba(59,130,246,.1); border-color: rgba(59,130,246,.3); color: #1e293b; }
    body.brightMode .tbPop{ background: rgba(255,255,255,.98); border-color: rgba(0,0,0,.14); box-shadow: 0 8px 32px rgba(0,0,0,.15); }
    body.brightMode #viewPill{ background: rgba(255,255,255,.95); border-color: rgba(59,130,246,.3); box-shadow: 0 2px 12px rgba(0,0,0,.1); }
    body.brightMode .tbRow1{ background: rgba(255,255,255,.6); border-color: rgba(0,0,0,.12); }
    body.brightMode .tbSep{ background: rgba(0,0,0,.15); }
    body.brightMode .filterChip:hover{ filter:brightness(0.82); box-shadow:0 0 0 1.5px rgba(0,0,0,.2); }
    body.brightMode .popItem.dragOver{ border-color: rgba(59,130,246,.5); }
    body.brightMode .feEmojiOption:hover{ background:rgba(0,0,0,.08) !important; }
    body.brightMode .feStyleBar{ background:rgba(0,0,0,.03); border-color:rgba(0,0,0,.12); }
    body.brightMode .feStyleItem:hover{ background:rgba(0,0,0,.06); border-color:rgba(0,0,0,.12); }
    body.brightMode .feStyleItem.feSwatchDragOver{ background:rgba(59,130,246,.1); border-color:rgba(59,130,246,.5); }
    body.brightMode .feColorSwatch{ border-color:rgba(0,0,0,.18); }
    body.brightMode .btn{
      background: rgba(255,255,255,.7);
      border-color: rgba(0,0,0,.16);
      color: #1e293b;
    }
    body.brightMode .btn:hover{ background: rgba(255,255,255,.95); }
    body.brightMode .btn.btnSave{ opacity: .35; pointer-events: none; }
    body.brightMode .btn.btnDirty{ border-color: rgba(180,130,10,.50); background: rgba(255,208,92,.22); color: var(--text); opacity: 1; pointer-events: auto; }
    body.brightMode .btn.btnDirty:hover{ background: rgba(255,208,92,.35); }
    body.brightMode .req{ color: rgba(200,60,60,.6); }
    body.brightMode .toggle{
      background: rgba(255,255,255,.7);
      border-color: rgba(0,0,0,.16);
      color: #1e293b;
    }
    body.brightMode .toggle:hover{ background: rgba(0,0,0,.08); border-color: rgba(0,0,0,.25); }
    body.brightMode .modeToggle.prominent{
      border-color: rgba(160,110,0,.50);
      background: rgba(255,208,92,.16);
    }
    body.brightMode .modeToggle.prominent:hover{ background: rgba(255,208,92,.26); }
    body.brightMode .popover{
      background: rgba(255,255,255,.98);
      border-color: rgba(0,0,0,.14);
      box-shadow: 0 24px 80px rgba(0,0,0,.22);
    }
    /* Panels */
    body.brightMode .panelHeader{ background: rgba(0,0,0,.05); }
    body.brightMode .panelHeader.colored{ background: var(--col-bg); border-bottom: 2px solid var(--col-color); }    body.brightMode .panelHeader.colored:hover{ background: var(--col-bg-hover); }
    body.brightMode .panelHeader.selected, body.brightMode .panelHeader.selected:hover{ background: rgba(234,179,8,0.22); border-bottom-color: var(--active-br); }
    body.brightMode .detailsHeader{ background: rgba(0,0,0,.05); }
    body.brightMode .details{ background: linear-gradient(to bottom, rgba(255,255,255,.90), rgba(255,255,255,.75)); }
    body.brightMode .foot{ background: rgba(0,0,0,.04); }
    /* Items / nodes */
    body.brightMode .item{ background: rgba(0,0,0,.06); }
    body.brightMode .item:hover{ background: rgba(0,0,0,.09); border-color: rgba(0,0,0,.14); }
    body.brightMode .item.connected{ background: rgba(59,130,246,.12); border-color: rgba(30,80,200,.35); }
    body.brightMode .item.active{ background: rgba(234,179,8,.15); border-color: rgba(160,110,0,.45); }
    body.brightMode .item.dimmed{ opacity: var(--dim); }
    /* Pills / tags */
    body.brightMode .pill{ background: rgba(0,0,0,.06); color: #475569; }
    body.brightMode .tag{ background: rgba(0,0,0,.06); color: #1e293b; }
    body.brightMode .tagChip{ color: #1e293b; border-color: color-mix(in srgb, var(--c,#3b82f6) 50%, rgba(0,0,0,.18)); background: color-mix(in srgb, var(--c,#3b82f6) 18%, rgba(0,0,0,.04)); }
    body.brightMode .box{ background: rgba(0,0,0,.03); }
    body.brightMode .k{ color: #475569; }
    /* Edges */
    body.brightMode .edgeMarker{ fill: rgba(0,0,0,.30); }
    body.brightMode .edgeMarker.hl{ fill: rgba(30,80,200,.85); }
    body.brightMode .edgeMarker.active{ fill: rgba(160,110,0,.90); }
    body.brightMode .edge{ stroke: rgba(0,0,0,.18); }
    body.brightMode .edge.hl{ stroke: rgba(30,80,200,.85); }
    body.brightMode .edge.active{ stroke: rgba(160,110,0,.90); }
    body.brightMode .edgeLabel{ fill: rgba(0,0,0,.7); stroke: #f8fafc; }
    body.brightMode .edgeLabel.hl{ fill: rgba(30,80,200,.85); }
    body.brightMode .edgeLabel.active{ fill: rgba(160,110,0,.90); }
    /* Search */
    body.brightMode .search{
      background: rgba(255,255,255,.75);
      border-color: rgba(0,0,0,.16);
    }
    body.brightMode .search input{ color: var(--text); }
    body.brightMode .search .hint{ background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.12); color: #475569; }
    /* Docs */
    /* Kbd */
    body.brightMode kbd{
      background: rgba(0,0,0,.06);
      border-color: rgba(0,0,0,.16);
      color: var(--text);
    }
    /* Slider labels */
    body.brightMode .sliderGroup{ color: #475569; }
    body.brightMode .sliderGroup .sliderVal{ color: #1e293b; }
    /* Tree carets */
    body.brightMode .caret{ border-left-color: rgba(0,0,0,.50); }
    body.brightMode .caret:hover{ background: rgba(0,0,0,.06); }
    /* Popover title */
    body.brightMode .popTitle{ color: #1e293b; }
    /* Map notes */
    body.brightMode .mapNote{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.10); color: #374151; }
    /* Mini buttons */
    body.brightMode .miniBtn{ background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.14); color: #1e293b; }
    /* Map card */
    body.brightMode .mapCard summary{ color: #374151; }
    /* Route/mono text */
    body.brightMode .route{ color: #475569; }
    body.brightMode code{ color: #1e293b; }
    /* Docs header name */
    /* Docs body text */
    body.brightMode .docsBody h2{ color: #111827; }
    body.brightMode .docsBody h3{ color: #1e293b; }
    body.brightMode .docsBody p, body.brightMode .docsBody li{ color: #374151; }
    body.brightMode .docsBody code{ background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.12); color: #1e293b; }
    body.brightMode .docsBody pre{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.10); }
    body.brightMode .docsBody pre code{ color: #1e293b; }
    body.brightMode .docsBody b, body.brightMode .docsBody strong{ color: #111827; }
    body.brightMode .docsBody a{ color: #2563eb; }
    /* Group icon (expand indicator) */
    body.brightMode .groupIcon{ border-left-color: rgba(0,0,0,.50); }
    body.brightMode .children{ border-left-color: rgba(0,0,0,.18); }
    /* Dirty save button */
    .btn.dirty{
      background: rgba(255,208,92,0.16);
      border-color: rgba(255,208,92,0.55);
      color: var(--text);
      font-weight: 700;
    }
    /* Bright mode: dirty save */
    body.brightMode .btn.dirty{
      background: rgba(255,208,92,0.22);
      border-color: rgba(180,130,10,0.50);
      color: var(--text);
    }
    /* Panel mode button in bright mode */
    body.brightMode .resizeHandle::after{ background: rgba(0,0,0,.08); }
    body.brightMode .resizeHandleH::after{ background: rgba(0,0,0,.08); }
    /* Project title input */
    body.brightMode #projectTitle{ background: rgba(0,0,0,.05) !important; border-color: rgba(0,0,0,.14) !important; }
    body.brightMode #projectTitle:focus{ background: rgba(255,255,255,.9) !important; border-color: rgba(59,130,246,.45) !important; }
    body.brightMode #projectTitle::placeholder{ color: rgba(0,0,0,.35); }
    /* Sub info bar */
    body.brightMode .sub{ color: #475569; }
    body.brightMode .sub span{ color: #475569; }
    /* Context menus */
    body.brightMode .ctxMenu{
      background: rgba(255,255,255,.98);
      border-color: rgba(0,0,0,.12);
      box-shadow: 0 12px 40px rgba(0,0,0,.18);
      backdrop-filter: blur(10px);
    }
    body.brightMode .ctxItem{
      color: #1e293b;
    }
    body.brightMode .ctxItem:hover{ background: rgba(0,0,0,.06); }
    body.brightMode .ctxItem:active{ background: rgba(0,0,0,.1); }
    body.brightMode .ctxItem.danger{ color: #dc2626; }
    body.brightMode .ctxItem.danger:hover{ background: rgba(220,38,38,.08); }
    body.brightMode .ctxSep{ background: rgba(0,0,0,.08); }
    body.brightMode .ctxLabel{ color: rgba(0,0,0,.35); }
    body.brightMode .ctxItem:disabled{ opacity: .40; }
    body.brightMode .ctxItem.danger{ background: rgba(220,38,38,.06); border-color: rgba(220,38,38,.18); color: #b91c1c; }
    body.brightMode .ctxItem.danger:hover{ background: rgba(220,38,38,.12); border-color: rgba(220,38,38,.30); }
    body.brightMode .ctxSep{ background: rgba(0,0,0,.10); }
    body.brightMode .swatch{ border-color: rgba(0,0,0,.18); }
    body.brightMode .swatch.sel{ outline-color: rgba(0,0,0,.50); }
    /* Modal / Help dialog */
    body.brightMode .modal{
      background: rgba(255,255,255,.98);
      border-color: rgba(0,0,0,.14);
      box-shadow: 0 24px 80px rgba(0,0,0,.18);
      color: #1e293b;
    }
    body.brightMode .modalHeader{
      background: rgba(0,0,0,.03);
      border-bottom-color: rgba(0,0,0,.12);
    }
    body.brightMode .modalHeader .title{ color: #111827; }
    body.brightMode .modalBody{ color: #374151; }
    body.brightMode .modalBody h2, body.brightMode .modalBody h3, body.brightMode .modalBody h4{ color: #111827; }
    body.brightMode .modalBody code{ background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.12); color: #1e293b; }
    body.brightMode .modalBody a{ color: #2563eb; }
    body.brightMode .modalBody li{ color: #374151; }
    body.brightMode .modalBody strong{ color: #111827; }
    body.brightMode .modalBody kbd{ background: rgba(0,0,0,.06); border-color: rgba(0,0,0,.14); color: #1e293b; }
    /* Form inputs in modals */
    body.brightMode .inp{ background: rgba(0,0,0,.04); color: #1e293b; }
    body.brightMode .inp:focus{ border-color: rgba(59,130,246,.55); }
    body.brightMode select.inp{ background: rgba(0,0,0,.04); color: #1e293b; }
    body.brightMode select.inp option{ background: #fff; color: #1e293b; }
    body.brightMode select.inp option:checked{ background: #e0ecff; }
    body.brightMode select.inp option:disabled{ color: #94a3b8; }
    /* Map notes, link buttons */
    body.brightMode .mapNote{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.10); color: #374151; }
    body.brightMode .linkBtn{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.12); color: #1e293b; }
    body.brightMode .linkBtn:hover{ background: rgba(0,0,0,.08); }
    /* Map card */
    body.brightMode .mapCard{ border-color: rgba(0,0,0,.10); }
    body.brightMode .mapCard summary{ color: #374151; }
    /* Modal mask */
    body.brightMode .modalMask{ background: rgba(0,0,0,.30); }
    /* Status line */
    body.brightMode .statusLine{ color: #475569; }
    body.brightMode .viewerStatus{ color: #475569; }
    /* Create modal */
    body.brightMode .modalBody code#createIdPreview{ background: rgba(0,0,0,.08); border-color: rgba(0,0,0,.18); color: #1e293b; }
    /* Disabled / readonly inputs in bright mode */
    body.brightMode .inp:disabled, body.brightMode .inp[readonly],
    body.brightMode input:disabled, body.brightMode input[readonly],
    body.brightMode textarea:disabled, body.brightMode textarea[readonly]{
      background: rgba(0,0,0,.03); color: #6b7280; border-color: rgba(0,0,0,.08); -webkit-text-fill-color: #6b7280; opacity: 1;
      border-style: dashed;
    }
    /* Dimmed items - ensure text remains readable */
    body.brightMode .dimmed > .row{ opacity: var(--dim); }
    body.brightMode .node:not(.dimmed):not(.active):not(.connected) > .row .item{ background: rgba(0,0,0,.04); }
    /* Scrollbars - ensure visibility */
    
    *{ box-sizing: border-box; }

    /* Custom scrollbars  wider for easy grabbing */
    ::-webkit-scrollbar{ width: 10px; height: 10px; }
    ::-webkit-scrollbar-track{ background: rgba(255,255,255,.04); border-radius: 6px; }
    ::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.16); border-radius: 6px; min-height: 40px; }
    ::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.28); }
    ::-webkit-scrollbar-corner{ background: transparent; }
    /* Firefox */
    *{ scrollbar-width: auto; scrollbar-color: rgba(255,255,255,.16) rgba(255,255,255,.04); }
    /* Bright mode scrollbar overrides */
    body.brightMode ::-webkit-scrollbar{ width: 10px; height: 10px; }
    body.brightMode ::-webkit-scrollbar-track{ background: rgba(0,0,0,.06); border-radius: 6px; }
    body.brightMode ::-webkit-scrollbar-thumb{ background: rgba(0,0,0,.22); border-radius: 6px; min-height: 40px; }
    body.brightMode ::-webkit-scrollbar-thumb:hover{ background: rgba(0,0,0,.38); }
    body.brightMode, body.brightMode *{ scrollbar-color: rgba(0,0,0,.22) rgba(0,0,0,.06); scrollbar-width: auto; }

    /* === Viewport-locked layout === */
    html{ height: 100%; overflow: hidden; }
    body{
      margin: 0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(59,130,246,.10), transparent 60%),
        radial-gradient(900px 500px at 90% 20%, rgba(255,208,92,.08), transparent 60%),
        var(--bg);
      color: var(--text);
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header{
      position: relative;
      z-index: 50;
      flex-shrink: 0;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,16,32,.92), rgba(11,16,32,.70));
      border-bottom: 1px solid var(--border);
      padding: 12px 14px;
    }

    .top{
      display:grid;
      grid-template-columns: auto 1fr auto;
      align-items:center;
      gap: 12px;
    }
    @media(max-width:900px){ .top{ grid-template-columns:1fr; justify-items:center; } }
    .topCenter{display:flex;align-items:center;gap:6px;justify-content:center;}
    .topCenter input{
      font-size:14px;font-weight:600;text-align:center;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);
      border-radius:8px;padding:6px 14px;color:var(--text);
      max-width:600px;width:100%;transition:all .2s ease;
    }
    .topRight{display:flex;align-items:center;gap:8px;justify-content:flex-end;flex-wrap:wrap;}
    .topBtn{display:inline-flex;align-items:center;gap:5px;}
    .topBtn svg{flex-shrink:0;opacity:.55;transition:opacity .15s;}
    .topBtn:hover svg{opacity:.85;}
    .topIconBtn{width:34px;height:34px;padding:0;display:inline-flex;align-items:center;justify-content:center;}
    .topIconBtn svg{opacity:.6;transition:opacity .15s;}
    .topIconBtn:hover svg{opacity:1;}
    .editorToggle{transition:background .2s,border-color .2s,color .2s;}
    .editorToggle.active{border-color:rgba(255,208,92,.55);background:rgba(255,208,92,.16);font-weight:700;}
    .editorToggle.active:hover{background:rgba(255,208,92,.26);}
    .editorToggle.active svg{opacity:.9;}
    body.brightMode .editorToggle.active{border-color:rgba(180,130,10,.50);background:rgba(255,208,92,.22);}
    body.brightMode .editorToggle.active:hover{background:rgba(255,208,92,.35);}
    .colsBtn{display:inline-flex;align-items:center;gap:5px;}
    .colsBtn svg{flex-shrink:0;opacity:.55;transition:opacity .15s;}
    .colsBtn:hover svg{opacity:.85;}

    h1{
      font-size: 17px;
      margin: 0;
      font-weight: 800;
      letter-spacing: 1.0px;
      text-transform: uppercase;
    }


    .sub{
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items: center;
    }
    kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      color: var(--text);
    }

    /* shared buttons / controls */
    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap: wrap;
    }
    .btn{
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      transition: transform .05s ease, background .2s ease;
      user-select: none;
      white-space: nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn:active{ transform: translateY(1px); }
    .edDirBtn.active{ background: rgba(59,130,246,.25); border-color: rgba(59,130,246,.5); color: #7cb3f4; }
    .btn.btnSave{ opacity: .35; pointer-events: none; font-weight: 600; }
    .btn.btnDirty{ border-color: rgba(255,208,92,.55); background: rgba(255,208,92,.16); color: var(--text); font-weight: 700; opacity: 1; pointer-events: auto; }
    .btn.btnDirty:hover{ background: rgba(255,208,92,.26); }
    .req{ color: rgba(239,130,130,.7); font-weight: 700; margin-left: 2px; font-size: 11px; }
    .btn.btnDanger{ border-color: rgba(239,68,68,.5); color: #ef4444; }
    .btn.btnDanger:hover{ background: rgba(239,68,68,.15); }
    .autoTag{ display:inline-block; font-size:9px; padding:1px 5px; border-radius:6px; background:rgba(59,130,246,.15); color:rgba(130,180,255,.8); vertical-align:middle; margin-left:6px; pointer-events:none; letter-spacing:.3px; user-select:none; transition: opacity .15s, background .15s; white-space:nowrap; flex-shrink:0; }
    .autoTag.clickable{ pointer-events:auto; cursor:pointer; }
    .autoTag.clickable:hover{ background:rgba(59,130,246,.3); }
    .autoTag.clickable::after{ content:' '; font-size:8px; opacity:.6; }
    .k .autoTag{ margin-left:4px; font-size:8px; padding:1px 4px; vertical-align:baseline; }
    body.brightMode .autoTag{ background:rgba(59,130,246,.1); color:rgba(37,99,235,.6); }
    body.brightMode .autoTag.clickable:hover{ background:rgba(59,130,246,.2); }
    .miniCard:hover{ background: rgba(255,255,255,.06); }
    body.brightMode .miniCard:hover{ background: rgba(0,0,0,.05); }
    body.brightMode .btn.btnDanger{ border-color: rgba(220,38,38,.4); color: #dc2626; }
    body.brightMode .btn.btnDanger:hover{ background: rgba(220,38,38,.08); }

    /* === Multi-selection action panel === */
    .msBulk{
      display:flex; flex-direction:column; gap:10px; padding-bottom:12px; margin-bottom:6px;
      border-bottom:1px solid var(--border);
    }
    .msCard{
      border:1px solid rgba(255,255,255,.10); border-radius:14px;
      background: linear-gradient(135deg, rgba(255,255,255,.04) 0%, rgba(255,255,255,.015) 100%);
      padding:10px; display:flex; flex-direction:column; gap:4px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18);
    }
    .msCard.danger{ border-color: rgba(255,154,168,.14); background: linear-gradient(135deg, rgba(239,68,68,.06) 0%, rgba(239,68,68,.02) 100%); }
    .msCardHead{
      display:flex; align-items:center; gap:7px; padding:2px 4px 6px;
      font-size:10px; text-transform:uppercase; letter-spacing:.7px;
      color:rgba(130,180,255,.55); font-weight:600;
    }
    .msCardHead .msCount{
      font-size:9px; padding:1px 6px; border-radius:8px;
      background:rgba(59,130,246,.14); color:rgba(130,180,255,.7);
      font-weight:700; letter-spacing:0; text-transform:none;
    }
    .msCard.danger .msCardHead{ color:rgba(255,154,168,.55); }
    .msCard.danger .msCardHead .msCount{ background:rgba(239,68,68,.14); color:rgba(255,154,168,.7); }
    .msActBtn{
      display:flex; align-items:center; gap:9px; width:100%;
      border:1px solid transparent; background: rgba(255,255,255,.03);
      color: rgba(232,238,252,.88); padding:8px 10px; border-radius:11px;
      cursor:pointer; font-size:11.5px; text-align:left; transition: all .12s ease;
      user-select:none;
    }
    .msActBtn:hover{ background: rgba(255,255,255,.07); border-color: rgba(255,255,255,.10); }
    .msActBtn:active{ transform:translateY(1px); }
    .msActBtn .msIco{ width:18px; text-align:center; opacity:.75; flex:0 0 auto; font-size:13px; }
    .msActBtn.danger{ color: rgba(255,154,168,.90); }
    .msActBtn.danger:hover{ background: rgba(255,154,168,.10); border-color: rgba(255,154,168,.20); }
    .msActBtn .msArrow{ margin-left:auto; opacity:.25; font-size:10px; }
    .msStatGrid{
      display:grid; grid-template-columns:1fr 1fr; gap:6px;
    }
    .msStat{
      border:1px solid rgba(255,255,255,.07); border-radius:10px;
      background: rgba(255,255,255,.025); padding:8px 10px;
      display:flex; flex-direction:column; gap:2px;
    }
    .msStat .msStatLabel{
      font-size:9px; text-transform:uppercase; letter-spacing:.5px;
      opacity:.35; font-weight:500;
    }
    .msStat .msStatVal{
      font-size:15px; font-weight:700; letter-spacing:-.3px;
      color:rgba(232,238,252,.9);
    }
    .msStat .msStatSub{
      font-size:10px; opacity:.4; margin-top:1px;
    }
    .msStat.wide{ grid-column: 1 / -1; flex-direction:row; align-items:center; gap:10px; }
    .msStat.wide .msStatVal{ font-size:13px; }
    .msColChip{
      display:inline-flex; align-items:center; gap:5px;
      padding:4px 9px; border-radius:8px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      font-size:11px; white-space:nowrap;
      transition: background .12s;
    }
    .msColChip:hover{ background: rgba(255,255,255,.07); }
    .msColDot{
      width:7px; height:7px; border-radius:50%; flex-shrink:0;
      box-shadow: 0 0 6px currentColor;
    }
    .msColCount{ font-weight:600; opacity:.8; }
    /* bright mode overrides */
    body.brightMode .msCard{
      border-color: rgba(0,0,0,.10);
      background: linear-gradient(135deg, rgba(255,255,255,.5) 0%, rgba(245,247,250,.3) 100%);
      box-shadow: 0 2px 10px rgba(0,0,0,.06);
    }
    body.brightMode .msCard.danger{ border-color: rgba(220,38,38,.15); background: linear-gradient(135deg, rgba(220,38,38,.05) 0%, rgba(220,38,38,.02) 100%); }
    body.brightMode .msCardHead{ color:rgba(37,99,235,.55); }
    body.brightMode .msCardHead .msCount{ background:rgba(59,130,246,.10); color:rgba(37,99,235,.6); }
    body.brightMode .msCard.danger .msCardHead{ color:rgba(220,38,38,.50); }
    body.brightMode .msCard.danger .msCardHead .msCount{ background:rgba(220,38,38,.08); color:rgba(220,38,38,.6); }
    body.brightMode .msActBtn{ background: rgba(0,0,0,.025); color: rgba(30,41,59,.85); }
    body.brightMode .msActBtn:hover{ background: rgba(0,0,0,.06); border-color: rgba(0,0,0,.12); }
    body.brightMode .msActBtn.danger{ color: rgba(220,38,38,.80); }
    body.brightMode .msActBtn.danger:hover{ background: rgba(220,38,38,.07); border-color: rgba(220,38,38,.18); }
    body.brightMode .msStat{ border-color: rgba(0,0,0,.06); background: rgba(0,0,0,.02); }
    body.brightMode .msStat .msStatVal{ color: rgba(30,41,59,.85); }
    body.brightMode .msColChip{ border-color: rgba(0,0,0,.08); background: rgba(0,0,0,.03); }
    body.brightMode .msColChip:hover{ background: rgba(0,0,0,.06); }

    /* === Detail panel hero & metadata === */
    .dtHero{
      display:flex; align-items:flex-start; justify-content:space-between; gap:8px;
      padding:2px 2px 10px; margin-bottom:2px;
    }
    .dtEditorHead{
      display:flex; align-items:center; gap:8px;
      padding:0 0 8px; margin-bottom:4px;
      border-bottom:1px solid rgba(255,255,255,.05);
    }
    .dtEditorHead .dtEditorLabel{
      font-size:10px; opacity:.35; font-weight:500; letter-spacing:.3px;
    }
    .dtName{
      font-size:17px; font-weight:700; letter-spacing:-.2px;
      color:var(--text); line-height:1.25; word-break:break-word;
    }
    .dtType{
      font-size:9px; font-weight:700; text-transform:uppercase; letter-spacing:.8px;
      padding:3px 8px; border-radius:7px; flex-shrink:0; margin-top:3px;
      background:rgba(59,130,246,.12); color:rgba(130,180,255,.75);
      border:1px solid rgba(59,130,246,.15);
    }
    .dtType.group{ background:rgba(168,85,247,.12); color:rgba(192,148,255,.8); border-color:rgba(168,85,247,.18); }
    .dtType.column{ background:rgba(34,197,94,.10); color:rgba(100,220,150,.8); border-color:rgba(34,197,94,.15); }
    .dtType.mapping{ background:rgba(251,146,60,.10); color:rgba(251,176,100,.8); border-color:rgba(251,146,60,.15); }
    .dtRow{
      display:flex; align-items:baseline; gap:8px; padding:5px 2px;
      border-bottom:1px solid rgba(255,255,255,.04); font-size:12px;
    }
    .dtRow:last-child{ border-bottom:none; }
    .dtRowK{
      font-family:var(--mono); font-size:10px; color:rgba(155,176,230,.65);
      text-transform:uppercase; letter-spacing:.4px; flex:0 0 auto; min-width:54px;
    }
    .dtRowV{ flex:1; word-break:break-word; color:var(--text); }
    .dtId{
      font-family:var(--mono); font-size:11px; opacity:.7;
      display:inline-flex; align-items:center; gap:4px;
    }
    .dtNote{
      font-size:11.5px; opacity:.7; line-height:1.45; padding:6px 10px;
      border-radius:8px; background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.05); margin:2px 0;
    }
    .dtChipWrap{
      display:flex; flex-wrap:wrap; gap:5px; padding:4px 0;
    }
    .dtStatRow{
      display:flex; gap:6px; flex-wrap:wrap; padding:4px 0 2px;
    }
    .dtStatChip{
      font-size:11px; padding:4px 9px; border-radius:8px;
      border:1px solid rgba(255,255,255,.07); background:rgba(255,255,255,.03);
      display:inline-flex; align-items:center; gap:5px;
    }
    .dtStatChip .dtStatN{ font-weight:700; font-size:13px; letter-spacing:-.2px; }
    .dtStatChip .dtStatL{ opacity:.45; font-size:10px; }
    .dtColorSwatch{
      width:14px; height:14px; border-radius:5px; flex-shrink:0;
      border:1px solid rgba(255,255,255,.18); display:inline-block; vertical-align:middle;
    }
    .dtAttrGroup{
      display:flex; align-items:center; gap:5px; flex-wrap:wrap;
      padding:3px 0;
    }
    .dtAttrLabel{
      font-size:10px; font-family:var(--mono); padding:2px 7px;
      border-radius:6px; background:rgba(59,130,246,.10); color:rgba(130,180,255,.7);
      border:1px solid rgba(59,130,246,.10); font-weight:600;
    }
    .dtAttrVal{
      font-size:10.5px; padding:2px 7px; border-radius:6px;
      background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.08);
    }
    .dtActions{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      padding:10px 0 2px; margin-top:6px; border-top:1px solid var(--border);
    }
    .dtActions .spacer{ flex:1; }
    .dtHint{
      font-size:11px; opacity:.4; padding:6px 0 2px; line-height:1.4;
    }
    /* bright mode */
    body.brightMode .dtType{ background:rgba(59,130,246,.08); color:rgba(37,99,235,.6); border-color:rgba(59,130,246,.12); }
    body.brightMode .dtType.group{ background:rgba(168,85,247,.08); color:rgba(126,58,194,.6); border-color:rgba(168,85,247,.12); }
    body.brightMode .dtType.column{ background:rgba(34,197,94,.08); color:rgba(22,163,74,.6); border-color:rgba(34,197,94,.12); }
    body.brightMode .dtType.mapping{ background:rgba(251,146,60,.08); color:rgba(194,96,16,.6); border-color:rgba(251,146,60,.12); }
    body.brightMode .dtRow{ border-bottom-color:rgba(0,0,0,.04); }
    body.brightMode .dtEditorHead{ border-bottom-color:rgba(0,0,0,.06); }
    body.brightMode .dtRowK{ color:rgba(71,85,105,.6); }
    body.brightMode .dtNote{ background:rgba(0,0,0,.02); border-color:rgba(0,0,0,.06); }
    body.brightMode .dtStatChip{ border-color:rgba(0,0,0,.06); background:rgba(0,0,0,.02); }
    body.brightMode .dtStatChip .dtStatN{ color:rgba(30,41,59,.85); }
    body.brightMode .dtAttrLabel{ background:rgba(59,130,246,.07); color:rgba(37,99,235,.6); border-color:rgba(59,130,246,.08); }
    body.brightMode .dtAttrVal{ background:rgba(0,0,0,.03); border-color:rgba(0,0,0,.07); }
    body.brightMode .dtColorSwatch{ border-color:rgba(0,0,0,.15); }

    .toggle{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      cursor: pointer;
      user-select: none;
      font-size: 12px;
      white-space: nowrap;
      transition: background .15s, border-color .15s;
    }
    .toggle:hover{ background: rgba(255,255,255,.12); border-color: rgba(255,255,255,.2); }
    .toggle input{ accent-color: #3b82f6; width: 14px; height: 14px; margin: 0; }

    .search{
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      border-radius: 12px;
      padding: 6px 10px;
      min-width: min(520px, 92vw);
      flex: 1 1 auto;
    }
    .search input{
      width: 100%;
      border: none;
      outline: none;
      background: transparent;
      color: var(--text);
      font-size: 12px;
      padding: 4px 0;
    }
    .search .hint{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(155,176,230,.9);
      border: 1px solid var(--border);
      padding: 2px 6px;
      border-radius: 8px;
      background: rgba(255,255,255,.04);
      white-space: nowrap;
    }

    /* main content areas */
    main{
      padding: 14px;
      flex: 1 1 0;
      min-height: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* App footer */
    .appFooter{
      display: flex; align-items: center; justify-content: space-between;
      padding: 6px 14px;
      border-top: 1px solid var(--border);
      font-size: 10px; color: var(--muted); opacity: .5;
      flex-shrink: 0; user-select: none;
      letter-spacing: .2px;
    }
    .appFooter a{ color: var(--muted); text-decoration: none; }
    .appFooter a:hover{ text-decoration: underline; }
    .aboutLicenseLink{ color: inherit; text-decoration: none; cursor: pointer; }
    .aboutLicenseLink:hover{ text-decoration: underline; }
    .view{
      display:none;
    }
    .view.active{
      display: flex;
      flex-direction: column;
      flex: 1 1 0;
      min-height: 0;
    }

    /* Viewer layout  panel modes controlled by [data-panel] */
    .viewerGrid{
      display: grid;
      grid-template-columns: 1fr 440px;
      gap: 14px;
      flex: 1 1 0;
      min-height: 0;
      overflow: hidden;
      position: relative;
    }
    /* Side mode  RIGHT (default) */
    .viewerGrid[data-panel="right"]{ grid-template-columns: 1fr 440px; grid-template-rows: 1fr; }
    .viewerGrid[data-panel="right"] .details{ max-height: none; }
    /* Side mode  LEFT */
    .viewerGrid[data-panel="left"]{ grid-template-columns: 440px 1fr; grid-template-rows: 1fr; }
    .viewerGrid[data-panel="left"] .details{ max-height: none; order: -1; }
    .viewerGrid[data-panel="left"] .columnsWrap{ order: 1; }
    .viewerGrid[data-panel="left"] .resizeHandle{ order: 0; }
    /* Bottom mode */
    .viewerGrid[data-panel="bottom"]{ grid-template-columns: 1fr; grid-template-rows: 1fr calc(30vh - 28px); }
    .viewerGrid[data-panel="bottom"] .details{ max-height: 65vh; min-height: 120px; }
    .viewerGrid[data-panel="bottom"] .detailsBody{ max-height: none; }
    /* Floating mode */
    .viewerGrid[data-panel="float"]{ grid-template-columns: 1fr; grid-template-rows: 1fr; }
    .viewerGrid[data-panel="float"] .details{
      position: fixed;
      z-index: 180;
      top: auto; left: auto; right: auto; bottom: auto;
      width: 444px; max-width: calc(100vw - 32px);
      height: 380px; min-height: 160px; min-width: 300px;
      border-radius: var(--radius);
      box-shadow: 0 20px 60px rgba(0,0,0,.55), 0 0 0 1px rgba(255,255,255,.10);
      backdrop-filter: blur(24px);
      background: rgba(11,16,32,.97);
      overflow: visible;
    }
    body.brightMode .viewerGrid[data-panel="float"] .details{
      box-shadow: 0 20px 60px rgba(0,0,0,.25), 0 0 0 1px rgba(0,0,0,.14);
      background: rgba(245,247,250,.97);
      backdrop-filter: blur(24px);
    }
    /* Floating mode: entire header is the drag handle */
    .viewerGrid[data-panel="float"] .detailsHeader{
      cursor: move; user-select: none;
      border-radius: var(--radius) var(--radius) 0 0;
    }
    /* Float resize: custom corner handle */
    .floatResizeHandle{
      display: none; position: absolute; bottom: 0; right: 0;
      width: 18px; height: 18px; cursor: nwse-resize; z-index: 5;
    }
    .floatResizeHandle::after{
      content: ''; position: absolute; bottom: 3px; right: 3px;
      width: 8px; height: 8px;
      border-right: 2px solid rgba(255,255,255,.25);
      border-bottom: 2px solid rgba(255,255,255,.25);
    }
    .floatResizeHandle:hover::after{
      border-color: rgba(59,130,246,.7);
    }
    body.brightMode .floatResizeHandle::after{
      border-color: rgba(0,0,0,.2);
    }
    body.brightMode .floatResizeHandle:hover::after{
      border-color: rgba(59,130,246,.6);
    }
    .viewerGrid[data-panel="float"] .floatResizeHandle{ display: block; }
    .viewerGrid[data-panel="float"] .floatOnly{ display: inline-flex !important; }
    .viewerGrid[data-panel="float"] .details{ transition: opacity .25s ease; }
    .viewerGrid[data-panel="float"] .detailsBody{ border-radius: 0 0 var(--radius) var(--radius); }
    .viewerGrid[data-panel="float"] .details.minimized .detailsBody,
    .viewerGrid[data-panel="float"] .details.minimized .floatResizeHandle{ display: none; }
    .viewerGrid[data-panel="float"] .details.minimized{ height: auto !important; min-height: 0 !important; }
    body.brightMode #opacityPopover{ background: rgba(245,247,250,.97); box-shadow: 0 8px 24px rgba(0,0,0,.15); }
    /* Hidden mode */
    .viewerGrid[data-panel="hidden"]{ grid-template-columns: 1fr; grid-template-rows: 1fr; }
    .viewerGrid[data-panel="hidden"] .details{ display: none; }

    /* Details drag grip icon (float mode only) */
    .detailsDragHandle{ display: none; }
    .detailsGrip{
      display: none; width: 12px; height: 18px; cursor: move;
      flex-shrink: 0; opacity: .3; transition: opacity .15s;
      background-image: radial-gradient(circle, currentColor 1.2px, transparent 1.2px);
      background-size: 6px 6px;
      background-position: 0 0;
      background-repeat: repeat;
    }
    .detailsGrip:hover{ opacity: .6; }
    .viewerGrid[data-panel="float"] .detailsGrip{ display: block; }

    /* Close button for details panel */
    .detailsClose{
      display: inline-flex; width: 22px; height: 22px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06);
      color: var(--muted); font-size: 13px; line-height: 1;
      cursor: pointer; align-items: center; justify-content: center;
      transition: all .15s; flex-shrink: 0;
    }
    .detailsClose:hover{ background: rgba(255,255,255,.12); color: var(--text); }
    body.brightMode .detailsClose{ border-color: rgba(0,0,0,.12); background: rgba(0,0,0,.04); }
    body.brightMode .detailsClose:hover{ background: rgba(0,0,0,.08); }

    /* Resize handle for side mode  absolutely positioned over the gap */
    .resizeHandle{
      position: absolute; top: 0; bottom: 0; width: 14px; cursor: col-resize;
      z-index: 15; user-select: none; display: none;
    }
    .resizeHandle::before{
      content: ''; position: absolute; top: 12px; bottom: 12px; left: 50%; width: 1px;
      background: var(--border); transform: translateX(-50%);
    }
    .resizeHandle::after{
      content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
      width: 4px; height: 48px; border-radius: 4px;
      background: rgba(255,255,255,.14);
      transition: background .15s, height .15s, box-shadow .15s;
    }
    .resizeHandle:hover::after, .resizeHandle.active::after{
      background: rgba(59,130,246,.65); height: 64px;
      box-shadow: 0 0 8px rgba(59,130,246,.25);
    }
    body.brightMode .resizeHandle::before{ background: rgba(0,0,0,.1); }
    body.brightMode .resizeHandle::after{ background: rgba(0,0,0,.12); }
    body.brightMode .resizeHandle:hover::after, body.brightMode .resizeHandle.active::after{
      background: rgba(59,130,246,.55); box-shadow: 0 0 8px rgba(59,130,246,.15);
    }
    .viewerGrid[data-panel="right"] .resizeHandle{ display: block; }
    .viewerGrid[data-panel="left"] .resizeHandle{ display: block; }
    /* Bottom mode resize handle */
    .resizeHandleH{
      position: absolute; left: 0; right: 0; height: 14px; cursor: row-resize;
      z-index: 15; user-select: none; display: none;
    }
    .resizeHandleH::before{
      content: ''; position: absolute; left: 12px; right: 12px; top: 50%; height: 1px;
      background: var(--border); transform: translateY(-50%);
    }
    .resizeHandleH::after{
      content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
      width: 48px; height: 4px; border-radius: 4px;
      background: rgba(255,255,255,.14);
      transition: background .15s, width .15s, box-shadow .15s;
    }
    .resizeHandleH:hover::after, .resizeHandleH.active::after{
      background: rgba(59,130,246,.65); width: 64px;
      box-shadow: 0 0 8px rgba(59,130,246,.25);
    }
    body.brightMode .resizeHandleH::before{ background: rgba(0,0,0,.1); }
    body.brightMode .resizeHandleH::after{ background: rgba(0,0,0,.12); }
    body.brightMode .resizeHandleH:hover::after, body.brightMode .resizeHandleH.active::after{
      background: rgba(59,130,246,.55); box-shadow: 0 0 8px rgba(59,130,246,.15);
    }
    .viewerGrid[data-panel="bottom"] .resizeHandleH{ display: block; }

    /* Pan mode (P key toggle) */
    .columnsScroller.panReady{ cursor: all-scroll !important; }
    .columnsScroller.panReady *{ cursor: all-scroll !important; pointer-events: none !important; }
    .columnsScroller.panning{ cursor: all-scroll !important; }
    .columnsScroller.panning *{ cursor: all-scroll !important; pointer-events: none !important; }

    /* Layout popover sections */
    .layoutSection{ padding: 8px 0; }
    .layoutSection + .layoutSection{ border-top: 1px solid var(--border); }
    .layoutSectionTitle{
      font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: .6px;
      color: var(--muted); opacity: .7; margin-bottom: 6px;
    }
    .layoutSliderRow{
      display: grid; grid-template-columns: 44px 1fr 36px 16px; gap: 6px;
      align-items: center; margin: 6px 0;
    }
    .layoutSliderLabel{ font-size: 11px; color: var(--muted); }
    .layoutSliderVal{ font-family: var(--mono); font-size: 11px; color: var(--muted); text-align: right; }
    .layoutSliderRow input[type="range"]{ width: 100%; }
    .layoutReset{
      font-size: 12px; cursor: pointer; opacity: 0; transition: opacity .15s;
      color: var(--muted); text-align: center; line-height: 1;
    }
    .layoutSliderRow:hover .layoutReset{ opacity: .4; }
    .layoutReset:hover{ opacity: .8 !important; color: var(--accent); }
    .layoutHint{
      font-size: 10px; opacity: .35; margin-top: 8px;
    }
    .layoutHint kbd{
      font-family: var(--mono); font-size: 10px; padding: 1px 4px;
      border-radius: 4px; border: 1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
    }
    body.brightMode .layoutHint kbd{
      border-color: rgba(0,0,0,.15); background: rgba(0,0,0,.04);
    }

    /* Dock selector  icon+label buttons in a row */
    .dockSelector{
      display: flex; gap: 4px; flex-wrap: wrap;
    }
    .dockOpt{
      display: flex; flex-direction: column; align-items: center; gap: 3px;
      padding: 6px 8px 5px; border-radius: 8px; border: 1px solid var(--border);
      background: rgba(255,255,255,.04); color: var(--muted);
      font-size: 10px; cursor: pointer; user-select: none;
      transition: all .15s; flex: 1 1 0; min-width: 42px;
    }
    .dockOpt:hover{
      background: rgba(255,255,255,.08); color: var(--text); border-color: rgba(255,255,255,.18);
    }
    .dockOpt.active{
      background: rgba(59,130,246,.15); border-color: rgba(59,130,246,.5); color: var(--text);
    }
    .dockOpt svg{ flex-shrink: 0; }
    body.brightMode .dockOpt{
      background: rgba(0,0,0,.03); color: #64748b; border-color: rgba(0,0,0,.12);
    }
    body.brightMode .dockOpt:hover{
      background: rgba(0,0,0,.06); color: #1e293b; border-color: rgba(0,0,0,.2);
    }
    body.brightMode .dockOpt.active{
      background: rgba(59,130,246,.1); border-color: rgba(59,130,246,.4); color: #1e293b;
    }

    /* Details header dock actions  always visible */
    .detailsDockActions{
      display: flex; gap: 2px; align-items: center;
    }
    .dockAction{
      width: 22px; height: 22px; border-radius: 6px;
      border: 1px solid rgba(255,255,255,.10); background: transparent;
      color: var(--muted); cursor: pointer; display: inline-flex;
      align-items: center; justify-content: center; transition: all .12s;
      padding: 0;
    }
    .dockAction:hover{ background: rgba(255,255,255,.10); color: var(--text); }
    body.brightMode .dockAction{ border-color: rgba(0,0,0,.10); }
    body.brightMode .dockAction:hover{ background: rgba(0,0,0,.06); color: #1e293b; }

    /* Snap-to-edge indicator when dragging float panel */
    .snapIndicator{
      position: fixed; z-index: 175; display: none;
      background: rgba(59,130,246,.12); border: 2px dashed rgba(59,130,246,.5);
      border-radius: 8px; pointer-events: none;
      transition: all .15s ease;
    }
    body.brightMode .snapIndicator{
      background: rgba(59,130,246,.08); border-color: rgba(59,130,246,.4);
    }

    .columnsWrap{
      position: relative;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(to bottom, rgba(255,255,255,.045), rgba(255,255,255,.02));
      overflow: hidden;
      min-height: 0;
      min-width: 0;
      display:flex;
      flex-direction: column;
      flex: 1 1 0;
    }
    .columnsHeader{
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.10);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .statusLine{
      color: var(--muted);
      font-size: 12px;
      min-width: 220px;
      flex: 1 1 auto;
    }

    .viewerControls{
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }
    .vcGroup{
      display: inline-flex;
      align-items: center;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 8px;
      padding: 2px;
      gap: 1px;
    }
    .vcBtn{
      width: 28px;
      height: 28px;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      transition: all .15s;
      opacity: .65;
    }
    .vcBtn:hover{ background: rgba(255,255,255,.1); opacity: 1; color: var(--text); }
    .vcBtn:active{ background: rgba(255,255,255,.15); }
    .vcBtn.active{ background: rgba(59,130,246,.2); color: #60a5fa; opacity: 1; }
    .vcBtn[disabled]{ opacity: .25; pointer-events: none; }

    .columnsScroller{
      position: relative;
      overflow: auto;
      min-height: 0;
      padding: 12px;
      flex: 1 1 0;
    }

    .columnsRow{
      position: relative;
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(var(--col-width, 300px), 1fr);
      gap: var(--col-gap, 20px);
      align-items: stretch;
      min-width: 920px; /* allows horizontal scroll when many columns */
      padding-bottom: 6px;
      min-height: 100%;
    }

    #svgOverlay{
 position: absolute;
 inset: 0;
 pointer-events: none;
 z-index: 40;
 overflow: hidden;
 }

    .panel{
      position: relative;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: linear-gradient(to bottom, rgba(255,255,255,.05), rgba(255,255,255,.03));
      min-height: 0;
      display:flex;
      flex-direction: column;
      height: 100%;
    }

    .panelHeader{
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.10);
      user-select: none;
    }
    .panelHeader .name{
      font-weight: 900;
      font-size: 13px;
      letter-spacing: .2px;
    }
    .panelHeader .meta{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
    }
    
.panelHeader.clickable{cursor:pointer;}
.panelHeader.clickable:hover{background: rgba(59,130,246,.08);}
.panelHeader.clickable:active{transform: translateY(1px);}
.panelHeader.colored{ background: var(--col-bg); border-bottom: 2px solid var(--col-color); }
.panelHeader.colored:hover{ background: var(--col-bg-hover); }
.panelHeader.selected, .panelHeader.selected:hover{background: var(--active-bg); border-bottom-color: var(--active-br);}
.panelHeader.selected.colored, .panelHeader.selected.colored:hover{background: var(--active-bg); border-bottom-color: var(--active-br);}
.tree{
      padding: 8px;
      overflow: auto;
      min-height: 0;
      flex: 1 1 0;
    }
    .foot{
      padding: 10px 12px;
      border-top: 1px solid var(--border);
      background: rgba(0,0,0,.08);
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }

    .node{ margin: 2px 0; border-radius: 10px; }
    .row{
 position: relative;
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      border: 1px solid transparent;
      transition: transform .05s ease;
    }
    .row:hover{ background: rgba(255,255,255,.05); }
    .row:active{ transform: translateY(1px); }
    .hasNodeColor:not(.active):not(.connected):not(.filterHighlight):not(.filterDimmed) > .row{ background: var(--node-color); border-color: var(--node-color-border); }

    .badge{
      font-family: var(--mono);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(255,255,255,.04);
      flex: 0 0 auto;
    }

    .caret{
      width: 0; height: 0;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 7px solid rgba(232,238,252,.72);
      transition: transform .12s ease;
      margin-right: 2px;
      flex: 0 0 auto;
      cursor: pointer;
      padding: 6px;
      border-radius: 8px;
    }
    .caret:hover{ background: rgba(255,255,255,.06); }
    .group.collapsed > .row .caret{ transform: rotate(-90deg); }

    .label{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width: 0;
 flex: 1 1 auto;
      font-size: 13px;
    }
    .label .text{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
 display:block;
 min-width:0;
 flex: 1 1 auto;
    }

    .id{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(155,176,230,.85);
      margin-left:auto;
      opacity: .75;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 48%;
    }
/* Hide node IDs in tree rows (IDs remain in Details/breadcrumbs) */
.row .id{display:none !important;}
/* Inline rename input (keyboard quick-create) */
.row .inlineRenameWrap{ flex:1 1 auto; min-width:0; display:flex; align-items:center; }
.row .inlineRenameWrap input{ background:transparent; border:none; border-bottom:1.5px solid rgba(59,130,246,.55); outline:none; color:var(--text); font:inherit; font-size:12.5px; width:100%; padding:0 0 1px; margin:0; }
.row .inlineRenameWrap input::placeholder{ color:var(--muted); opacity:.6; }
body.brightMode .row .inlineRenameWrap input{ border-bottom-color:rgba(59,130,246,.45); }


    .children{
      margin-left: 16px;
      padding-left: 8px;
      border-left: 1px dashed rgba(255,255,255,.14);
    }

    .hidden{ display:none !important; }
    .filterDimmed > .row{ opacity: 0.25; }
    .filterDimmed.active > .row, .filterDimmed.connected > .row{ opacity: 1 !important; }
    .filterHighlight > .row{ background: var(--filter-bg, transparent) !important; border-radius: 4px; }
    .filterHighlight > .row{ border-left: 3px solid var(--filter-border, transparent); padding-left: 3px; }
    .filterBold > .row .label .text{ font-weight: 700 !important; }
    .filterFrame{ outline: 2px solid var(--filter-frame, #3b82f6); outline-offset: -1px; border-radius: 5px; }
    .filterEmoji{ font-style: normal; }
    .catItem.dragOver{ border-color: rgba(59,130,246,.6) !important; box-shadow: 0 0 0 1px rgba(59,130,246,.4) !important; background:rgba(59,130,246,.04) !important; }
    .condGroup{ border-left: 2px solid var(--accent); margin: 4px 0 4px 8px; padding: 2px 0 2px 10px; border-radius: 0 0 0 6px; }
    .condDragHandle{ cursor:grab; opacity:.35; font-size:11px; user-select:none; padding:0 2px; transition:opacity .15s; }
    .condDragHandle:hover{ opacity:.8; }
    .condRow.condDragOver-above, .condGroup.condDragOver-above{ box-shadow:0 -2px 0 0 var(--accent); background:rgba(59,130,246,.06); border-radius:4px; }
    .condRow.condDragOver-below, .condGroup.condDragOver-below{ box-shadow:0 2px 0 0 var(--accent); background:rgba(59,130,246,.06); border-radius:4px; }
    .condGroup.condDragOver-into{ background:rgba(59,130,246,.10); border-color:var(--accent); }
    .condRow.condDragging, .condGroup.condDragging{ opacity:.3; }
    .condRow{ position:relative; padding:3px 0; border-radius:4px; transition:background .1s, box-shadow .1s; }
    .condGroup{ position:relative; transition:background .1s, box-shadow .1s; }
    .condActions .btn{ opacity:.4; min-width:20px; text-align:center; }
    .condActions .btn:hover{ opacity:1; }
    .condActions .ruleDel{ opacity:.5; }
    .condActions .ruleDel:hover{ opacity:1; background:rgba(248,113,113,.12); }
    .feHighlightGrid, .feStyleBar{ display:flex; gap:0; align-items:center; flex-wrap:wrap; margin-bottom:6px; padding:8px 10px; border:1px solid var(--border); border-radius:10px; background:rgba(255,255,255,.03); justify-content:space-between; }
    .feStyleItem{ display:flex; align-items:center; gap:4px; font-size:11px; cursor:grab; padding:3px 6px; border-radius:8px; border:1px solid transparent; transition:all .15s; }
    .feStyleItem:hover{ background:rgba(255,255,255,.06); border-color:var(--border); }
    .feStyleItem.feSwatchDragOver{ border-color:rgba(59,130,246,.7); background:rgba(59,130,246,.15); box-shadow:0 0 8px rgba(59,130,246,.3); }
    .feStyleItem.feSwatchDragging{ opacity:.45; }
    .feStyleLabel{ font-size:10px; opacity:.65; letter-spacing:.3px; }
    .feColorSwatch{ width:26px; height:20px; border:1px solid rgba(255,255,255,.15); border-radius:5px; cursor:pointer; padding:0; }
    .feStyleSep{ width:1px; height:22px; background:var(--border); flex-shrink:0; }
    .feEmojiOption:hover{ background:rgba(255,255,255,.12) !important; border-color:var(--accent) !important; }
    .dimmed > .row{ opacity: var(--dim); }
    .active > .row{ background: var(--active-bg) !important; border-color: var(--active-br) !important; }
.active > .row{opacity:1 !important;}
.active.dimmed > .row{opacity:1 !important;}
    .connected > .row{ background: var(--hl-bg) !important; border-color: var(--hl-br) !important; }
    .connectedParent > .row{ background: rgba(59,130,246,.09) !important; border-color: rgba(59,130,246,.35) !important; }
    body.brightMode .connectedParent > .row{ background: rgba(59,130,246,.06) !important; border-color: rgba(30,80,200,.30) !important; }
    .active.connectedParent > .row{ background: var(--active-bg) !important; border-color: var(--active-br) !important; }
    .active.connected > .row{ background: linear-gradient(90deg, var(--active-bg), var(--hl-bg)) !important; }

    /* Details panel */
    .details{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: linear-gradient(to bottom, rgba(255,255,255,.05), rgba(255,255,255,.03));
      display:flex;
      flex-direction: column;
      min-height:0;
      min-width:0;
    }
    .detailsHeader{
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.10);
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
    }
    .detailsHeader .name{ font-weight: 900; font-size: 13px; }
    .detailsHeader .meta{ font-family: var(--mono); color: var(--muted); font-size: 11px; }
    .detailsBody{
      padding: 10px 12px 12px;
      overflow: auto;
      min-height: 0;
      flex: 1 1 0;
    }
    .box{
 border: 1px solid var(--border);

      border: 1px solid var(--border);
      background: rgba(255,255,255,.04);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
    }
    .box h3{
      margin: 0 0 6px 0;
      font-size: 12px;
      color: var(--muted);
      font-weight: 900;
      letter-spacing: .2px;
      text-transform: uppercase;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    /* Collapsible detail sections */
    .detailSectionHead{ cursor:pointer; user-select:none; }
    .detailSectionHead::before{ content:''; display:inline-block; width:12px; font-size:10px; opacity:.5; transition:transform .15s; }
    .detailSection.collapsed .detailSectionHead::before{ transform:rotate(-90deg); }
    .detailSection.collapsed .detailSectionBody{ display:none; }
    .detailSectionHead:hover{ color:var(--text); }
    .kv{
      display:grid;
      grid-template-columns: 96px 1fr;
      gap: 6px 10px;
      font-size: 12px;
      align-items: start;
    }
    .k{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(155,176,230,.95);
      padding-top: 2px;
    }
    .v{ word-break: break-word; }

    .list{
      list-style:none;
      padding:0;
      margin: 8px 0 0 0;
      display:flex;
      flex-direction: column;
      gap: 6px;
    }
    .item{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 8px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: rgba(0,0,0,.10);
      cursor: pointer;
      user-select: none;
    }
/* Mapping row action icons (Details pane) */
.item{position:relative;}
.item .itemActions{margin-left:auto; display:flex; gap:6px; align-items:center; opacity:0; transition: opacity .12s ease;}
.item:hover .itemActions{opacity:1;}
.mapNote{flex: 1 1 100%; margin-left: 0; font-family: var(--mono); font-size: 11px; opacity:.78; overflow-wrap:anywhere;}

    .item:hover{
      border-color: rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
    }
    .pill{
      font-family: var(--mono);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(255,255,255,.04);
      flex: 0 0 auto;
    }
    .tag{
      font-family: var(--mono);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: rgba(232,238,252,.85);
      background: rgba(255,255,255,.05);
      flex: 0 0 auto;
      max-width: 190px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .empty{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* SVG edges */
    .edge{
 stroke-linecap: round;
 stroke-linejoin: round;
      fill: none;
      stroke: var(--line);
      stroke-width: 1.3;
      opacity: .95;
    }
    .edge.hl{
      stroke: var(--line-hl);
      stroke-width: 2.0;
      opacity: 1;
    }
    .edge.dimmed{ opacity: var(--dim); }
    .edge.fadeOut{ opacity: 0 !important; }
    .edgeLabel{
      font-family: var(--sans); font-size: 10px; fill: #94a3b8; opacity: .95;
      pointer-events: none; text-anchor: middle; dominant-baseline: central;
      paint-order: stroke; stroke: var(--bg); stroke-width: 3px; stroke-linecap: round; stroke-linejoin: round;
    }
    .edgeLabel.hl{ opacity: 1; font-weight: 600; fill: var(--line-hl); }
    .edgeLabel.active{ opacity: 1; font-weight: 700; fill: var(--line-active); }
    .edgeLabel.dimmed{ opacity: var(--dim); }
    .edgeLabel.fadeOut{ opacity: 0 !important; }
 .edge.active{
      stroke: var(--line-active);
      stroke-width: 2.4;
      opacity: 1;
    }
    .edgeMarker{ fill: var(--line); opacity: .95; }
    .edgeMarker.hl{ fill: var(--line-hl); opacity: 1; }
    .edgeMarker.active{ fill: var(--line-active); opacity: 1; }

    /* Editor layout */
    textarea{
      width: 100%;
      height: 100%;
      min-height: 0;
      resize: none;
      border: none;
      outline: none;
      background: rgba(0,0,0,.10);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      padding: 12px;
      tab-size: 2;
    }

    .ok{ color: #9be6b0; }
    .warn{ color: #f5d27b; }
    .err{ color: #ff9aa8; }

    /* Docs */
    .docsBody{
      padding: 24px;
    }
    .docsBody h2{
      margin: 20px 0 8px 0;
      font-size: 14px;
      scroll-margin-top: 8px;
    }
    .docsBody h2:first-of-type{ margin-top: 10px; }
    .docsBody h3{
      margin: 14px 0 6px 0;
      font-size: 13px;
      color: rgba(232,238,252,.92);
      scroll-margin-top: 8px;
    }
    .docsToc{ margin-bottom: 20px; padding: 14px 18px 12px; background: rgba(255,255,255,.03); border: 1px solid var(--border); border-radius: var(--radius); }
    .docsToc .tocTitle{ font-weight: 700; font-size: 11px; margin-bottom: 10px; color: rgba(232,238,252,.45); text-transform: uppercase; letter-spacing: .8px; }
    .docsToc .tocGrid{ display: grid; grid-template-columns: 1fr 1fr; gap: 2px 32px; }
    .docsToc .tocSection{ break-inside: avoid; padding: 3px 0; }
    .docsToc .tocSection a.main{ display: block; font-size: 12.5px; font-weight: 600; color: rgba(200,218,255,.9); text-decoration: none; padding: 2px 0; line-height: 1.45; }
    .docsToc .tocSection a.main:hover{ text-decoration: underline; color: rgba(140,180,255,1); }
    .docsToc .tocSection .tocSubs{ padding-left: 10px; border-left: 1px solid rgba(255,255,255,.06); margin: 1px 0 4px 4px; }
    .docsToc .tocSection .tocSubs a{ display: block; font-size: 11.5px; color: rgba(160,185,240,.55); text-decoration: none; padding: 1px 0; line-height: 1.45; }
    .docsToc .tocSection .tocSubs a:hover{ text-decoration: underline; color: rgba(140,180,255,.9); }
    body.brightMode .docsToc{ background: rgba(0,0,0,.025); }
    body.brightMode .docsToc .tocTitle{ color: #9ca3af; }
    body.brightMode .docsToc .tocSection a.main{ color: #1e40af; }
    body.brightMode .docsToc .tocSection a.main:hover{ color: #1d4ed8; }
    body.brightMode .docsToc .tocSection .tocSubs{ border-left-color: rgba(0,0,0,.08); }
    body.brightMode .docsToc .tocSection .tocSubs a{ color: #6b7fad; }
    body.brightMode .docsToc .tocSection .tocSubs a:hover{ color: #1d4ed8; }
    .docsBody p, .docsBody li{
      color: rgba(232,238,252,.86);
      font-size: 12.5px;
      line-height: 1.55;
    }
    .docsBody code{
      font-family: var(--mono);
      font-size: 11.5px;
      background: rgba(255,255,255,.06);
      padding: 1px 5px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.10);
    }
    .docsBody pre{
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
      overflow: auto;
    }
    .docsBody pre code{
      background: transparent;
      border: none;
      padding: 0;
      border-radius: 0;
    }

    @media (max-width: 1180px){
      .viewerGrid[data-panel="right"]{ grid-template-columns: 1fr; grid-template-rows: 1fr auto; }
      .viewerGrid[data-panel="right"] .details{ max-height: 38vh; min-height: 120px; }
      .viewerGrid[data-panel="right"] .resizeHandle{ display: none; }
      .viewerGrid[data-panel="right"] .resizeHandleH{ display: block; }
      .viewerGrid[data-panel="left"]{ grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      .viewerGrid[data-panel="left"] .details{ max-height: 38vh; min-height: 120px; order: -1; }
      .viewerGrid[data-panel="left"] .resizeHandle{ display: none; }
      .viewerGrid[data-panel="left"] .resizeHandleH{ display: block; }
      .columnsRow{ grid-auto-columns: minmax(280px, 1fr); }
    }
    @media (max-width: 768px){
      header{ padding: 8px 10px; }
      main{ padding: 8px; }
      .viewerGrid{ gap: 8px; }
      .viewerGrid[data-panel="float"] .details{ width: calc(100vw - 20px); right: 10px; bottom: 10px; }
    }

    
    .inp{
      width: 100%;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.16);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      outline: none;
    }
    
/* Improved select dropdown readability */
select.inp{ color: var(--text); background: rgba(0,0,0,.18); }
select.inp option{ background: #16203a; color: #e8eefc; }
select.inp option:checked{ background: #2b3a5c; color: #ffffff; }
select.inp option:disabled{ color: rgba(155,176,230,.95); }
.inp:focus{ border-color: rgba(59,130,246,.55); box-shadow: 0 0 0 2px rgba(59,130,246,.12); }
    .mapCard{
      border: 1px solid var(--border);
      background: rgba(0,0,0,.10);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
    }
    .mapCard.catItem{ transition: border-color .15s, box-shadow .15s; }
    .mapCard.catItem:not(.catEditing):hover{ border-color: rgba(59,130,246,.35); box-shadow: 0 0 0 1px rgba(59,130,246,.12); }
    .mapCard.catEditing{ border-color: rgba(59,130,246,.5); box-shadow: 0 0 0 2px rgba(59,130,246,.12); }
    .catEditActive .catItem:not(.catEditing){ opacity: 0.3; pointer-events: none; filter: grayscale(.4); transition: opacity .2s, filter .2s; }
    .catEditActive .catItem.catEditing{ position:relative; z-index:1; }
    .mapCard .topRow{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .mapCard .topRow .mini{ font-family: var(--mono); font-size: 11px; color: var(--muted); }
    .mapCard details{ margin-top: 8px; }
    .mapCard summary{ cursor:pointer; color: rgba(232,238,252,.86); font-size:12px; }

  

/* --- Enhancements (2026-02): ports, overflow, column wrapping, popovers --- */
.row .port{position:absolute; top:50%; transform:translateY(-50%); width:10px; height:10px; border-radius:999px;
  background: rgba(59,130,246,.20); border:1px solid rgba(59,130,246,.55); opacity:0; pointer-events:none;}
.row .port.portL{left:-6px;}
.row .port.portR{right:-6px;}
.node.field .row .port{background: rgba(255,208,92,.14); border-color: rgba(255,208,92,.45);}
.row:hover .port{opacity:.35;}

/* Details panel: prevent ugly overflow */

/* --- Mapping list layout tweaks (v6_4): always break field name + prettier notes --- */
.item{flex-wrap:wrap; align-items:flex-start; gap:8px;}
.item .txt{flex:1 1 100%; min-width:0; margin-top:2px; font-weight:800;}
.item .route{flex:1 1 100%; margin-left:0; margin-top:6px; font-family:var(--mono); font-size:11px; opacity:.72; overflow-wrap:anywhere; word-break:break-word;}
.mapNote{flex:1 1 100%; margin-left:0; margin-top:6px; padding:6px 8px; border-radius:10px; border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.10); color:rgba(232,238,252,.82); font-size:11px; line-height:1.35; overflow-wrap:anywhere;}
.mapNote::before{content:'Note'; display:inline-block; margin-right:6px; font-weight:900; color:rgba(155,176,230,.95);}
.item{flex-wrap:wrap; align-items:flex-start; gap:8px;}
.item .txt{min-width: 160px; flex: 1 1 220px; overflow:hidden; text-overflow: ellipsis;}
.item .route{flex: 1 1 100%; margin-left: 0; font-family: var(--mono); font-size: 11px; opacity: .75;
  overflow-wrap:anywhere; word-break: break-word;}
.tag{max-width: 260px;}

/* Column wrap mode (stack columns under each other) */
.columnsRow.wrap{grid-auto-flow: row; grid-template-columns: repeat(auto-fit, minmax(var(--col-width, 300px), 1fr)); min-width: 0 !important;}
.panel.hiddenCol{display:none !important;}

/* Popover + modal */
.popover{position:absolute; top: 44px; right: 14px; z-index: 120; width: min(520px, 92vw);
  border:1px solid var(--border); border-radius: 14px; background: rgba(11,16,32,.92);
  box-shadow: 0 20px 60px rgba(0,0,0,.45); backdrop-filter: blur(10px); padding: 10px; display:none;}
.popover.active{display:block;}
.popover .popTitle{font-weight: 900; font-size: 12px; margin: 2px 0 10px 0; color: rgba(232,238,252,.92);} 
.popItem{display:flex; align-items:center; gap:8px; padding: 8px; border-radius: 12px; border:1px solid transparent; background: rgba(255,255,255,.03);} 
.popItem:hover{border-color: rgba(255,255,255,.10); background: rgba(255,255,255,.05);} 
.popItem.dragOver{border-color: rgba(59,130,246,.6); box-shadow: 0 -2px 0 0 rgba(59,130,246,.7);}
.popItem .grow{flex:1 1 auto; min-width: 0;} 
.popItem input[type='checkbox']{accent-color:#3b82f6;}
    /* Columns popover */
    .colPopFooter{display:flex;gap:6px;align-items:center;margin-top:10px;padding-top:8px;border-top:1px solid var(--border);flex-wrap:wrap;}
    .viewDeactivateBtn{opacity:.7;}
    .colPopBtn{display:inline-flex;align-items:center;gap:4px;font-size:11px;padding:5px 8px;}
    .colPopBtn svg{flex-shrink:0;opacity:.5;}
    .colPopBtn:hover svg{opacity:.8;}
    .colPopAdd{display:inline-flex;gap:6px;}
    #columnsList{display:flex;flex-direction:column;gap:3px;}
    .colItem{display:flex;align-items:center;gap:8px;padding:7px 8px;border-radius:10px;border:1px solid transparent;background:rgba(255,255,255,.025);transition:background .15s,border-color .15s;cursor:pointer;}
    .colItem .grow{flex:1 1 auto;min-width:0;}
    .colItemActions{display:flex;align-items:center;gap:4px;flex-shrink:0;margin-left:auto;}
    .colItem:hover{border-color:rgba(255,255,255,.08);background:rgba(255,255,255,.05);}
    .colItem.dragOver{border-color:rgba(59,130,246,.6);box-shadow:0 -2px 0 0 rgba(59,130,246,.7);}
    .colItem.colHidden{opacity:.45;}
    .colItem.colHidden:hover{opacity:.7;}
    .colColorDot{width:10px;height:10px;border-radius:50%;flex-shrink:0;border:1px solid rgba(255,255,255,.15);}
    body.brightMode .colColorDot{border-color:rgba(0,0,0,.15);}
    .colEyeBtn{width:22px;height:22px;padding:0;border:none;background:transparent;color:var(--muted);cursor:pointer;display:inline-flex;align-items:center;justify-content:center;border-radius:6px;opacity:.5;transition:all .15s;flex-shrink:0;}
    .colEyeBtn:hover{opacity:1;background:rgba(255,255,255,.08);}
    body.brightMode .colEyeBtn:hover{background:rgba(0,0,0,.06);}
    .colEyeBtn.colEyeOff{opacity:.25;}
    .colEyeBtn.colEyeOff:hover{opacity:.6;}
    .colMoveBtn{width:24px;height:24px;padding:0;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.03);color:var(--muted);cursor:pointer;display:inline-flex;align-items:center;justify-content:center;border-radius:6px;opacity:.5;transition:all .12s;flex-shrink:0;}
    .colMoveBtn:hover{opacity:1;background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.14);}
    .colMoveBtn[disabled]{opacity:.15;pointer-events:none;}
    .colDelBtn{width:24px;height:24px;padding:0;border:1px solid rgba(255,120,120,.2);background:rgba(255,120,120,.04);color:rgba(255,120,120,.6);cursor:pointer;display:inline-flex;align-items:center;justify-content:center;border-radius:6px;transition:all .12s;flex-shrink:0;}
    .colDelBtn:hover{background:rgba(255,120,120,.15);border-color:rgba(255,120,120,.4);color:rgba(255,120,120,.9);}
    body.brightMode .colItem{background:rgba(0,0,0,.02);}
    body.brightMode .colItem:hover{background:rgba(0,0,0,.05);border-color:rgba(0,0,0,.08);}
    body.brightMode .colMoveBtn{border-color:rgba(0,0,0,.1);background:rgba(0,0,0,.02);}
    body.brightMode .colMoveBtn:hover{background:rgba(0,0,0,.07);border-color:rgba(0,0,0,.18);}
    body.brightMode .colDelBtn{border-color:rgba(220,38,38,.2);background:rgba(220,38,38,.03);color:rgba(220,38,38,.5);}
    body.brightMode .colDelBtn:hover{background:rgba(220,38,38,.1);border-color:rgba(220,38,38,.35);color:rgba(220,38,38,.8);}
    /* Catalog card action buttons (shared across tags, attributes, filters) */
    .catActions{display:flex;align-items:center;gap:4px;flex-shrink:0;margin-left:auto;}
    .catMoveBtn{width:24px;height:24px;padding:0;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.03);color:var(--muted);cursor:pointer;display:inline-flex;align-items:center;justify-content:center;border-radius:6px;opacity:.5;transition:all .12s;flex-shrink:0;}
    .catMoveBtn:hover{opacity:1;background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.14);}
    .catMoveBtn[disabled]{opacity:.15;pointer-events:none;}
    body.brightMode .catMoveBtn{border-color:rgba(0,0,0,.1);background:rgba(0,0,0,.02);}
    body.brightMode .catMoveBtn:hover{background:rgba(0,0,0,.07);border-color:rgba(0,0,0,.18);}
    .catValMoveBtn{width:20px;height:20px;padding:0;border:1px solid rgba(255,255,255,.06);background:rgba(255,255,255,.02);color:var(--muted);cursor:pointer;display:inline-flex;align-items:center;justify-content:center;border-radius:5px;opacity:.4;transition:all .12s;flex-shrink:0;}
    .catValMoveBtn:hover{opacity:1;background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.12);}
    .catValMoveBtn[disabled]{opacity:.1;pointer-events:none;}
    body.brightMode .catValMoveBtn{border-color:rgba(0,0,0,.08);background:rgba(0,0,0,.02);}
    body.brightMode .catValMoveBtn:hover{background:rgba(0,0,0,.06);border-color:rgba(0,0,0,.14);}
    body.brightMode .attrValRow{background:rgba(0,0,0,.02) !important;border-color:rgba(0,0,0,.1) !important;}
    .attrValRow:hover{border-color:rgba(255,255,255,.15) !important;}
    .attrValRow[draggable]:active{cursor:grabbing;}
    .attrValRow.valDragOver{border-color:rgba(59,130,246,.6) !important;box-shadow:0 0 0 1px rgba(59,130,246,.4) !important;background:rgba(59,130,246,.04) !important;}
    .valDragHandle:hover{opacity:.6 !important;}
    .catGrip{opacity:.2;line-height:0;flex-shrink:0;cursor:grab;align-self:center;}
    .catGrip:hover{opacity:.5 !important;}
    body.brightMode .attrValRow:hover{border-color:rgba(0,0,0,.18) !important;}
    body.brightMode .attrValRow.valDragOver{border-color:rgba(59,130,246,.6) !important;box-shadow:0 0 0 1px rgba(59,130,246,.4) !important;background:rgba(59,130,246,.04) !important;}
    .ruleActBtn{width:22px;height:22px;padding:0;border:1px solid rgba(255,255,255,.06);background:rgba(255,255,255,.02);color:var(--muted);cursor:pointer;display:inline-flex;align-items:center;justify-content:center;border-radius:5px;opacity:.45;transition:all .12s;flex-shrink:0;}
    .ruleActBtn:hover{opacity:1;background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.12);}
    .ruleActBtn.ruleDel{border-color:rgba(255,100,100,.25);color:#f87171;opacity:.5;}
    .ruleActBtn.ruleDel:hover{border-color:rgba(255,100,100,.5);background:rgba(255,80,80,.08);opacity:1;}
    body.brightMode .ruleActBtn{border-color:rgba(0,0,0,.08);background:rgba(0,0,0,.02);}
    body.brightMode .ruleActBtn:hover{background:rgba(0,0,0,.06);border-color:rgba(0,0,0,.14);}
    body.brightMode .ruleActBtn.ruleDel{border-color:rgba(220,38,38,.25);color:rgba(220,38,38,.7);}
    body.brightMode .ruleActBtn.ruleDel:hover{border-color:rgba(220,38,38,.45);background:rgba(220,38,38,.06);}

.modalMask{position:fixed; inset:0; background: rgba(0,0,0,.55); z-index: 200; display:none;}
.modalMask.active{display:block;}
.modalMask.elevated{z-index: 300;}
.modal{position:fixed; inset: 7vh 14px auto 14px; max-width: 980px; margin: 0 auto; z-index: 210;
  border:1px solid var(--border); border-radius: 16px; background: rgba(11,16,32,.96);
  box-shadow: 0 24px 80px rgba(0,0,0,.55); display:none; overflow:hidden;}
.modal.active{display:block;}
.modal.elevated{z-index: 310;}
.modalMask.elevated-2{z-index: 400;}
.modal.elevated-2{z-index: 410;}
.modalHeader{display:flex; justify-content:space-between; align-items:center; gap:10px; padding: 12px 14px;
  border-bottom:1px solid var(--border); background: rgba(255,255,255,.03);} 
.modalHeader .title{font-weight:900; font-size: 13px;}
.modalBody{padding: 12px 14px; max-height: 72vh; overflow:auto;}
.modalBody h4{font-size:13px; margin:0; color: rgba(232,238,252,.95);}
body.brightMode .modalBody h4{color:#111827;}



.modalBody code#createIdPreview{display:inline-block; padding:6px 8px; border-radius:10px; border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.12); color: rgba(232,238,252,.92); overflow-wrap:anywhere;}
/* --- Inline Editor Mode (2026-02) --- */
#editorOverlay{position:absolute; inset:0; z-index:30; pointer-events:none;}
/* Prevent editor overlay from affecting scrollable extents (avoids surprise scrollbars) */
#editorOverlay{overflow:hidden; contain: layout paint;}
/* Keep layout stable when scrollbars appear/disappear */
.columnsScroller{scrollbar-gutter: stable both-edges;}

body.editorMode #editorOverlay{pointer-events:none;}








/* Editor-mode: overlay row actions without changing row height */
body.editorMode .row{position:relative;}
body.editorMode .row .rowActions{position:absolute; right:8px; top:50%; transform:translateY(-50%);
  margin-left:0; opacity:0; pointer-events:none;}
body.editorMode .row:hover .rowActions{opacity:1; pointer-events:auto;}

/* Editor-mode: row action buttons must overlay (no layout shift, no premature ellipsis) */
body.editorMode .row{position:relative;}
body.editorMode .row .rowActions{
  position:absolute !important;
  right:6px; top:0; bottom:0;
  transform: translateY(1px);
  margin:0 !important; padding:0 !important;
  display:none !important; opacity:1 !important;
  gap:4px; align-items:center; justify-content:flex-end;
  pointer-events:none;
}
body.editorMode .row:hover .rowActions{display:flex !important; pointer-events:auto;}
body.editorMode .row.menuOpen .rowActions{display:flex !important; pointer-events:auto; opacity:1 !important;}
body.editorMode .active > .row .rowActions{display:flex !important; pointer-events:auto; opacity:1 !important;}

/* Row hover actions */
.row .rowActions{margin-left:8px; display:flex; gap:6px; align-items:center; opacity:0; transition: opacity .12s ease;}
body.editorMode .row:hover .rowActions{opacity:1;}
.miniBtn{border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.14); color: rgba(232,238,252,.92);
 width:18px; height:18px; border-radius:7px; cursor:pointer; font-weight:900; font-size:11px;
 line-height:18px; padding:0; text-align:center;
 display:flex; align-items:center; justify-content:center; flex:0 0 auto;}
body.editorMode .miniBtn{padding-top:1px;}
.miniBtn:hover{background: rgba(255,255,255,.08);}
.miniBtn.danger{border-color: rgba(255,154,168,.38); background: rgba(255,154,168,.10);}
.miniBtn.danger:hover{background: rgba(255,154,168,.18);}

/* Tag chips (replace field/group badges) */
.tagStrip{display:flex;gap:6px;align-items:center;flex:0 0 auto;}
.tagChip{font-family: var(--mono); font-size: 10px; padding:2px 6px; border-radius:999px; border:1px solid rgba(59,130,246,.55); background: rgba(59,130,246,.18); color: rgba(232,238,252,.95); line-height:1;}
.tagChip[data-color]{border-color: color-mix(in srgb, var(--c) 70%, rgba(255,255,255,.12)); background: color-mix(in srgb, var(--c) 22%, transparent);}
/* Inline action menu */
.miniMenu{position:absolute; right: 6px; top: 30px; z-index: 999; border:1px solid rgba(255,255,255,.14); border-radius: 12px; background: rgba(11,16,32,.95); box-shadow: 0 18px 50px rgba(0,0,0,.45); padding: 6px; display:none; gap:6px;}
.miniMenu.active{display:flex;}
.miniMenu .miniBtn{width:auto;padding:6px 8px;border-radius:10px;}

/* --- Context menu (vertical, viewport-anchored; avoids clipping in scroll containers) --- */
.ctxMenu{position:fixed; z-index: 2500; min-width: 180px; max-width: 260px;
  border:1px solid rgba(255,255,255,.1); border-radius: 10px;
  background: rgba(11,16,32,.97); backdrop-filter: blur(10px);
  box-shadow: 0 12px 40px rgba(0,0,0,.55);
  padding: 4px; display:flex; flex-direction: column; gap: 1px;
}
.ctxItem{display:flex; align-items:center; gap:8px; width:100%;
  border:1px solid transparent; background: transparent;
  color: rgba(232,238,252,.88);
  padding: 6px 10px; border-radius: 7px; cursor:pointer;
  font-size: 12px; text-align:left; transition: background .1s;
}
.ctxItem:hover{background: rgba(255,255,255,.08);}
.ctxItem:active{background: rgba(255,255,255,.12);}
.ctxItem:disabled{opacity:.3; cursor: not-allowed;}
.ctxItem:disabled:hover{background:transparent;}
.ctxItem .ico{width:16px; text-align:center; opacity:.7; flex: 0 0 auto; display:flex; align-items:center; justify-content:center;}
.ctxItem:hover .ico{opacity:1;}
.ctxItem .kbd{margin-left:auto; font-size:10px; font-family:var(--mono); opacity:.3; white-space:nowrap;}
.ctxItem.danger{color: rgba(255,154,168,.95);}
.ctxItem.danger:hover{background: rgba(255,154,168,.12);}
.ctxSep{height:1px; background: rgba(255,255,255,.07); margin: 3px 6px;}
.ctxLabel{font-size:9px; text-transform:uppercase; letter-spacing:.6px; color:rgba(255,255,255,.3); padding:6px 10px 2px; user-select:none;}
/* Hover menus */

/* Tag create swatches */
.swatch{width:22px;height:22px;border-radius:8px;border:1px solid rgba(255,255,255,.18);cursor:pointer;box-shadow:0 10px 24px rgba(0,0,0,.25);}
.swatch:hover{transform: translateY(-1px);}
.swatch.sel{outline:2px solid rgba(255,255,255,.60); outline-offset:2px;}



/* Drag & drop */
body.editorMode .node.field .row{cursor: grab;}
body.editorMode .node.field .row:active{cursor: grabbing;}
.row.dropTarget{outline: 2px solid rgba(59,130,246,.80); background: rgba(59,130,246,.12);}
.row.illegal{cursor:not-allowed !important;}

/* Make SVG clickable in editor mode */
#svgOverlay{pointer-events:none;}
body.editorMode #svgOverlay{pointer-events:none;}
body.editorMode .edge{

 stroke-linecap: round;
 stroke-linejoin: round;pointer-events:none;}
body.editorMode .edge.selected{stroke: rgba(255,208,92,.98); stroke-width: 3.0;}


/* Multi-value custom attribute checklist */
.multiValsActions{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;}
.multiValsActions .linkBtn{background:transparent;border:1px solid rgba(255,255,255,.12);color:rgba(232,238,252,.9);padding:5px 8px;border-radius:10px;cursor:pointer;font-size:11px;}
.multiValsActions .linkBtn:hover{background:rgba(255,255,255,.06);}

.multiVals{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px;}
.multiVals label{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border:1px solid rgba(255,255,255,.10);border-radius:10px;background:rgba(0,0,0,.10);cursor:pointer;font-size:12px;}
.multiVals input[type=checkbox]{accent-color:#3b82f6;}


/* v6_5+ line-break spacer to force mapped field label onto a new row */
.itemBreak{flex:0 0 100% !important;width:100% !important;height:0 !important;display:block !important;margin:0 !important;padding:0 !important;}

/* HIT-TEST OVERRIDES v7_3 */
#svgOverlay{pointer-events:none !important;}
#edgesLayer{pointer-events:none;}
.edge{pointer-events:stroke;}
body.editorMode .edge{pointer-events:stroke;}

.box.clickable{cursor:pointer;}
.box.clickable:hover{background: rgba(255,255,255,.06);}
body.brightMode .box.clickable:hover{background: rgba(0,0,0,.05);}

/* --- Drag ghost (visual-only) --- */
#dragGhost{
  position:fixed; z-index:3000; pointer-events:none; display:none;
  background:rgba(11,16,32,.96);
  border:1px solid rgba(255,255,255,.14);
  border-radius:10px; padding:6px 8px; color:#e8eefc;
  font:12px var(--sans); box-shadow:0 12px 32px rgba(0,0,0,.45);
  max-width:480px; opacity:.98;
}
#dragGhost .top {display:flex; align-items:center; gap:8px; margin-bottom:6px;}
#dragGhost .chip {
  font-family: var(--mono, ui-monospace, Consolas, monospace);
  font-size:10px; padding:2px 6px; border-radius:999px;
  border:1px solid rgba(255,255,255,.22); line-height:1;
  background:rgba(255,255,255,.06);
}
#dragGhost .chip.move { border-color:#3b82f6; background:rgba(59,130,246,.20); color:#fff; }
#dragGhost .chip.copy { border-color:#22c55e; background:rgba(34,197,94,.18); color:#fff; }
#dragGhost .chip.copyPlus { border-color:#84cc16; background:rgba(132,204,22,.20); color:#fff; }
#dragGhost .chip.map  { border-color:#f59e0b; background:rgba(245,158,11,.18); color:#fff; }
#dragGhost .chip.mapBidi { border-color:#a78bfa; background:rgba(167,139,250,.20); color:#e0d4ff; }
#dragGhost .chip.mapNone { border-color:#94a3b8; background:rgba(148,163,184,.18); color:#cbd5e1; }
#dragGhost .label { font-weight:900; letter-spacing:.2px; }
#dragGhost .body  { opacity:.92; }
#dragGhost .multiBadge {
  font-family: var(--mono, ui-monospace, Consolas, monospace);
  font-size:10px; font-weight:800; padding:2px 5px; border-radius:999px;
  background:rgba(255,255,255,.12); color:rgba(255,255,255,.85);
  line-height:1; display:none;
}


/* === Empty-column drop placeholder (v20.5) === */
body.editorMode .panel[data-empty="1"].dropOpen .emptyDrop { display: block; }
.emptyDrop { display: none;
  margin: 10px; border: 2px dashed rgba(59,130,246,.55); border-radius: 10px;
  padding: 12px 10px; color: rgba(232,238,252,.88); background: rgba(59,130,246,.08);
  font-size: 12px; text-align: center; user-select: none;
}
.emptyDrop.copy { border-color:#22c55e; background: rgba(34,197,94,.10); }
.emptyDrop.move { border-color:#3b82f6; background: rgba(59,130,246,.10); }


/* --- v23 header polish --- */
.brand .logo{filter:drop-shadow(0 2px 6px rgba(0,0,0,.25));}
.modeToggle.prominent{border-color: rgba(255,208,92,.55); background: rgba(255,208,92,.16);} 
.modeToggle.prominent:hover{background: rgba(255,208,92,.22);} 
.modeToggle.prominent input{accent-color:#f59e0b;}
#viewerControls{display:flex; flex-direction: column; gap:6px; margin-top:12px; padding-top:10px; border-top:1px solid var(--border);}

/* --- Toolbar Row 1: always-visible filter bar --- */
.tbRow1{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:6px 10px;border:1px solid var(--border);border-radius:12px;background:var(--panel);}
.tbRow1 .search{flex:0 1 260px;}
.tbFilterOpts{display:flex;gap:6px;align-items:center;flex-wrap:nowrap;padding:2px 8px;border-left:1px solid var(--border);margin-left:2px;}
.tbFilterOpts .toggle, .tbFilterOpts .btn{ font-size:11px; padding:5px 8px; }
.fbGroup{
  display:flex; align-items:center; gap:3px;
  padding:2px 3px; border-radius:9px;
  background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06);
}
.fbGroup .fbOpt{
  font-size:10px; padding:4px 8px; border-radius:7px; border:1px solid transparent;
  background:transparent; color:var(--muted); cursor:pointer; user-select:none;
  transition:all .12s; white-space:nowrap; font-weight:500; letter-spacing:.2px;
}
.fbGroup .fbOpt:hover{ color:var(--text); background:rgba(255,255,255,.06); }
.fbGroup .fbOpt.active{
  background:rgba(59,130,246,.15); border-color:rgba(59,130,246,.4);
  color:var(--text); font-weight:600;
}
.fbGroup .fbOpt.active.fbWarn{
  background:rgba(251,146,60,.12); border-color:rgba(251,146,60,.35);
}
.fbGroup .fbOpt.active.fbHide{
  background:rgba(239,68,68,.10); border-color:rgba(239,68,68,.30);
  color:rgba(255,180,180,.9);
}
.fbSep{ width:1px; align-self:stretch; background:var(--border); margin:0 2px; flex-shrink:0; }
.fbToggle{
  font-size:10.5px; padding:4px 9px; border-radius:8px; border:1px solid var(--border);
  background:rgba(255,255,255,.03); color:var(--muted); cursor:pointer; user-select:none;
  transition:all .12s; white-space:nowrap; display:inline-flex; align-items:center; gap:5px;
}
.fbToggle:hover{ background:rgba(255,255,255,.06); color:var(--text); }
.fbToggle.active{ background:rgba(59,130,246,.12); border-color:rgba(59,130,246,.35); color:var(--text); }
.fbToggle input{ display:none; }
.fbToggle .fbDot{
  width:6px; height:6px; border-radius:50%; background:var(--muted); transition:background .12s;
}
.fbToggle.active .fbDot{ background:rgba(59,130,246,.9); }
.fbClear{
  font-size:10px; padding:4px 10px; border-radius:7px; border:1px solid rgba(255,255,255,.08);
  background:rgba(255,255,255,.03); color:var(--muted); cursor:pointer; user-select:none;
  transition:all .12s; white-space:nowrap; font-weight:500; letter-spacing:.2px;
}
.fbClear:hover{ background:rgba(239,68,68,.10); border-color:rgba(239,68,68,.25); color:rgba(255,180,180,.9); }
body.brightMode .fbGroup{ background:rgba(0,0,0,.02); border-color:rgba(0,0,0,.06); }
body.brightMode .fbGroup .fbOpt:hover{ background:rgba(0,0,0,.04); color:#1e293b; }
body.brightMode .fbGroup .fbOpt.active{ background:rgba(59,130,246,.08); border-color:rgba(59,130,246,.3); color:#1e293b; }
body.brightMode .fbGroup .fbOpt.active.fbHide{ background:rgba(239,68,68,.08); border-color:rgba(239,68,68,.25); color:#b91c1c; }
body.brightMode .fbGroup .fbOpt.active.fbWarn{ background:rgba(251,146,60,.08); border-color:rgba(251,146,60,.25); color:#9a3412; }
body.brightMode .fbToggle{ background:rgba(0,0,0,.02); border-color:rgba(0,0,0,.08); color:#64748b; }
body.brightMode .fbToggle:hover{ background:rgba(0,0,0,.04); color:#1e293b; }
body.brightMode .fbToggle.active{ background:rgba(59,130,246,.06); border-color:rgba(59,130,246,.25); color:#1e293b; }
body.brightMode .fbToggle.active .fbDot{ background:rgba(37,99,235,.8); }
body.brightMode .fbClear{ background:rgba(0,0,0,.02); border-color:rgba(0,0,0,.06); color:#64748b; }
body.brightMode .fbClear:hover{ background:rgba(239,68,68,.06); border-color:rgba(239,68,68,.2); color:#b91c1c; }
.filterChip:hover{filter:brightness(1.3);box-shadow:0 0 0 1px rgba(255,255,255,.15);}

/* --- Toolbar Row 2: icon toolbar --- */
.tbRow2{display:flex;gap:4px;align-items:center;flex-wrap:wrap;}
.tbBtn{position:relative;display:inline-flex;align-items:center;gap:5px;padding:5px 10px;border-radius:8px;background:transparent;color:var(--muted);font-size:11px;font-weight:700;letter-spacing:.3px;border:1px solid transparent;cursor:pointer;transition:all .15s;white-space:nowrap;}
.tbBtn:hover{background:rgba(255,255,255,.06);border-color:var(--border);color:var(--text);}
.tbBtn.active{background:rgba(59,130,246,.12);border-color:rgba(59,130,246,.35);color:var(--text);}
.tbBtn .tbIcon{font-size:13px;line-height:1;opacity:.7;}
.tbBtn:hover .tbIcon{opacity:1;}
.tbSep{width:1px;height:20px;background:var(--border);margin:0 4px;flex-shrink:0;}

/* --- Toolbar popovers --- */
.tbPop{display:none;position:absolute;top:calc(100% + 6px);left:0;min-width:200px;padding:10px 14px;border-radius:12px;border:1px solid var(--border);background:rgba(16,20,34,.97);box-shadow:0 8px 32px rgba(0,0,0,.5);z-index:200;flex-direction:column;gap:8px;}
.tbPop.open{display:flex;}
.tbPop .tbPopTitle{font-size:10px;font-weight:900;letter-spacing:.5px;text-transform:uppercase;color:var(--muted);margin-bottom:2px;}
.tbPop .tbPopRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.selMenuActions{ display:flex; flex-direction:column; gap:4px; }
.selActionBtn{ display:flex; align-items:center; gap:7px; font-size:12px; }
.selActionBtn svg{ flex-shrink:0; opacity:.6; }


/* Brand */
.brand h1{display:block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:45vw; margin:0;}


/* v23.2.3b: ensure quick toolbar is visible and spaced */
#toolbarQuick{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 2px 0}
#toolbarQuick .btn{font-weight:700}

/* Range slider in toolbar */
.sliderGroup{display:flex;align-items:center;gap:8px;font-size:11px;color:var(--muted);white-space:nowrap;}
.sliderGroup input[type=range]{width:90px;accent-color:#3b82f6;cursor:pointer;}
.sliderGroup .sliderVal{font-family:var(--mono);font-size:10px;min-width:32px;text-align:right;color:var(--text);}


/* --- Cancel and Bin drop zones (v24.2) --- */
.dragDropZone {
  position: fixed;
  bottom: 20px;
  z-index: 9999;
  padding: 16px 24px;
  border-radius: 12px;
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.3px;
  user-select: none;
  pointer-events: auto;
  transition: all 0.2s ease;
  opacity: 0;
  transform: translateY(10px) scale(0.95);
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
}

.dragDropZone.visible {
  opacity: 1;
  transform: translateY(0) scale(1);
}

.dragDropZone.dragover {
  transform: translateY(0) scale(1.05);
  box-shadow: 0 12px 32px rgba(0,0,0,.5);
}

#cancelZone {
  left: 20px;
  background: linear-gradient(135deg, rgba(148, 163, 184, 0.32), rgba(100, 116, 139, 0.26));
  border: 2px solid rgba(148, 163, 184, 0.7);
  color: rgba(226, 232, 240, 0.95);
  backdrop-filter: blur(12px);
}

#cancelZone.dragover {
  background: linear-gradient(135deg, rgba(148, 163, 184, 0.45), rgba(100, 116, 139, 0.38));
  border-color: rgba(148, 163, 184, 0.90);
}

#binZone {
  right: 20px;
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.35), rgba(220, 38, 38, 0.28));
  border: 2px solid rgba(239, 68, 68, 0.75);
  color: rgba(254, 226, 226, 0.95);
  backdrop-filter: blur(12px);
}

#binZone.dragover {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.48), rgba(220, 38, 38, 0.40));
  border-color: rgba(239, 68, 68, 0.95);
}

/*  Command Palette  */
.cmdPaletteMask{ position:fixed;inset:0;background:rgba(0,0,0,.45);z-index:9999;display:none;align-items:flex-start;justify-content:center;padding-top:min(20vh,140px); }
.cmdPaletteMask.active{ display:flex; }
.cmdPalette{ background:rgba(11,16,32,.97);border:1px solid var(--border);border-radius:14px;width:min(520px,92vw);max-height:min(440px,60vh);display:flex;flex-direction:column;box-shadow:0 16px 64px rgba(0,0,0,.5),0 0 0 1px rgba(255,255,255,.05);overflow:hidden; }
body.brightMode .cmdPalette{ background:#fff;border-color:rgba(0,0,0,.15);box-shadow:0 16px 64px rgba(0,0,0,.18); }
.cmdPaletteInput{ background:transparent;border:none;border-bottom:1px solid var(--border);color:var(--text);font-size:14px;padding:14px 16px;outline:none;width:100%;font-family:inherit; }
.cmdPaletteInput::placeholder{ color:var(--muted);opacity:.5; }
.cmdPaletteResults{ overflow-y:auto;padding:6px;flex:1;min-height:0; }
.cmdPaletteResults:empty::after{ content:'No results';display:block;text-align:center;padding:20px;opacity:.35;font-size:13px; }
.cmdCat{ font-size:10px;text-transform:uppercase;letter-spacing:.08em;opacity:.4;padding:8px 10px 4px;font-weight:600; }
.cmdItem{ display:flex;align-items:center;gap:10px;padding:8px 12px;border-radius:8px;cursor:pointer;font-size:13px;transition:background .1s; }
.cmdItem:hover,.cmdItem.active{ background:rgba(59,130,246,.15); }
body.brightMode .cmdItem:hover, body.brightMode .cmdItem.active{ background:rgba(59,130,246,.1); }
.cmdItem .cmdIcon{ width:20px;text-align:center;font-size:14px;flex-shrink:0;opacity:.7; }
.cmdItem .cmdLabel{ flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap; }
.cmdItem .cmdLabel mark{ background:rgba(59,130,246,.35);color:inherit;border-radius:2px;padding:0 1px; }
body.brightMode .cmdItem .cmdLabel mark{ background:rgba(59,130,246,.2); }
.cmdItem .cmdHint{ font-size:10px;opacity:.4;flex-shrink:0;white-space:nowrap; }
.cmdItem .cmdKbd{ font-size:10px;opacity:.45;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.1);border-radius:4px;padding:1px 5px;font-family:var(--mono);flex-shrink:0; }
body.brightMode .cmdItem .cmdKbd{ background:rgba(0,0,0,.06);border-color:rgba(0,0,0,.12); }
.cmdPaletteFooter{ border-top:1px solid var(--border);padding:6px 14px;display:flex;gap:12px;font-size:10px;opacity:.4;align-items:center; }
.cmdPaletteFooter kbd{ font-family:var(--mono);background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.08);border-radius:3px;padding:0 4px;font-size:9px; }
body.brightMode .cmdPaletteFooter kbd{ background:rgba(0,0,0,.06);border-color:rgba(0,0,0,.1); }

/* Suppress all hover effects during marquee/lasso selection */
.lassoActive * { pointer-events: none !important; }


</style>
</head>
<body>
<header>
<div class="top">
<div class="brand">
<h1>Dunnode</h1>
</div>
<div class="topCenter">
<input id="projectTitle" type="text" placeholder="New Project" title="Project title (click to edit)"/>
<button class="btn" id="projectInfoBtn" title="Project properties" style="padding:4px 8px;font-size:13px;min-width:0;line-height:1;"></button>
</div>
<div class="topRight">
<button class="btn topBtn" id="newMappingBtn" title="Start a new blank project (Alt+N)"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 1H4a1.5 1.5 0 0 0-1.5 1.5v9A1.5 1.5 0 0 0 4 13h6a1.5 1.5 0 0 0 1.5-1.5V4.5Z"/><polyline points="8,1 8,4.5 11.5,4.5"/></svg>New</button>
<button class="btn topBtn" id="openProjectBtn" title="Upload and open a project JSON file (Alt+O)"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M1.5 11V3.5A1.5 1.5 0 0 1 3 2h2.5L7 3.5h4A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 11Z"/></svg>Open</button>
<button class="btn topBtn" id="saveProjectBtn" title="Download the current project as JSON (Alt+S)"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 9.5v2a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1v-2"/><polyline points="4.5,6 7,8.5 9.5,6"/><line x1="7" y1="1.5" x2="7" y2="8.5"/></svg>Save</button>
<button class="btn topBtn editorToggle" id="editorModeBtn" title="Toggle inline editing controls in the viewer (Alt+E)">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M8.5 2.5l3 3-7 7H1.5V9.5z"/><line x1="7" y1="4" x2="10" y2="7" opacity=".3"/></svg>
<span>Editor mode</span>
</button>
<input id="editorModeToggle" type="checkbox" style="display:none;"/>
<button class="btn topIconBtn" id="brightModeBtn" title="Toggle bright/dark mode"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"><circle cx="7" cy="7" r="2.5"/><line x1="7" y1="1" x2="7" y2="2.5"/><line x1="7" y1="11.5" x2="7" y2="13"/><line x1="1" y1="7" x2="2.5" y2="7"/><line x1="11.5" y1="7" x2="13" y2="7"/><line x1="2.76" y1="2.76" x2="3.82" y2="3.82"/><line x1="10.18" y1="10.18" x2="11.24" y2="11.24"/><line x1="2.76" y1="11.24" x2="3.82" y2="10.18"/><line x1="10.18" y1="3.82" x2="11.24" y2="2.76"/></svg></button>
<button class="btn topIconBtn" id="cmdPaletteBtn" title="Command palette (Ctrl+K)"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="6" height="6" rx=".5"/><circle cx="3" cy="3" r="2"/><circle cx="11" cy="3" r="2"/><circle cx="3" cy="11" r="2"/><circle cx="11" cy="11" r="2"/></svg></button>
</div>
</div>
<!-- Viewer controls: two-row toolbar -->
<div id="viewerControls">

<!-- Row 1: Icon toolbar with popovers -->
<div class="tbRow2">

<!-- Filter bar toggle -->
<div class="tbBtn" id="tbFilterToggle" title="Show/hide filter bar">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;"><circle cx="5.5" cy="5.5" r="4" fill="none" stroke="currentColor" stroke-width="1.4"/><line x1="8.5" y1="8.5" x2="12.5" y2="12.5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/></svg></span>Filter<span id="filterBadge" style="display:none;background:#3b82f6;color:#fff;font-size:9px;padding:1px 5px;border-radius:8px;font-weight:700;"></span>
</div>

<div class="tbSep"></div>

<!-- Graph -->
<div class="tbBtn" id="tbGraph" title="Mapping & graph display options">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"><circle cx="3" cy="3" r="2"/><circle cx="11" cy="3" r="2"/><circle cx="7" cy="11" r="2"/><line x1="4.5" y1="4.5" x2="6" y2="9.5"/><line x1="9.5" y1="4.5" x2="8" y2="9.5"/></svg></span>Graph
<div class="tbPop" id="tbPopGraph" style="min-width:260px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Show mappings</div>
<div class="dockSelector" id="arrowModeSelector">
<button class="dockOpt active" data-amode="selected" title="Only mappings for selected/hovered nodes">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="currentColor" stroke-width="1.5"/><polygon points="10,2.5 14,5 10,7.5" fill="currentColor"/><circle cx="2" cy="5" r="1.5" fill="currentColor" opacity=".5"/></svg>
<span>Selected</span>
</button>
<button class="dockOpt" data-amode="all" title="Show all mappings at once">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="3" x2="11" y2="3" stroke="currentColor" stroke-width="1.2"/><polygon points="10,.5 14,3 10,5.5" fill="currentColor"/><line x1="1" y1="7" x2="11" y2="7" stroke="currentColor" stroke-width="1.2" opacity=".5"/><polygon points="10,4.5 14,7 10,9.5" fill="currentColor" opacity=".5"/></svg>
<span>All</span>
</button>
<button class="dockOpt" data-amode="off" title="Hide all mappings">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="currentColor" stroke-width="1.5" opacity=".2"/><polygon points="10,2.5 14,5 10,7.5" fill="currentColor" opacity=".2"/><line x1="2" y1="2" x2="13" y2="8" stroke="currentColor" stroke-width="1.5" opacity=".6"/></svg>
<span>Off</span>
</button>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0 4px;"></div>
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Mapping scope</div>
<div style="display:flex;gap:6px;flex-wrap:wrap;">
<label class="toggle" style="flex:1;" title="Show mappings within the same column"><input id="showSameColToggle" type="checkbox" checked/>Same-column</label>
<label class="toggle" style="flex:1;" title="Show mappings across non-adjacent columns"><input id="showDistantToggle" type="checkbox" checked/>Distant</label>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0 4px;"></div>
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Mapping labels</div>
<div id="edgeLabelModeSelector" class="dockSelector">
<button class="dockOpt active" data-elm="always" title="Always show mapping labels">
<svg width="20" height="10" viewBox="0 0 20 10"><line x1="0" y1="5" x2="18" y2="5" stroke="currentColor" stroke-width="1.2" opacity=".3"/><polygon points="16,2.5 20,5 16,7.5" fill="currentColor" opacity=".3"/><text x="10" y="7.5" text-anchor="middle" font-size="7" font-weight="bold" font-family="sans-serif" fill="currentColor">Ab</text></svg>
<span>Always</span>
</button>
<button class="dockOpt" data-elm="highlight" title="Show mapping labels only when highlighted">
<svg width="20" height="10" viewBox="0 0 20 10"><line x1="0" y1="5" x2="18" y2="5" stroke="currentColor" stroke-width="1.2" opacity=".3"/><polygon points="16,2.5 20,5 16,7.5" fill="currentColor" opacity=".3"/><text x="10" y="7.5" text-anchor="middle" font-size="7" font-family="sans-serif" fill="currentColor" opacity=".25">Ab</text><circle cx="3" cy="5" r="2.2" fill="currentColor" opacity=".5"/><text x="10" y="7.5" text-anchor="middle" font-size="7" font-weight="bold" font-family="sans-serif" fill="currentColor" opacity=".85" stroke="rgba(59,130,246,.6)" stroke-width=".5">Ab</text></svg>
<span>Highlight</span>
</button>
<button class="dockOpt" data-elm="off" title="Hide mapping labels">
<svg width="20" height="10" viewBox="0 0 20 10"><line x1="0" y1="5" x2="18" y2="5" stroke="currentColor" stroke-width="1.2" opacity=".3"/><polygon points="16,2.5 20,5 16,7.5" fill="currentColor" opacity=".3"/><text x="10" y="7.5" text-anchor="middle" font-size="7" font-family="sans-serif" fill="currentColor" opacity=".15">Ab</text><line x1="4" y1="1" x2="16" y2="9" stroke="currentColor" stroke-width="1.3" opacity=".5"/></svg>
<span>Off</span>
</button>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0 4px;"></div>
<div style="font-size:10px;opacity:.5;margin-bottom:4px;">Color mappings by</div>
<div class="dockSelector" id="edgeColorSelector">
<button class="dockOpt active" data-scheme="" title="No auto-coloring (manual / filter only)">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="13" y2="5" stroke="currentColor" stroke-width="1.5" opacity=".4"/><polygon points="12,2 16,5 12,8" fill="currentColor" opacity=".4"/></svg>
<span>Off</span>
</button>
<button class="dockOpt" data-scheme="cardinality" title="Color by cardinality (1:1, 1:N, N:1, N:M)">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="13" y2="5" stroke="#f59e0b" stroke-width="1.5"/><polygon points="12,2 16,5 12,8" fill="#f59e0b"/></svg>
<span>Card.</span>
</button>
<button class="dockOpt" data-scheme="transform" title="Color by first transform">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="13" y2="5" stroke="#8b5cf6" stroke-width="1.5"/><polygon points="12,2 16,5 12,8" fill="#8b5cf6"/></svg>
<span>Xform</span>
</button>
<button class="dockOpt" data-scheme="srcTag" title="Color by source tag (highest priority)">
<svg width="16" height="10" viewBox="0 0 16 10"><circle cx="2.5" cy="5" r="2.5" fill="#22c55e"/><line x1="5" y1="5" x2="13" y2="5" stroke="#22c55e" stroke-width="1.5"/><polygon points="12,2 16,5 12,8" fill="#22c55e"/></svg>
<span>Src </span>
</button>
<button class="dockOpt" data-scheme="tgtTag" title="Color by target tag (highest priority)">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="#06b6d4" stroke-width="1.5"/><polygon points="10,2 14,5 10,8" fill="#06b6d4"/><circle cx="2.5" cy="5" r="2.5" fill="none" stroke="#06b6d4" stroke-width="1"/></svg>
<span>Tgt </span>
</button>
</div>
<div id="edgeColorLegend" style="display:none;margin-top:6px;font-size:10px;"></div>
</div>
</div>
</div>

<!-- Layout -->
<div class="tbBtn" id="tbLayout" title="Column layout & details panel position">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;" fill="none" stroke="currentColor" stroke-width="1.2"><rect x="1" y="1" width="5" height="12" rx="1.5"/><rect x="8" y="1" width="5" height="12" rx="1.5"/><line x1="1" y1="4" x2="6" y2="4" opacity=".4"/><line x1="8" y1="4" x2="13" y2="4" opacity=".4"/></svg></span>Layout
<div class="tbPop" id="tbPopLayout" style="min-width:260px;">
<div class="layoutSection">
<div class="layoutSectionTitle">Columns</div>
<div class="layoutSliderRow">
<span class="layoutSliderLabel">Width</span>
<input id="colWidthSlider" type="range" min="200" max="600" step="10" value="300"/>
<span class="layoutSliderVal" id="colWidthVal">300</span>
<span class="layoutReset" id="colWidthReset" title="Reset to default (300)"></span>
</div>
<div class="layoutSliderRow">
<span class="layoutSliderLabel">Gap</span>
<input id="colGapSlider" type="range" min="0" max="60" step="2" value="20"/>
<span class="layoutSliderVal" id="colGapVal">20</span>
<span class="layoutReset" id="colGapReset" title="Reset to default (20)"></span>
</div>
<div class="layoutSliderRow">
<span class="layoutSliderLabel">Zoom</span>
<input id="colZoomSlider" type="range" min="50" max="150" step="5" value="100"/>
<span class="layoutSliderVal" id="colZoomVal">100%</span>
<span class="layoutReset" id="colZoomReset" title="Reset to default (100%)"></span>
</div>
<div class="selMenuActions" style="margin:8px 0 0;padding:8px 0 0;border-top:1px solid var(--border);">
<button class="btn selActionBtn" id="wrapToggleBtn" title="Toggle wrap columns into rows" style="justify-content:flex-start;">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="1" width="4" height="5" rx="1"/><rect x="9" y="1" width="4" height="5" rx="1"/><rect x="1" y="8" width="4" height="5" rx="1"/><rect x="9" y="8" width="4" height="5" rx="1"/></svg>
<span>Wrap columns</span>
<span id="wrapIndicator" style="margin-left:auto;font-size:10px;opacity:.4;">OFF</span>
</button>
</div>
<input id="wrapToggle" type="checkbox" style="display:none;"/>
</div>
<div class="layoutSection">
<div class="layoutSectionTitle">Node labels</div>
<div style="font-size:10px;opacity:.5;margin-bottom:4px;">Tag pills</div>
<div class="dockSelector" id="tagPillsModeSelector">
<button class="dockOpt active" data-tpm="left" title="Tags left of label">
<svg width="16" height="12" viewBox="0 0 16 12"><rect x=".5" y=".5" width="15" height="11" rx="2" fill="none" stroke="currentColor" stroke-width=".8"/><rect x="2" y="4" width="3" height="4" rx="1" fill="currentColor" opacity=".7"/><line x1="7" y1="6" x2="13" y2="6" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity=".4"/></svg>
<span>Left</span>
</button>
<button class="dockOpt" data-tpm="right" title="Tags right of label">
<svg width="16" height="12" viewBox="0 0 16 12"><rect x=".5" y=".5" width="15" height="11" rx="2" fill="none" stroke="currentColor" stroke-width=".8"/><line x1="2" y1="6" x2="8" y2="6" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity=".4"/><rect x="10" y="4" width="3" height="4" rx="1" fill="currentColor" opacity=".7"/></svg>
<span>Right</span>
</button>
<button class="dockOpt" data-tpm="off" title="Hide tag pills">
<svg width="16" height="12" viewBox="0 0 16 12"><rect x=".5" y=".5" width="15" height="11" rx="2" fill="none" stroke="currentColor" stroke-width=".8"/><line x1="4" y1="4" x2="12" y2="8" stroke="currentColor" stroke-width="1" opacity=".4"/><line x1="12" y1="4" x2="4" y2="8" stroke="currentColor" stroke-width="1" opacity=".4"/></svg>
<span>Off</span>
</button>
</div>
<div style="font-size:10px;opacity:.5;margin-bottom:4px;margin-top:6px;">Attribute pills</div>
<div class="dockSelector" id="attrPillsModeSelector">
<button class="dockOpt active" data-apm="left" title="Attributes left of label">
<svg width="16" height="12" viewBox="0 0 16 12"><rect x=".5" y=".5" width="15" height="11" rx="2" fill="none" stroke="currentColor" stroke-width=".8"/><rect x="2" y="4" width="3" height="4" rx="1" fill="currentColor" opacity=".7"/><line x1="7" y1="6" x2="13" y2="6" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity=".4"/></svg>
<span>Left</span>
</button>
<button class="dockOpt" data-apm="right" title="Attributes right of label">
<svg width="16" height="12" viewBox="0 0 16 12"><rect x=".5" y=".5" width="15" height="11" rx="2" fill="none" stroke="currentColor" stroke-width=".8"/><line x1="2" y1="6" x2="8" y2="6" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity=".4"/><rect x="10" y="4" width="3" height="4" rx="1" fill="currentColor" opacity=".7"/></svg>
<span>Right</span>
</button>
<button class="dockOpt" data-apm="off" title="Hide attribute pills">
<svg width="16" height="12" viewBox="0 0 16 12"><rect x=".5" y=".5" width="15" height="11" rx="2" fill="none" stroke="currentColor" stroke-width=".8"/><line x1="4" y1="4" x2="12" y2="8" stroke="currentColor" stroke-width="1" opacity=".4"/><line x1="12" y1="4" x2="4" y2="8" stroke="currentColor" stroke-width="1" opacity=".4"/></svg>
<span>Off</span>
</button>
</div>
</div>
<div class="layoutSection">
<div class="layoutSectionTitle">Node colors</div>
<div style="font-size:10px;opacity:.5;margin-bottom:4px;">Background tint inheritance</div>
<div class="dockSelector" id="nodeColorModeSelector">
<button class="dockOpt active" data-ncm="all" title="All levels: node  group  column">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="14" height="3" rx="1" fill="currentColor" opacity=".25"/><rect x="2" y="5" width="12" height="3" rx="1" fill="currentColor" opacity=".45"/><rect x="3" y="9" width="10" height="3.5" rx="1" fill="currentColor" opacity=".75"/></svg>
<span>All</span>
</button>
<button class="dockOpt" data-ncm="groups" title="Column + group colors only (no field override)">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="14" height="3" rx="1" fill="currentColor" opacity=".25"/><rect x="2" y="5" width="12" height="3" rx="1" fill="currentColor" opacity=".45"/><rect x="3" y="9" width="10" height="3.5" rx="1" fill="none" stroke="currentColor" stroke-width=".5" stroke-dasharray="1.5 1" opacity=".3"/></svg>
<span>Groups</span>
</button>
<button class="dockOpt" data-ncm="column" title="Column color only (no group/field override)">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="14" height="3" rx="1" fill="currentColor" opacity=".25"/><rect x="2" y="5" width="12" height="3" rx="1" fill="none" stroke="currentColor" stroke-width=".5" stroke-dasharray="1.5 1" opacity=".3"/><rect x="3" y="9" width="10" height="3.5" rx="1" fill="none" stroke="currentColor" stroke-width=".5" stroke-dasharray="1.5 1" opacity=".3"/></svg>
<span>Column</span>
</button>
<button class="dockOpt" data-ncm="off" title="No background tinting">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><line x1="3" y1="3" x2="13" y2="11" stroke="currentColor" stroke-width="1.5" opacity=".4"/><line x1="13" y1="3" x2="3" y2="11" stroke="currentColor" stroke-width="1.5" opacity=".4"/></svg>
<span>Off</span>
</button>
</div>
</div>
<div class="layoutSection">
<div class="layoutSectionTitle">Details panel</div>
<div class="dockSelector" id="panelModeSelector">
<button class="dockOpt" data-mode="left" title="Dock details to left side">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="5" height="12" rx="1" fill="currentColor" opacity=".45"/></svg>
<span>Left</span>
</button>
<button class="dockOpt" data-mode="bottom" title="Dock details to bottom">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="9" width="14" height="4" rx="1" fill="currentColor" opacity=".45"/></svg>
<span>Bottom</span>
</button>
<button class="dockOpt" data-mode="right" title="Dock details to right side">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="10" y="1" width="5" height="12" rx="1" fill="currentColor" opacity=".45"/></svg>
<span>Right</span>
</button>
<button class="dockOpt" data-mode="float" title="Floating panel  drag to reposition">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1" stroke-dasharray="2,2"/><rect x="6" y="4" width="8" height="7" rx="1.5" fill="currentColor" opacity=".45" stroke="currentColor" stroke-width=".5"/></svg>
<span>Float</span>
</button>
<button class="dockOpt" data-mode="hidden" title="Hide details panel">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><line x1="4" y1="3" x2="12" y2="11" stroke="currentColor" stroke-width="1" opacity=".4"/><line x1="12" y1="3" x2="4" y2="11" stroke="currentColor" stroke-width="1" opacity=".4"/></svg>
<span>Hidden</span>
</button>
</div>
<div class="layoutHint">Press <kbd>D</kbd> to toggle details  <kbd>P</kbd> to pan viewer<br/>Drag float panel to edge to dock</div>
</div>
</div>
</div>

<div class="tbSep"></div>

<!-- Selection -->
<div class="tbBtn" id="tbSelection" title="Expand, collapse & clear selection">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;" fill="none" stroke="currentColor" stroke-width="1.2"><circle cx="7" cy="7" r="5.5"/><circle cx="7" cy="7" r="2" fill="currentColor" opacity=".5"/></svg></span>Selection
<div class="tbPop" id="tbPopSelection" style="min-width:210px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Dim unselected</div>
<div class="dockSelector" id="dimModeSelector">
<button class="dockOpt active" data-dim="all" title="Dim all unselected nodes">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="2" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="9" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".2"/><rect x="2" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".2"/><rect x="9" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".2"/></svg>
<span>All</span>
</button>
<button class="dockOpt" data-dim="keepParents" title="Dim unselected but keep parent groups visible">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="2" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="9" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".5"/><rect x="2" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".2"/><rect x="9" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".5"/></svg>
<span>Parents</span>
</button>
<button class="dockOpt" data-dim="off" title="No dimming  all nodes stay at full opacity">
<svg width="16" height="14" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="2" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="9" y="2" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="2" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/><rect x="9" y="8" width="5" height="4" rx="1" fill="currentColor" opacity=".9"/></svg>
<span>Off</span>
</button>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0;"></div>
<div style="font-size:10px;opacity:.5;margin-bottom:2px;">Highlight mode</div>
<div class="dockSelector" id="multiArrowModeSelector">
<button class="dockOpt active" data-mode="chain" title="Highlight the full mapping chain across all columns">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="6" y2="5" stroke="currentColor" stroke-width="1.5"/><line x1="6" y1="5" x2="11" y2="5" stroke="currentColor" stroke-width="1.5" stroke-dasharray="1 1.5"/><polygon points="10,2.5 14,5 10,7.5" fill="currentColor"/></svg>
<span>Chain</span>
</button>
<button class="dockOpt" data-mode="direct" title="Highlight only direct (adjacent) mappings">
<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="currentColor" stroke-width="1.5"/><polygon points="10,2.5 14,5 10,7.5" fill="currentColor"/></svg>
<span>Direct</span>
</button>
<button class="dockOpt" data-mode="selected" title="Highlight only the selected node(s), no connected fields">
<svg width="16" height="10" viewBox="0 0 16 10"><circle cx="4" cy="5" r="3" fill="currentColor"/><line x1="8" y1="5" x2="14" y2="5" stroke="currentColor" stroke-width="1" opacity=".25"/></svg>
<span>Selected</span>
</button>
</div>
<div style="border-top:1px solid var(--border);margin:6px 0;"></div>
<div class="selMenuActions">
<button class="btn selActionBtn" id="selectAllBtn" title="Select all visible nodes (Ctrl+A)">
<svg width="14" height="14" viewBox="0 0 14 14"><rect x="1" y="1" width="5" height="5" rx="1" fill="currentColor"/><rect x="8" y="1" width="5" height="5" rx="1" fill="currentColor"/><rect x="1" y="8" width="5" height="5" rx="1" fill="currentColor"/><rect x="8" y="8" width="5" height="5" rx="1" fill="currentColor"/></svg>
Select all
</button>
<button class="btn selActionBtn" id="invertSelectionBtn" title="Invert current selection (Ctrl+Shift+I)">
<svg width="14" height="14" viewBox="0 0 14 14"><rect x="1" y="1" width="5" height="5" rx="1" fill="currentColor"/><rect x="8" y="1" width="5" height="5" rx="1" fill="none" stroke="currentColor" stroke-width="1.2"/><rect x="1" y="8" width="5" height="5" rx="1" fill="none" stroke="currentColor" stroke-width="1.2"/><rect x="8" y="8" width="5" height="5" rx="1" fill="currentColor"/></svg>
Invert selection
</button>
<button class="btn selActionBtn" id="clearSelectionBtn" title="Clear selection (Esc)">
<svg width="14" height="14" viewBox="0 0 14 14"><rect x="1" y="1" width="12" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="1.2"/><line x1="4" y1="4" x2="10" y2="10" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/><line x1="10" y1="4" x2="4" y2="10" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>
Clear selection
</button>
</div>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="hlColorsBtn" title="Customize highlight colors">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 1A6 6 0 0 0 7 13c1 0 1.5-.5 1.5-1.2 0-.4-.2-.7-.4-1-.2-.3-.4-.6-.4-1 0-.8.7-1.3 1.5-1.3H11a3 3 0 0 0 3-3C14 3 10.9 1 7 1Z"/><circle cx="5" cy="4.5" r="1" fill="currentColor" opacity=".7"/><circle cx="8" cy="3.5" r="1" fill="currentColor" opacity=".5"/><circle cx="3.5" cy="7" r="1" fill="currentColor" opacity=".6"/></svg>
Highlight colors
</button>
</div>
</div>
</div>

<!-- Catalogs -->
<div class="tbBtn" id="tbCatalogs" title="Tags, transforms, attributes & filters">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><rect x="2" y="1" width="10" height="12" rx="1.5"/><line x1="2" y1="4" x2="12" y2="4" opacity=".5"/><line x1="2" y1="7" x2="12" y2="7" opacity=".3"/><line x1="2" y1="10" x2="12" y2="10" opacity=".3"/></svg></span>Catalogs
<div class="tbPop" id="tbPopCatalogs" style="min-width:180px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<button class="btn selActionBtn" id="tagsBtn" title="Manage tags">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M1.5 8.2V2.5a1 1 0 0 1 1-1h5.7a1 1 0 0 1 .7.3l3.8 3.8a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4 0L1.8 8.9a1 1 0 0 1-.3-.7z"/><circle cx="5" cy="5" r="1" fill="currentColor"/></svg>
Tags
</button>
<button class="btn selActionBtn" id="transformsBtn" title="Manage transformations">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 3H3.5A1.5 1.5 0 0 0 2 4.5V5"/><polyline points="7,1 9,3 7,5"/><path d="M5 11h5.5a1.5 1.5 0 0 0 1.5-1.5V9"/><polyline points="7,13 5,11 7,9"/></svg>
Transforms
</button>
<button class="btn selActionBtn" id="customAttrsBtn" title="Manage attributes">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M5.5 1.5L2 7h4.5l-1 5.5L12 5.5H7.5l1-4z"/></svg>
Attributes
</button>
<button class="btn selActionBtn" id="filtersBtn" title="Manage saved filters and conditional formatting">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M1.5 2.5h11l-4 5v4l-3 1v-5z"/></svg>
Filters
</button>
</div>
</div>
</div>

<!-- Views -->
<div class="tbBtn" id="tbViews" title="Saved views  one-click presentation states">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;"><rect x="1" y="1" width="12" height="8" rx="2" fill="none" stroke="currentColor" stroke-width="1.3"/><circle cx="7" cy="5" r="2" fill="currentColor" opacity=".5"/><rect x="3.5" y="11" width="2" height="1.5" rx=".5" fill="currentColor" opacity=".4"/><rect x="6" y="11" width="2" height="1.5" rx=".5" fill="currentColor" opacity=".4"/><rect x="8.5" y="11" width="2" height="1.5" rx=".5" fill="currentColor" opacity=".4"/></svg></span>Views
<div class="tbPop" id="tbPopViews" style="min-width:240px;max-height:440px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<div id="viewsQuickList" style="max-height:280px;overflow-y:auto;"></div>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="viewsSaveCurrentBtn" title="Save current viewer state as a new view (Ctrl+Alt+S)">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 13H3a1.5 1.5 0 0 1-1.5-1.5v-9A1.5 1.5 0 0 1 3 1h6l3.5 3.5v7A1.5 1.5 0 0 1 11 13z"/><rect x="4.5" y="7.5" width="5" height="4" rx=".5"/><line x1="5" y1="1" x2="5" y2="4"/></svg>
Save current view
</button>
<div id="viewsNavRow" style="display:none;gap:4px;">
<button class="btn selActionBtn" id="viewsRestorePrevBtn" title="Previous view in catalog (,)" style="flex:1;">
<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="10" y1="6" x2="2" y2="6"/><polyline points="5,3 2,6 5,9"/></svg>
Prev
</button>
<button class="btn selActionBtn" id="viewsNextBtn" title="Next view in catalog (.)" style="flex:1;">
Next
<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="2" y1="6" x2="10" y2="6"/><polyline points="7,3 10,6 7,9"/></svg>
</button>
</div>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="viewsCatalogBtn" title="Manage saved views">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><rect x="1.5" y="1.5" width="11" height="11" rx="2"/><line x1="4.5" y1="5" x2="9.5" y2="5"/><line x1="4.5" y1="7.5" x2="9.5" y2="7.5"/><line x1="4.5" y1="10" x2="7" y2="10"/></svg>
Manage views
</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="viewsResetBtn" title="Reset viewer to default state (Ctrl+Alt+0)">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><path d="M2.5 2.5v3.5h3.5"/><path d="M2.5 6A5 5 0 1 1 3.5 9.5"/></svg>
Reset view
</button>
</div>
</div>
</div>

<div class="tbSep"></div>

<!-- Import -->
<div class="tbBtn" id="tbImport" title="Import data">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="7" y1="9" x2="7" y2="1"/><polyline points="3.5,5.5 7,9 10.5,5.5"/><path d="M1.5 9.5v2.5a1 1 0 0 0 1 1h9a1 1 0 0 0 1-1V9.5"/></svg></span>Import
<div class="tbPop" id="tbPopImport" style="min-width:200px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<button class="btn selActionBtn" id="importFieldsBtn" title="Paste field names into the selected column">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 1.5L10.5 6L6 10.5L1.5 6Z"/><line x1="11" y1="3" x2="11" y2="11"/><polyline points="9,9 11,11 13,9"/></svg>
Import fields
</button>
<button class="btn selActionBtn" id="importColumnsBtn" title="Create multiple columns at once">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="1.5" width="5" height="11" rx="1"/><line x1="1" y1="4" x2="6" y2="4"/><rect x="8" y="1.5" width="5" height="11" rx="1"/><line x1="8" y1="4" x2="13" y2="4"/></svg>
Import columns
</button>
<button class="btn selActionBtn" id="importSqlBtn" title="Parse SQL CREATE TABLE statements into columns and fields">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><ellipse cx="7" cy="3.5" rx="5" ry="2"/><path d="M2 3.5v3.5c0 1.1 2.24 2 5 2s5-.9 5-2V3.5"/><path d="M2 7v3.5c0 1.1 2.24 2 5 2s5-.9 5-2V7"/></svg>
Import SQL/DDL
</button>
<button class="btn selActionBtn" id="importCsvFileBtn" title="Upload a CSV or TSV file and map its columns">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 1H3.5A1.5 1.5 0 0 0 2 2.5v9A1.5 1.5 0 0 0 3.5 13h7a1.5 1.5 0 0 0 1.5-1.5V5z"/><polyline points="8,1 8,5 12,5"/><line x1="5" y1="8" x2="9" y2="8"/><line x1="5" y1="10.5" x2="8" y2="10.5"/></svg>
Import CSV/TSV file
</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="importMappingsBtn" title="Import mapping definitions from pasted text or CSV">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><line x1="2" y1="4" x2="6" y2="4"/><line x1="8" y1="4" x2="12" y2="4"/><line x1="2" y1="7" x2="6" y2="7"/><line x1="8" y1="7" x2="12" y2="7"/><line x1="2" y1="10" x2="6" y2="10"/><line x1="8" y1="10" x2="12" y2="10"/><path d="M6 4 C7 4 7 7 8 7" stroke-dasharray="1.5 1.5"/><path d="M6 7 C7 7 7 10 8 10" stroke-dasharray="1.5 1.5"/></svg>
Import mappings
</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="importProjectBtn" title="Merge columns from another Dunnode project file">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M1.5 11V3.5A1.5 1.5 0 0 1 3 2h2.5L7 3.5h4A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 11Z"/><line x1="7" y1="7" x2="7" y2="11"/><polyline points="5,9 7,11 9,9"/></svg>
Import from project
</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="presetBundleBtn" title="Load a preset bundle of tags, attributes & transforms for common domains">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="2" width="12" height="10" rx="1.5"/><path d="M1 5h12"/><circle cx="3.5" cy="3.5" r=".5" fill="currentColor"/><circle cx="5.5" cy="3.5" r=".5" fill="currentColor"/><circle cx="7.5" cy="3.5" r=".5" fill="currentColor"/></svg>
Load preset bundle
</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="importCatTagsBtn" title="Paste tag definitions to add to the catalog">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 7.5V2.5A1.5 1.5 0 0 1 2.5 1h3.59a1 1 0 0 1 .7.29l5.92 5.92a1 1 0 0 1 0 1.41l-3.59 3.59a1 1 0 0 1-1.41 0L1.29 5.79A1 1 0 0 1 1 5.09V7.5"/><circle cx="4" cy="4" r=".75" fill="currentColor"/></svg>
Import tags
</button>
<button class="btn selActionBtn" id="importCatAttrsBtn" title="Paste attribute definitions to add to the catalog">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><polygon points="7,1 13,4.5 13,9.5 7,13 1,9.5 1,4.5"/><line x1="1" y1="4.5" x2="13" y2="4.5"/></svg>
Import attributes
</button>
<button class="btn selActionBtn" id="importCatTfBtn" title="Paste transform definitions to add to the catalog">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5.5"/><path d="M5 5.5a2.5 2.5 0 0 1 4 0"/><path d="M5 8.5a2.5 2.5 0 0 0 4 0"/></svg>
Import transforms
</button>
</div>
</div>
</div>

<div class="tbSep"></div>

<!-- Export -->
<div class="tbBtn" id="tbExport" title="Export data">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="7" y1="1" x2="7" y2="9"/><polyline points="3.5,5.5 7,1 10.5,5.5"/><path d="M1.5 9.5v2.5a1 1 0 0 0 1 1h9a1 1 0 0 0 1-1V9.5"/></svg></span>Export
<div class="tbPop" id="tbPopExport" style="min-width:170px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<button class="btn selActionBtn" id="exportCsvBtn" title="Export mappings as CSV">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 1H3.5A1.5 1.5 0 0 0 2 2.5v9A1.5 1.5 0 0 0 3.5 13h7a1.5 1.5 0 0 0 1.5-1.5V5z"/><polyline points="8,1 8,5 12,5"/></svg>
Export CSV
</button>
<button class="btn selActionBtn" id="exportReportBtn" title="Export HTML report">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><rect x="1.5" y="1.5" width="11" height="11" rx="2"/><line x1="4.5" y1="5" x2="9.5" y2="5"/><line x1="4.5" y1="7.5" x2="9.5" y2="7.5"/><line x1="4.5" y1="10" x2="7.5" y2="10"/></svg>
Export report
</button>
</div>
</div>
</div>

<!-- Help -->
<div class="tbBtn" id="tbHelp" title="Help, docs & examples">
<span class="tbIcon"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><circle cx="7" cy="7" r="5.5"/><path d="M5.5 5.5a1.75 1.75 0 0 1 3.25 1c0 1.2-1.75 1.5-1.75 1.5"/><circle cx="7" cy="10" r=".5" fill="currentColor"/></svg></span>Help
<div class="tbPop" id="tbPopHelp" style="min-width:190px;">
<div class="tbPopRow" style="flex-direction:column;align-items:stretch;">
<button class="btn selActionBtn" id="helpBtn" title="Help / shortcuts (press ?)">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5.5"/><path d="M5.5 5.5a1.75 1.75 0 0 1 3.25 1c0 1.2-1.75 1.5-1.75 1.5"/><circle cx="7" cy="10" r=".5" fill="currentColor"/></svg>
Quick start
</button>
<button class="btn selActionBtn" id="kbdShortcutsBtn" title="Keyboard shortcut reference">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="3" width="12" height="8" rx="1.5"/><rect x="3" y="5.5" width="2" height="2" rx=".5"/><rect x="6" y="5.5" width="2" height="2" rx=".5"/><rect x="9" y="5.5" width="2" height="2" rx=".5"/><line x1="4" y1="9" x2="10" y2="9"/></svg>
Keyboard shortcuts
</button>
<button class="btn selActionBtn" id="goDocsBtn" title="Open documentation">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 2.5A1.5 1.5 0 0 1 3.5 1H10l2.5 2.5V11a1.5 1.5 0 0 1-1.5 1.5H3.5A1.5 1.5 0 0 1 2 11V2.5z"/><line x1="5" y1="5.5" x2="9" y2="5.5"/><line x1="5" y1="8" x2="9" y2="8"/></svg>
Documentation
</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="loadExampleBtn" title="Load the built-in example project">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><rect x="1.5" y="3" width="11" height="9" rx="1.5"/><path d="M4 3V2a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v1"/><line x1="7" y1="6" x2="7" y2="10"/><polyline points="5,8 7,10 9,8"/></svg>
Load example
</button>
<div style="border-top:1px solid var(--border);margin:4px 0;"></div>
<button class="btn selActionBtn" id="releaseNotesBtn" title="View release notes">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 1v5l2.5 1.5"/><circle cx="7" cy="7" r="6"/></svg>
Release notes
</button>
<button class="btn selActionBtn" id="aboutBtn" title="About Dunnode">
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><circle cx="7" cy="7" r="5.5"/><line x1="7" y1="6.5" x2="7" y2="10"/><circle cx="7" cy="4.5" r=".5" fill="currentColor"/></svg>
About
</button>
</div>
</div>
</div>

</div>

<!-- Row 2: Filter bar (toggleable, below icons) -->
<div class="tbRow1" id="tbFilterBar" style="display:none;">
<div class="search" style="flex:1 1 200px;" title="Search labels &amp; IDs across all columns">
<span style="opacity:.85"><svg width="13" height="13" viewBox="0 0 14 14" style="vertical-align:middle;"><circle cx="5.5" cy="5.5" r="4" fill="none" stroke="currentColor" stroke-width="1.4"/><line x1="8.5" y1="8.5" x2="12.5" y2="12.5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/></svg></span>
<input id="searchInput" placeholder="Search" style="min-width:100px;"/>
<span class="hint">Esc</span>
</div>
<div class="tbFilterOpts">
<label class="fbToggle" id="onlyMappedWrap" title="Hide fields without any mappings"><input id="onlyMappedToggle" type="checkbox"/><span class="fbDot"></span>Only mapped</label>
<span class="fbSep"></span>
<div class="fbGroup" id="filterModeGroup">
<button class="fbOpt fbHide active" data-fmode="hide" title="Hide non-matching fields">Hide</button>
<button class="fbOpt fbWarn" data-fmode="dim" title="Dim non-matching fields">Dim</button>
<button class="fbOpt" data-fmode="highlight" title="Highlight matching fields only">Highlight</button>
</div>
<span class="fbSep"></span>
<div class="fbGroup" id="filterLogicGroup">
<button class="fbOpt" data-flogic="and" title="Node must match ALL active filters">AND</button>
<button class="fbOpt active" data-flogic="or" title="Node must match ANY active filter">OR</button>
</div>
<span class="fbSep"></span>
<button class="fbClear" id="clearFilterBtn" title="Clear search and all active filters">Clear all</button>
</div>
<div id="filterChips" style="display:flex;gap:5px;align-items:center;flex-wrap:wrap;flex:1 1 100%;min-height:0;"></div>
</div>

</div>
<div class="sub">
<span id="globalStatus">Hover a field/group to preview. Click to lock. Click again to unlock.</span>
<span></span>
<span>Tips: <kbd>Click</kbd> lock  <kbd>Esc</kbd> clear search + selection  caret collapses groups  non-adjacent mappings supported  toggle Editor mode to edit</span>
</div>
</header>
<main>
<!-- VIEWER -->
<section class="view active" id="view-viewer">
<div class="viewerGrid" data-panel="right">
<div class="columnsWrap">
<div class="columnsHeader">
<div class="statusLine" id="viewerStatus">Ready.</div>
<div id="viewPill" style="display:none;align-items:center;gap:2px;font-size:12px;background:rgba(59,130,246,.1);border:1px solid rgba(59,130,246,.3);border-radius:16px;padding:2px 4px 2px 8px;white-space:nowrap;flex-shrink:0;position:relative;">
<span id="viewPillEmoji" style="font-size:12px;"></span>
<span id="viewPillLabel" style="max-width:160px;overflow:hidden;text-overflow:ellipsis;font-weight:600;padding:0 2px;color:var(--text);"></span>
<button class="btn" id="viewPillPrev" title="Previous view (,)" style="width:20px;height:20px;padding:0;font-size:11px;border-radius:50%;display:flex;align-items:center;justify-content:center;"></button>
<button class="btn" id="viewPillNext" title="Next view (.)" style="width:20px;height:20px;padding:0;font-size:11px;border-radius:50%;display:flex;align-items:center;justify-content:center;"></button>
<button class="btn" id="viewPillClose" title="Deactivate view" style="width:20px;height:20px;padding:0;font-size:12px;border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:.4;"></button>
<select id="viewPillSelect" title="Switch view" style="position:absolute;top:0;left:0;width:calc(100% - 66px);height:100%;opacity:0;cursor:pointer;"></select>
</div>
<div class="viewerControls">
<!-- Columns button -->
<button class="btn colsBtn" id="showAllColumnsBtn" title="Show/hide and reorder columns"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2"><rect x="1" y="1" width="5" height="12" rx="1.5"/><rect x="8" y="1" width="5" height="12" rx="1.5"/><line x1="1" y1="4" x2="6" y2="4" opacity=".4"/><line x1="8" y1="4" x2="13" y2="4" opacity=".4"/></svg>Columns</button>
<!-- View actions group -->
<div class="vcGroup">
<button class="vcBtn" id="panToggleBtn" title="Toggle pan mode (P)"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="1" x2="8" y2="15"/><line x1="1" y1="8" x2="15" y2="8"/><polyline points="5.5,3.5 8,1 10.5,3.5"/><polyline points="5.5,12.5 8,15 10.5,12.5"/><polyline points="3.5,5.5 1,8 3.5,10.5"/><polyline points="12.5,5.5 15,8 12.5,10.5"/></svg></button>
<button class="vcBtn" id="clearSelBtn" title="Clear selection (Esc)"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"><circle cx="7" cy="7" r="5.5"/><line x1="4" y1="4" x2="10" y2="10"/></svg></button>
<button class="vcBtn" id="expandAllBtn" title="Expand all groups"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><polyline points="4,4 7,1.5 10,4"/><polyline points="4,10 7,12.5 10,10"/><line x1="7" y1="5" x2="7" y2="9" opacity=".3"/></svg></button>
<button class="vcBtn" id="collapseAllBtn" title="Collapse all groups"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><polyline points="4,2 7,4.5 10,2"/><polyline points="4,12 7,9.5 10,12"/><line x1="7" y1="5.5" x2="7" y2="8.5" opacity=".3"/></svg></button>
<button class="vcBtn" id="resetViewBtn" title="Reset view to defaults (Ctrl+Alt+0)"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"><path d="M2.5 2.5v3.5h3.5"/><path d="M2.5 6A5 5 0 1 1 3.5 9.5"/></svg></button>
</div>
<!-- Editor: history group -->
<div class="vcGroup vcEditorOnly" id="vcHistoryGroup" style="display:none;">
<button class="vcBtn" id="undoBtn" title="Undo (Ctrl+Z)" disabled><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><path d="M3 5.5h6a3 3 0 0 1 0 6H7"/><polyline points="5.5,3 3,5.5 5.5,8"/></svg></button>
<button class="vcBtn" id="redoBtn" title="Redo (Ctrl+Y)" disabled><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5.5H5a3 3 0 0 0 0 6h2"/><polyline points="8.5,3 11,5.5 8.5,8"/></svg></button>
</div>
</div>
</div>
<div class="columnsScroller" id="columnsScroller">
<div id="lassoRect" style="display:none;position:absolute;border:1.5px dashed rgba(59,130,246,.7);background:rgba(59,130,246,.08);border-radius:2px;pointer-events:none;z-index:9999;"></div>
<svg id="lassoSvg" style="display:none;position:absolute;top:0;left:0;pointer-events:none;z-index:9999;overflow:visible;"><polygon id="lassoPolygon" fill="rgba(59,130,246,.08)" stroke="rgba(59,130,246,.7)" stroke-width="1.5" stroke-dasharray="4,3"/></svg>
<svg aria-hidden="true" id="svgOverlay">
<defs>
<marker id="arrowDefault" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto" refx="0" refy="7" viewbox="0 0 14 14">
<!-- Slightly bigger; refX=0 so the path ends exactly at arrow base (flat side) -->
<path class="edgeMarker" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<marker id="arrowHL" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker hl" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<marker id="arrowActive" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker active" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<!-- Bidirectional markers - for start of line, use same shape but reversed orientation -->
<marker id="arrowStartDefault" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto-start-reverse" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<marker id="arrowStartHL" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto-start-reverse" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker hl" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<marker id="arrowStartActive" markerheight="14" markerunits="userSpaceOnUse" markerwidth="14" orient="auto-start-reverse" refx="0" refy="7" viewbox="0 0 14 14">
<path class="edgeMarker active" d="M0,2.6 L0,11.4 L13,7 z"></path>
</marker>
<!-- Dot markers for directionless edges -->
<marker id="dotDefault" markerHeight="8" markerUnits="userSpaceOnUse" markerWidth="8" refX="4" refY="4" viewBox="0 0 8 8">
<circle class="edgeMarker" cx="4" cy="4" r="3"></circle>
</marker>
<marker id="dotHL" markerHeight="8" markerUnits="userSpaceOnUse" markerWidth="8" refX="4" refY="4" viewBox="0 0 8 8">
<circle class="edgeMarker hl" cx="4" cy="4" r="3"></circle>
</marker>
<marker id="dotActive" markerHeight="8" markerUnits="userSpaceOnUse" markerWidth="8" refX="4" refY="4" viewBox="0 0 8 8">
<circle class="edgeMarker active" cx="4" cy="4" r="3"></circle>
</marker>
</defs>
<g id="edgesLayer"></g>
</svg>
<div class="columnsRow" id="columnsRow"></div>
</div>
</div>
<div class="resizeHandle" id="resizeHandle"></div>
<div class="resizeHandleH" id="resizeHandleH"></div>
<aside class="details" id="detailsPanel">
<div class="detailsHeader" id="detailsHeader">
<div style="display:flex;align-items:center;gap:10px;">
<div class="detailsGrip" title="Drag to reposition"></div>
<div class="name">Details</div>
</div>
<div style="display:flex;align-items:center;gap:6px;">
<div class="meta" id="detailsMeta"></div>
<div class="detailsDockActions" id="detailsDockActions"></div>
<button class="detailsClose floatOnly" id="detailsOpacityBtn" title="Inactive opacity" style="font-size:11px;display:none;position:relative;overflow:visible;"><div id="opacityPopover" style="display:none;position:absolute;right:0;padding:8px 12px;background:rgba(11,16,32,.95);border:1px solid var(--border);border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.4);z-index:200;white-space:nowrap;min-width:140px;">
<div style="font-size:10px;opacity:.5;margin-bottom:6px;letter-spacing:.3px;">INACTIVE OPACITY</div>
<div style="display:flex;align-items:center;gap:8px;">
<input type="range" id="opacitySlider" min="10" max="100" value="30" style="flex:1;accent-color:#3b82f6;cursor:pointer;"/>
<span id="opacityVal" style="font-size:11px;font-family:var(--mono);min-width:28px;text-align:right;">30%</span>
</div>
</div></button>
<button class="detailsClose" id="detailsDefaultBtn" title="Reset to default size" style="font-size:11px;"></button>
<button class="detailsClose floatOnly" id="detailsMinBtn" title="Minimize panel" style="font-size:11px;display:none;"></button>
<button class="detailsClose" id="detailsCloseBtn" title="Hide details panel"></button>
</div>
</div>
<div class="detailsBody" id="detailsBody">
<div class="empty">
Hover a field/group to preview details. Click to lock selection.
<br/><br/>
Use the Details pane to see <b>Outbound</b> and <b>Inbound</b> mappings for the selection.
</div>
</div>
<div class="floatResizeHandle" id="floatResizeHandle"></div>
</aside>
<div class="snapIndicator" id="snapIndicator"></div>
</div>
</section>
<!-- Hidden: file input for Open project, jsonArea for internal state sync, fieldDatalist for autocomplete -->
<input accept=".json,application/json" id="fileInput" style="display:none" type="file"/>
<input accept=".json,application/json" id="importProjectFileInput" style="display:none" type="file"/>
<datalist id="fieldDatalist"></datalist>
<textarea id="jsonArea" spellcheck="false" style="display:none"></textarea>
<div id="logArea" style="display:none"></div>
<!-- Docs modal -->
<div class="modalMask" id="docsMask"></div>
<div aria-label="Documentation" class="modal" id="docsModal" role="dialog" style="max-width:880px;">
<div class="modalHeader">
<div class="title">Documentation</div>
<div class="controls">
<button class="btn" id="closeDocsBtn">Close</button>
</div>
</div>
<div class="modalBody docsBody" id="docsBody">
<!-- populated by JS -->
</div>
</div>
</main>
<footer class="appFooter">
<span> 2026 Olivr Bn  <a href="#" id="footerLicenseLink">MIT License</a></span>
<span id="appVersionLabel">v1.7.2</span>
</footer>
<!-- Permanent DnD overlay  all drag visuals live here to avoid body flex reflow -->
<div id="dndOverlay" style="position:fixed;inset:0;z-index:9998;pointer-events:none;">
  <div id="cancelZone" class="dragDropZone"> Cancel</div>
  <div id="binZone" class="dragDropZone"> Delete</div>
</div>
<!-- Columns popover -->
<div aria-label="Columns" class="popover" id="columnsPopover" role="dialog">
<div class="popTitle">Columns</div>
<div id="columnsList"></div>
<div class="colPopFooter">
<span id="colPopAddBtns" class="colPopAdd" style="display:none;">
<button class="btn colPopBtn" id="addColumnLeftBtn" title="Add a new column at the far left"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><line x1="6" y1="2" x2="6" y2="10"/><line x1="2" y1="6" x2="10" y2="6"/></svg>Add left</button>
<button class="btn colPopBtn" id="addColumnRightBtn" title="Add a new column at the far right"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><line x1="6" y1="2" x2="6" y2="10"/><line x1="2" y1="6" x2="10" y2="6"/></svg>Add right</button>
</span>
<span style="flex:1;"></span>
<button class="btn colPopBtn" id="showAllColsBtn"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><path d="M1 6s2-3 5-3 5 3 5 3-2 3-5 3-5-3-5-3z"/><circle cx="6" cy="6" r="1.5"/></svg>Show all</button>
<button class="btn colPopBtn" id="hideUnmappedColsBtn" title="Hide columns with no mapped fields"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><path d="M1 6s2-3 5-3 5 3 5 3-2 3-5 3-5-3-5-3z"/><line x1="2" y1="10" x2="10" y2="2"/></svg>Hide unmapped</button>
<button class="btn colPopBtn" id="closeColumnsBtn">Close</button>
</div>
</div>
<!-- Tags modal -->
<div class="modalMask" id="tagsMask"></div>
<div aria-label="Tags" class="modal" id="tagsModal" role="dialog">
<div class="modalHeader">
<div class="title">Tags catalog</div>
<div class="controls">
<button class="btn" id="importTagsBtn" style="font-size:11px;">Import</button>
<button class="btn" id="addTagBtn">Add tag</button>
<button class="btn" id="closeTagsBtn">Close</button>
</div>
</div>
<div class="modalBody" id="tagsBody"></div>
</div>
<!-- Transforms modal -->
<div class="modalMask" id="transformsMask"></div>
<div aria-label="Transforms" class="modal" id="transformsModal" role="dialog">
<div class="modalHeader">
<div class="title">Transforms catalog</div>
<div class="controls">
<button class="btn" id="importTransformsBtn" style="font-size:11px;">Import</button>
<button class="btn" id="addTransformBtn">Add transform</button>
<button class="btn" id="closeTransformsBtn">Close</button>
</div>
</div>
<div class="modalBody" id="transformsBody"></div>
</div>
<!-- Attributes modal -->
<div class="modalMask" id="customAttrsMask"></div>
<div aria-label="Attributes" class="modal" id="customAttrsModal" role="dialog">
<div class="modalHeader">
<div class="title">Attributes catalog</div>
<div class="controls">
<button class="btn" id="importAttrsBtn" style="font-size:11px;">Import</button>
<button class="btn" id="addCustomAttrBtn">Add attribute</button>
<button class="btn" id="closeCustomAttrsBtn">Close</button>
</div>
</div>
<div class="modalBody" id="customAttrsBody"></div>
</div>
<!-- Filters modal -->
<div class="modalMask" id="filtersMask"></div>
<div aria-label="Filters" class="modal" id="filtersModal" role="dialog" style="max-width:720px;">
<div class="modalHeader">
<div class="title">Filter catalog</div>
<div class="controls">
<button class="btn" id="addFilterBtn">Add filter</button>
<button class="btn" id="closeFiltersBtn">Close</button>
</div>
</div>
<div class="modalBody" id="filtersBody"></div>
</div>
<!-- Views catalog modal -->
<div class="modalMask" id="viewsMask"></div>
<div aria-label="Views" class="modal" id="viewsModal" role="dialog" style="max-width:620px;">
<div class="modalHeader">
<div class="title">Views catalog</div>
<div class="controls">
<button class="btn" id="addViewBtn">Add view</button>
<button class="btn" id="closeViewsBtn">Close</button>
</div>
</div>
<div class="modalBody" id="viewsBody"></div>
</div>
<!-- Import fields modal -->
<div class="modalMask" id="importFieldsMask"></div>
<div aria-label="Import Fields" class="modal" id="importFieldsModal" role="dialog" style="max-width:780px;">
<div class="modalHeader">
<div class="title">Import fields</div>
<div class="controls">
<label class="btn" style="font-size:11px;cursor:pointer;">Upload file
<input type="file" id="importFieldsFileInput" accept=".csv,.tsv,.txt" style="display:none;">
</label>
<button class="btn btnSave" id="importFieldsCommit" disabled>Import</button>
<button class="btn" id="importFieldsClose">Cancel</button>
</div>
</div>
<div class="modalBody" id="importFieldsBody" style="max-height:72vh;overflow-y:auto;"></div>
</div>
<!-- Import columns modal -->
<div class="modalMask" id="importColumnsMask"></div>
<div aria-label="Import Columns" class="modal" id="importColumnsModal" role="dialog" style="max-width:780px;">
<div class="modalHeader">
<div class="title">Import columns</div>
<div class="controls">
<label class="btn" style="font-size:11px;cursor:pointer;">Upload file
<input type="file" id="importColumnsFileInput" accept=".csv,.tsv,.txt" style="display:none;">
</label>
<button class="btn btnSave" id="importColumnsCommit" disabled>Import</button>
<button class="btn" id="importColumnsClose">Cancel</button>
</div>
</div>
<div class="modalBody" id="importColumnsBody" style="max-height:72vh;overflow-y:auto;"></div>
</div>
<!-- Import SQL/DDL modal -->
<div class="modalMask" id="importSqlMask"></div>
<div aria-label="Import SQL/DDL" class="modal" id="importSqlModal" role="dialog" style="max-width:820px;">
<div class="modalHeader">
<div class="title">Import SQL / DDL</div>
<div class="controls">
<label class="btn" style="font-size:11px;cursor:pointer;">Upload .sql
<input type="file" id="importSqlFileInput" accept=".sql,.ddl,.txt" style="display:none;">
</label>
<button class="btn btnSave" id="importSqlCommit" disabled>Import</button>
<button class="btn" id="importSqlClose">Cancel</button>
</div>
</div>
<div class="modalBody" id="importSqlBody" style="max-height:72vh;overflow-y:auto;"></div>
</div>
<!-- Import CSV/TSV file modal -->
<div class="modalMask" id="importCsvFileMask"></div>
<div aria-label="Import CSV/TSV File" class="modal" id="importCsvFileModal" role="dialog" style="max-width:880px;">
<div class="modalHeader">
<div class="title">Import CSV / TSV file</div>
<div class="controls">
<button class="btn btnSave" id="importCsvFileCommit" disabled>Import</button>
<button class="btn" id="importCsvFileClose">Cancel</button>
</div>
</div>
<div class="modalBody" id="importCsvFileBody" style="max-height:72vh;overflow-y:auto;"></div>
</div>
<!-- Import mappings modal -->
<div class="modalMask" id="importMappingsMask"></div>
<div aria-label="Import Mappings" class="modal" id="importMappingsModal" role="dialog" style="max-width:880px;">
<div class="modalHeader">
<div class="title">Import mappings</div>
<div class="controls">
<label class="btn" style="font-size:11px;cursor:pointer;">Upload file
<input type="file" id="importMappingsFileInput" accept=".csv,.tsv,.txt" style="display:none;">
</label>
<button class="btn btnSave" id="importMappingsCommit" disabled>Import</button>
<button class="btn" id="importMappingsClose">Cancel</button>
</div>
</div>
<div class="modalBody" id="importMappingsBody" style="max-height:72vh;overflow-y:auto;"></div>
</div>
<!-- Import from project modal -->
<div class="modalMask" id="importProjectMask"></div>
<div aria-label="Import from Project" class="modal" id="importProjectModal" role="dialog" style="max-width:780px;">
<div class="modalHeader">
<div class="title">Import from project</div>
<div class="controls">
<button class="btn btnSave" id="importProjectCommit" disabled>Import selected</button>
<button class="btn" id="importProjectClose">Cancel</button>
</div>
</div>
<div class="modalBody" id="importProjectBody" style="max-height:72vh;overflow-y:auto;"></div>
</div>
<!-- Import catalog items modal (shared by tags, attributes, transforms) -->
<div class="modalMask" id="importCatalogMask"></div>
<div aria-label="Import Catalog" class="modal" id="importCatalogModal" role="dialog" style="max-width:780px;">
<div class="modalHeader">
<div class="title" id="importCatalogTitle">Import catalog items</div>
<div class="controls">
<label class="btn" id="importCatalogFileLabel" style="font-size:11px;cursor:pointer;">Upload file
<input type="file" id="importCatalogFileInput" accept=".csv,.tsv,.txt" style="display:none;">
</label>
<button class="btn btnSave" id="importCatalogCommit" disabled>Import</button>
<button class="btn" id="importCatalogClose">Cancel</button>
</div>
</div>
<div class="modalBody" id="importCatalogBody" style="max-height:72vh;overflow-y:auto;"></div>
</div>
<!-- Preset bundle modal -->
<div class="modalMask" id="presetBundleMask"></div>
<div aria-label="Preset Bundle" class="modal" id="presetBundleModal" role="dialog" style="max-width:680px;">
<div class="modalHeader">
<div class="title">Load preset bundle</div>
<div class="controls">
<button class="btn btnSave" id="presetBundleApply" disabled>Apply</button>
<button class="btn" id="presetBundleClose">Cancel</button>
</div>
</div>
<div class="modalBody" id="presetBundleBody" style="max-height:72vh;overflow-y:auto;"></div>
</div>
<!-- Keyboard shortcuts modal -->
<div class="modalMask" id="kbdShortcutsMask"></div>
<div aria-label="Keyboard Shortcuts" class="modal" id="kbdShortcutsModal" role="dialog" style="max-width:660px;">
<div class="modalHeader">
<div class="title">Keyboard &amp; mouse shortcuts</div>
<div class="controls"><button class="btn" id="kbdShortcutsClose">Close</button></div>
</div>
<div class="modalBody" id="kbdShortcutsBody" style="max-height:70vh;overflow-y:auto;padding:18px 22px;"></div>
</div>
<!-- Custom alert/confirm modal -->
<div class="modalMask" id="customDialogMask" style="z-index:10000;"></div>
<div aria-label="Dialog" class="modal" id="customDialog" role="dialog" style="z-index:10001;max-width:500px;">
<div class="modalHeader">
<div class="title">Dialog</div>
<div class="controls"><button class="modalClose" title="Close">&times;</button></div>
</div>
<div class="modalBody" style="padding:24px;">
<div id="customDialogMessage" style="font-size:15px;line-height:1.6;margin-bottom:24px;white-space:pre-wrap;"></div>
<div id="customDialogButtons" style="display:flex;gap:8px;justify-content:flex-end;"></div>
</div>
</div>
<!-- Unified create modal (columns, nodes, tags, transforms, attributes, values) -->
<div class="modalMask" id="createMask"></div>
<div aria-label="Create" class="modal" id="createModal" role="dialog">
<div class="modalHeader">
<div class="title" id="createTitle">Create</div>
<div class="controls">
<button class="btn" id="createCloseBtn">Close</button>
</div>
</div>
<div class="modalBody">
<div class="kv" style="grid-template-columns: 110px 1fr;">
<div class="k">Label<span class="req">*</span></div>
<div class="v"><input class="inp" id="createLabel" placeholder=""/></div>
<div class="k">ID <span class="autoTag" id="createIdAuto">auto</span></div>
<div class="v" style="display:flex;align-items:center;gap:0;">
<span id="createIdPrefix" style="font-family:var(--mono);font-size:11px;opacity:.55;white-space:nowrap;"></span>
<input class="inp" id="createIdInput" value="" style="font-family:var(--mono);font-size:11px;flex:1 1 auto;"/>
</div>
<div class="k crOpt" id="crAbbrK" style="display:none">Abbr <span class="autoTag" id="createAbbrAuto">auto</span></div>
<div class="v crOpt" id="crAbbrV" data-flex="1" style="display:none;align-items:center;"><input class="inp" id="createAbbr" placeholder="e.g. S" style="flex:1;"/></div>
<div class="k crOpt" id="crEmojiK" style="display:none">Emoji</div>
<div class="v crOpt" id="crEmojiV" style="display:none">
<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
<input class="inp" id="createEmoji" value="" style="width:42px;text-align:center;font-size:16px;" placeholder="" maxlength="4"/>
<div id="createEmojiGrid" style="display:flex;flex-wrap:wrap;gap:2px;"></div>
</div>
</div>
<div class="k crOpt" id="crDisplayK" style="display:none">Display</div>
<div class="v crOpt" id="crDisplayV" style="display:none">
<div id="createDisplayMode" style="display:inline-flex;border:1px solid var(--border);border-radius:6px;overflow:hidden;">
<button class="crDmOpt" data-dm="abbr" style="padding:2px 10px;font-size:11px;border:none;cursor:pointer;background:rgba(59,130,246,.25);color:var(--fg);transition:all .15s;">Abbr</button>
<button class="crDmOpt" data-dm="emoji" style="padding:2px 10px;font-size:11px;border:none;border-left:1px solid var(--border);cursor:pointer;background:transparent;color:var(--fg);opacity:.4;transition:all .15s;">Emoji</button>
</div>
</div>
<div class="k crOpt" id="crColorK" style="display:none">Color</div>
<div class="v crOpt" id="crColorV" style="display:none">
<div id="createColors" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
<div style="display:flex;align-items:center;gap:6px;margin-top:8px;">
<input type="color" id="createColorPicker" value="#3b82f6" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;opacity:.3;"/>
<input class="inp" id="createColorHex" placeholder="optional" style="flex:1;"/>
<label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" id="createColorOn"/> Apply</label>
<span class="layoutReset" id="createColorReset" title="Reset color" style="opacity:.35;cursor:pointer;font-size:13px;color:var(--muted);transition:opacity .15s;"></span>
</div>
</div>
<div class="k crOpt" id="crMultiK" style="display:none">Mode</div>
<div class="v crOpt" id="crMultiV" style="display:none">
<label class="toggle" style="padding:6px 10px; display:inline-flex;">
<input type="checkbox" id="createMulti"/>
Multi-value
</label>
<div class="empty" style="margin-top:6px;">If OFF, selecting a value replaces the previous one.</div>
</div>
<div class="k" id="crNoteK">Note</div>
<div class="v" id="crNoteV"><input class="inp" id="createNote" placeholder="optional"/></div>
<div class="k crOpt" id="crParamsK" style="display:none">Params</div>
<div class="v crOpt" id="crParamsV" style="display:none">
<div id="createParamsRows"></div>
<button class="btn" id="createAddParamBtn" type="button" style="margin-top:4px;font-size:11px;padding:2px 8px;">+ Add param</button>
</div>
<div class="k crOpt" id="crTagsK" style="display:none">Tags</div>
<div class="v crOpt" id="crTagsV" style="display:none">
<div id="createTagChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;">
<select class="inp" id="createTagSel" style="max-width:280px;flex:0 0 auto;"><option value="">Add tag</option></select>
<button class="btn" id="createTagMgr" type="button">Tags</button>
</div>
</div>
<div class="k crOpt" id="crAttrsK" style="display:none">Custom</div>
<div class="v crOpt" id="crAttrsV" style="display:none">
<div id="createAttrChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;">
<select class="inp" id="createAttrSel" style="max-width:240px;"><option value="">Attribute</option></select>
<select class="inp" id="createAttrValSel" style="max-width:240px;"><option value="">Value</option></select>
<button class="btn" id="createAttrMgr" type="button">Attributes</button>
</div>
</div>
</div>
<div class="empty" id="createHint" style="margin-top:8px;"></div>
<div style="display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap; margin-top:12px;">
<button class="btn" id="createCancelBtn">Cancel</button>
<button class="btn btnSave" id="createOkBtn">Save</button>
</div>
</div>
</div>
<!-- Help modal -->
<div class="modalMask" id="helpMask"></div>
<div aria-label="Help" class="modal" id="helpModal" role="dialog" style="max-width:660px;">
<div class="modalHeader">
<div class="title">Quick Start Guide</div>
<div class="controls">
<button class="btn" id="closeHelpBtn">Close</button>
</div>
</div>
<div class="modalBody" id="helpBody"></div>
</div>
<!-- Release notes modal -->
<div class="modalMask" id="releaseNotesMask"></div>
<div aria-label="Release Notes" class="modal" id="releaseNotesModal" role="dialog" style="max-width:640px;">
<div class="modalHeader">
<div class="title">Release Notes</div>
<div class="controls">
<button class="btn" id="closeReleaseNotesBtn">Close</button>
</div>
</div>
<div class="modalBody" id="releaseNotesBody" style="max-height:70vh;overflow-y:auto;"></div>
</div>
<div class="modalMask" id="projPropsMask"></div>
<div aria-label="Project Properties" class="modal" id="projectPropsModal" role="dialog">
<div class="modalHeader">
<div class="title">Project Properties</div>
<div class="controls">
<button class="btn btnSave" id="projPropsSave">Save</button>
<button class="btn" id="projPropsCancel">Cancel</button>
</div>
</div>
<div class="modalBody" id="projPropsBody" style="max-height:65vh;overflow-y:auto;"></div>
</div>

<div class="modalMask" id="aboutMask"></div>
<div aria-label="About" class="modal" id="aboutModal" role="dialog" style="max-width:380px;">
<div class="modalHeader">
<div class="title">About</div>
<div class="controls"><button class="btn" id="aboutClose">Close</button></div>
</div>
<div class="modalBody" style="text-align:center;padding:28px 24px;">
<div style="font-size:12px;font-style:italic;opacity:.4;margin-bottom:16px;">Dunno where your data goes?</div>
<div style="font-size:22px;font-weight:800;letter-spacing:1.2px;margin-bottom:2px;text-transform:uppercase;">Dunnode</div>
<div style="font-size:13px;font-weight:600;opacity:.55;letter-spacing:.4px;margin-bottom:14px;">Done. Now.</div>
<div style="font-size:12px;opacity:.6;line-height:1.6;margin-bottom:18px;">A lightweight mapping studio for complex flows.</div>
<div style="font-size:11px;opacity:.5;line-height:1.8;">
Created by Olivr Bn<br/>
<span id="dunnodeContact" style="color:var(--accent);cursor:pointer;text-decoration:none;"></span><br/>
<a href="https://dunnode.com" target="_blank" rel="noopener" style="color:var(--accent);text-decoration:none;">dunnode.com</a>
</div>
<div style="margin-top:14px;font-size:10.5px;opacity:.4;line-height:1.6;">
<a href="#" id="aboutLicenseLink" class="aboutLicenseLink">MIT Licensed</a>  Runs entirely in your browser
</div>
<div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border);font-size:10px;opacity:.35;" id="aboutVersion">v</div>
</div>
</div>

<div class="modalMask" id="hlColorsMask"></div>
<div aria-label="Highlight colors" class="modal" id="hlColorsModal" role="dialog" style="max-width:380px;">
<div class="modalHeader">
<div class="title">Highlight colors</div>
<div class="controls"><button class="btn" id="hlColorsClose">Close</button></div>
</div>
<div class="modalBody" id="hlColorsBody" style="padding:18px 22px;">
<div style="margin-bottom:16px;">
<div style="font-size:12px;font-weight:600;margin-bottom:8px;">Selected / Hovered</div>
<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
<input type="color" id="hlActivePicker" value="#ffd05c" style="width:30px;height:24px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;"/>
<div id="hlActiveSwatches" style="display:flex;gap:5px;flex-wrap:nowrap;"></div>
<span class="layoutReset hlEditOnly" id="hlActiveReset" title="Reset to default (#ffd05c)" style="opacity:.35;cursor:pointer;font-size:13px;color:var(--muted);transition:opacity .15s,color .15s;"></span>
</div>
</div>
<div style="margin-bottom:4px;">
<div style="font-size:12px;font-weight:600;margin-bottom:8px;">Connected</div>
<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
<input type="color" id="hlConnectedPicker" value="#3b82f6" style="width:30px;height:24px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;"/>
<div id="hlConnectedSwatches" style="display:flex;gap:5px;flex-wrap:nowrap;"></div>
<span class="layoutReset hlEditOnly" id="hlConnectedReset" title="Reset to default (#3b82f6)" style="opacity:.35;cursor:pointer;font-size:13px;color:var(--muted);transition:opacity .15s,color .15s;"></span>
</div>
</div>
<div style="border-top:1px solid var(--border);margin-top:16px;padding-top:14px;">
<div style="font-size:11px;opacity:.4;margin-bottom:10px;text-align:center;">Preview  hover or click to test</div>
<div id="hlTester" style="display:flex;align-items:center;justify-content:center;gap:0;user-select:none;padding:10px 4px;">
<div id="hlTesterSource" class="hlTesterNode" style="padding:8px 20px;border-radius:8px;border:1.5px solid var(--border);background:var(--panel);font-size:12.5px;font-weight:600;cursor:pointer;transition:background .15s, border-color .15s;position:relative;z-index:1;">Source</div>
<svg id="hlTesterArrow" width="70" height="24" viewBox="0 0 70 24" style="flex-shrink:0;overflow:visible;cursor:pointer;margin-right:-6px;">
<line x1="2" y1="12" x2="58" y2="12" stroke="var(--line)" stroke-width="1.5" id="hlTesterLine" style="transition:stroke .15s;"/>
<polygon points="56,7 66,12 56,17" fill="var(--line)" id="hlTesterHead" style="transition:fill .15s;"/>
</svg>
<div id="hlTesterTarget" class="hlTesterNode" style="padding:8px 20px;border-radius:8px;border:1.5px solid var(--border);background:var(--panel);font-size:12.5px;font-weight:600;cursor:pointer;transition:background .15s, border-color .15s;position:relative;z-index:1;">Target</div>
</div>
</div>
<div id="hlColorsEditorActions" style="display:none;margin-top:14px;padding-top:10px;border-top:1px solid var(--border);">
<div style="display:flex;gap:8px;flex-wrap:wrap;">
<button class="btn" id="hlColorsDelete" style="border-color:rgba(255,154,168,.45);">Delete</button>
<span style="flex:1;"></span>
<button class="btn" id="hlColorsCancel">Cancel</button>
<button class="btn btnSave" id="hlColorsSave">Save</button>
</div>
</div>
<div id="hlViewerHint" style="display:none;margin-top:12px;font-size:11px;opacity:.4;text-align:center;">Switch to Editor mode to change highlight colors.</div>
</div>
</div>

<!-- Command Palette -->
<div class="cmdPaletteMask" id="cmdPaletteMask">
<div class="cmdPalette" id="cmdPalette">
<input class="cmdPaletteInput" id="cmdPaletteInput" placeholder="Type a command, search nodes or docs" autocomplete="off" spellcheck="false"/>
<div class="cmdPaletteResults" id="cmdPaletteResults"></div>
<div class="cmdPaletteFooter"><kbd></kbd> navigate <kbd></kbd> run <kbd>esc</kbd> close</div>
</div>
</div>

<script>
/* =========================================================
   Dunnode  One page app (Vanilla JS)
   - Multi-column schema viewer with nested trees
   - Hover highlight + click lock
   - Arrows across adjacent or non-adjacent columns
   - Documentation embedded
  Mapping model:
  - One mapping per (fromto) pair
  - One-to-many is expressed as multiple mappings
  - 'default' may be provided as an attribute

========================================================= */

/* ----------------------- Example JSON (v3) -----------------------
   New format supports ANY number of columns:
   {
     columns: [
       { id, label, schema: (tree root group node) },
       ...
     ],
     mappings: [
       { from, to, cardinality, transforms: [{ref, params?}], label, note, default, tags, customAttributes }
     ],
     transformCatalog: [{ id, label, abbr, note, color?, params?: [{id, label, type, default?}] }],
     customAttributeCatalog: [{ id, label, abbr, note, multi, displayOnNode?, priority?,
       color?, colorEnabled?,
       values: [{ id, label, abbr?, note?, color?, colorEnabled?, priority? }] }],
     columns: [{ id, label, note?, color?, schema: { ... } }]
   }

   Field IDs MUST start with "<columnId>." so we can infer the column.
------------------------------------------------------------------- */
const APP_VERSION = '1.7.2';

const EXAMPLE_JSON = {
  "title": "Mars Mission Data Integration",
  "subtitle": "Spacecraft telemetry and research pipeline",
  "description": "Maps mission data across five systems: Mission Control, Spacecraft Telemetry, the Lab analysis pipeline, an Archive database, and the Obs ground-tracking dashboard.\n\nDemonstrates nested schemas, bidirectional mappings, tags for workflow stages, ordered transforms, custom attributes for data classification, multi-column chains, and color inheritance  every column has a color, groups override their column (e.g. Crew  red, Personnel  pink, dim_crew  indigo), and individual fields can override their group (e.g. CommanderName  amber).",
  "author": "Mars Systems Integration Team",
  "organization": "Ares Space Agency",
  "contact": "hello@dunnode.com",
  "url": "https://dunnode.com",
  "projectVersion": "1.0",
  "date": "2026-02-22",
  "_app": { "name": "Dunnode", "version": "1.7.2", "schema": 1 },
  "_savedAt": "",
  "columns": [
    {
      "id": "mc",
      "_autoId": false,
      "label": "Mission Control",
      "note": "Primary command center. Source of truth for crew assignments and mission parameters.",
      "color": "#3b82f6",
      "schema": {
        "id": "mc",
        "_autoId": false,
        "label": "Mission Control",
        "type": "group",
        "children": [
          {
            "id": "mc.mission",
            "label": "Mission",
            "type": "group",
            "tags": ["active"],
            "note": "Core mission parameters group.",
            "children": [
              {
                "id": "mc.mission.missionId",
                "label": "MissionId",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "no",
                  "domain": ["telemetry","navigation"]
                },
                "note": "Unique mission identifier (e.g. ARES-2026-07)."
              },
              {
                "id": "mc.mission.missionName",
                "label": "MissionName",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "no"
                }
              },
              {
                "id": "mc.mission.objectiveCode",
                "label": "ObjectiveCode",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "mc.mission.launchMass",
                "label": "LaunchMassKg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                }
              },
              {
                "id": "mc.mission.fuelBudget",
                "label": "FuelBudgetKg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                }
              },
              {
                "id": "mc.mission.targetOrbit",
                "label": "TargetOrbit",
                "type": "field",
                "tags": [
                  "active",
                   "critical"
                ],
                "customAttributes": {
                  "format": "string",
                  "domain": ["navigation"]
                }
              },
              {
                "id": "mc.mission.legacyCallsign",
                "label": "LegacyCallsign",
                "type": "field",
                "tags": [
                  "retired",
                   "pending"
                ],
                "note": "Deprecated  old radio callsign format, replaced in 2025."
              }
            ]
          },
          {
            "id": "mc.crew",
            "label": "Crew",
            "type": "group",
            "tags": ["active","pending"],
            "customAttributes": { "classified": "yes" },
            "note": "Crew manifest  restricted access group.",
            "color": "#ef4444",
            "children": [
              {
                "id": "mc.crew.crewId",
                "label": "CrewId",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string",
                  "domain": ["personnel","navigation"]
                }
              },
              {
                "id": "mc.crew.commanderName",
                "label": "CommanderName",
                "type": "field",
                "tags": [
                  "active",
                   "pending"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "yes",
                  "domain": ["personnel"]
                },
                "note": "Commander identity  restricted access.",
                "color": "#f59e0b"
              },
              {
                "id": "mc.crew.headcount",
                "label": "Headcount",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "integer"
                }
              }
            ]
          },
          {
            "id": "mc.forecast",
            "label": "Forecast",
            "type": "group",
            "tags": ["pending"],
            "note": "Experimental forecast models  subject to change.",
            "children": [
              {
                "id": "mc.forecast.arrivalWindow",
                "label": "ArrivalWindow",
                "type": "field",
                "tags": [
                  "pending"
                ],
                "customAttributes": {
                  "format": "string"
                },
                "note": "Under review  orbital mechanics model being recalibrated."
              }
            ]
          }
        ]
      }
    },
    {
      "id": "sat",
      "label": "Spacecraft Telemetry",
      "note": "Live telemetry feed from the spacecraft. Nested subsystem sensors.",
      "color": "#8b5cf6",
      "schema": {
        "id": "sat",
        "label": "Spacecraft Telemetry",
        "type": "group",
        "children": [
          {
            "id": "sat.vehicle",
            "label": "Vehicle",
            "type": "group",
            "children": [
              {
                "id": "sat.vehicle.vehicleCode",
                "label": "VehicleCode",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "no",
                  "domain": ["telemetry","navigation"]
                },
                "note": "Spacecraft identifier (maps to Mission Control ID)."
              },
              {
                "id": "sat.vehicle.missionLabel",
                "label": "MissionLabel",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "sat.vehicle.objectiveTag",
                "label": "ObjectiveTag",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "sat.vehicle.massKg",
                "label": "MassKg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal",
                  "domain": ["telemetry","science"]
                }
              },
              {
                "id": "sat.vehicle.fuelKg",
                "label": "FuelKg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal",
                  "domain": ["telemetry","navigation"]
                }
              },
              {
                "id": "sat.vehicle.nav",
                "label": "Navigation",
                "type": "group",
                "tags": ["active"],
                "customAttributes": { "classified": "yes" },
                "note": "Navigation subsystem  contains crew identity data.",
                "color": "#f97316",
                "children": [
                  {
                    "id": "sat.vehicle.nav.crewRef",
                    "label": "CrewRef",
                    "type": "field",
                    "tags": [
                      "active"
                    ],
                    "customAttributes": {
                      "format": "string"
                    }
                  },
                  {
                    "id": "sat.vehicle.nav.pilotCallsign",
                    "label": "PilotCallsign",
                    "type": "field",
                    "tags": [
                      "active"
                    ],
                    "customAttributes": {
                      "format": "string"
                    }
                  },
                  {
                    "id": "sat.vehicle.nav.pilotName",
                    "label": "PilotName",
                    "type": "field",
                    "tags": [
                      "active",
                   "pending"
                    ],
                    "customAttributes": {
                      "format": "string",
                      "classified": "yes",
                      "domain": ["personnel","navigation"]
                    }
                  }
                ]
              },
              {
                "id": "sat.vehicle.heartbeatTs",
                "label": "HeartbeatTs",
                "type": "field",
                "customAttributes": {
                  "format": "datetime"
                },
                "note": "Telemetry heartbeat timestamp  not mapped."
              }
            ]
          }
        ]
      }
    },
    {
      "id": "lab",
      "_autoId": true,
      "label": "Lab",
      "note": "Research analysis pipeline. Processes raw telemetry into normalized experiment data.",
      "color": "#10b981",
      "schema": {
        "id": "lab",
        "_autoId": true,
        "label": "Lab",
        "type": "group",
        "children": [
          {
            "id": "lab.experiment",
            "label": "EXPERIMENT",
            "type": "group",
            "tags": ["active"],
            "note": "Primary experiment data from telemetry.",
            "children": [
              {
                "id": "lab.experiment.experiment_ref",
                "_autoId": true,
                "label": "experiment_ref",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.experiment.experiment_name",
                "_autoId": true,
                "label": "experiment_name",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.experiment.objective_slug",
                "label": "objective_slug",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.experiment.payload_mass",
                "_autoId": true,
                "label": "payload_mass",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal",
                  "domain": ["science","telemetry"]
                }
              },
              {
                "id": "lab.experiment.payload_mass_norm",
                "label": "payload_mass_norm",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                },
                "note": "Mass normalized to standard gravity units."
              },
              {
                "id": "lab.experiment.fuel_reserve",
                "_autoId": true,
                "label": "fuel_reserve",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal",
                  "domain": ["science","navigation"]
                }
              },
              {
                "id": "lab.experiment.sample_analysis",
                "label": "SAMPLE_ANALYSIS",
                "type": "group",
                "note": "Nested group: laboratory sample breakdown.",
                "children": [
                  {
                    "id": "lab.experiment.sample_analysis.sample_id",
                "_autoId": true,
                    "label": "sample_id",
                    "type": "field",
                    "tags": ["active"],
                    "customAttributes": { "format": "string" }
                  },
                  {
                    "id": "lab.experiment.sample_analysis.composition",
                    "label": "composition",
                    "type": "field",
                    "tags": ["active", "critical"],
                    "customAttributes": { "format": "string", "domain": ["science"] }
                  },
                  {
                    "id": "lab.experiment.sample_analysis.mass_mg",
                    "label": "mass_mg",
                    "type": "field",
                    "tags": ["active"],
                    "customAttributes": { "format": "decimal" }
                  }
                ]
              }
            ]
          },
          {
            "id": "lab.personnel",
            "label": "PERSONNEL",
            "type": "group",
            "color": "#ec4899",
            "children": [
              {
                "id": "lab.personnel.team_code",
                "_autoId": true,
                "label": "team_code",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.personnel.lead_callsign",
                "label": "lead_callsign",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "lab.personnel.lead_name",
                "_autoId": true,
                "label": "lead_name",
                "type": "field",
                "tags": [
                  "active",
                   "pending"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "yes"
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "arch",
      "label": "Archive DB",
      "note": "Long-term storage. Star schema with dim_ and fact_ tables for historical analysis.",
      "color": "#64748b",
      "schema": {
        "id": "arch",
        "label": "Archive DB",
        "type": "group",
        "children": [
          {
            "id": "arch.dim_mission",
                "_autoId": true,
            "label": "dim_mission",
            "type": "group",
            "children": [
              {
                "id": "arch.dim_mission.mission_id",
                "_autoId": true,
                "label": "mission_id",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.dim_mission.mission_name",
                "_autoId": true,
                "label": "mission_name",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.dim_mission.objective_cd",
                "label": "objective_cd",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.dim_mission.mass_kg",
                "_autoId": true,
                "label": "mass_kg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                },
                "note": "Launch mass, rounded to 2 decimals."
              },
              {
                "id": "arch.dim_mission.mass_kg_norm",
                "label": "mass_kg_norm",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                }
              },
              {
                "id": "arch.dim_mission.fuel_kg",
                "label": "fuel_kg",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "decimal"
                }
              }
            ]
          },
          {
            "id": "arch.dim_crew",
                "_autoId": true,
            "label": "dim_crew",
            "type": "group",
            "tags": ["active"],
            "customAttributes": { "classified": "yes" },
            "note": "Crew dimension  contains restricted personnel data.",
            "color": "#6366f1",
            "children": [
              {
                "id": "arch.dim_crew.crew_id",
                "_autoId": true,
                "label": "crew_id",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.dim_crew.crew_name",
                "_autoId": true,
                "label": "crew_name",
                "type": "field",
                "tags": [
                  "active",
                   "pending"
                ],
                "customAttributes": {
                  "format": "string",
                  "classified": "yes"
                }
              },
              {
                "id": "arch.dim_crew.crew_callsign",
                "label": "crew_callsign",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              }
            ]
          },
          {
            "id": "arch.fact_telemetry",
                "_autoId": true,
            "label": "fact_telemetry",
            "type": "group",
            "color": "#0ea5e9",
            "children": [
              {
                "id": "arch.fact_telemetry.mission_id",
                "_autoId": true,
                "label": "mission_id",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.fact_telemetry.orbit_cd",
                "label": "orbit_cd",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "arch.fact_telemetry.recorded_ts",
                "_autoId": true,
                "label": "recorded_ts",
                "type": "field",
                "tags": [
                  "active",
                  "critical"
                ],
                "customAttributes": {
                  "format": "datetime"
                },
                "note": "Archive ingestion timestamp  generated, not mapped."
              }
            ]
          }
        ]
      }
    },
    {
      "id": "obs",
      "_autoId": true,
      "label": "Obs",
      "note": "Ground-based tracking and analysis. Feeds enrichment data back to the archive.",
      "color": "#f59e0b",
      "schema": {
        "id": "obs",
        "_autoId": true,
        "label": "Obs",
        "type": "group",
        "children": [
          {
            "id": "obs.tracking",
            "label": "Tracking",
            "type": "group",
            "children": [
              {
                "id": "obs.tracking.missionKey",
                "label": "MissionKey",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              },
              {
                "id": "obs.tracking.orbitBucket",
                "label": "OrbitBucket",
                "type": "field",
                "tags": [
                  "active"
                ],
                "customAttributes": {
                  "format": "string"
                }
              }
            ]
          },
          {
            "id": "obs.validation",
            "label": "Validation",
            "type": "group",
            "tags": ["pending"],
            "note": "Validation rules still being calibrated.",
            "color": "#eab308",
            "children": [
              {
                "id": "obs.validation.isNominal",
                "label": "IsNominal",
                "type": "field",
                "tags": [
                  "pending",
                   "active"
                ],
                "customAttributes": {
                  "format": "boolean"
                },
                "note": "Trajectory nominal flag  validation thresholds still being tuned."
              },
              {
                "id": "obs.validation.anomalyCodes",
                "label": "AnomalyCodes",
                "type": "field",
                "tags": [
                  "pending"
                ],
                "customAttributes": {
                  "format": "string"
                },
                "note": "Pipe-separated anomaly codes from ground tracking."
              }
            ]
          }
        ]
      }
    }
  ],
  "tagCatalog": [
    {
      "id": "status",
      "_autoId": true,
      "label": "Status",
      "abbr": "ST",
      "emoji": "",
      "displayMode": "emoji",
      "color": "#6366f1",
      "note": "Category tag  groups lifecycle status tags.",
      "metaOnly": true,
      "priority": 1
    },
    {
      "id": "category",
      "_autoId": true,
      "label": "Category",
      "abbr": "CT",
      "emoji": "",
      "displayMode": "emoji",
      "color": "#8b5cf6",
      "note": "Category tag  groups domain/purpose tags.",
      "metaOnly": true,
      "priority": 2
    },
    {
      "id": "active",
      "_autoId": true,
      "label": "Active",
      "abbr": "A",
      "emoji": "",
      "displayMode": "emoji",
      "color": "#22c55e",
      "note": "Field is active in production.",
      "priority": 3,
      "tags": ["status"]
    },
    {
      "id": "pending",
      "_autoId": true,
      "label": "Pending",
      "abbr": "?",
      "emoji": "",
      "displayMode": "abbr",
      "color": "#f59e0b",
      "note": "Mapping or field is still being defined  may change.",
      "priority": 4,
      "tags": ["status"]
    },
    {
      "id": "retired",
      "_autoId": true,
      "label": "Retired",
      "abbr": "R",
      "color": "#ef4444",
      "note": "No longer in use. Kept for historical reference.",
      "priority": 5,
      "tags": ["status"]
    },
    {
      "id": "critical",
      "_autoId": true,
      "label": "Critical",
      "abbr": "!",
      "color": "#dc2626",
      "note": "High-priority field  must be mapped for go-live.",
      "priority": 6,
      "tags": ["status"]
    }
  ],
  "transformCatalog": [
    {
      "id": "trim",
      "label": "Trim whitespace",
      "abbr": "TR",
      "note": "Remove leading/trailing whitespace.",
      "color": "#22c55e",
      "tags": ["category"]
    },
    {
      "id": "upper",
      "label": "Uppercase",
      "abbr": "UP",
      "note": "Convert to uppercase.",
      "tags": ["category"]
    },
    {
      "id": "norm_ws",
      "label": "Normalize whitespace",
      "abbr": "NW",
      "note": "Collapse multiple spaces and trim.",
      "tags": ["category"]
    },
    {
      "id": "cast_dec",
      "label": "Cast to decimal",
      "abbr": "CD",
      "note": "Parse string to decimal with configurable precision.",
      "params": [
        {"id": "precision", "label": "Precision", "type": "number", "default": 2}
      ]
    },
    {
      "id": "normalize_g",
      "label": "Normalize to std gravity",
      "abbr": "NG",
      "note": "Convert mass to standard gravity units ( 9.80665)."
    },
    {
      "id": "round2",
      "label": "Round to N decimals",
      "abbr": "RN",
      "note": "Standard rounding before archival.",
      "params": [
        {"id": "decimals", "label": "Decimals", "type": "number", "default": 2}
      ]
    },
    {
      "id": "slugify",
      "label": "Slugify code",
      "abbr": "SL",
      "note": "Convert objective to lowercase slug (e.g. Geology/Core  geology-core).",
      "tags": ["category"]
    },
    {
      "id": "fallback",
      "label": "Fallback to default",
      "abbr": "FB",
      "note": "Use default value when source is null or empty.",
      "params": [
        {"id": "value", "label": "Fallback value", "type": "text", "default": ""}
      ]
    },
    {
      "id": "lookup",
      "label": "Reference lookup",
      "abbr": "LK",
      "note": "Resolve foreign key to a descriptive value via lookup table.",
      "params": [
        {"id": "table", "label": "Lookup table", "type": "text", "default": ""},
        {"id": "key", "label": "Key column", "type": "text", "default": "id"}
      ]
    }
  ],
  "customAttributeCatalog": [
    {
      "id": "format",
      "_autoId": true,
      "label": "Format",
      "abbr": "FM",
      "note": "Logical data format of the field.",
      "priority": 1,
      "displayOnNode": true,
      "tags": ["category"],
      "values": [
        {
          "id": "string",
          "_autoId": true,
          "label": "String",
          "abbr": "STR",
          "note": "Variable-length text",
          "color": "#22c55e",
          "colorEnabled": true,
          "priority": 1
        },
        {
          "id": "integer",
          "_autoId": true,
          "label": "Integer",
          "abbr": "INT",
          "note": "Whole number",
          "color": "#3b82f6",
          "colorEnabled": true,
          "priority": 2
        },
        {
          "id": "decimal",
          "_autoId": true,
          "label": "Decimal",
          "abbr": "DEC",
          "note": "Fixed-point number",
          "color": "#8b5cf6",
          "colorEnabled": true,
          "priority": 3
        },
        {
          "id": "boolean",
          "_autoId": true,
          "label": "Boolean",
          "abbr": "BOL",
          "note": "True/false flag",
          "color": "#f97316",
          "colorEnabled": true,
          "priority": 4
        },
        {
          "id": "datetime",
          "_autoId": true,
          "label": "DateTime",
          "abbr": "DT",
          "note": "ISO 8601 timestamp",
          "color": "#06b6d4",
          "colorEnabled": true,
          "priority": 5
        }
      ],
      "multi": false
    },
    {
      "id": "classified",
      "_autoId": true,
      "label": "Classified",
      "abbr": "CL",
      "note": "Whether the field contains restricted personnel information.",
      "priority": 2,
      "displayOnNode": true,
      "tags": ["status"],
      "color": "#f59e0b",
      "colorEnabled": true,
      "values": [
        {
          "id": "yes",
          "_autoId": true,
          "label": "Yes",
          "abbr": "Y",
          "note": "Restricted  need-to-know access only",
          "color": "#ef4444",
          "colorEnabled": true,
          "priority": 1
        },
        {
          "id": "no",
          "_autoId": true,
          "label": "No",
          "abbr": "N",
          "color": "#22c55e",
          "colorEnabled": false,
          "priority": 2
        }
      ],
      "multi": false
    },
    {
      "id": "domain",
      "_autoId": true,
      "label": "Domain",
      "abbr": "DM",
      "note": "Which mission domains this field participates in. Multi-select.",
      "priority": 3,
      "displayOnNode": false,
      "tags": ["category"],
      "values": [
        { "id": "telemetry", "label": "Telemetry", "abbr": "TM", "note": "Spacecraft sensor and flight data", "color": "#0ea5e9", "colorEnabled": true, "priority": 1 },
        { "id": "navigation", "label": "Navigation", "abbr": "NV", "note": "Orbit and trajectory data", "color": "#eab308", "colorEnabled": true, "priority": 2 },
        { "id": "personnel", "label": "Personnel", "abbr": "PR", "note": "Crew and team member data", "color": "#ec4899", "colorEnabled": true, "priority": 3 },
        { "id": "science", "label": "Science", "abbr": "SC", "note": "Experiment and research data", "color": "#10b981", "colorEnabled": true, "priority": 4 }
      ],
      "multi": true
    }
  ],
  "mappings": [
    {
      "from": "mc.mission.missionId",
      "to": "sat.vehicle.vehicleCode",
      "cardinality": "1:1",
      "label": "ID  Code",
      "transforms": [
        {"ref": "trim"}
      ],
      "tags": ["active"],
      "note": "Mission Control ID becomes spacecraft vehicle code."
    },
    {
      "from": "mc.mission.missionName",
      "to": "sat.vehicle.missionLabel",
      "cardinality": "1:1",
      "label": "Name copy",
      "transforms": [
        {"ref": "trim"},
        {"ref": "norm_ws"}
      ],
      "tags": ["pending"],
      "customAttributes": {"fidelity": "string"},
      "note": "Mission name flows to telemetry label."
    },
    {
      "from": "mc.mission.objectiveCode",
      "to": "sat.vehicle.objectiveTag",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "mc.mission.launchMass",
      "to": "sat.vehicle.massKg",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec", "params": {"precision": 4}}
      ]
    },
    {
      "from": "mc.mission.fuelBudget",
      "to": "sat.vehicle.fuelKg",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec"}
      ]
    },
    {
      "from": "mc.crew.crewId",
      "to": "sat.vehicle.nav.crewRef",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ]
    },
    {
      "from": "mc.crew.commanderName",
      "to": "sat.vehicle.nav.pilotName",
      "cardinality": "1:1",
      "color": "#eab308",
      "transforms": [
        {"ref": "trim"},
        {"ref": "norm_ws"}
      ]
    },
    {
      "from": "mc.crew.headcount",
      "to": "sat.vehicle.nav.pilotCallsign",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ],
      "note": "Crew headcount used to derive callsign pattern."
    },
    {
      "from": "sat.vehicle.vehicleCode",
      "to": "lab.experiment.experiment_ref",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ],
      "note": "Rename VehicleCode  experiment_ref."
    },
    {
      "from": "sat.vehicle.missionLabel",
      "to": "lab.experiment.experiment_name",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "norm_ws"}
      ]
    },
    {
      "from": "sat.vehicle.objectiveTag",
      "to": "lab.experiment.objective_slug",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "slugify"}
      ],
      "note": "Slugify objective for internal catalog."
    },
    {
      "from": "sat.vehicle.massKg",
      "to": "lab.experiment.payload_mass",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec"}
      ],
      "note": "Original mass reading."
    },
    {
      "from": "sat.vehicle.massKg",
      "to": "lab.experiment.payload_mass_norm",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec"},
        {"ref": "normalize_g"}
      ],
      "note": "Normalized mass (two transforms in sequence)."
    },
    {
      "from": "sat.vehicle.fuelKg",
      "to": "lab.experiment.fuel_reserve",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "cast_dec"}
      ]
    },
    {
      "from": "sat.vehicle.nav.crewRef",
      "to": "lab.personnel.team_code",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"},
        {"ref": "upper"}
      ]
    },
    {
      "from": "sat.vehicle.nav.pilotName",
      "to": "lab.personnel.lead_name",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "norm_ws"},
        {"ref": "fallback", "params": {"value": "UNASSIGNED"}}
      ],
      "default": "UNASSIGNED",
      "note": "Default to UNASSIGNED when pilot name is pending."
    },
    {
      "from": "sat.vehicle.nav.pilotCallsign",
      "to": "lab.personnel.lead_callsign",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "upper"}
      ]
    },
    {
      "from": "lab.experiment.experiment_ref",
      "to": "arch.dim_mission.mission_id",
      "cardinality": "1:1",
      "transforms": [],
      "note": "Direct passthrough to archive."
    },
    {
      "from": "lab.experiment.experiment_name",
      "to": "arch.dim_mission.mission_name",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "lab.experiment.objective_slug",
      "to": "arch.dim_mission.objective_cd",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "upper"}
      ]
    },
    {
      "from": "lab.experiment.payload_mass",
      "to": "arch.dim_mission.mass_kg",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "round2"}
      ],
      "note": "Round before archival."
    },
    {
      "from": "lab.experiment.payload_mass_norm",
      "to": "arch.dim_mission.mass_kg_norm",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "round2", "params": {"decimals": 4}}
      ]
    },
    {
      "from": "lab.experiment.fuel_reserve",
      "to": "arch.dim_mission.fuel_kg",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "lab.personnel.team_code",
      "to": "arch.dim_crew.crew_id",
      "cardinality": "n:1",
      "transforms": [],
      "note": "Multiple missions may share a crew."
    },
    {
      "from": "lab.personnel.lead_name",
      "to": "arch.dim_crew.crew_name",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "lab.personnel.lead_callsign",
      "to": "arch.dim_crew.crew_callsign",
      "cardinality": "1:1",
      "transforms": []
    },
    {
      "from": "arch.dim_mission.mission_id",
      "to": "obs.tracking.missionKey",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "trim"}
      ],
      "note": "Archive feeds observatory tracking."
    },
    {
      "from": "obs.tracking.missionKey",
      "to": "arch.fact_telemetry.mission_id",
      "cardinality": "1:1",
      "color": "#3b82f6",
      "transforms": [],
      "note": "Observatory writes back to archive fact table."
    },
    {
      "from": "obs.tracking.orbitBucket",
      "to": "arch.fact_telemetry.orbit_cd",
      "cardinality": "1:1",
      "transforms": [
        {"ref": "upper"}
      ]
    },
    {
      "from": "mc.forecast.arrivalWindow",
      "to": "obs.tracking.orbitBucket",
      "cardinality": "1:1",
      "color": "#f43f5e",
      "transforms": [
        {"ref": "upper"},
        {"ref": "trim"}
      ],
      "note": "Non-adjacent: Mission Control forecast feeds observatory directly."
    },
    {
      "from": "arch.dim_mission.mission_id",
      "to": "lab.experiment.experiment_ref",
      "cardinality": "1:1",
      "color": "#a855f7",
      "transforms": [],
      "note": "Bidirectional: archive can reconcile back to science lab."
    },
    {
      "from": "lab.experiment.sample_analysis.sample_id",
      "to": "arch.dim_mission.mission_id",
      "cardinality": "N:1",
      "color": "#f97316",
      "transforms": [
        {"ref": "trim"}
      ],
      "tags": ["active"],
      "note": "Links sample records back to the parent mission in archive."
    },
    {
      "from": "obs.tracking.missionKey",
      "to": "obs.validation.isNominal",
      "cardinality": "1:1",
      "color": "#06b6d4",
      "transforms": [],
      "note": "Same-column: tracking key determines nominal validation flag."
    },
    {
      "from": "lab.experiment.experiment_ref",
      "to": "lab.personnel.lead_name",
      "cardinality": "N:1",
      "color": "#22c55e",
      "transforms": [
        {"ref": "lookup", "params": {"table": "personnel_roster", "key": "experiment_id"}}
      ],
      "note": "Same-column: experiment reference resolves to the lead researcher."
    },
    {
      "from": "mc.crew.crewId",
      "to": "arch.dim_crew.crew_id",
      "cardinality": "1:1",
      "direction": "both",
      "transforms": [
        {"ref": "trim"}
      ],
      "tags": ["active"],
      "note": "Bidirectional sync: crew IDs reconciled between Mission Control and Archive."
    },
    {
      "from": "mc.crew.commanderName",
      "to": "arch.dim_crew.crew_name",
      "cardinality": "1:1",
      "direction": "both",
      "transforms": [
        {"ref": "trim"},
        {"ref": "norm_ws"}
      ],
      "note": "Bidirectional: commander name kept in sync across both systems."
    },
    {
      "from": "lab.experiment.sample_analysis.composition",
      "to": "obs.validation.anomalyCodes",
      "direction": "none",
      "note": "Linked: sample composition cross-referenced with anomaly codes for review."
    },
    {
      "from": "lab.experiment.fuel_reserve",
      "to": "arch.dim_mission.fuel_kg",
      "direction": "none",
      "note": "Linked: fuel reserve associated with archive fuel records for audit trail."
    }
  ],
  "filterCatalog": [
    {
      "id": "critical_unmapped",
      "label": "Critical & Unmapped",
      "note": "Fields tagged Critical that have no mappings yet  likely gaps.",
      "priority": 1,
      "rules": [
        { "field": "tag", "op": "has", "value": "critical" },
        { "join": "and", "field": "mapped", "op": "no", "value": "" }
      ],
      "highlight": { "bg": "#ef4444", "border": "#ef4444", "edgeColor": "#ef4444", "frameColor": "#ef4444", "bgEnabled": true, "borderEnabled": true, "edgeEnabled": false, "bold": true, "frame": true, "emoji": "" }
    },
    {
      "id": "string_fields",
      "label": "String format",
      "note": "All fields with Format = String",
      "priority": 2,
      "rules": [
        { "field": "attr:format", "op": "is", "value": "string" }
      ],
      "highlight": { "bg": "#22c55e", "border": "#22c55e", "edgeColor": "#22c55e", "frameColor": "#22c55e", "bgEnabled": true, "borderEnabled": true, "edgeEnabled": true, "bold": false, "frame": false, "emoji": "" }
    },
    {
      "id": "trimmed_fields",
      "label": "Trimmed mappings",
      "note": "Nodes connected by mappings using the Trim transform",
      "priority": 3,
      "rules": [
        { "field": "transform", "op": "has", "value": "trim" }
      ],
      "highlight": { "bg": "#a855f7", "border": "#a855f7", "edgeColor": "#a855f7", "frameColor": "#a855f7", "bgEnabled": true, "borderEnabled": false, "edgeEnabled": true, "bold": false, "frame": false, "emoji": "" }
    }
  ],
  "viewCatalog": [
    {
      "id": "full_overview",
      "label": "Full Overview",
      "note": "All columns visible, no filters, everything expanded",
      "emoji": "",
      "state": {
        "activeFilterIds": [],
        "filterMode": "hide",
        "filterLogic": "or",
        "onlyMapped": false,
        "search": "",
        "selection": [],
        "highlightMode": "chain",
        "arrowMode": "selected",
        "showSameColumn": true,
        "showDistant": true,
        "selectionDim": "all",
        "hiddenColumns": [],
        "collapsedGroups": [],
        "edgeColorScheme": "",
        "nodeColorMode": "all"
      }
    },
    {
      "id": "critical_gaps",
      "label": "Critical Gaps",
      "note": "Show only critical unmapped fields  red flags for review",
      "emoji": "",
      "state": {
        "activeFilterIds": ["critical_unmapped"],
        "filterMode": "highlight",
        "filterLogic": "or",
        "onlyMapped": false,
        "search": "",
        "selection": [],
        "highlightMode": "chain",
        "arrowMode": "selected",
        "showSameColumn": true,
        "showDistant": true,
        "selectionDim": "all",
        "hiddenColumns": ["arch"],
        "collapsedGroups": [],
        "edgeColorScheme": "",
        "nodeColorMode": "all"
      }
    },
    {
      "id": "mission_chain",
      "label": "Mission ID Chain",
      "note": "Trace missionId across all five systems",
      "emoji": "",
      "state": {
        "activeFilterIds": [],
        "filterMode": "hide",
        "filterLogic": "or",
        "onlyMapped": false,
        "search": "",
        "selection": ["mc.mission.missionId"],
        "highlightMode": "chain",
        "arrowMode": "selected",
        "showSameColumn": false,
        "showDistant": true,
        "selectionDim": "all",
        "hiddenColumns": [],
        "collapsedGroups": ["mc.mission", "mc.crew", "sat.telemetry", "sat.payload", "lab.samples", "lab.results", "arch.records", "arch.personnel", "obs.tracking", "obs.weather"],
        "edgeColorScheme": "cardinality",
        "nodeColorMode": "all"
      }
    },
    {
      "id": "data_formats",
      "label": "Data Formats",
      "note": "Color by transform to see data conversion patterns",
      "emoji": "",
      "state": {
        "activeFilterIds": ["trimmed_fields"],
        "filterMode": "highlight",
        "filterLogic": "or",
        "onlyMapped": true,
        "search": "",
        "selection": [],
        "highlightMode": "chain",
        "arrowMode": "all",
        "showSameColumn": true,
        "showDistant": true,
        "selectionDim": "all",
        "hiddenColumns": ["mc"],
        "collapsedGroups": [],
        "edgeColorScheme": "transform",
        "nodeColorMode": "all"
      }
    }
  ]
};/* =========================
   App state
========================= */
const state = {
  tab: "viewer",

  // viewer state
  lockedId: null,
  hoverId: null,
  search: "",
  onlyMapped: false,
  activeFilterIds: [],   // IDs from filterCatalog currently applied
  filterLogic: 'or',     // 'and' | 'or'  how multiple active filters combine
  filterMode: 'hide',    // 'hide' | 'dim' | 'highlight'
  arrowsOn: true,
  allArrows: false,
  showSameColumn: true,
  showDistant: true,
  selectionDim: 'all',  // 'all' | 'keepParents' | 'off'
  panMode: false,
  multiSelection: new Set(),       // multi-select: set of node IDs
  _multiCollapsed: { nodes: true, mappings: false, mapInternal: false, mapOutbound: false, mapInbound: false, mapLinked: false }, // collapse state for multi-select panel sections
  multiSelectArrowMode: 'chain',   // 'chain' | 'direct' | 'selected'  highlight mode for selections
  edgeColorScheme: '',  // '' | 'cardinality' | 'transform' | 'srcTag' | 'tgtTag' | 'srcAttr:id' | 'tgtAttr:id'
  hiddenColumns: new Set(),
  wrapColumns: false,
  tagPillsMode: 'left',    // tag pill placement: 'off', 'left', 'right'
  attrPillsMode: 'left',   // custom attribute pill placement: 'off', 'left', 'right'
  showEdgeLabels: 'always', // edge label display: 'off', 'always', 'highlight'
  nodeColorMode: 'all',    // 'all' | 'groups' | 'column' | 'off'
  
  // project state
  isDirty: false,
  
  // undo/redo
  undoStack: [],
  redoStack: [],
  maxUndoSteps: 50,

  // inline editor
  editorMode: false,
  selectedEdgeId: null,
  selectedColumnId: null,
  hoverEdgeId: null,
  // node editor UI state
  nodeEditorAttrFocus: '',
  // panel layout
  panelMode: 'right',  // 'left' | 'right' | 'bottom' | 'float' | 'hidden'
  panelWidth: 444,    // side mode width
  panelHeight: null,   // bottom mode height (null = auto)
  // data
  data: null
};

/* =========================
   DOM refs
========================= */
const viewerControls = document.getElementById("viewerControls");
const views = {
  viewer: document.getElementById("view-viewer")
};

const globalStatus = document.getElementById("globalStatus");
const viewerStatus = document.getElementById("viewerStatus");

const columnsScroller = document.getElementById("columnsScroller");
const columnsRow = document.getElementById("columnsRow");
const svgOverlay = document.getElementById("svgOverlay");
const edgesLayer = document.getElementById("edgesLayer");

const detailsMeta = document.getElementById("detailsMeta");
const detailsBody = document.getElementById("detailsBody");

const jsonArea = document.getElementById("jsonArea");
const logArea = document.getElementById("logArea");
const fileInput = document.getElementById("fileInput");


const fieldDatalist = document.getElementById("fieldDatalist");

/* Viewer controls */
const searchInput = document.getElementById("searchInput");
const clearFilterBtn = document.getElementById("clearFilterBtn");
const expandAllBtn = document.getElementById("expandAllBtn");
const collapseAllBtn = document.getElementById("collapseAllBtn");
const clearSelectionBtn = document.getElementById("clearSelectionBtn");
const onlyMappedToggle = document.getElementById("onlyMappedToggle");
const showSameColToggle = document.getElementById("showSameColToggle");
const showDistantToggle = document.getElementById("showDistantToggle");
const wrapToggle = document.getElementById("wrapToggle");
const editorModeToggle = document.getElementById("editorModeToggle");
const editorOverlay = document.getElementById("editorOverlay");
const columnsBtn = document.getElementById("columnsBtn");
const columnsPopover = document.getElementById("columnsPopover");
const columnsList = document.getElementById("columnsList");
const showAllColsBtn = document.getElementById("showAllColsBtn");
const hideUnmappedColsBtn = document.getElementById("hideUnmappedColsBtn");
const closeColumnsBtn = document.getElementById("closeColumnsBtn");
const exportCsvBtn = document.getElementById("exportCsvBtn");
const exportReportBtn = document.getElementById("exportReportBtn");
const helpBtn = document.getElementById("helpBtn");
const helpMask = document.getElementById("helpMask");
const helpModal = document.getElementById("helpModal");
const helpBody = document.getElementById("helpBody");
const closeHelpBtn = document.getElementById("closeHelpBtn");
const tagsBtn = document.getElementById("tagsBtn");
const tagsMask = document.getElementById("tagsMask");
const tagsModal = document.getElementById("tagsModal");
const tagsBody = document.getElementById("tagsBody");
const closeTagsBtn = document.getElementById("closeTagsBtn");
const addTagBtn = document.getElementById("addTagBtn");
const addTransformBtn = document.getElementById("addTransformBtn");
const addCustomAttrBtn = document.getElementById("addCustomAttrBtn");
const closeCustomAttrsBtn = document.getElementById("closeCustomAttrsBtn");
const customAttrsMask = document.getElementById("customAttrsMask");

const loadExampleBtn = document.getElementById("loadExampleBtn");
const newMappingBtn = document.getElementById("newMappingBtn");
const openProjectBtn = document.getElementById("openProjectBtn");
const saveProjectBtn = document.getElementById("saveProjectBtn");
const showAllColumnsBtn = document.getElementById("showAllColumnsBtn");
const undoBtn = document.getElementById("undoBtn");
const redoBtn = document.getElementById("redoBtn");
const addColumnLeftBtn = document.getElementById("addColumnLeftBtn");
const addColumnRightBtn = document.getElementById("addColumnRightBtn");

/* Docs */
const docsBody = document.getElementById("docsBody");

/* =========================
   In-memory indexes rebuilt on render
========================= */
let IDX = null;

function resetIndexes(){
  IDX = {
    // column order and meta
    columns: [],                 // [{id,label,schema}]
    columnIndex: new Map(),      // id -> index

    // nodes
    nodeById: new Map(),         // nodeId -> node
    parentById: new Map(),       // nodeId -> parentId
    elementById: new Map(),      // nodeId -> .node element
    rowById: new Map(),          // nodeId -> .row element
    nodeColumnById: new Map(),   // nodeId -> columnId
    fieldIds: new Set(),         // all field IDs

    // descendants
    nodeFieldDescendants: new Map(), // nodeId -> [fieldIds]

    // edges
    edges: [],                   // expanded edges {id, from, to, ...meta}
    edgesByField: new Map(),     // fieldId -> [edge]
    adjacency: new Map(),        // fieldId -> Set(connected fieldId)
    mappedFields: new Set(),     // field ids present in any edge

    // for geometry / rendering
    panelByColumnId: new Map(),  // colId -> panel element
    treeByColumnId: new Map(),   // colId -> tree element
  };
}

/* =========================
   Utilities
========================= */
const norm = s => (s ?? "").toString().toLowerCase();

function columnOf(id){
  // expects "<colId>." prefix
  const i = id.indexOf(".");
  return i > 0 ? id.slice(0, i) : null;
}
function isField(id){ return IDX.fieldIds.has(id); }

function ensureArr(map, key){ if(!map.has(key)) map.set(key, []); return map.get(key); }
function ensureSet(map, key){ if(!map.has(key)) map.set(key, new Set()); return map.get(key); }

function short(s, max=52){
  if(s === undefined || s === null) return "";
  s = String(s);
  return s.length > max ? s.slice(0, max-1) + "" : s;
}

// --- ID generation helpers (rename updates) ---
// Transliterate Unicode to ASCII (a, e, u, n, etc.)
function transliterate(s){
  return String(s).normalize('NFD').replace(/[\u0300-\u036f]/g,'');
}
function idPartFromLabel(label, {lower=false}={}){
  let s = transliterate(String(label||'').trim());
  // Replace spaces with underscore, keep existing underscores and alphanumerics.
  s = s.replace(/\s+/g,'_').replace(/[^A-Za-z0-9_]/g,'').replace(/_+/g,'_');
  if(lower) s = s.toLowerCase();
  if(!s) return '';
  // Avoid starting with a digit
  if(/^[0-9]/.test(s)) s = 'n_' + s;
  return s;
}
// Check if an object's ID is auto-derived from its label.
function isLikelyAutoId(obj){
  return !!(obj && obj._autoId);
}
function ensureUniqueId(baseId, taken){
  let id = baseId;
  let i = 2;
  while(taken.has(id)){
    id = baseId + '_' + i;
    i += 1;
    }
    return id;
}

// --- v20.1: always compute a unique ID within target parent/group (sibling scope)
function uniqueSiblingId(parentId, label, siblings) {
  const taken = new Set((siblings || []).map(n => n && n.id).filter(Boolean));
  const base = parentId + '.' + (idPartFromLabel(label, { lower:false }) || 'node');
  return ensureUniqueId(base, taken);
}

function findColumnByIdIn(data, colId){
  return (data?.columns||[]).find(c=>c && c.id===colId);
}
function replaceIdsInMappings(data, idMap){
  if(!data || !Array.isArray(data.mappings)) return;
  data.mappings.forEach(m=>{
    if(!m || typeof m!=='object') return;
    if(typeof m.from==='string' && idMap[m.from]) m.from = idMap[m.from];
    if(Array.isArray(m.to)){
      m.to = m.to.map(t => (typeof t==='string' && idMap[t]) ? idMap[t] : t);
    } else if(typeof m.to==='string' && idMap[m.to]){
      m.to = idMap[m.to];
    }
  });
}
function buildSubtreeIdMap(node, oldPrefix, newPrefix, out){
  if(!node || typeof node!=='object') return;
  const oldId = node.id;
  // Replace only the prefix for subtree
  const newId = (oldId === oldPrefix) ? newPrefix : (newPrefix + oldId.slice(oldPrefix.length));
  out[oldId] = newId;
  node.id = newId;
  (node.children||[]).forEach(ch => buildSubtreeIdMap(ch, oldPrefix, newPrefix, out));
}

// v20.1 safety net: ensure sibling IDs are unique per group (fixes any duplicate copies)
function normalizeSiblingIds(data){
  if(!data || !Array.isArray(data.columns)) return;
  const idMap = {};
  function walk(node){
    if(!node || typeof node!== 'object' || !Array.isArray(node.children)) return;
    const seen = new Map();
    for(let i=0;i<node.children.length;i++){
      const ch = node.children[i];
      if(!ch || !ch.id) continue;
      const key = ch.id;
      if(!seen.has(key)){
        seen.set(key, 1);
      } else {
        // duplicate under same parent: compute unique id and rewrite subtree
        const siblings = node.children;
        const newId = uniqueSiblingId(node.id, ch.label || ch.id, siblings);
        const oldId = ch.id;
        if(newId !== oldId){
          buildSubtreeIdMap(ch, oldId, newId, idMap);
        }
      }
    }
    // recurse after potential rewrites
    for(const ch of (node.children||[])){ walk(ch); }
  }
  for(const col of (data.columns||[])){ if(col && col.schema) walk(col.schema); }
  if(Object.keys(idMap).length){ replaceIdsInMappings(data, idMap); }
}

function renameNodeInData(data, nodeId, newLabel, explicitColId=null){
  if(!data) return nodeId;
  const colId = explicitColId || columnOf(nodeId) || nodeId;
  const col = findColumnByIdIn(data, colId);
  if(!col || !col.schema) return nodeId;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.node) return nodeId;

  // Update label only  ID is independent and stays unchanged
  loc.node.label = newLabel;
  return nodeId;
}
function renameColumnInData(data, oldColId, newLabel){
  if(!data) return oldColId;
  const col = findColumnByIdIn(data, oldColId);
  if(!col) return oldColId;

  // Update column label only  ID is independent and stays unchanged
  col.label = newLabel;
  return oldColId;
}

/* ---- ID refactoring functions ---- */

// Collect ALL node IDs across the entire project
function collectAllNodeIds(data){
  const ids = new Set();
  for(const col of (data?.columns||[])){
    if(!col || !col.schema) continue;
    (function walk(n){ if(!n) return; if(n.id) ids.add(n.id); (n.children||[]).forEach(walk); })(col.schema);
  }
  return ids;
}

// Walk all nodes in all columns, calling fn(node) for each
function walkAllNodes(data, fn){
  for(const col of (data?.columns||[])){
    if(!col || !col.schema) continue;
    (function walk(n){ if(!n) return; fn(n); (n.children||[]).forEach(walk); })(col.schema);
  }
}

// Sanitize a manually-entered ID: trim, replace spaces with underscores
function sanitizeManualId(raw){
  return (raw||'').trim().replace(/\s+/g,'_');
}

// Extract the last segment of a dotted node ID (the "local" part)
function localIdSegment(nodeId){
  if(!nodeId) return '';
  const lastDot = nodeId.lastIndexOf('.');
  return lastDot >= 0 ? nodeId.slice(lastDot + 1) : nodeId;
}

// Extract the path prefix of a dotted node ID (everything before the last dot, inclusive)
function idPathPrefix(nodeId){
  if(!nodeId) return '';
  const lastDot = nodeId.lastIndexOf('.');
  return lastDot >= 0 ? nodeId.slice(0, lastDot + 1) : '';
}

// Rename a column's ID independently from its label
function reIdColumnInData(data, oldColId, newColId){
  if(!data || !newColId || oldColId === newColId) return oldColId;
  const col = findColumnByIdIn(data, oldColId);
  if(!col) return oldColId;
  const taken = new Set((data.columns||[]).filter(c=>c && c.id!==oldColId).map(c=>c.id));
  if(taken.has(newColId)) return oldColId;

  const idMap = {};
  const root = col.schema;
  root.id = oldColId;
  buildSubtreeIdMap(root, oldColId, newColId, idMap);
  col.id = newColId;
  if(col.schema) col.schema.id = newColId;
  replaceIdsInMappings(data, idMap);

  if(data === state.data && state.hiddenColumns && state.hiddenColumns.has(oldColId)){
    state.hiddenColumns.delete(oldColId);
    state.hiddenColumns.add(newColId);
  }
  return newColId;
}

// Rename a node's ID independently from its label
function reIdNodeInData(data, oldNodeId, newNodeId, explicitColId){
  if(!data || !newNodeId || oldNodeId === newNodeId) return oldNodeId;
  // Check global uniqueness (excluding the node's own subtree)
  const allIds = collectAllNodeIds(data);
  // Remove the old subtree IDs (they'll be rewritten)
  const colId = explicitColId || columnOf(oldNodeId) || oldNodeId;
  const col = findColumnByIdIn(data, colId);
  if(!col || !col.schema) return oldNodeId;
  const loc = locateNode(col.schema, oldNodeId);
  if(!loc || !loc.node) return oldNodeId;
  // Remove old subtree from taken set
  (function removeOld(n){ if(!n) return; allIds.delete(n.id); (n.children||[]).forEach(removeOld); })(loc.node);
  // Check if new id or any projected descendant collides
  if(allIds.has(newNodeId)) return oldNodeId;

  const idMap = {};
  buildSubtreeIdMap(loc.node, oldNodeId, newNodeId, idMap);
  // Verify no collisions with projected new ids
  for(const nid of Object.values(idMap)){
    if(allIds.has(nid)) {
      // Collision  revert by rebuilding with old ids
      buildSubtreeIdMap(loc.node, newNodeId, oldNodeId, {});
      return oldNodeId;
    }
  }
  replaceIdsInMappings(data, idMap);
  return newNodeId;
}

// Rename a tag's ID and update all node.tags references
function reIdTagInData(data, oldTagId, newTagId){
  if(!data || !newTagId || oldTagId === newTagId) return oldTagId;
  const cat = data.tagCatalog || [];
  const tag = cat.find(t => t && t.id === oldTagId);
  if(!tag) return oldTagId;
  if(cat.some(t => t && t.id === newTagId && t !== tag)) return oldTagId;
  tag.id = newTagId;
  walkAllNodes(data, n => {
    if(Array.isArray(n.tags)) n.tags = n.tags.map(t => t === oldTagId ? newTagId : t);
  });
  return newTagId;
}

// Rename a custom attribute's ID and update all node.customAttributes keys
function reIdCustomAttrInData(data, oldAttrId, newAttrId){
  if(!data || !newAttrId || oldAttrId === newAttrId) return oldAttrId;
  const cat = data.customAttributeCatalog || [];
  const attr = cat.find(a => a && a.id === oldAttrId);
  if(!attr) return oldAttrId;
  if(cat.some(a => a && a.id === newAttrId && a !== attr)) return oldAttrId;
  attr.id = newAttrId;
  walkAllNodes(data, n => {
    if(n.customAttributes && typeof n.customAttributes === 'object' && !Array.isArray(n.customAttributes)){
      if(oldAttrId in n.customAttributes){
        n.customAttributes[newAttrId] = n.customAttributes[oldAttrId];
        delete n.customAttributes[oldAttrId];
      }
    }
  });
  return newAttrId;
}

// Rename a transform's ID and update all mapping.transforms references
function reIdTransformInData(data, oldTrId, newTrId){
  if(!data || !newTrId || oldTrId === newTrId) return oldTrId;
  const cat = data.transformCatalog || [];
  const tr = cat.find(t => t && t.id === oldTrId);
  if(!tr) return oldTrId;
  if(cat.some(t => t && t.id === newTrId && t !== tr)) return oldTrId;
  tr.id = newTrId;
  if(Array.isArray(data.mappings)){
    data.mappings.forEach(m => {
      if(m && Array.isArray(m.transforms)){
        m.transforms = m.transforms.map(t => {
          if(typeof t === 'string') return t === oldTrId ? newTrId : t;
          if(typeof t === 'object' && t && t.ref === oldTrId) return { ...t, ref: newTrId };
          return t;
        });
      }
    });
  }
  return newTrId;
}

// Rename a custom attribute value's ID and update all node.customAttributes values
function reIdCustomAttrValueInData(data, attrId, oldValId, newValId){
  if(!data || !newValId || oldValId === newValId) return oldValId;
  const cat = data.customAttributeCatalog || [];
  const attr = cat.find(a => a && a.id === attrId);
  if(!attr || !Array.isArray(attr.values)) return oldValId;
  const val = attr.values.find(v => v && v.id === oldValId);
  if(!val) return oldValId;
  if(attr.values.some(v => v && v.id === newValId && v !== val)) return oldValId;
  val.id = newValId;
  walkAllNodes(data, n => {
    if(n.customAttributes && typeof n.customAttributes === 'object' && !Array.isArray(n.customAttributes)){
      const cur = n.customAttributes[attrId];
      if(Array.isArray(cur)){
        n.customAttributes[attrId] = cur.map(v => String(v) === String(oldValId) ? newValId : v);
      } else if(cur !== undefined && String(cur) === String(oldValId)){
        n.customAttributes[attrId] = newValId;
      }
    }
  });
  return newValId;
}


function formatTransform(t){
  if(!t) return "";
  if(typeof t === "string") return t;
  if(Array.isArray(t)) return t.map(formatTransform).filter(Boolean).join("  ");
  if(typeof t === "object"){
    const params = t.params ? JSON.stringify(t.params) : "";
    return params ? `${t.type} ${params}` : `${t.type}`;
  }
  return String(t);
}

function edgeSortKey(e){ return `${e.from}${e.to}`; }
function compareEdgesSimple(a,b){ return edgeSortKey(a).localeCompare(edgeSortKey(b)); }




function isCompute(edge){
  if(edge.computeGroup) return true;
  const t = edge.transform;
  const check = o => o && typeof o === "object" && !Array.isArray(o) && o.type === "compute";
  if(check(t)) return true;
  if(Array.isArray(t)) return t.some(check);
  return false;
}

function isFallback(edge){
  if(edge.default !== undefined && edge.default !== null && String(edge.default) !== "") return true;
  const t = edge.transform;
  const check = o => o && typeof o === "object" && !Array.isArray(o)
    && ["defaultIfNull","defaultIfEmpty","defaultIfNullOrEmpty","coalesce"].includes(o.type);
  if(check(t)) return true;
  if(Array.isArray(t)) return t.some(check);
  return false;
}

function setGlobalStatus(text){ globalStatus.textContent = text; }
function setViewerStatus(text){ viewerStatus.textContent = text; }
function syncBrowserTitle(){
  const name = (state.data?.title || '').trim();
  document.title = name ? ('Dunnode  ' + name) : 'Dunnode';
}

// Custom alert/confirm dialogs (replaces browser prompts)
// Ensure the standard dialog body structure exists (bulk modals may replace innerHTML)
function _ensureDialogBody(){
  const dialog = document.getElementById('customDialog');
  const body = dialog?.querySelector('.modalBody');
  if(!body) return;
  if(!document.getElementById('customDialogMessage')){
    body.innerHTML = `<div id="customDialogMessage" style="font-size:15px;line-height:1.6;margin-bottom:24px;white-space:pre-wrap;"></div>
      <div id="customDialogButtons" style="display:flex;gap:8px;justify-content:flex-end;"></div>`;
  }
}
function customAlert(message){
  return new Promise((resolve) => {
    _ensureDialogBody();
    const mask = document.getElementById('customDialogMask');
    const dialog = document.getElementById('customDialog');
    const messageEl = document.getElementById('customDialogMessage');
    const buttonsEl = document.getElementById('customDialogButtons');
    
    messageEl.textContent = message;
    buttonsEl.innerHTML = '';
    const hdr = dialog.querySelector('.modalHeader');
    if(hdr) hdr.style.display = 'none';
    
    const okBtn = document.createElement('button');
    okBtn.className = 'btn';
    okBtn.textContent = 'OK';
    okBtn.style.minWidth = '80px';
    okBtn.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      resolve();
    });
    buttonsEl.appendChild(okBtn);
    
    mask.classList.add('active');
    dialog.classList.add('active');
    okBtn.focus();
    
    // Close on Escape or Enter
    const onEscape = (e) => {
      if(e.key === 'Escape' || e.key === 'Enter'){ 
        e.preventDefault();
        e.stopPropagation();
        mask.classList.remove('active');
        dialog.classList.remove('active');
        document.removeEventListener('keydown', onEscape);
        resolve();
      }
    };
    document.addEventListener('keydown', onEscape);
    
    mask.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      document.removeEventListener('keydown', onEscape);
      resolve();
    }, {once: true});
  });
}

function customConfirm(message){
  return new Promise((resolve) => {
    _ensureDialogBody();
    const mask = document.getElementById('customDialogMask');
    const dialog = document.getElementById('customDialog');
    const messageEl = document.getElementById('customDialogMessage');
    const buttonsEl = document.getElementById('customDialogButtons');
    
    messageEl.textContent = message;
    buttonsEl.innerHTML = '';
    const hdr = dialog.querySelector('.modalHeader');
    if(hdr) hdr.style.display = 'none';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.minWidth = '80px';
    cancelBtn.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      resolve(false);
    });
    
    const okBtn = document.createElement('button');
    okBtn.className = 'btn';
    okBtn.textContent = 'OK';
    okBtn.style.minWidth = '80px';
    okBtn.style.background = 'rgba(59,130,246,0.15)';
    okBtn.style.borderColor = 'rgba(59,130,246,0.4)';
    okBtn.style.color = 'rgba(96,165,250,1)';
    okBtn.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      resolve(true);
    });
    
    buttonsEl.appendChild(cancelBtn);
    buttonsEl.appendChild(okBtn);
    
    mask.classList.add('active');
    dialog.classList.add('active');
    okBtn.focus();
    
    // Enter = OK, Escape = Cancel
    const onKey = (e) => {
      if(e.key === 'Escape'){
        e.preventDefault();
        e.stopPropagation();
        mask.classList.remove('active');
        dialog.classList.remove('active');
        document.removeEventListener('keydown', onKey);
        resolve(false);
      }
      if(e.key === 'Enter'){
        e.preventDefault();
        e.stopPropagation();
        mask.classList.remove('active');
        dialog.classList.remove('active');
        document.removeEventListener('keydown', onKey);
        resolve(true);
      }
    };
    document.addEventListener('keydown', onKey);
    
    mask.addEventListener('click', () => {
      mask.classList.remove('active');
      dialog.classList.remove('active');
      document.removeEventListener('keydown', onKey);
      resolve(false);
    }, {once: true});
  });
}




// --- Transforms (mapping-level) ---
function ensureTransformCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.transformCatalog)) state.data.transformCatalog = [];
  return state.data.transformCatalog;
}
function transformById(id){
  const cat = ensureTransformCatalog();
  return cat.find(t=>t && t.id===id) || null;
}
function transformAbbr(t){
  if(!t) return '';
  const a = (t.abbr||'').trim();
  if(a) return a;
  const lbl = (t.label||t.id||'').trim();
  return lbl ? lbl.slice(0,2).toUpperCase() : '';
}
function formatTransformRef(ref){
  if(!ref) return '';
  // Legacy string format
  if(typeof ref==='string'){
    const t = transformById(ref);
    return t ? (t.label||t.id) : ref;
  }
  // Array = chain
  if(Array.isArray(ref)) return ref.map(formatTransformRef).filter(Boolean).join('  ');
  // New {ref, params} instance format
  if(typeof ref==='object' && ref.ref){
    const t = transformById(ref.ref);
    const label = t ? (t.label||t.id) : ref.ref;
    const p = ref.params;
    if(p && typeof p==='object' && Object.keys(p).length > 0){
      const pStr = Object.entries(p).map(([k,v])=>`${k}=${v}`).join(', ');
      return `${label}(${pStr})`;
    }
    return label;
  }
  // Legacy object with .type
  if(typeof ref==='object' && ref.type){
    const params = ref.params ? JSON.stringify(ref.params) : '';
    return params ? `${ref.type} ${params}` : `${ref.type}`;
  }
  return String(ref);
}

// Get the catalog ref ID from a transform instance (handles both old string and new object format)
function transformRefId(inst){
  if(!inst) return '';
  if(typeof inst === 'string') return inst;
  if(typeof inst === 'object' && inst.ref) return inst.ref;
  return '';
}

// Get abbreviated label for a transform instance
function formatTransformAbbr(inst){
  const rid = transformRefId(inst);
  const t = transformById(rid);
  if(!t) return rid;
  const label = transformDisplayLabel(t);
  const p = (typeof inst === 'object' && inst.params && Object.keys(inst.params).length > 0);
  return p ? label + '()' : label;
}

// Normalize a transforms array: convert legacy strings to {ref} objects
function normalizeTransforms(arr){
  if(!Array.isArray(arr)) return [];
  return arr.map(t => {
    if(typeof t === 'string') return { ref: t };
    if(typeof t === 'object' && t && t.ref) return t;
    return null;
  }).filter(Boolean);
}
// --- Tags (node-level) ---
const DEFAULT_TAG_COLOR = '#3b82f6';
const CATALOG_EMOJI_PICKS = ['','','','','','','','','','','','','','','','','','','','','','','',''];
function ensureTagCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.tagCatalog)) state.data.tagCatalog = [];
  return state.data.tagCatalog;
}
function tagById(id){
  const cat = ensureTagCatalog();
  return cat.find(t=>t && t.id===id) || null;
}
function normalizeNodeTags(node){
  if(!node) return [];
  if(!Array.isArray(node.tags)) node.tags = [];
  node.tags = node.tags.filter(x=>typeof x==='string' && x.trim());
  return node.tags;
}
function tagColor(tag){
  return (tag && tag.color && tag.colorEnabled !== false) ? tag.color : DEFAULT_TAG_COLOR;
}
function tagAbbr(tag){
  if(!tag) return '';
  const a = (tag.abbr||'').trim();
  if(a) return a;
  const lbl = (tag.label||tag.id||'').trim();
  return lbl ? lbl.slice(0,1).toUpperCase() : '';
}
function tagDisplayLabel(tag){
  if(!tag) return '';
  if(tag.displayMode === 'emoji' && tag.emoji) return tag.emoji;
  return tagAbbr(tag);
}
function transformDisplayLabel(t){
  if(!t) return '';
  if(t.displayMode === 'emoji' && t.emoji) return t.emoji;
  return transformAbbr(t);
}
function attrValDisplayLabel(vDef){
  if(!vDef) return '';
  if(vDef.displayMode === 'emoji' && vDef.emoji) return vDef.emoji;
  return (vDef.abbr || vDef.label || vDef.id || '');
}
function attrDisplayLabel(attr){
  if(!attr) return '';
  if(attr.displayMode === 'emoji' && attr.emoji) return attr.emoji;
  return (attr.abbr || attr.label || attr.id || '');
}
function sortTagIdsByPriority(tagIds){
  if(!tagIds || !tagIds.length) return tagIds;
  const cat = ensureTagCatalog();
  return [...tagIds].sort((a,b)=>{
    const ta = cat.find(t=>t.id===a);
    const tb = cat.find(t=>t.id===b);
    const pa = ta && typeof ta.priority==='number' ? ta.priority : 9999;
    const pb = tb && typeof tb.priority==='number' ? tb.priority : 9999;
    return pa - pb;
  });
}
function nextTagPriority(){
  const cat = ensureTagCatalog();
  let max = 0;
  cat.forEach(t=>{ if(typeof t.priority==='number' && t.priority > max) max = t.priority; });
  return max + 1;
}

// Build <option>/<optgroup> HTML for tag selectors on nodes/mappings.
// Filters out metaOnly tags and groups remaining tags by their meta-only category.
// excludeIds: array of tag IDs already assigned (excluded from options)
// opts: { includeNew: true to append "+ New tag" option, allTags: true to skip metaOnly filtering (for filter selectors) }
function _buildTagSelectOptions(excludeIds, opts){
  const o = opts || {};
  const cat = ensureTagCatalog();
  const sorted = [...cat].sort((a,b)=>{
    const pa = typeof a.priority==='number' ? a.priority : 9999;
    const pb = typeof b.priority==='number' ? b.priority : 9999;
    return pa - pb;
  });
  const metaTags = sorted.filter(t => t.metaOnly);
  const assignable = o.allTags ? sorted : sorted.filter(t => !t.metaOnly);
  const excl = new Set(excludeIds || []);
  const available = assignable.filter(t => !excl.has(t.id));

  if(!metaTags.length || o.allTags){
    let html = available.map(t => {
      const lbl = (t.abbr ? (t.abbr+'  ') : '') + (t.label||t.id);
      return `<option value="${escapeHtml(t.id)}">${escapeHtml(lbl)}</option>`;
    }).join('');
    if(o.includeNew) html += '<option value="__new__">+ New tag</option>';
    return html;
  }

  // Group available tags by ALL their meta-only parents (item can appear in multiple groups)
  const groups = {}; // metaTagId -> [tags]
  const grouped = new Set();
  for(const t of available){
    const metaParents = (t.tags || []).filter(tid => metaTags.some(m => m.id === tid));
    for(const mp of metaParents){
      if(!groups[mp]) groups[mp] = [];
      groups[mp].push(t);
      grouped.add(t.id);
    }
  }
  const ungrouped = available.filter(t => !grouped.has(t.id));

  let html = '';
  for(const mt of metaTags){
    const items = groups[mt.id];
    if(!items || !items.length) continue;
    const grpLabel = (mt.emoji ? mt.emoji + ' ' : '') + mt.label;
    html += `<optgroup label="${escapeHtml(grpLabel)}">`;
    html += items.map(t => {
      const lbl = (t.abbr ? (t.abbr+'  ') : '') + (t.label||t.id);
      return `<option value="${escapeHtml(t.id)}">${escapeHtml(lbl)}</option>`;
    }).join('');
    html += '</optgroup>';
  }
  if(ungrouped.length){
    if(html) html += `<optgroup label="Other">`;
    html += ungrouped.map(t => {
      const lbl = (t.abbr ? (t.abbr+'  ') : '') + (t.label||t.id);
      return `<option value="${escapeHtml(t.id)}">${escapeHtml(lbl)}</option>`;
    }).join('');
    if(html.includes('<optgroup label="Other">')) html += '</optgroup>';
  }
  if(o.includeNew) html += '<option value="__new__">+ New tag</option>';
  return html;
}

// Build <option>/<optgroup> HTML for attribute selectors on nodes/mappings.
// Groups attributes by meta-only tags they are tagged with.
// opts: { includeNew: true to append "+ New attribute" option }
// Build display label for catalog items (attributes, values) in dropdowns.
// Prefers emoji over abbreviation when both are set.
function _catalogItemLabel(item){
  const name = item.label || item.id;
  if(item.emoji) return item.emoji + ' ' + name;
  if(item.abbr) return item.abbr + ' \u2014 ' + name;
  return name;
}

function _buildAttrSelectOptions(opts){
  const o = opts || {};
  const cat = ensureCustomAttributeCatalog();
  const tagCat = ensureTagCatalog();
  const metaTags = tagCat.filter(t => t.metaOnly);

  if(!metaTags.length){
    let html = cat.map(a => {
      const lbl = _catalogItemLabel(a);
      return `<option value="${escapeHtml(a.id)}">${escapeHtml(lbl)}</option>`;
    }).join('');
    if(o.includeNew) html += '<option value="__new__">+ New attribute</option>';
    return html;
  }

  const groups = {};
  const grouped = new Set();
  for(const a of cat){
    const metaParents = (a.tags || []).filter(tid => metaTags.some(m => m.id === tid));
    for(const mp of metaParents){
      if(!groups[mp]) groups[mp] = [];
      groups[mp].push(a);
      grouped.add(a.id);
    }
  }
  const ungrouped = cat.filter(a => !grouped.has(a.id));

  let html = '';
  for(const mt of metaTags){
    const items = groups[mt.id];
    if(!items || !items.length) continue;
    const grpLabel = (mt.emoji ? mt.emoji + ' ' : '') + mt.label;
    html += `<optgroup label="${escapeHtml(grpLabel)}">`;
    html += items.map(a => {
      const lbl = _catalogItemLabel(a);
      return `<option value="${escapeHtml(a.id)}">${escapeHtml(lbl)}</option>`;
    }).join('');
    html += '</optgroup>';
  }
  if(ungrouped.length){
    if(html) html += `<optgroup label="Other">`;
    html += ungrouped.map(a => {
      const lbl = _catalogItemLabel(a);
      return `<option value="${escapeHtml(a.id)}">${escapeHtml(lbl)}</option>`;
    }).join('');
    if(html.includes('<optgroup label="Other">')) html += '</optgroup>';
  }
  if(o.includeNew) html += '<option value="__new__">+ New attribute</option>';
  return html;
}

// Build <option>/<optgroup> HTML for transform selectors on mappings.
// Groups transforms by meta-only tags they are tagged with.
// excludeIds: transform IDs already assigned (excluded from options)
// opts: { includeNew: true to append "+ New transform" option }
function _buildTransformSelectOptions(excludeIds, opts){
  const o = opts || {};
  const cat = ensureTransformCatalog();
  const tagCat = ensureTagCatalog();
  const metaTags = tagCat.filter(t => t.metaOnly);
  const excl = new Set(excludeIds || []);
  const available = cat.filter(t => !excl.has(t.id));

  const _optHtml = (t) => {
    const lbl = (t.abbr ? (t.abbr+'  ') : '') + (t.label||t.id) + ((t.params&&t.params.length)?' \u2699':'');
    return `<option value="${escapeHtml(t.id)}">${escapeHtml(lbl)}</option>`;
  };

  if(!metaTags.length){
    let html = available.map(_optHtml).join('');
    if(o.includeNew) html += '<option value="__new__">+ New transform</option>';
    return html;
  }

  const groups = {};
  const grouped = new Set();
  for(const t of available){
    const metaParents = (t.tags || []).filter(tid => metaTags.some(m => m.id === tid));
    for(const mp of metaParents){
      if(!groups[mp]) groups[mp] = [];
      groups[mp].push(t);
      grouped.add(t.id);
    }
  }
  const ungrouped = available.filter(t => !grouped.has(t.id));

  let html = '';
  for(const mt of metaTags){
    const items = groups[mt.id];
    if(!items || !items.length) continue;
    const grpLabel = (mt.emoji ? mt.emoji + ' ' : '') + mt.label;
    html += `<optgroup label="${escapeHtml(grpLabel)}">`;
    html += items.map(_optHtml).join('');
    html += '</optgroup>';
  }
  if(ungrouped.length){
    if(html) html += `<optgroup label="Other">`;
    html += ungrouped.map(_optHtml).join('');
    if(html.includes('<optgroup label="Other">')) html += '</optgroup>';
  }
  if(o.includeNew) html += '<option value="__new__">+ New transform</option>';
  return html;
}

// --- Tag creation modal (auto id + preset colors) ---

// 
// Catalog item tags ("tags on tags")
// 
// Renders a tag selector row for use inside catalog inline editors.
// excludeId: optional tag ID to exclude from the dropdown (prevents self-tagging)
function _catTagRowHtml(itemTags, excludeId){
  const cat = ensureTagCatalog();
  const tags = Array.isArray(itemTags) ? itemTags : [];
  const chips = tags.map(tid => {
    const t = cat.find(x => x.id === tid);
    if(!t) return '';
    const color = (t.color && t.colorEnabled !== false) ? t.color : DEFAULT_TAG_COLOR;
    return `<span class="tagChip catItemTag" data-tid="${escapeHtml(tid)}" style="background:${escapeHtml(color)};color:#fff;font-size:10px;cursor:pointer;padding:1px 7px;" title="Click to remove">${escapeHtml(tagDisplayLabel(t))}</span>`;
  }).join('');
  const chipsHtml = chips || '<span class="empty" style="font-size:10px;">None</span>';
  return `<div class="k">Category</div><div class="v"><div class="catItemTagWrap" style="display:flex;gap:4px;flex-wrap:wrap;align-items:center;">
    ${chipsHtml}
    <select class="inp catItemTagSel" style="max-width:160px;font-size:11px;flex:0 0 auto;" data-exclude="${escapeHtml(excludeId||'')}"><option value="">+ Category</option></select>
  </div></div>`;
}

// Wire up tag selector events inside a catalog card
function _wireCatTagSelector(card){
  const wrap = card.querySelector('.catItemTagWrap');
  if(!wrap) return;

  const rebuildDropdown = () => {
    const sel = wrap.querySelector('.catItemTagSel');
    if(!sel) return;
    const excludeId = sel.dataset.exclude || '';
    const assigned = [...wrap.querySelectorAll('.catItemTag')].map(c => c.dataset.tid);
    const cat = ensureTagCatalog();
    const sorted = [...cat].sort((a,b) => (a.priority||0) - (b.priority||0));
    sel.innerHTML = '<option value="">+ Category</option>' + sorted
      .filter(t => t.metaOnly && t.id !== excludeId && !assigned.includes(t.id))
      .map(t => {
        const emoji = t.emoji ? t.emoji + ' ' : '';
        return `<option value="${escapeHtml(t.id)}">${emoji}${escapeHtml(t.label||t.id)}</option>`;
      }).join('');
  };

  // Remove chip on click
  wrap.addEventListener('click', (e) => {
    const chip = e.target.closest('.catItemTag');
    if(!chip) return;
    chip.remove();
    // Remove "No tags" placeholder if present
    const empty = wrap.querySelector('.empty');
    if(!wrap.querySelector('.catItemTag') && !empty){
      wrap.insertAdjacentHTML('afterbegin', '<span class="empty" style="font-size:10px;">None</span>');
    }
    rebuildDropdown();
    const _kick = card.querySelector('[data-act="save"]');
    if(_kick && _kick.__dirtyUpdate) _kick.__dirtyUpdate();
  });

  // Add from dropdown
  const sel = wrap.querySelector('.catItemTagSel');
  if(sel) sel.addEventListener('change', () => {
    const tid = sel.value;
    if(!tid) return;
    const cat = ensureTagCatalog();
    const t = cat.find(x => x.id === tid);
    if(!t) return;
    // Remove "No tags" placeholder
    const empty = wrap.querySelector('.empty');
    if(empty) empty.remove();
    const color = (t.color && t.colorEnabled !== false) ? t.color : DEFAULT_TAG_COLOR;
    const chipHtml = `<span class="tagChip catItemTag" data-tid="${escapeHtml(tid)}" style="background:${escapeHtml(color)};color:#fff;font-size:10px;cursor:pointer;padding:1px 7px;" title="Click to remove">${escapeHtml(tagDisplayLabel(t))}</span>`;
    sel.insertAdjacentHTML('beforebegin', chipHtml);
    sel.value = '';
    rebuildDropdown();
    const _kick = card.querySelector('[data-act="save"]');
    if(_kick && _kick.__dirtyUpdate) _kick.__dirtyUpdate();
  });

  rebuildDropdown();
}

// Read selected tag IDs from a catalog card
function _readCatTags(card){
  return [...card.querySelectorAll('.catItemTag')].map(c => c.dataset.tid);
}

// Render small inline tag pills for non-editing catalog cards
function _catTagPillsHtml(itemTags){
  if(!Array.isArray(itemTags) || !itemTags.length) return '';
  const cat = ensureTagCatalog();
  const pills = itemTags.map(tid => {
    const t = cat.find(x => x.id === tid);
    if(!t) return '';
    const color = (t.color && t.colorEnabled !== false) ? t.color : DEFAULT_TAG_COLOR;
    return `<span class="tagChip" style="background:${escapeHtml(color)};color:#fff;font-size:8px;padding:0 5px;pointer-events:none;">${escapeHtml(tagDisplayLabel(t))}</span>`;
  }).filter(Boolean).join('');
  return pills ? `<div style="display:flex;gap:3px;flex-wrap:wrap;margin-top:3px;">${pills}</div>` : '';
}


// --- Transform creation modal (catalog-based; no browser prompts) ---

function slugifyTagLabel(label){
  return transliterate(String(label||''))
    .trim()
    .toLowerCase()
    .replace(/\s+/g,'_')
    .replace(/[^a-z0-9_\-]/g,'')
    .replace(/_+/g,'_')
    .replace(/^_+|_+$/g,'');
}

function slugifyTransformLabel(label){
  return transliterate(String(label||'')).trim().toLowerCase()
    .replace(/\s+/g,'_')
    .replace(/[^a-z0-9_\-]/g,'')
    .replace(/_+/g,'_')
    .replace(/^_+|_+$/g,'');
}
function generateTransformIdFromLabel(label){
  const base0 = slugifyTransformLabel(label) || 'transform';
  const cat = ensureTransformCatalog();
  const taken = new Set((cat||[]).map(t=>t && t.id).filter(Boolean));
  let id = base0, i = 2;
  while(taken.has(id)) { id = base0 + '_' + i; i += 1; }
  return id;
}
function openTransformCreateModal(opts={}){
  const afterCreate = opts.afterCreate || null;
  const cat = ensureTransformCatalog();
  const taken = new Set((cat||[]).map(t=>t && t.id).filter(Boolean));
  openCreateModal({
    kind: 'transform',
    title: 'Create transform',
    placeholder: 'e.g. Trim whitespace',
    hint: 'ID is generated from the label. You can override it.',
    taken,
    onCommit: ({label, id, abbr, note, color, emoji, displayMode, _autoId, _autoAbbr})=>{
      const finalAbbr = (abbr||'').trim() || label.replace(/\s+/g,'').slice(0,2).toUpperCase();
      const finalNote = (note||'').trim();
      // Read params from create modal
      const paramsContainer = document.getElementById('createParamsRows');
      const newParams = [];
      if(paramsContainer){
        paramsContainer.querySelectorAll('.trParamRow').forEach(row => {
          let pid = (row.querySelector('[data-pf="id"]')?.value||'').trim();
          const plabel = (row.querySelector('[data-pf="label"]')?.value||'').trim();
          const ptype = row.querySelector('[data-pf="type"]')?.value || 'text';
          const pdef = (row.querySelector('[data-pf="default"]')?.value||'').trim();
          if(!pid && plabel) pid = transliterate(plabel).toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
          if(pid){
            const p = { id: pid, label: plabel || pid, type: ptype };
            if(pdef !== '') p.default = ptype === 'number' ? Number(pdef) : pdef;
            newParams.push(p);
          }
        });
      }
      const cat2 = ensureTransformCatalog();
      recordChange();
      const entry = { id, label, abbr: finalAbbr, note: finalNote, _autoId, _autoAbbr };
      if(color) { entry.color = color; entry.colorEnabled = true; }
      if(emoji) entry.emoji = emoji;
      if(displayMode) entry.displayMode = displayMode;
      if(newParams.length) entry.params = newParams;
      cat2.push(entry);
      renderAll();
      renderTransformsManager();
      if(typeof afterCreate === 'function'){
        try { afterCreate(id); } catch(e){ console.error(e); }
      }
      setGlobalStatus('Created transform ' + id);
    }
  });
}


// --- Custom Attributes (node-level; catalogized keys & values) ---
function ensureCustomAttributeCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.customAttributeCatalog)) state.data.customAttributeCatalog = [];
  return state.data.customAttributeCatalog;
}
function customAttrById(id){
  const cat = ensureCustomAttributeCatalog();
  return cat.find(a=>a && a.id===id) || null;
}
function customValueById(attrId, valId){
  const a = customAttrById(attrId);
  const vals = (a && Array.isArray(a.values)) ? a.values : [];
  return vals.find(v=>v && v.id===valId) || null;
}
function customAttrLabel(id){
  const a = customAttrById(id);
  return a ? (a.label||a.id) : id;
}
function customValueLabel(attrId, valId){
  const v = customValueById(attrId, valId);
  return v ? (v.label||v.id) : valId;
}
function customAttrAbbr(a){
  if(!a) return '';
  const ab = (a.abbr||'').trim();
  if(ab) return ab;
  const lbl = (a.label||a.id||'').trim();
  return lbl ? lbl.slice(0,2).toUpperCase() : '';
}

// Per-attribute multiplicity (single vs multi)
function customAttrIsMulti(aid){
  const a = customAttrById(aid);
  // default is single-select unless explicitly marked multi
  return !!(a && a.multi);
}
function normalizeCatalogMultiFlag(){
  const cat = ensureCustomAttributeCatalog();
  (cat||[]).forEach(a=>{ if(a && typeof a==='object' && a.multi===undefined) a.multi = false; });
}
function normalizeCustomAttributes(node){
  if(!node || typeof node!=='object') return {};
  if(!node.customAttributes || typeof node.customAttributes!=='object' || Array.isArray(node.customAttributes)) node.customAttributes = {};
  for(const k of Object.keys(node.customAttributes)){
    let v = node.customAttributes[k];
    if(v===null || v===undefined){ delete node.customAttributes[k]; continue; }
    const isMulti = customAttrIsMulti(k);
    if(Array.isArray(v)){
      const arr = v.map(x=>String(x||'').trim()).filter(Boolean);
      const uniq = Array.from(new Set(arr));
      if(!uniq.length){ delete node.customAttributes[k]; continue; }
      node.customAttributes[k] = isMulti ? uniq : uniq[0];
    } else {
      const s = String(v).trim();
      if(!s) delete node.customAttributes[k];
      else node.customAttributes[k] = s;
    }
  }
  return node.customAttributes;
}


function normalizeNodeNote(node){
  if(!node || typeof node!=='object') return '';
  if(node.note===undefined || node.note===null) node.note='';
  if(typeof node.note!=='string') node.note = String(node.note);
  return node.note;
}
const TAG_COLOR_PRESETS = [
  {name:'Blue', value:'#3b82f6'},
  {name:'Cyan', value:'#06b6d4'},
  {name:'Green', value:'#22c55e'},
  {name:'Lime', value:'#84cc16'},
  {name:'Amber', value:'#f59e0b'},
  {name:'Orange', value:'#f97316'},
  {name:'Rose', value:'#f43f5e'},
  {name:'Purple', value:'#a855f7'},
  {name:'Slate', value:'#64748b'},
  {name:'Teal', value:'#14b8a6'},
];

// Build preset swatch row that syncs with a color input
function buildColorSwatches(container, targetInput, applyCheckbox, dirtyFn){
  if(!container) return;
  container.innerHTML = '';
  TAG_COLOR_PRESETS.forEach(p=>{
    const s = document.createElement('div');
    s.className = 'swatch';
    s.style.cssText = 'width:14px;height:14px;border-radius:5px;box-shadow:none;flex-shrink:0;';
    s.style.background = p.value;
    s.title = p.name;
    s.addEventListener('click', ()=>{
      if(targetInput){
        targetInput.value = p.value;
        targetInput.style.opacity = '1';
        targetInput.dispatchEvent(new Event('input', {bubbles:true}));
      }
      if(applyCheckbox) applyCheckbox.checked = true;
      container.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
      s.classList.add('sel');
      if(dirtyFn) dirtyFn();
    });
    container.appendChild(s);
  });
}

let __tagCreateCtx = { attachNodeId: null, afterCreate: null };

function openTagCreateModal(opts={}){
  __tagCreateCtx.attachNodeId = opts.attachNodeId || null;
  __tagCreateCtx.afterCreate = opts.afterCreate || null;
  const cat = ensureTagCatalog();
  const taken = new Set((cat||[]).map(t=>t && t.id).filter(Boolean));
  openCreateModal({
    kind: 'tag',
    title: 'Create tag',
    placeholder: 'e.g. Screening',
    hint: 'ID is generated from the label. You can override it.',
    taken,
    onCommit: ({label, id, abbr, note, color, emoji, displayMode, _autoId, _autoAbbr})=>{
      const finalAbbr = (abbr||'').trim() || label.slice(0,1).toUpperCase();
      const finalColor = color || DEFAULT_TAG_COLOR;
      const finalNote = (note||'').trim();
      const cat2 = ensureTagCatalog();
      recordChange();
      const newTag = { id, label, abbr: finalAbbr, color: finalColor, colorEnabled: true, note: finalNote, priority: nextTagPriority(), _autoId, _autoAbbr };
      if(emoji) newTag.emoji = emoji;
      if(displayMode) newTag.displayMode = displayMode;
      cat2.push(newTag);
      // Attach to node if requested
      if(__tagCreateCtx.attachNodeId){
        const node = IDX?.nodeById?.get(__tagCreateCtx.attachNodeId);
        if(node){
          normalizeNodeTags(node);
          if(!node.tags.includes(id)) node.tags.push(id);
          state.lockedId = __tagCreateCtx.attachNodeId;
          state.hoverId = null;
        }
      }
      if(__tagCreateCtx.afterCreate === 'tagsManager'){
        renderTagsManager();
      }
      renderAll();
      applyHighlight();
      setGlobalStatus('Created tag ' + id);
    }
  });
}

function currentEffectiveId(){
  return state.hoverId ?? state.lockedId ?? null;
}

/* =========================
   Validation (Editor)
========================= */

// =========================
// New blank mapping (two empty columns)
// =========================
function createBlankMappingData(){
  return {
    title: 'New Project',
    subtitle: '',
    description: '',
    author: '',
    organization: '',
    contact: '',
    url: '',
    projectVersion: '',
    date: '',
    _app: { name: 'Dunnode', version: APP_VERSION, schema: 1 },
    _savedAt: '',
    columns: [
      { id:'a', label:'A', _autoId: true, schema:{ id:'a', label:'A', _autoId: true, type:'group', children: [] } },
      { id:'b', label:'B', _autoId: true, schema:{ id:'b', label:'B', _autoId: true, type:'group', children: [] } },
    ],
    mappings: [],
    tagCatalog: [],
  transformCatalog: [],
    customAttributeCatalog: [],
    filterCatalog: [],
    viewCatalog: []
  };
}
async function startNewMapping(){
  const ok = await customConfirm(`Start a new project?\n\nAny unsaved changes to the current project will be lost.\nMake sure you\u2019ve saved your work first.`);
  if(!ok) return;
  state.data = createBlankMappingData();
  // Reset selection + filters
  state.lockedId = null; state.hoverId = null; state.selectedColumnId = null; state.selectedEdgeId = null; state.multiSelection.clear();
  // Clear any in-flight edit sessions (prevents stale abandon guards)
  __editSnapshot = null;
  __edgeEditSession = null;
  state.search = ''; if(searchInput) searchInput.value='';
  state.hiddenColumns = new Set();
  state.onlyMapped = false; if(onlyMappedToggle) onlyMappedToggle.checked=false;
  const _omWrap2 = document.getElementById('onlyMappedWrap'); if(_omWrap2) _omWrap2.classList.remove('active');
  state.activeFilterIds = [];
  state.filterMode = 'hide';
  state.filterLogic = 'or';
  if(typeof updateFilterModeUI==='function') updateFilterModeUI();
  if(typeof updateFilterLogicUI==='function') updateFilterLogicUI();
  renderActiveFilterChips(); updateFilterBadge();
  state.allArrows = false; state.arrowsOn = true; state.showSameColumn = true; state.showDistant = true;
  if(showSameColToggle) showSameColToggle.checked = true;
  if(showDistantToggle) showDistantToggle.checked = true;
  if(typeof updateArrowModeUI==='function') updateArrowModeUI();
  // Tag manager should show empty state
  // Sync editor JSON + structured list
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  validateEditor();
  clearUndoHistory(); // Clear undo on new project
  renderAll();
  markClean(); // Fresh project, not dirty (after renderAll normalizes data)
  applyHighlight();
  setGlobalStatus('Started a new blank mapping.');
}

function validateData(data){
  const errors = [];
  const warnings = [];
  if(!data || typeof data !== 'object'){
    errors.push('Root must be an object.');
    return { errors, warnings };
  }
  if(!Array.isArray(data.columns)){
    errors.push('columns must be an array.');
  }

  const colIds = new Set();
  const nodeIds = new Set();
  const fieldIds = new Set();
  // customAttributeCatalog validation (must be ready before schema walk)
  const customAttrIds = new Set();
  const customValIdsByAttr = new Map();
  if(data.customAttributeCatalog !== undefined){
    if(!Array.isArray(data.customAttributeCatalog)) errors.push('customAttributeCatalog must be an array when present.');
    else {
      for(const a of data.customAttributeCatalog){
        if(!a || typeof a!=='object'){ warnings.push('customAttributeCatalog contains a non-object entry.'); continue; }
        if(!a.id || typeof a.id!=='string'){ errors.push('customAttributeCatalog entry missing string id.'); continue; }
        if(customAttrIds.has(a.id)) errors.push('Duplicate customAttributeCatalog id: ' + a.id);
        customAttrIds.add(a.id);
        const vset = new Set();
        const vals = Array.isArray(a.values) ? a.values : [];
        for(const v of vals){
          if(!v || typeof v!=='object'){ warnings.push('customAttributeCatalog['+a.id+'] has a non-object value.'); continue; }
          if(!v.id || typeof v.id!=='string'){ errors.push('customAttributeCatalog['+a.id+'] value missing string id.'); continue; }
          if(vset.has(v.id)) errors.push('Duplicate value id in customAttributeCatalog['+a.id+']: ' + v.id);
          vset.add(v.id);
        }
        customValIdsByAttr.set(a.id, vset);
      }
    }
  }


  function walk(node, parentId, colId){
    if(!node || typeof node !== 'object') return;
    if(!node.id || typeof node.id !== 'string'){
      errors.push(`Node missing string id in column '${colId}'.`);
      return;
    }
    if(nodeIds.has(node.id)) errors.push(`Duplicate node id: ${node.id}`);
    nodeIds.add(node.id);
    if(node.id !== colId && !node.id.startsWith(colId + '.')){
      warnings.push(`Node id '${node.id}' does not start with column prefix '${colId}.' (recommended). Root can be exactly '${colId}'.`);
    }
    if(node.type === 'field') fieldIds.add(node.id);
    else if(node.type !== 'group') warnings.push(`Node '${node.id}' has unknown type '${node.type}'. Expected 'group' or 'field'.`);
    if(node.note !== undefined && node.note !== null && typeof node.note !== 'string') warnings.push(`Node '${node.id}' note should be a string.`);
    if(node.customAttributes !== undefined){
      if(!node.customAttributes || typeof node.customAttributes !== 'object' || Array.isArray(node.customAttributes)) errors.push(`Node '${node.id}' customAttributes must be an object {aid: valueId or [valueId,...]}.`);
      else {
        for(const [aid, vid] of Object.entries(node.customAttributes||{})){
          if(customAttrIds.size && !customAttrIds.has(aid)) errors.push(`Node '${node.id}' references unknown custom attribute: ${aid}`);
          const vset = customValIdsByAttr.get(aid);
          if(vset){
            if(Array.isArray(vid)){
              for(const one of vid){
                if(one && !vset.has(String(one))) errors.push(`Node '${node.id}' references unknown custom attribute value: ${aid}.${one}`);
              }
            } else {
              if(vid && !vset.has(String(vid))) errors.push(`Node '${node.id}' references unknown custom attribute value: ${aid}.${vid}`);
            }
          // enforce catalog multiplicity (single vs multi)
          const def = (data.customAttributeCatalog||[]).find(x=>x && x.id===aid);
          const isMulti = !!(def && def.multi);
          if(!isMulti && Array.isArray(vid) && vid.length>1){
            errors.push(`Node '${node.id}' custom attribute '${aid}' is single-select but has multiple values.`);
          }
          }
        }
      }
    }
    if(Array.isArray(node.children)) node.children.forEach(ch=>walk(ch, node.id, colId));
  }

  if(Array.isArray(data.columns)){
    for(const c of data.columns){
      if(!c || typeof c !== 'object'){ errors.push('Each column must be an object.'); continue; }
      if(!c.id || typeof c.id !== 'string'){ errors.push('Each column requires a string id.'); continue; }
      if(colIds.has(c.id)) errors.push(`Duplicate column id: ${c.id}`);
      colIds.add(c.id);
      if(!c.label || typeof c.label !== 'string') warnings.push(`Column '${c.id}' has no label (string).`);
      if(!c.schema || typeof c.schema !== 'object'){ errors.push(`Column '${c.id}' is missing schema object.`); continue; }
      if(c.schema.id !== c.id) warnings.push(`Column '${c.id}' schema root id is '${c.schema.id}'. Recommended: schema.id == column.id.`);
      walk(c.schema, null, c.id);
    }
  }

  
  // transform catalog validation (catalog-only transforms)
  const transformIds = new Set();
  if(data.transformCatalog !== undefined){
    if(!Array.isArray(data.transformCatalog)) errors.push('transformCatalog must be an array when present.');
    else {
      for(const t of data.transformCatalog){
        if(!t || typeof t !== 'object') { warnings.push('transformCatalog contains a non-object entry.'); continue; }
        if(!t.id || typeof t.id !== 'string') { errors.push('transformCatalog entry missing string id.'); continue; }
        if(transformIds.has(t.id)) errors.push('Duplicate transformCatalog id: ' + t.id);
        transformIds.add(t.id);
      }
    }
  }
if(!Array.isArray(data.mappings)){
    errors.push('mappings must be an array.');
  } else {
    const seen = new Set();
    let idx = 0;
    for(const m of data.mappings){
      idx++;
      if(!m || typeof m !== 'object'){ errors.push(`mappings[${idx}] must be an object.`); continue; }
      if(!m.from || typeof m.from !== 'string'){ errors.push(`mappings[${idx}].from must be a string field id.`); continue; }
      if(!m.to || typeof m.to !== 'string'){ errors.push(`mappings[${idx}].to must be a string field id.`); continue; }
      if(!fieldIds.has(m.from)) errors.push(`mappings[${idx}].from references unknown/non-field id: ${m.from}`);
      if(!fieldIds.has(m.to)) errors.push(`mappings[${idx}].to references unknown/non-field id: ${m.to}`);
      const key = `${m.from}${m.to}`;
      if(seen.has(key)) errors.push(`Duplicate mapping pair not allowed: ${key}`);
      seen.add(key);
      // catalog-only transforms: reject legacy 'transform'
      if(m.transform !== undefined && m.transform !== null && String(m.transform).trim() !== ''){
        errors.push(`mappings[${idx}].transform is not allowed. Use transforms: [<catalogId>, ...].`);
      }
      // validate transforms ids
      if(m.transforms !== undefined){
        const arr = normalizeTransforms(m.transforms);
        if(arr.length && transformIds.size===0){
          errors.push(`mappings[${idx}].transforms provided but transformCatalog is missing or empty.`);
        }
        for(const inst of arr){
          const tid = inst.ref;
          if(!tid || (typeof tid !== 'string') || !tid.trim()) continue;
          if(transformIds.size && !transformIds.has(tid)){
            errors.push(`mappings[${idx}].transforms references unknown transform id: ${tid}`);
          }
        }
      }

                }
  }

  return { errors, warnings };
}


function renderValidationLog(result){
  const { errors, warnings } = result;

  const html = [];
  html.push(`<div class="msg"><h4 class="${errors.length ? 'err' : 'ok'}">Parse/Schema</h4>`);
  if(errors.length === 0){
    html.push(`<div class="ok"> No blocking errors.</div>`);
  } else {
    html.push(`<div class="err"> ${errors.length} error(s) found. Fix before applying.</div>`);
    html.push(`<ul>` + errors.map(e => `<li>${escapeHtml(e)}</li>`).join("\n") + `</ul>`);
  }
  html.push(`</div>`);

  html.push(`<div class="msg"><h4 class="${warnings.length ? 'warn' : 'ok'}">Warnings</h4>`);
  if(warnings.length === 0){
    html.push(`<div class="ok"> No warnings.</div>`);
  } else {
    html.push(`<div class="warn"> ${warnings.length} warning(s). You can still apply, but results may be surprising.</div>`);
    html.push(`<ul>` + warnings.map(w => `<li>${escapeHtml(w)}</li>`).join("\n") + `</ul>`);
  }
  html.push(`</div>`);

  html.push(`<div class="msg"><h4>Notes</h4>
    <ul>
      <li><b>Uniqueness:</b> only one mapping is allowed per <code>from</code>  <code>to</code> pair.</li>
      <li>To reduce clutter, keep mappings on <b>Selected</b> mode and rely on hover/click highlighting.</li>
      <li>Non-adjacent mappings are supported; consider hiding same-column or distant mappings in the Graph menu if clutter increases.</li>
    </ul>
  </div>`);

  logArea.innerHTML = html.join("\n");
}


function escapeHtml(s){
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

const _isMac = /Mac|iPhone|iPad/.test(navigator.platform||navigator.userAgent||'');
function platformKbd(s){
  if(!_isMac) return s;
  return s.replace(/Ctrl\+Alt\+/g,'\u2318\u2325').replace(/Ctrl\+/g,'\u2318').replace(/Alt\+/g,'\u2325').replace(/\bDelete\b/g,'\u232B').replace(/\bShift\+/g,'\u21E7');
}

//  Shared SVG icon library 
const ICONS = {
  field:  '<svg width="12" height="12" viewBox="0 0 12 12"><path d="M6 1.5L10.5 6L6 10.5L1.5 6Z" fill="none" stroke="currentColor" stroke-width="1.2"/></svg>',
  group:  '<svg width="12" height="12" viewBox="0 0 12 12"><rect x="1.5" y="1.5" width="9" height="9" rx="1.5" fill="none" stroke="currentColor" stroke-width="1.2"/><line x1="1.5" y1="4.5" x2="10.5" y2="4.5" stroke="currentColor" stroke-width=".8" opacity=".4"/></svg>',
  column: '<svg width="12" height="12" viewBox="0 0 12 12"><rect x="2" y="1" width="8" height="10" rx="1.5" fill="none" stroke="currentColor" stroke-width="1.1"/><line x1="2" y1="3.5" x2="10" y2="3.5" stroke="currentColor" stroke-width=".8" opacity=".5"/></svg>',
  edit:     '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><path d="M7 2l3 3-7 7H0V9z"/><line x1="5.5" y1="3.5" x2="8.5" y2="6.5" opacity=".3"/></svg>',
  addFieldUp:   '<svg width="14" height="12" viewBox="0 0 14 12"><path d="M5 4.5L7.5 2L10 4.5L7.5 7Z" fill="none" stroke="currentColor" stroke-width="1"/><line x1="2" y1="1.5" x2="2" y2="7" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"/><polyline points="0.5,3.5 2,1.5 3.5,3.5" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  addFieldDown: '<svg width="14" height="12" viewBox="0 0 14 12"><path d="M5 4.5L7.5 2L10 4.5L7.5 7Z" fill="none" stroke="currentColor" stroke-width="1"/><line x1="2" y1="4" x2="2" y2="9.5" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"/><polyline points="0.5,7.5 2,9.5 3.5,7.5" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  addGroupUp:   '<svg width="14" height="12" viewBox="0 0 14 12"><rect x="5" y="2" width="6" height="6" rx="1" fill="none" stroke="currentColor" stroke-width="1"/><line x1="5" y1="4.2" x2="11" y2="4.2" stroke="currentColor" stroke-width=".6" opacity=".4"/><line x1="2" y1="1.5" x2="2" y2="7" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"/><polyline points="0.5,3.5 2,1.5 3.5,3.5" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  addGroupDown: '<svg width="14" height="12" viewBox="0 0 14 12"><rect x="5" y="2" width="6" height="6" rx="1" fill="none" stroke="currentColor" stroke-width="1"/><line x1="5" y1="4.2" x2="11" y2="4.2" stroke="currentColor" stroke-width=".6" opacity=".4"/><line x1="2" y1="4" x2="2" y2="9.5" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"/><polyline points="0.5,7.5 2,9.5 3.5,7.5" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  moveUp:   '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="10" x2="6" y2="2"/><polyline points="3,5 6,2 9,5"/></svg>',
  moveDown: '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="2" x2="6" y2="10"/><polyline points="3,7 6,10 9,7"/></svg>',
  moveLeft: '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><line x1="10" y1="6" x2="2" y2="6"/><polyline points="5,3 2,6 5,9"/></svg>',
  moveRight:'<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><line x1="2" y1="6" x2="10" y2="6"/><polyline points="7,3 10,6 7,9"/></svg>',
  indent:   '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><polyline points="2,3 5,6 2,9"/><line x1="6" y1="3" x2="10" y2="3"/><line x1="6" y1="6" x2="10" y2="6"/><line x1="6" y1="9" x2="10" y2="9"/></svg>',
  outdent:  '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><polyline points="5,3 2,6 5,9"/><line x1="6" y1="3" x2="10" y2="3"/><line x1="6" y1="6" x2="10" y2="6"/><line x1="6" y1="9" x2="10" y2="9"/></svg>',
  duplicate:'<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linejoin="round"><rect x="3.5" y="3.5" width="7" height="7" rx="1.2"/><path d="M8.5 3.5V2A1.2 1.2 0 0 0 7.3.8H2A1.2 1.2 0 0 0 .8 2v5.3A1.2 1.2 0 0 0 2 8.5h1.5"/></svg>',
  duplicatePlus:'<svg width="14" height="12" viewBox="0 0 14 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linejoin="round"><rect x="3.5" y="3.5" width="7" height="7" rx="1.2"/><path d="M8.5 3.5V2A1.2 1.2 0 0 0 7.3.8H2A1.2 1.2 0 0 0 .8 2v5.3A1.2 1.2 0 0 0 2 8.5h1.5"/><line x1="12.5" y1="2" x2="12.5" y2="5" stroke-linecap="round"/><line x1="11" y1="3.5" x2="14" y2="3.5" stroke-linecap="round"/></svg>',
  insertColLeft: '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><rect x="5" y="1" width="6" height="10" rx="1.2"/><line x1="5" y1="3.5" x2="11" y2="3.5" stroke-width=".7" opacity=".4"/><line x1="1.5" y1="3" x2="1.5" y2="9" stroke-width="1.2" stroke-dasharray="1.5 1.5"/></svg>',
  insertColRight:'<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><rect x="1" y="1" width="6" height="10" rx="1.2"/><line x1="1" y1="3.5" x2="7" y2="3.5" stroke-width=".7" opacity=".4"/><line x1="10.5" y1="3" x2="10.5" y2="9" stroke-width="1.2" stroke-dasharray="1.5 1.5"/></svg>',
  hide:     '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><path d="M1 6s2-3.5 5-3.5S11 6 11 6s-2 3.5-5 3.5S1 6 1 6z"/><line x1="2" y1="10" x2="10" y2="2"/></svg>',
  convert:  '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><path d="M9 3H3.5A1.5 1.5 0 0 0 2 4.5V5"/><polyline points="7,1 9,3 7,5"/><path d="M3 9h5.5A1.5 1.5 0 0 0 10 7.5V7"/><polyline points="5,11 3,9 5,7"/></svg>',
  trash:    '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><polyline points="1,3 11,3"/><path d="M4 3V1.5h4V3"/><path d="M2.5 3l.5 7.5a1 1 0 0 0 1 .9h4a1 1 0 0 0 1-.9L9.5 3"/></svg>',
  // Top bar icons (1414)
  newDoc:   '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 1H4a1.5 1.5 0 0 0-1.5 1.5v9A1.5 1.5 0 0 0 4 13h6a1.5 1.5 0 0 0 1.5-1.5V4.5Z"/><polyline points="8,1 8,4.5 11.5,4.5"/></svg>',
  openDoc:  '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M1.5 11V3.5A1.5 1.5 0 0 1 3 2h2.5L7 3.5h4A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 11Z"/></svg>',
  saveDoc:  '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 9.5v2a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1v-2"/><polyline points="4.5,6 7,8.5 9.5,6"/><line x1="7" y1="1.5" x2="7" y2="8.5"/></svg>',
  sun:      '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"><circle cx="7" cy="7" r="2.5"/><line x1="7" y1="1" x2="7" y2="2.5"/><line x1="7" y1="11.5" x2="7" y2="13"/><line x1="1" y1="7" x2="2.5" y2="7"/><line x1="11.5" y1="7" x2="13" y2="7"/><line x1="2.76" y1="2.76" x2="3.82" y2="3.82"/><line x1="10.18" y1="10.18" x2="11.24" y2="11.24"/><line x1="2.76" y1="11.24" x2="3.82" y2="10.18"/><line x1="10.18" y1="3.82" x2="11.24" y2="2.76"/></svg>',
  moon:     '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8.5A5.5 5.5 0 0 1 5.5 2a5.5 5.5 0 1 0 6.5 6.5Z"/></svg>',
  cmdPalette:'<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="6" height="6" rx=".5"/><circle cx="3" cy="3" r="2"/><circle cx="11" cy="3" r="2"/><circle cx="3" cy="11" r="2"/><circle cx="11" cy="11" r="2"/></svg>',
  columns:  '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2"><rect x="1" y="1" width="5" height="12" rx="1.5"/><rect x="8" y="1" width="5" height="12" rx="1.5"/><line x1="1" y1="4" x2="6" y2="4" opacity=".4"/><line x1="8" y1="4" x2="13" y2="4" opacity=".4"/></svg>',
  copy:     '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="6.5" height="6.5" rx="1"/><path d="M8 4V2.5a1 1 0 0 0-1-1H2.5a1 1 0 0 0-1 1V7a1 1 0 0 0 1 1H4"/></svg>',
  paste:    '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2.5" width="8" height="8.5" rx="1"/><path d="M4.5 2.5V2a1 1 0 0 1 1-1h1a1 1 0 0 1 1 1v.5"/></svg>',
  groupWrap:'<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="1" width="10" height="10" rx="1.5"/><line x1="1" y1="3.5" x2="11" y2="3.5" opacity=".5"/><line x1="3.5" y1="5.5" x2="8.5" y2="5.5"/><line x1="3.5" y1="7.5" x2="8.5" y2="7.5"/></svg>',
  importFields:'<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><polyline points="1,4.5 6,9.5 11,4.5"/><line x1="6" y1="9" x2="6" y2="1"/><line x1="2" y1="11" x2="10" y2="11"/></svg>',
  ungroupDissolve:'<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="1" width="10" height="10" rx="1.5" stroke-dasharray="2 2"/><line x1="3.5" y1="4.5" x2="8.5" y2="4.5"/><line x1="3.5" y1="6.5" x2="8.5" y2="6.5"/><line x1="3.5" y1="8.5" x2="8.5" y2="8.5"/></svg>',
};
function nodeIcon(type){ return type === 'group' ? ICONS.group : ICONS.field; }






// =========================
// Generic create modal (label -> id) + edit cancel snapshots
// =========================
let __createCtx = null;
function closeCreateModal(){
  const cm = document.getElementById('createMask');
  const md = document.getElementById('createModal');
  cm?.classList.remove('active', 'elevated-2');
  md?.classList.remove('active', 'elevated-2');
  // Restore button label in case it was relabeled for nested flow
  const closeBtn = document.getElementById('createCloseBtn');
  if(closeBtn) closeBtn.textContent = 'Close';
  __createCtx = null;
}
function computeAutoIdFromLabel(label, ctx){
  const raw = String(label||'').trim();
  if(!raw) return '';
  if(ctx.kind==='column'){
    const base0 = idPartFromLabel(raw, {lower:false}).replace(/\./g,'');
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0 || 'col', taken);
  }
  if(ctx.kind==='tag'){
    const base0 = slugifyTagLabel(raw) || 'tag';
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0, taken);
  }
  if(ctx.kind==='transform'){
    const base0 = slugifyTransformLabel(raw) || 'transform';
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0, taken);
  }
  if(ctx.kind==='customAttr')
  {
    const base0 = idPartFromLabel(raw, {lower:true});
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0 || 'attr', taken);
  }
  if(ctx.kind==='customAttrValue')
  {
    const base0 = idPartFromLabel(raw, {lower:true});
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0 || 'val', taken);
  }

  if(ctx.kind==='node'){
    const base0 = (ctx.parentId || ctx.colId) + '.' + (idPartFromLabel(raw, {lower:true}) || 'node');
    const taken = ctx.taken || new Set();
    return ensureUniqueId(base0 || ((ctx.parentId||ctx.colId)+'.node'), taken);
  }
  return '';
}

// Which optional fields to show per entity kind
const CREATE_FIELDS = {
  column:          { color: true, note: true },
  node:            { note: true, tags: true, customAttrs: true },
  tag:             { abbr: true, emoji: true, color: true, note: true },
  transform:       { abbr: true, emoji: true, color: true, note: true, params: true },
  customAttr:      { abbr: true, emoji: true, color: true, multi: true, note: true },
  customAttrValue: { abbr: true, emoji: true, color: true, note: true },
};

let __createSelectedColor = null;
let __createTags = [];
let __createCustomAttrs = {};
let __createModalAutoElevate = false;

function _renderCreateTagChips(){
  const wrap = document.getElementById('createTagChips'); if(!wrap) return;
  const cat = ensureTagCatalog();
  if(!__createTags.length){ wrap.innerHTML = '<span class="empty">No tags.</span>'; return; }
  wrap.innerHTML = __createTags.map(tid=>{
    const t = cat.find(x=>x.id===tid);
    const lbl = t ? (t.abbr || t.label) : tid;
    const col = t?.color || DEFAULT_TAG_COLOR;
    return `<span class="tagChip" style="background:${escapeHtml(col)};color:#fff;cursor:pointer;" data-tid="${escapeHtml(tid)}" title="Click to remove">${escapeHtml(lbl)}</span>`;
  }).join('');
  wrap.querySelectorAll('.tagChip').forEach(ch=>{
    ch.addEventListener('click', ()=>{
      __createTags = __createTags.filter(x=>x!==ch.dataset.tid);
      _renderCreateTagChips();
      _populateCreateTagSel();
    });
  });
}
function _populateCreateTagSel(){
  const sel = document.getElementById('createTagSel'); if(!sel) return;
  sel.innerHTML = '<option value="">Add tag</option>' + _buildTagSelectOptions(__createTags, {includeNew: true});
  sel.onchange = ()=>{
    const v = sel.value; if(!v) return;
    sel.value = '';
    if(v==='__new__'){
      _openNestedCreateFromNodeCreate('tag');
      return;
    }
    __createTags.push(v);
    _renderCreateTagChips();
    _populateCreateTagSel();
  };
}
function _renderCreateAttrChips(){
  const wrap = document.getElementById('createAttrChips'); if(!wrap) return;
  const cat = ensureCustomAttributeCatalog();
  const entries = Object.entries(__createCustomAttrs).filter(([,v])=>v&&v.length);
  if(!entries.length){ wrap.innerHTML = '<span class="empty">No attributes.</span>'; return; }
  wrap.innerHTML = entries.map(([aid, vals])=>{
    const a = cat.find(x=>x.id===aid);
    const aLabel = a ? a.label : aid;
    return vals.map(vid=>{
      const v = (a?.values||[]).find(x=>x.id===vid);
      const vLabel = v ? v.label : vid;
      return `<span class="tagChip" style="cursor:pointer;" data-aid="${escapeHtml(aid)}" data-vid="${escapeHtml(vid)}" title="Click to remove">${escapeHtml(aLabel)}: ${escapeHtml(vLabel)}</span>`;
    }).join('');
  }).join('');
  wrap.querySelectorAll('.tagChip').forEach(ch=>{
    ch.addEventListener('click', ()=>{
      const aid = ch.dataset.aid, vid = ch.dataset.vid;
      if(__createCustomAttrs[aid]) __createCustomAttrs[aid] = __createCustomAttrs[aid].filter(x=>x!==vid);
      if(!__createCustomAttrs[aid]?.length) delete __createCustomAttrs[aid];
      _renderCreateAttrChips();
    });
  });
}
function _populateCreateAttrSel(){
  const attrSel = document.getElementById('createAttrSel');
  const valSel = document.getElementById('createAttrValSel');
  if(!attrSel || !valSel) return;
  const cat = ensureCustomAttributeCatalog();
  attrSel.innerHTML = '<option value="">Attribute</option>' + _buildAttrSelectOptions({includeNew: true});
  valSel.innerHTML = '<option value="">Value</option>';
  attrSel.onchange = ()=>{
    const aid = attrSel.value;
    if(aid==='__new__'){
      attrSel.value = '';
      _openNestedCreateFromNodeCreate('customAttr');
      return;
    }
    const a = cat.find(x=>x.id===aid);
    const vals = a?.values || [];
    valSel.innerHTML = '<option value="">Value</option>' + vals.map(v=>
      `<option value="${escapeHtml(v.id)}">${escapeHtml(_catalogItemLabel(v))}</option>`
    ).join('') + (aid ? '<option value="__new__">+ New value</option>' : '');
  };
  valSel.onchange = ()=>{
    const aid = attrSel.value, vid = valSel.value;
    if(!aid || aid==='__new__') return;
    if(vid==='__new__'){
      valSel.value = '';
      _openNestedCreateFromNodeCreate('customAttrValue', { aid });
      return;
    }
    if(!vid) return;
    const a = cat.find(x=>x.id===aid);
    if(!__createCustomAttrs[aid]) __createCustomAttrs[aid] = [];
    if(a?.multi){
      if(!__createCustomAttrs[aid].includes(vid)) __createCustomAttrs[aid].push(vid);
    } else {
      __createCustomAttrs[aid] = [vid];
    }
    valSel.value = '';
    _renderCreateAttrChips();
  };
}

// Watch for a modal to lose '.active' class and fire callback once
function _watchModalClose(modalEl, cb){
  if(!modalEl) return;
  const obs = new MutationObserver(()=>{
    if(!modalEl.classList.contains('active')){
      obs.disconnect();
      cb();
    }
  });
  obs.observe(modalEl, { attributes: true, attributeFilter: ['class'] });
}

// Open a catalog modal elevated above the create modal, refresh on close
let __savedCreateState = null; // saved create-node-modal state during catalog visit

function _openCatalogFromCreateModal(which){
  let modal, mask, openFn, closeBtnId;
  if(which==='tags'){
    modal = document.getElementById('tagsModal');
    mask = document.getElementById('tagsMask');
    openFn = openTags;
    closeBtnId = 'closeTagsBtn';
  } else {
    modal = document.getElementById('customAttrsModal');
    mask = document.getElementById('customAttrsMask');
    openFn = openCustomAttrs;
    closeBtnId = 'closeCustomAttrsBtn';
  }

  // --- Save full create-modal state ---
  const createModal = document.getElementById('createModal');
  const createMask = document.getElementById('createMask');
  __savedCreateState = {
    ctx: __createCtx,
    tags: [...__createTags],
    customAttrs: JSON.parse(JSON.stringify(__createCustomAttrs)),
    label: document.getElementById('createLabel')?.value || '',
    idInput: document.getElementById('createIdInput')?.value || '',
    note: document.getElementById('createNote')?.value || '',
  };

  // Hide create modal (catalog takes over)
  createModal?.classList.remove('active');
  createMask?.classList.remove('active');

  // Elevate catalog above where create modal was
  if(modal) modal.classList.add('elevated');
  if(mask) mask.classList.add('elevated');

  // Relabel Close   Back
  const closeBtn = document.getElementById(closeBtnId);
  if(closeBtn) closeBtn.textContent = ' Back';

  // Flag: any openCreateModal() called while catalog is elevated should auto-elevate
  __createModalAutoElevate = true;

  openFn();

  _watchModalClose(modal, ()=>{
    __createModalAutoElevate = false;
    // Remove elevation and restore button label
    if(modal) modal.classList.remove('elevated');
    if(mask) mask.classList.remove('elevated');
    if(closeBtn) closeBtn.textContent = 'Close';

    // --- Restore create-node-modal ---
    const saved = __savedCreateState;
    __savedCreateState = null;
    if(!saved || !saved.ctx) return;

    // Re-open with saved context
    openCreateModal(saved.ctx);

    // Restore form values  but first clean up entries deleted during catalog visit
    const tagCat = ensureTagCatalog();
    const tagCatIds = new Set(tagCat.map(t=>t.id));
    __createTags = saved.tags.filter(tid=>tagCatIds.has(tid));

    const attrCat = ensureCustomAttributeCatalog();
    const attrCatIds = new Set(attrCat.map(a=>a.id));
    const cleanedAttrs = saved.customAttrs;
    for(const aid of Object.keys(cleanedAttrs)){
      if(!attrCatIds.has(aid)){ delete cleanedAttrs[aid]; continue; }
      const a = attrCat.find(x=>x.id===aid);
      const valIds = new Set((a?.values||[]).map(v=>v.id));
      cleanedAttrs[aid] = (cleanedAttrs[aid]||[]).filter(vid=>valIds.has(vid));
      if(!cleanedAttrs[aid].length) delete cleanedAttrs[aid];
    }
    __createCustomAttrs = cleanedAttrs;
    const lEl = document.getElementById('createLabel');
    const iEl = document.getElementById('createIdInput');
    const nEl = document.getElementById('createNote');
    if(lEl) lEl.value = saved.label;
    if(iEl) iEl.value = saved.idInput;
    if(nEl) nEl.value = saved.note;

    // Refresh chips and dropdowns to reflect catalog changes
    _renderCreateTagChips();
    _populateCreateTagSel();
    _renderCreateAttrChips();
    _populateCreateAttrSel();
  });
}

// Open a nested create modal from within the node create modal
// (e.g. "+ New tag", "+ New attribute", "+ New value")
function _openNestedCreateFromNodeCreate(kind, extraCtx){
  const createModal = document.getElementById('createModal');
  const createMask = document.getElementById('createMask');

  // Save full create-node-modal state
  const saved = {
    ctx: __createCtx,
    tags: [...__createTags],
    customAttrs: JSON.parse(JSON.stringify(__createCustomAttrs)),
    selectedColor: __createSelectedColor,
    label: document.getElementById('createLabel')?.value || '',
    idInput: document.getElementById('createIdInput')?.value || '',
    abbr: document.getElementById('createAbbr')?.value || '',
    note: document.getElementById('createNote')?.value || '',
    multi: document.getElementById('createMulti')?.checked || false,
    colorOn: document.getElementById('createColorOn')?.checked || false,
  };

  // Silently close current create modal
  __createCtx = null;
  createModal?.classList.remove('active');
  createMask?.classList.remove('active');

  function restoreNodeCreate(){
    openCreateModal(saved.ctx);
    // Restore collected tags/attrs
    const tagCat = ensureTagCatalog();
    const tagCatIds = new Set(tagCat.map(t=>t.id));
    __createTags = saved.tags.filter(tid=>tagCatIds.has(tid));
    const attrCat = ensureCustomAttributeCatalog();
    const attrCatIds = new Set(attrCat.map(a=>a.id));
    const cleanedAttrs = saved.customAttrs;
    for(const aid of Object.keys(cleanedAttrs)){
      if(!attrCatIds.has(aid)){ delete cleanedAttrs[aid]; continue; }
      const a = attrCat.find(x=>x.id===aid);
      const valIds = new Set((a?.values||[]).map(v=>v.id));
      cleanedAttrs[aid] = (cleanedAttrs[aid]||[]).filter(vid=>valIds.has(vid));
      if(!cleanedAttrs[aid].length) delete cleanedAttrs[aid];
    }
    __createCustomAttrs = cleanedAttrs;
    // Restore form field values
    const lEl = document.getElementById('createLabel');
    const iEl = document.getElementById('createIdInput');
    const nEl = document.getElementById('createNote');
    if(lEl) lEl.value = saved.label;
    if(iEl) iEl.value = saved.idInput;
    if(nEl) nEl.value = saved.note;
    // Refresh chips and dropdowns
    _renderCreateTagChips();
    _populateCreateTagSel();
    _renderCreateAttrChips();
    _populateCreateAttrSel();
  }

  // Track whether restoreNodeCreate was already called by onCommit
  let _nestedRestored = false;
  const _restore = ()=>{
    if(_nestedRestored) return;
    _nestedRestored = true;
    restoreNodeCreate();
  };

  if(kind === 'tag'){
    const cat = ensureTagCatalog();
    const taken = new Set(cat.map(t=>t?.id).filter(Boolean));
    openCreateModal({
      kind: 'tag',
      title: 'Create tag',
      placeholder: 'e.g. Screening',
      hint: 'ID is generated from the label.',
      taken,
      onCommit: ({label, id, abbr, note, color, emoji, displayMode, _autoId, _autoAbbr})=>{
        const finalAbbr = (abbr||'').trim() || label.slice(0,1).toUpperCase();
        const finalColor = color || DEFAULT_TAG_COLOR;
        recordChange();
        const nt = { id, label, abbr: finalAbbr, color: finalColor, colorEnabled: true, note: (note||'').trim(), priority: nextTagPriority(), _autoId, _autoAbbr };
        if(emoji) nt.emoji = emoji;
        if(displayMode) nt.displayMode = displayMode;
        ensureTagCatalog().push(nt);
        saved.tags.push(id);
        renderAll();
        _restore();
      }
    });
  } else if(kind === 'customAttr'){
    const cat = ensureCustomAttributeCatalog();
    const taken = new Set(cat.map(a=>a?.id).filter(Boolean));
    openCreateModal({
      kind: 'customAttr',
      title: 'Add custom attribute',
      placeholder: 'Attribute label',
      hint: 'ID is generated from the label.',
      taken,
      onCommit: ({label, id, abbr, note, color, multi, emoji, displayMode, _autoId, _autoAbbr})=>{
        const entry = { id, label, abbr: (abbr||'').trim() || (label||'').replace(/\s+/g,'').slice(0,2).toUpperCase(), note: (note||''), multi: !!multi, values: [], _autoId, _autoAbbr };
        if(color){ entry.color = color; entry.colorEnabled = true; }
        if(emoji) entry.emoji = emoji;
        if(displayMode) entry.displayMode = displayMode;
        recordChange();
        ensureCustomAttributeCatalog().push(entry);
        renderAll();
        _restore();
      }
    });
  } else if(kind === 'customAttrValue'){
    const aid = extraCtx?.aid;
    const a = ensureCustomAttributeCatalog().find(x=>x.id===aid);
    if(!a){ restoreNodeCreate(); return; }
    if(!Array.isArray(a.values)) a.values = [];
    const taken = new Set(a.values.map(v=>v?.id).filter(Boolean));
    openCreateModal({
      kind: 'customAttrValue',
      title: `Add value to ${a.label||a.id}`,
      placeholder: 'Value label',
      hint: 'ID is generated from the value label.',
      taken,
      onCommit: ({label, id, note, color, abbr, emoji, displayMode, _autoId, _autoAbbr})=>{
        let maxVP = 0;
        a.values.forEach(v=>{ if(v && typeof v.priority==='number' && v.priority > maxVP) maxVP = v.priority; });
        const vObj = { id, label, note: (note||''), priority: maxVP + 1, _autoId, _autoAbbr };
        if(abbr) vObj.abbr = abbr;
        if(emoji) vObj.emoji = emoji;
        if(displayMode) vObj.displayMode = displayMode;
        if(color){ vObj.color = color; vObj.colorEnabled = true; }
        recordChange();
        a.values.push(vObj);
        // Auto-add the new value to the node's custom attrs being assembled
        if(!saved.customAttrs[aid]) saved.customAttrs[aid] = [];
        if(a.multi){
          if(!saved.customAttrs[aid].includes(id)) saved.customAttrs[aid].push(id);
        } else {
          saved.customAttrs[aid] = [id];
        }
        renderAll();
        _restore();
      }
    });
  }

  // If user cancels nested create, restore node create on close
  _watchModalClose(createModal, ()=> _restore());
}

function openCreateModal(ctx){
  __createCtx = ctx;
  __createSelectedColor = TAG_COLOR_PRESETS[0].value;
  const mask = document.getElementById('createMask');
  const modal = document.getElementById('createModal');
  const title = document.getElementById('createTitle');
  const labelEl = document.getElementById('createLabel');
  const idPrefix = document.getElementById('createIdPrefix');
  const idInput = document.getElementById('createIdInput');
  const abbrEl = document.getElementById('createAbbr');
  const colorHex = document.getElementById('createColorHex');
  const colorsEl = document.getElementById('createColors');
  const multiEl = document.getElementById('createMulti');
  const noteEl = document.getElementById('createNote');
  const hint = document.getElementById('createHint');
  const ok = document.getElementById('createOkBtn');

  if(title) title.textContent = ctx.title || 'New item';
  if(labelEl){
    labelEl.value = ctx.defaultLabel || '';
    labelEl.placeholder = ctx.placeholder || 'Label';
  }
  if(hint) hint.textContent = ctx.hint || '';
  if(ok) ok.textContent = ctx.okText || 'Save';
  if(abbrEl) abbrEl.value = '';
  if(noteEl) noteEl.value = '';
  if(multiEl) multiEl.checked = false;
  if(idInput) idInput.value = '';
  const _crEmojiEl = document.getElementById('createEmoji');
  if(_crEmojiEl) _crEmojiEl.value = '';

  // Node prefix
  if(ctx.kind==='node'){
    const prefix = (ctx.parentId || ctx.colId || '') + '.';
    if(idPrefix) { idPrefix.textContent = prefix; idPrefix.style.display = ''; }
  } else {
    if(idPrefix) { idPrefix.textContent = ''; idPrefix.style.display = 'none'; }
  }

  // Show/hide optional fields
  const fields = CREATE_FIELDS[ctx.kind] || {};
  const show = (k, v) => {
    const kEl = document.getElementById('cr'+k.charAt(0).toUpperCase()+k.slice(1)+'K');
    const vEl = document.getElementById('cr'+k.charAt(0).toUpperCase()+k.slice(1)+'V');
    if(kEl) kEl.style.display = v ? '' : 'none';
    if(vEl) vEl.style.display = v ? (vEl.dataset.flex ? 'flex' : '') : 'none';
  };
  show('abbr', fields.abbr);
  show('emoji', fields.emoji);
  show('display', fields.emoji);
  show('color', fields.color);
  show('multi', fields.multi);
  show('note', true); // always show note
  show('params', fields.params);
  show('tags', fields.tags);
  show('attrs', fields.customAttrs);

  // Wire emoji picker + display mode in create modal
  let __crDM = 'abbr';
  if(fields.emoji){
    const emojiGrid = document.getElementById('createEmojiGrid');
    const crDmWrap = document.getElementById('createDisplayMode');
    if(emojiGrid) emojiGrid.innerHTML = CATALOG_EMOJI_PICKS.map(e=>`<button class="crEmojiPick" data-emoji="${e}" style="font-size:14px;padding:2px 4px;border:1px solid transparent;border-radius:5px;background:transparent;cursor:pointer;line-height:1;" title="${e}">${e}</button>`).join('') + '<button class="crEmojiPick" data-emoji="" style="font-size:10px;padding:2px 5px;border:1px solid var(--border);border-radius:5px;background:transparent;cursor:pointer;color:var(--muted);line-height:1;" title="Clear"></button>';
    const _refreshCrDm = ()=>{
      if(!crDmWrap) return;
      const has = !!(_crEmojiEl && _crEmojiEl.value.trim());
      crDmWrap.querySelectorAll('.crDmOpt').forEach(b=>{
        b.style.background = b.dataset.dm === __crDM ? 'rgba(59,130,246,.25)' : 'transparent';
        if(b.dataset.dm === 'emoji') b.style.opacity = has ? '1' : '.4';
      });
    };
    if(emojiGrid) emojiGrid.querySelectorAll('.crEmojiPick').forEach(btn => btn.addEventListener('click', (e)=>{
      e.preventDefault();
      if(_crEmojiEl) _crEmojiEl.value = btn.dataset.emoji;
      if(btn.dataset.emoji && __crDM === 'abbr') __crDM = 'emoji';
      if(!btn.dataset.emoji && __crDM === 'emoji') __crDM = 'abbr';
      _refreshCrDm();
    }));
    if(_crEmojiEl) _crEmojiEl.addEventListener('input', ()=>{
      if(_crEmojiEl.value.trim() && __crDM === 'abbr') __crDM = 'emoji';
      if(!_crEmojiEl.value.trim() && __crDM === 'emoji') __crDM = 'abbr';
      _refreshCrDm();
    });
    if(crDmWrap) crDmWrap.addEventListener('click', (e)=>{
      const btn = e.target.closest('.crDmOpt');
      if(!btn) return;
      if(btn.dataset.dm === 'emoji' && !(_crEmojiEl && _crEmojiEl.value.trim())) return;
      __crDM = btn.dataset.dm;
      _refreshCrDm();
    });
  }

  // Transform params in create modal
  if(fields.params){
    const paramsContainer = document.getElementById('createParamsRows');
    if(paramsContainer) paramsContainer.innerHTML = '';
    const addParamBtn = document.getElementById('createAddParamBtn');
    if(addParamBtn) addParamBtn.onclick = ()=>{
      if(!paramsContainer) return;
      const row = document.createElement('div');
      row.className = 'trParamRow';
      row.style.cssText = 'display:flex;gap:4px;align-items:center;margin-bottom:4px;';
      row.innerHTML = `
        <input class="inp" data-pf="label" value="" placeholder="label" style="flex:2;"/>
        <input class="inp" data-pf="id" value="" placeholder="id (auto)" style="flex:1;font-family:var(--mono);font-size:10px;"/>
        <select class="inp" data-pf="type" style="flex:0 0 70px;font-size:11px;">
          <option value="text">text</option>
          <option value="number">number</option>
        </select>
        <input class="inp" data-pf="default" value="" placeholder="default" style="flex:1;font-size:11px;"/>
        <button class="btn" style="padding:2px 6px;font-size:11px;" title="Remove"></button>
      `;
      row.querySelector('button').addEventListener('click', ()=> row.remove());
      // Auto-generate id from label whenever id is empty
      const lblInp = row.querySelector('[data-pf="label"]');
      const idInp = row.querySelector('[data-pf="id"]');
      const slugParam = (s)=> transliterate(s).trim().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
      if(lblInp && idInp){
        let _lastAuto = '';
        lblInp.addEventListener('input', ()=>{
          const cur = idInp.value.trim();
          if(!cur || cur === _lastAuto){ const a = slugParam(lblInp.value); idInp.value = a; _lastAuto = a; }
        });
        idInp.addEventListener('input', ()=>{
          if(!idInp.value.trim()){ const a = slugParam(lblInp.value); idInp.value = a; _lastAuto = a; }
          else _lastAuto = '';
        });
      }
      paramsContainer.appendChild(row);
    };
  }

  // Node tags and custom attrs in create modal
  __createTags = [];
  __createCustomAttrs = {};
  if(fields.tags){
    _renderCreateTagChips();
    _populateCreateTagSel();
    const tagMgrBtn = document.getElementById('createTagMgr');
    if(tagMgrBtn) tagMgrBtn.onclick = ()=> _openCatalogFromCreateModal('tags');
  }
  if(fields.customAttrs){
    _renderCreateAttrChips();
    _populateCreateAttrSel();
    const attrMgrBtn = document.getElementById('createAttrMgr');
    if(attrMgrBtn) attrMgrBtn.onclick = ()=> _openCatalogFromCreateModal('attrs');
  }

  // Build color swatches
  if(fields.color && colorsEl){
    colorsEl.innerHTML = '';
    const colorPicker = document.getElementById('createColorPicker');
    const colorOnCb = document.getElementById('createColorOn');
    const isAlwaysColor = (ctx.kind === 'tag'); // tags always have color
    const _dirtyKick = ()=>{ if(ok && ok.__dirtyUpdate) ok.__dirtyUpdate(); };

    // Initialize Apply state
    if(colorOnCb){
      colorOnCb.checked = isAlwaysColor;
    }
    if(colorPicker){
      colorPicker.value = __createSelectedColor || DEFAULT_TAG_COLOR;
      colorPicker.style.opacity = isAlwaysColor ? '1' : '.3';
    }
    if(colorHex){
      colorHex.value = isAlwaysColor ? (__createSelectedColor || DEFAULT_TAG_COLOR) : '';
    }

    TAG_COLOR_PRESETS.forEach(p=>{
      const s = document.createElement('div');
      s.className = 'swatch' + (isAlwaysColor && p.value===__createSelectedColor ? ' sel' : '');
      s.style.background = p.value;
      s.title = p.name + ' ' + p.value;
      s.addEventListener('click', (e)=>{
        e.stopPropagation();
        __createSelectedColor = p.value;
        if(colorHex) colorHex.value = p.value;
        if(colorPicker){ colorPicker.value = p.value; colorPicker.style.opacity = '1'; }
        if(colorOnCb) colorOnCb.checked = true;
        colorsEl.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        s.classList.add('sel');
        _dirtyKick();
      });
      colorsEl.appendChild(s);
    });
    if(colorPicker){
      colorPicker.addEventListener('input', ()=>{
        __createSelectedColor = colorPicker.value;
        if(colorHex) colorHex.value = colorPicker.value;
        colorPicker.style.opacity = '1';
        if(colorOnCb) colorOnCb.checked = true;
        colorsEl.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        _dirtyKick();
      });
    }
    if(colorHex){
      colorHex.oninput = ()=>{
        const v = (colorHex.value||'').trim();
        if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
          __createSelectedColor = v;
          if(colorPicker){ colorPicker.value = v; colorPicker.style.opacity = '1'; }
          if(colorOnCb) colorOnCb.checked = true;
          colorsEl.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        }
        _dirtyKick();
      };
    }
    if(colorOnCb){
      colorOnCb.addEventListener('change', ()=>{
        if(colorPicker) colorPicker.style.opacity = colorOnCb.checked ? '1' : '.3';
        _dirtyKick();
      });
    }
    const colorResetBtn = document.getElementById('createColorReset');
    if(colorResetBtn){
      colorResetBtn.onclick = ()=>{
        __createSelectedColor = isAlwaysColor ? DEFAULT_TAG_COLOR : '';
        if(colorPicker){ colorPicker.value = DEFAULT_TAG_COLOR; colorPicker.style.opacity = isAlwaysColor ? '1' : '.3'; }
        if(colorHex) colorHex.value = isAlwaysColor ? DEFAULT_TAG_COLOR : '';
        if(colorOnCb) colorOnCb.checked = isAlwaysColor;
        colorsEl.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
        if(isAlwaysColor){ const first = colorsEl.querySelector('.swatch'); if(first) first.classList.add('sel'); }
        _dirtyKick();
      };
    }
  }

  // ID auto-fill from label: keep updating as long as user hasn't manually edited
  __lastAutoId = '';
  const idAutoTag = document.getElementById('createIdAuto');
  const abbrAutoTag = document.getElementById('createAbbrAuto');
  const refreshId = ()=>{
    const cur = idInput ? idInput.value.trim() : '';
    if(cur && cur !== __lastAutoId) return; // user typed custom value  don't touch
    const autoId = computeAutoIdFromLabel(labelEl?.value||'', ctx);
    if(ctx.kind==='node'){
      const prefix = (ctx.parentId || ctx.colId || '') + '.';
      const seg = autoId ? autoId.slice(prefix.length) : '';
      if(seg){ if(idInput) idInput.value = seg; __lastAutoId = seg; }
    } else {
      if(autoId){ if(idInput) idInput.value = autoId; __lastAutoId = autoId; }
    }
  };
  __lastAutoAbbr = '';
  const computeAutoAbbr = (lbl)=>{
    if(!lbl) return '';
    if(ctx.kind==='tag') return lbl.slice(0,1).toUpperCase();
    if(ctx.kind==='customAttrValue') return lbl.replace(/\s+/g,'').slice(0,3).toUpperCase();
    return lbl.replace(/\s+/g,'').slice(0,2).toUpperCase();
  };
  const refreshAbbr = ()=>{
    if(!fields.abbr || !abbrEl) return;
    const curAbbr = abbrEl.value.trim();
    if(!curAbbr || curAbbr === __lastAutoAbbr){
      const a = computeAutoAbbr((labelEl?.value||'').trim());
      if(a){ abbrEl.value = a; __lastAutoAbbr = a; }
    }
  };
  const refreshAutoTags = ()=>{
    if(idAutoTag){ const on = __lastAutoId !== ''; idAutoTag.style.display = on ? '' : 'none'; idAutoTag.classList.toggle('clickable', on); }
    if(abbrAutoTag){ const on = __lastAutoAbbr !== ''; abbrAutoTag.style.display = on ? '' : 'none'; abbrAutoTag.classList.toggle('clickable', on); }
  };
  if(idAutoTag){ idAutoTag.title = 'Click to freeze ID'; idAutoTag.addEventListener('click', ()=>{
    __lastAutoId = '';
    refreshAutoTags();
  }); }
  if(abbrAutoTag){ abbrAutoTag.title = 'Click to freeze abbreviation'; abbrAutoTag.addEventListener('click', ()=>{
    __lastAutoAbbr = '';
    refreshAutoTags();
  }); }
  if(labelEl){
    labelEl.oninput = ()=>{
      refreshId();
      refreshAbbr();
      refreshAutoTags();
    };
  }
  if(idInput){
    idInput.oninput = ()=>{
      if(!idInput.value.trim()){
        refreshId();
      } else {
        __lastAutoId = '';
      }
      refreshAutoTags();
    };
  }
  if(abbrEl){
    abbrEl.oninput = ()=>{
      if(!abbrEl.value.trim()){
        const a = computeAutoAbbr((labelEl?.value||'').trim());
        abbrEl.value = a;
        __lastAutoAbbr = a;
      } else {
        __lastAutoAbbr = '';
      }
      refreshAutoTags();
    };
  }
  refreshId();
  refreshAutoTags();

  mask?.classList.add('active');
  modal?.classList.add('active');
  // Wire dirty highlight: Save button is disabled until form has content
  if(ok){
    const modalBody = modal?.querySelector('.modalBody');
    if(modalBody){
      const updateDirty = ()=>{ 
        const hasLabel = !!(document.getElementById('createLabel')?.value||'').trim();
        ok.classList.toggle('btnDirty', createModalIsDirty() && hasLabel);
      };
      // Remove old listeners by cloning approach: just add fresh ones (they stack but it's harmless for short-lived modals)
      modalBody.addEventListener('input', updateDirty);
      modalBody.addEventListener('change', updateDirty);
      modalBody.addEventListener('click', ()=> setTimeout(updateDirty, 50));
      ok.__dirtyUpdate = updateDirty;
      updateDirty(); // initial state: not dirty
    }
  }
  // Auto-elevate if opened from within an elevated catalog (e.g. "Add tag" in catalog)
  if(__createModalAutoElevate){
    mask?.classList.add('elevated-2');
    modal?.classList.add('elevated-2');
    // Relabel top Close   Back since there's a parent modal underneath
    const closeBtn = document.getElementById('createCloseBtn');
    if(closeBtn) closeBtn.textContent = ' Back';
  } else {
    const closeBtn = document.getElementById('createCloseBtn');
    if(closeBtn) closeBtn.textContent = 'Close';
  }
  setTimeout(()=> labelEl?.focus(), 0);
}
function commitCreateModal(){
  if(!__createCtx) return;
  const ctx = __createCtx;
  const labelEl = document.getElementById('createLabel');
  const idInput = document.getElementById('createIdInput');
  const abbrEl = document.getElementById('createAbbr');
  const noteEl = document.getElementById('createNote');
  const multiEl = document.getElementById('createMulti');
  const colorHex = document.getElementById('createColorHex');

  const raw = String(labelEl?.value||'').trim();
  if(!raw){
    customAlert('Please enter a label.');
    labelEl?.focus();
    return;
  }

  // Compute ID: use field value if non-empty, otherwise auto from label
  let id;
  const manualSeg = sanitizeManualId(idInput?.value || '');
  if(manualSeg){
    if(ctx.kind==='node'){
      id = (ctx.parentId || ctx.colId || '') + '.' + manualSeg;
    } else {
      id = manualSeg;
    }
    // Check uniqueness
    if(ctx.taken && ctx.taken.has(id)){
      customAlert('ID already exists. Please choose a unique ID.');
      idInput?.focus();
      return;
    }
  } else {
    id = computeAutoIdFromLabel(raw, ctx);
  }

  // Gather optional fields
  const fields = CREATE_FIELDS[ctx.kind] || {};
  const result = { label: raw, id, _autoId: __lastAutoId !== '' };
  if(fields.abbr) { result.abbr = (abbrEl?.value||'').trim(); result._autoAbbr = __lastAutoAbbr !== ''; }
  if(fields.emoji) {
    const crEm = (document.getElementById('createEmoji')?.value||'').trim();
    if(crEm) result.emoji = crEm;
    const activeBtn = document.querySelector('#createDisplayMode .crDmOpt[style*="rgba(59,130,246"]');
    result.displayMode = activeBtn?.dataset?.dm || 'abbr';
  }
  if(fields.note || true) result.note = (noteEl?.value||'').trim(); // always pass note
  if(fields.color) {
    const colorOn = document.getElementById('createColorOn')?.checked;
    if(colorOn) result.color = __createSelectedColor || (colorHex?.value||'').trim() || DEFAULT_TAG_COLOR;
  }
  if(fields.multi) result.multi = !!multiEl?.checked;
  if(fields.tags && __createTags.length) result.tags = [...__createTags];
  if(fields.customAttrs && Object.keys(__createCustomAttrs).length){
    result.customAttributes = {};
    for(const [k,v] of Object.entries(__createCustomAttrs)){
      if(v && v.length) result.customAttributes[k] = [...v];
    }
  }

  const cb = ctx.onCommit;
  closeCreateModal();
  try{ cb && cb(result); }catch(err){ console.error(err); }
}
function createModalIsDirty(){
  if(!__createCtx) return false;
  const label = (document.getElementById('createLabel')?.value||'').trim();
  const note = (document.getElementById('createNote')?.value||'').trim();
  const abbr = (document.getElementById('createAbbr')?.value||'').trim();
  // Check params rows for transforms
  const paramsContainer = document.getElementById('createParamsRows');
  const hasParams = paramsContainer && paramsContainer.querySelectorAll('.trParamRow').length > 0;
  // Check color Apply checkbox
  const colorOn = document.getElementById('createColorOn')?.checked;
  const fields = CREATE_FIELDS[__createCtx?.kind] || {};
  const isAlwaysColor = (__createCtx?.kind === 'tag');
  const colorDirty = fields.color && !isAlwaysColor && !!colorOn;
  return !!(label || note || abbr || hasParams || colorDirty || (__createTags && __createTags.length) || (__createCustomAttrs && Object.keys(__createCustomAttrs).length));
}
const CREATE_KIND_LABELS = { column:'column', node:'node', tag:'tag', transform:'transform', customAttr:'custom attribute', customAttrValue:'custom attribute value' };
async function guardedCloseCreateModal(){
  if(createModalIsDirty()){
    const kind = CREATE_KIND_LABELS[__createCtx?.kind] || __createCtx?.kind || 'item';
    const ok = await customConfirm('Discard new ' + kind + '?');
    if(!ok) return;
  }
  closeCreateModal();
}
// wire create modal
document.getElementById('createCloseBtn')?.addEventListener('click', guardedCloseCreateModal);
document.getElementById('createCancelBtn')?.addEventListener('click', ()=> closeCreateModal());
document.getElementById('createMask')?.addEventListener('click', guardedCloseCreateModal);
document.getElementById('createOkBtn')?.addEventListener('click', commitCreateModal);
document.getElementById('createLabel')?.addEventListener('keydown', (e)=>{
  if(e.key==='Enter'){ e.preventDefault(); commitCreateModal(); }
  if(e.key==='Escape'){ e.preventDefault(); guardedCloseCreateModal(); }
});

// --- Edit snapshots for Cancel button in Details pane ---
let __editSnapshot = null;
let __editorAutoId = false;   // true while current editor's ID is auto-linked to label
let __editorAutoAbbr = false; // true while current editor's abbr is auto-linked to label
let __editorDisplayMode = 'abbr'; // current catalog editor display mode (abbr or emoji)
let __lastAutoId = '';        // create modal: tracks last auto-generated ID value
let __lastAutoAbbr = '';      // create modal: tracks last auto-generated abbr value
function beginEditSnapshot(kind, id){
  if(__editSnapshot && __editSnapshot.kind===kind && __editSnapshot.id===id) return;
  // Auto-revert any existing unsaved edit session (user navigated away without Save)
  if(__editSnapshot && __editSnapshot.data){
    revertEditSnapshot();
    __editSnapshot = null;
    checkDirtyState();
    // Schedule re-render to clear stale viewer state (e.g. tag pills from reverted edits).
    // Use queueMicrotask to avoid recursion since we may be called from inside renderAll.
    // Skip if inline rename is active  the re-render would destroy the inline input.
    if(!__inlineRename) queueMicrotask(()=>{ renderAll(); });
  }
  __editSnapshot = { kind, id, data: null };
  if(kind==='column'){
    const col = findColumnById(id);
    __editSnapshot.data = col ? { label: col.label, id: col.id, note: (col.note||''), color: (col.color||''), _pendingColor: (col._pendingColor||''), _autoId: !!col._autoId } : null;
  } else if(kind==='node'){
    const node = IDX?.nodeById?.get(id);
    __editSnapshot.data = node ? { id: node.id, label: node.label, tags: Array.isArray(node.tags)? [...node.tags] : [], note: (node.note||''), color: (node.color||''), _pendingColor: (node._pendingColor||''), _autoId: !!node._autoId, customAttributes: node.customAttributes? JSON.parse(JSON.stringify(node.customAttributes)) : {} } : null;
  }
}
function revertEditSnapshot(){
  if(!__editSnapshot || !__editSnapshot.data) return;
  const { kind, id, data } = __editSnapshot;
  if(kind==='column'){
    const col = findColumnById(id);
    if(col){ col.label = data.label; col.note = (data.note||''); col._autoId = !!data._autoId; if(col.schema) col.schema._autoId = !!data._autoId; if(data.color) col.color = data.color; else delete col.color; if(data._pendingColor) col._pendingColor = data._pendingColor; else delete col._pendingColor; }
  } else if(kind==='node'){
    const colId = columnOf(id);
    const col = colId ? findColumnById(colId) : null;
    if(col){
      const loc = locateNode(col.schema, id);
      if(loc && loc.node){
        loc.node.label = data.label;
        loc.node.tags = Array.isArray(data.tags)? [...data.tags] : [];
        loc.node.note = (data.note||'');
        loc.node._autoId = !!data._autoId;
        if(data.color) loc.node.color = data.color; else delete loc.node.color;
        if(data._pendingColor) loc.node._pendingColor = data._pendingColor; else delete loc.node._pendingColor;
        loc.node.customAttributes = data.customAttributes ? JSON.parse(JSON.stringify(data.customAttributes)) : {};
      }
    }
  }
}
function cancelEditAndDeselect(){
  revertEditSnapshot();
  __editSnapshot = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.lockedId = null;
  state.hoverId = null;
  state.multiSelection.clear();
  state.__hoverCooldownUntil = Date.now() + 400;
  checkDirtyState();
  renderAll();
  setGlobalStatus('Cancelled changes.');
}

// --- Edge (mapping) edit session ---
// Ensures mapping edits (including transforms) are only persisted on explicit Save.
let __edgeEditSession = null; // { edgeId, from, to, ruleRef, draft }
function deepClone(obj){
  try{ return JSON.parse(JSON.stringify(obj)); }catch{ return obj; }
}
function edgeEditIsDirty(){
  if(!__edgeEditSession || !__edgeEditSession.ruleRef || !__edgeEditSession.draft) return false;
  if(JSON.stringify(__edgeEditSession.ruleRef) !== JSON.stringify(__edgeEditSession.draft)) return true;
  // Detect picker change OR checkbox toggle independently
  const edColorEl = document.getElementById('edColor');
  const edColorOnEl = document.getElementById('edColorOn');
  if(edColorEl && edColorOnEl){
    const origColor = __edgeEditSession.ruleRef.color || '';
    const origPickerVal = origColor || __edgeEditSession.ruleRef._pendingColor || '#3b82f6';
    if(edColorOnEl.checked !== !!origColor) return true;
    if(edColorEl.value !== origPickerVal) return true;
  }
  return false;
}
function clearEdgeEditSession(opts={}){
  __edgeEditSession = null;
  if(opts && opts.clearSelection){
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    state._selectedEdgeEndpoints = null;
    state.lockedId = null;
    state.hoverId = null;
  }
}

async function deleteMappingByEdgeId(edgeId){
  if(!state || !state.data || !Array.isArray(state.data.mappings)) return;
  const edge = (IDX && Array.isArray(IDX.edges)) ? IDX.edges.find(e=>e && e.id===edgeId) : null;
  if(!edge) return;
  const msg = `Delete mapping?
${edge.from}  ${edge.to}`;
  if(!await customConfirm(msg)) return;
  state.data.mappings = state.data.mappings.filter(m=>{
    if(!m || typeof m!=='object') return false;
    if(m.from!==edge.from) return true;
    const to = m.to;
    if(Array.isArray(to)) return !to.includes(edge.to);
    return String(to)!==String(edge.to);
  });
  __edgeEditSession = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.lockedId = null;
  state.hoverId = null;
  renderAll();
  applyHighlight();
  setGlobalStatus('Deleted mapping.');
}


/* =========================
   Index building and rendering
========================= */
function buildIndexes(data){
  try{ normalizeSiblingIds(data); }catch(e){}

  // Normalize project-level fields for stable JSON shape
  if(data.subtitle===undefined || data.subtitle===null) data.subtitle = '';
  if(data.description===undefined || data.description===null) data.description = '';
  if(data.author===undefined || data.author===null) data.author = '';
  if(data.organization===undefined || data.organization===null) data.organization = '';
  if(data.projectVersion===undefined || data.projectVersion===null) data.projectVersion = '';
  if(data.date===undefined || data.date===null) data.date = '';
  if(data.contact===undefined || data.contact===null) data.contact = '';
  if(data.url===undefined || data.url===null) data.url = '';
  if(data._appVersion===undefined || data._appVersion===null) data._appVersion = '';
  if(data._savedAt===undefined || data._savedAt===null) data._savedAt = '';
  if(data._app===undefined || data._app===null) data._app = '';

  // Normalize tag priorities (auto-assign sequential if missing)
  if(Array.isArray(data.tagCatalog)){
    let maxP = 0;
    data.tagCatalog.forEach(t=>{ if(t && typeof t.priority==='number') maxP = Math.max(maxP, t.priority); });
    data.tagCatalog.forEach(t=>{
      if(t && (t.priority===undefined || t.priority===null || typeof t.priority!=='number')){
        t.priority = ++maxP;
      }
    });
  }

  // Normalize custom attribute priorities and value priorities
  if(Array.isArray(data.customAttributeCatalog)){
    let maxAP = 0;
    data.customAttributeCatalog.forEach(a=>{ if(a && typeof a.priority==='number') maxAP = Math.max(maxAP, a.priority); });
    data.customAttributeCatalog.forEach(a=>{
      if(a && (a.priority===undefined || a.priority===null || typeof a.priority!=='number')){
        a.priority = ++maxAP;
      }
      // Normalize value priorities within each attribute
      if(a && Array.isArray(a.values)){
        let maxVP = 0;
        a.values.forEach(v=>{ if(v && typeof v.priority==='number') maxVP = Math.max(maxVP, v.priority); });
        a.values.forEach(v=>{
          if(v && (v.priority===undefined || v.priority===null || typeof v.priority!=='number')){
            v.priority = ++maxVP;
          }
        });
      }
    });
  }

  resetIndexes();
  IDX.columns = data.columns.map(c => {
    // Normalize note field for stable JSON shape
    if(c.note===undefined || c.note===null) c.note = '';
    return { id: c.id, label: c.label ?? c.id, schema: c.schema, note: c.note, color: c.color, _pendingColor: c._pendingColor };
  });
  IDX.columns.forEach((c, i) => IDX.columnIndex.set(c.id, i));

  // walk nodes per column
  for(const col of IDX.columns){
    walkAndIndex(col.schema, null, col.id);
  }

  // build edges
  expandEdges(data.mappings || []);
}

function walkAndIndex(node, parentId, columnId){
  IDX.nodeById.set(node.id, node);
  IDX.nodeColumnById.set(node.id, columnId);
  if(parentId) IDX.parentById.set(node.id, parentId);

  // Eagerly normalize node fields so the JSON shape is stable
  // (prevents dirty-flag false positives when editors touch nodes later)
  if(!Array.isArray(node.tags)) node.tags = [];
  node.tags = node.tags.filter(x=>typeof x==='string' && x.trim());
  if(!node.customAttributes || typeof node.customAttributes!=='object' || Array.isArray(node.customAttributes)) node.customAttributes = {};
  if(node.note===undefined || node.note===null) node.note='';

  if(node.type === "field"){
    IDX.fieldIds.add(node.id);
    IDX.nodeFieldDescendants.set(node.id, [node.id]);
    return [node.id];
  }

  const all = [];
  for(const child of (node.children || [])){
    all.push(...walkAndIndex(child, node.id, columnId));
  }
  IDX.nodeFieldDescendants.set(node.id, all);
  return all;
}

function expandEdges(mappings){
  // Migrate raw mapping data: normalize transforms from legacy string[] to {ref}[] format
  for(const m of (mappings||[])){
    if(m && Array.isArray(m.transforms)){
      m.transforms = normalizeTransforms(m.transforms);
    }
  }
  for(const fid of IDX.fieldIds){
    IDX.adjacency.set(fid, new Set());
    IDX.edgesByField.set(fid, []);
  }
  let counter = 0;
  const seenPair = new Set();
  for(const m of (mappings||[])){
    if(!m || typeof m !== 'object') continue;
    const from = m.from;
    const tos = Array.isArray(m.to) ? m.to : (typeof m.to === 'string' ? [m.to] : []);
    for(const to of tos){
      if(!from || !to) continue;
      const key = `${from}${to}`;
      if(seenPair.has(key)) continue;
      seenPair.add(key);
      counter++;
      const edge = { id: `e${counter}:${key}`, from, to,
        cardinality: m.cardinality ?? '',
        transform: m.transform ?? '',
        transforms: normalizeTransforms(m.transforms),
        note: m.note ?? '',
        label: m.label ?? '',
        labelHidden: !!m.labelHidden,
        default: m.default ?? '',
        color: m.color || '',
        tags: Array.isArray(m.tags) ? [...m.tags] : [],
        customAttributes: m.customAttributes ? JSON.parse(JSON.stringify(m.customAttributes)) : {},
        direction: m.direction || 'forward',
        };
      IDX.edges.push(edge);
      IDX.mappedFields.add(from); IDX.mappedFields.add(to);
      if(IDX.adjacency.has(from)) IDX.adjacency.get(from).add(to);
      if(IDX.adjacency.has(to)) IDX.adjacency.get(to).add(from);
      if(IDX.edgesByField.has(from)) IDX.edgesByField.get(from).push(edge);
      if(IDX.edgesByField.has(to)) IDX.edgesByField.get(to).push(edge);
    }
  }
}

// Mark bidirectional and consolidated edges in the index
function markConsolidatedEdges(){
  // Clear any previous markings
  for(const edge of IDX.edges){
    delete edge.__consolidated;
    delete edge.__isBidirectional;
    delete edge.__fromId;
    delete edge.__toId;
  }
  
  // Find bidirectional field pairs
  const bidirectionalPairs = new Map();
  for(const edge of IDX.edges){
    const pairKey = `${edge.from}${edge.to}`;
    const reversePairKey = `${edge.to}${edge.from}`;
    
    // Check if reverse mapping exists
    const reverseEdge = IDX.edges.find(e => e.from === edge.to && e.to === edge.from);
    if(reverseEdge){
      if(!bidirectionalPairs.has(pairKey)){
        bidirectionalPairs.set(pairKey, []);
      }
      bidirectionalPairs.get(pairKey).push(edge);
    }
  }
  
  // Mark edges as consolidated/bidirectional
  for(const [pairKey, edges] of bidirectionalPairs.entries()){
    if(edges.length === 0) continue;
    
    const [fromId, toId] = pairKey.split('');
    const reversePairKey = `${toId}${fromId}`;
    const isBidirectional = bidirectionalPairs.has(reversePairKey);
    
    // Only process each pair once
    if(isBidirectional && fromId > toId) continue;
    
    const representativeEdge = edges[0];
    
    // Combine edges from both directions
    let allEdges = [...edges];
    if(isBidirectional){
      const reverseEdges = bidirectionalPairs.get(reversePairKey) || [];
      allEdges = [...edges, ...reverseEdges];
    }
    
    // Mark the representative edge
    representativeEdge.__consolidated = allEdges;
    representativeEdge.__isBidirectional = isBidirectional;
    representativeEdge.__fromId = fromId;
    representativeEdge.__toId = toId;
  }
}


function clearViewerDOM(){
  columnsRow.innerHTML = "";
  edgesLayer.innerHTML = "";
  IDX.elementById.clear();
  IDX.rowById.clear();
  IDX.panelByColumnId.clear();
  IDX.treeByColumnId.clear();
}

/* Render panels for all columns */
function renderColumns(){
  clearViewerDOM();

  // wrap mode: columns can stack under each other (no forced horizontal min-width)
  columnsRow.classList.toggle('wrap', !!state.wrapColumns);
  const visibleCols = IDX.columns.filter(c => !state.hiddenColumns.has(c.id));
  const colW = parseInt(getComputedStyle(columnsRow).getPropertyValue('--col-width')) || 300;
  const minWidth = state.wrapColumns ? 0 : Math.max(920, visibleCols.length * (colW + 20));
  columnsRow.style.minWidth = (minWidth || 0) + 'px';

  for(const col of visibleCols){
    const panel = document.createElement("section");
    panel.className = "panel";
    panel.dataset.columnId = col.id;

    const header = document.createElement("div");
    header.className = "panelHeader";
    const name = document.createElement("div");
    name.className = "name";
    name.textContent = col.label;
    const meta = document.createElement("div");
    meta.className = "meta";

    const fieldsCount = (IDX.nodeFieldDescendants.get(col.id) || []).length;
    meta.textContent = `${fieldsCount} fields`;

    header.appendChild(name);
    header.appendChild(meta);

    // Apply column color to header (respects nodeColorMode)
    const ncm = state.nodeColorMode || 'all';
    if(col.color && ncm !== 'off'){
      const r = parseInt(col.color.slice(1,3),16), g = parseInt(col.color.slice(3,5),16), b = parseInt(col.color.slice(5,7),16);
      header.style.setProperty('--col-color', col.color);
      header.style.setProperty('--col-bg', `rgba(${r},${g},${b},.18)`);
      header.style.setProperty('--col-bg-hover', `rgba(${r},${g},${b},.28)`);
      header.classList.add('colored');
    }

    const tree = document.createElement("div");
    tree.className = "tree";
    tree.dataset.columnId = col.id;

    const foot = document.createElement("div");
    foot.className = "foot";
    foot.innerHTML = `Hover/click nodes to highlight. Column: <code>${col.id}</code>`;

    panel.appendChild(header);
    panel.appendChild(tree);
    panel.appendChild(foot);

    columnsRow.appendChild(panel);

    IDX.panelByColumnId.set(col.id, panel);
    IDX.treeByColumnId.set(col.id, tree);

    // render tree nodes
    // render tree nodes (skip redundant root; render its children)
 if(col.schema && Array.isArray(col.schema.children) && col.schema.children.length){
   for(const child of col.schema.children){
     tree.appendChild(createNodeElement(child, col.id));
   }
 }

    // interactions
    attachTreeInteractions(tree);
  }

  // overlay SVG must match scroller content box
  
 attachColumnHeaderActions();
 updateColumnHeaderSelectionStyles();
 
attachSvgEdgeInteractions();
scheduleArrowsUpdate();
}

/* DOM node creation */

// Build pill strips for a node, split by placement (left/right of label).
// Returns { left: Element|null, right: Element|null }
// Respects state.tagPillsMode, state.attrPillsMode, and per-attribute displayOnNode flag.
function buildNodePillStrips(node){
  const tagMode = state.tagPillsMode || 'left';
  const attrMode = state.attrPillsMode || 'left';
  const MAX_PILLS = 5;
  let count = 0;

  // Collect tag chips
  const tagChips = [];
  if(tagMode !== 'off'){
    const tags = sortTagIdsByPriority(normalizeNodeTags(node));
    for(let i = 0; i < tags.length && count < MAX_PILLS; i++){
      const tid = tags[i];
      const td = tagById(tid) || {id: tid, label: tid, abbr: tid.slice(0,1).toUpperCase(), color: DEFAULT_TAG_COLOR};
      const chip = document.createElement('span');
      chip.className = 'tagChip';
      chip.style.setProperty('--c', tagColor(td));
      chip.setAttribute('data-color','1');
      chip.title = (td.label||td.id||'') + (td.note?('  '+td.note):'');
      chip.textContent = tagDisplayLabel(td);
      tagChips.push(chip);
      count++;
    }
  }

  // Collect attr chips
  const attrChips = [];
  if(attrMode !== 'off'){
    const ca = normalizeCustomAttributes(node);
    const attrCat = ensureCustomAttributeCatalog()
      .filter(a => a && a.displayOnNode)
      .sort((a,b) => {
        const pa = typeof a.priority==='number' ? a.priority : 9999;
        const pb = typeof b.priority==='number' ? b.priority : 9999;
        return pa - pb;
      });
    for(const attr of attrCat){
      if(count >= MAX_PILLS) break;
      const raw = ca[attr.id];
      if(!raw) continue;
      const valIds = Array.isArray(raw) ? raw : [raw];
      const valsDef = Array.isArray(attr.values) ? attr.values : [];
      const sortedValIds = [...valIds].sort((a,b) => {
        const va = valsDef.find(v=>v.id===a);
        const vb = valsDef.find(v=>v.id===b);
        const pa = va && typeof va.priority==='number' ? va.priority : 9999;
        const pb = vb && typeof vb.priority==='number' ? vb.priority : 9999;
        return pa - pb;
      });
      for(const vid of sortedValIds){
        if(count >= MAX_PILLS) break;
        const vDef = valsDef.find(v=>v.id===vid);
        const vLabel = vDef ? attrValDisplayLabel(vDef) : vid;
        const vColorEnabled = vDef?.color && vDef?.colorEnabled !== false;
        const attrColorEnabled = attr.color && attr.colorEnabled !== false;
        const vColor = vColorEnabled ? vDef.color : (attrColorEnabled ? attr.color : '');
        const chip = document.createElement('span');
        chip.className = 'tagChip';
        if(vColor){
          chip.style.setProperty('--c', vColor);
          chip.setAttribute('data-color','1');
        }
        chip.title = (attr.label||attr.id) + ': ' + (vDef?.label||vid) + (vDef?.note ? ('  '+vDef.note) : '');
        chip.textContent = vLabel;
        attrChips.push(chip);
        count++;
      }
    }
  }

  // Build left and right strips
  function makeStrip(chips){
    if(!chips.length) return null;
    const s = document.createElement('div');
    s.className = 'tagStrip';
    chips.forEach(c => s.appendChild(c));
    return s;
  }

  const leftChips = [];
  const rightChips = [];
  if(tagMode === 'left') leftChips.push(...tagChips);
  else if(tagMode === 'right') rightChips.push(...tagChips);
  if(attrMode === 'left') leftChips.push(...attrChips);
  else if(attrMode === 'right') rightChips.push(...attrChips);

  return { left: makeStrip(leftChips), right: makeStrip(rightChips) };
}

function createNodeElement(node, columnId){
  const container = document.createElement("div");
  container.className = `node ${node.type}`;
  container.dataset.nodeId = node.id;
  container.dataset.columnId = columnId;

  const row = document.createElement("div");
  row.className = "row";
  row.dataset.nodeId = node.id;
  row.dataset.columnId = columnId;
 // Tooltip: show node ID
 row.title = `${node.type||'node'}: ${node.id}`;
  // connection ports (used as arrow anchor points; avoids arrowheads overlapping text)
  const portL = document.createElement('span');
  portL.className = 'port portL';
  const portR = document.createElement('span');
  portR.className = 'port portR';
  row.appendChild(portL);
  row.appendChild(portR);

  if(node.type === "group"){
    const caret = document.createElement("div");
    caret.className = "caret";
    caret.dataset.caretFor = node.id;
    row.appendChild(caret);
  } else {
    const spacer = document.createElement("div");
    spacer.style.width = "21px";
    spacer.style.flex = "0 0 auto";
    row.appendChild(spacer);
  }

  const pills = buildNodePillStrips(node);
  if(pills.left) row.appendChild(pills.left);

  const label = document.createElement("div");
  label.className = "label";
  const text = document.createElement("span");
  text.className = "text";
  text.textContent = node.label || node.id;
  label.appendChild(text);
  // ID is intentionally hidden in the tree row to save horizontal space.
  // Full ID is still available in Details and status/breadcrumbs.
  row.appendChild(label);

  if(pills.right) row.appendChild(pills.right);
  container.appendChild(row);

  if(node.type === "group"){
    const childrenWrap = document.createElement("div");
    childrenWrap.className = "children";
    for(const child of (node.children || [])){
      childrenWrap.appendChild(createNodeElement(child, columnId));
    }
    container.appendChild(childrenWrap);
  }

  IDX.elementById.set(node.id, container);
  IDX.rowById.set(node.id, row);

  // Apply custom node color as subtle background tint
  // Hierarchy: node.color (applied)  nearest ancestor color (applied)  column color  none
  // Respects state.nodeColorMode: 'all' | 'groups' | 'column' | 'off'
  const ncm = state.nodeColorMode || 'all';
  const effectiveColor = ncm === 'off' ? '' : (function(){
    // 'all': use node's own color for any type
    // 'groups': use node's own color only if it's a group (not field)
    // 'column': skip all node/group colors
    const useOwnColor = ncm === 'all' || (ncm === 'groups' && node.type === 'group');
    if(useOwnColor && node.color) return node.color;
    // Walk parent chain for group colors
    if(ncm !== 'column'){
      let pid = IDX.parentById.get(node.id);
      while(pid){
        const pNode = IDX.nodeById.get(pid);
        if(pNode && pNode.color) return pNode.color;
        pid = IDX.parentById.get(pid);
      }
    }
    // Fall back to column color
    const cid = columnId || columnOf(node.id);
    const colObj = cid ? findColumnByIdIn(state.data, cid) : null;
    return colObj?.color || '';
  })();
  if(effectiveColor){
    const cr = parseInt(effectiveColor.slice(1,3),16), cg = parseInt(effectiveColor.slice(3,5),16), cb = parseInt(effectiveColor.slice(5,7),16);
    const isGroup = node.type === 'group';
    row.style.setProperty('--node-color', `rgba(${cr},${cg},${cb},${isGroup ? .08 : .14})`);
    row.style.setProperty('--node-color-border', `rgba(${cr},${cg},${cb},${isGroup ? .22 : .38})`);
    container.classList.add('hasNodeColor');
  }

  return container;
}

function toggleCollapse(nodeId, force=null, skipHighlight=false){
  const el = IDX.elementById.get(nodeId);
  if(!el || !el.classList.contains("group")) return;
  const children = el.querySelector(":scope > .children");
  if(!children) return;

  const collapsed = el.classList.contains("collapsed");
  const next = (force === null) ? !collapsed : !!force;

  el.classList.toggle("collapsed", next);
  children.style.display = next ? "none" : "block";

  if(!skipHighlight) applyHighlight();
  scheduleArrowsUpdate();
  _scheduleDriftCheck();
}

function setAllGroupsCollapsed(collapsed){
  for(const [id, node] of IDX.nodeById.entries()){
    if(node.type === "group"){
      toggleCollapse(id, collapsed, true);
    }
  }
  applyHighlight();
  scheduleArrowsUpdate();
  _scheduleDriftCheck();
}

/* =========================
   Filter Catalog Engine
========================= */
function ensureFilterCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.filterCatalog)) state.data.filterCatalog = [];
  return state.data.filterCatalog;
}

// Condition field options
const FILTER_FIELDS = [
  { id:'tag', label:'Tag', valueType:'tagSelect' },
  { id:'mapped', label:'Has mappings', valueType:'boolean' },
  { id:'transform', label:'Has transform', valueType:'transformSelect' },
  { id:'type', label:'Node type', valueType:'typeSelect' },
  { id:'label', label:'Label', valueType:'text' },
  { id:'id', label:'ID', valueType:'text' },
  { id:'note', label:'Note', valueType:'text' },
];
function getFilterFieldOptions(){
  const base = [...FILTER_FIELDS];
  // Add one entry per custom attribute
  const attrCat = ensureCustomAttributeCatalog();
  attrCat.forEach(a=>{
    base.push({ id:'attr:'+a.id, label:'Attr: '+(a.abbr||a.label), valueType:'attrSelect', attrId:a.id });
  });
  // Add saved filters as possible conditions (for composition)
  const fCat = ensureFilterCatalog();
  fCat.forEach(f=>{
    base.push({ id:'filter:'+f.id, label:'Filter: '+f.label, valueType:'boolean' });
  });
  return base;
}

// Operators per value type
function getOperators(valueType){
  switch(valueType){
    case 'tagSelect': return [{id:'has',label:'has'},{id:'not_has',label:'does not have'}];
    case 'attrSelect': return [{id:'is',label:'is'},{id:'is_not',label:'is not'},{id:'is_set',label:'is set'},{id:'is_not_set',label:'is not set'}];
    case 'text': return [{id:'contains',label:'contains'},{id:'not_contains',label:'does not contain'},{id:'eq',label:'equals'},{id:'starts_with',label:'starts with'}];
    case 'boolean': return [{id:'yes',label:'yes'},{id:'no',label:'no'}];
    case 'typeSelect': return [{id:'is_field',label:'is field'},{id:'is_group',label:'is group'}];
    case 'transformSelect': return [{id:'has',label:'has'},{id:'not_has',label:'does not have'}];
    default: return [{id:'eq',label:'equals'}];
  }
}

// Evaluate a single condition against a node
function evaluateCondition(node, cond, visited){
  if(!cond || !cond.field) return true;
  const f = cond.field, op = cond.op || '', val = cond.value || '';

  if(f === 'tag'){
    const tags = Array.isArray(node.tags) ? node.tags : [];
    return op === 'not_has' ? !tags.includes(val) : tags.includes(val);
  }
  if(f === 'mapped'){
    const isMapped = IDX && IDX.mappedFields && IDX.mappedFields.has(node.id);
    return op === 'no' ? !isMapped : !!isMapped;
  }
  if(f === 'transform'){
    // Check edges connected to this node for the specified transform
    const edges = IDX?.edgesByField?.get(node.id) || [];
    const hasTransform = edges.some(e => Array.isArray(e.transforms) && e.transforms.some(inst => transformRefId(inst) === val));
    return op === 'not_has' ? !hasTransform : hasTransform;
  }
  if(f === 'type'){
    return op === 'is_group' ? node.type === 'group' : node.type === 'field';
  }
  if(f === 'label' || f === 'id' || f === 'note'){
    const hay = norm(f === 'label' ? (node.label||'') : f === 'id' ? (node.id||'') : (node.note||''));
    const needle = norm(val);
    if(!needle && (op==='contains'||op==='eq'||op==='starts_with')) return !needle;
    if(op === 'contains') return hay.includes(needle);
    if(op === 'not_contains') return !hay.includes(needle);
    if(op === 'eq') return hay === needle;
    if(op === 'starts_with') return hay.startsWith(needle);
    return hay.includes(needle);
  }
  if(f.startsWith('attr:')){
    const attrId = f.slice(5);
    const ca = node.customAttributes || {};
    const nodeVal = ca[attrId];
    const nodeVals = nodeVal ? (Array.isArray(nodeVal) ? nodeVal : [nodeVal]) : [];
    if(op === 'is_set') return nodeVals.length > 0;
    if(op === 'is_not_set') return nodeVals.length === 0;
    if(op === 'is') return nodeVals.includes(val);
    if(op === 'is_not') return !nodeVals.includes(val);
    return nodeVals.includes(val);
  }
  if(f.startsWith('filter:')){
    const refId = f.slice(7);
    const match = evaluateFilter(node, refId, visited);
    return op === 'no' ? !match : match;
  }
  return true;
}

// Evaluate all conditions of a filter against a node (with cycle detection)
// Supports recursive groups: rule = { field, op, value } or { type:'group', rules:[...] }
function evaluateRules(node, rules, visited){
  if(!rules || !rules.length) return true;
  let result = evaluateRule(node, rules[0], visited);
  for(let i = 1; i < rules.length; i++){
    const join = rules[i].join || 'and';
    const val = evaluateRule(node, rules[i], visited);
    result = join === 'or' ? (result || val) : (result && val);
  }
  return result;
}

function evaluateRule(node, rule, visited){
  if(!rule) return true;
  if(rule.type === 'group') return evaluateRules(node, rule.rules || [], visited);
  return evaluateCondition(node, rule, visited);
}

function evaluateFilter(node, filterId, visited){
  if(!visited) visited = new Set();
  if(visited.has(filterId)) return false;
  visited.add(filterId);
  const cat = ensureFilterCatalog();
  const filter = cat.find(f=>f.id === filterId);
  if(!filter) return true;
  return evaluateRules(node, filter.rules || [], new Set(visited));
}

// Get all nodes matching a filter
function getFilterMatchSet(filterId){
  const matches = new Set();
  if(!IDX) return matches;
  for(const [id, node] of IDX.nodeById.entries()){
    if(evaluateFilter(node, filterId)) matches.add(id);
  }
  return matches;
}

// Default highlight
const DEFAULT_HIGHLIGHT = { bg:'#3b82f6', border:'#3b82f6', bold:false, emoji:'', frame:false, edgeColor:'#3b82f6', bgEnabled:true, borderEnabled:true, edgeEnabled:false };

// ---- Filter catalog manager ----
let __filterEditId = null;
let __filterIsNew = false;

function renderFiltersManager(){
  const body = document.getElementById('filtersBody');
  if(!body) return;
  const cat = ensureFilterCatalog();
  const editable = state.editorMode;
  if(cat.length === 0){
    body.innerHTML = `<div class="empty" style="padding:18px;">No saved filters yet.${editable?' Click <b>Add filter</b> to create one.':''}</div>`;
    return;
  }

  // Build sorted index array by priority
  const sortedIdxs = cat.map((_,i)=>i).sort((a,b)=>{
    const pa = typeof cat[a].priority==='number' ? cat[a].priority : 9999;
    const pb = typeof cat[b].priority==='number' ? cat[b].priority : 9999;
    return pa - pb;
  });

  body.innerHTML = sortedIdxs.map((idx, sortPos)=>{
    const f = cat[idx];
    const hl = f.highlight || {};
    const isEditing = (__filterEditId === f.id);
    const isFirst = sortPos === 0;
    const isLast = sortPos === sortedIdxs.length - 1;

    // Rules summary
    const rulesSummary = summarizeRules(f.rules || []) || '<i style="opacity:.5">No conditions</i>';
    
    const swatch = hl.bg || hl.border || '';
    const swatchHtml = swatch ? `<span style="display:inline-block;width:14px;height:14px;border-radius:3px;background:${escapeHtml(hl.bgEnabled!==false?(hl.bg||'transparent'):'transparent')};border:2px solid ${escapeHtml(hl.borderEnabled!==false?(hl.border||hl.bg||'var(--border)'):'var(--border)')};vertical-align:middle;margin-right:6px;"></span>` : '';

    const isActive = state.activeFilterIds.includes(f.id);

    if(isEditing && editable){
      return renderFilterEditCard(f, idx);
    }

    return `<div class="catCard catItem filterCard" data-fid="${escapeHtml(f.id)}" data-fidx="${idx}" data-sort-pos="${sortPos}" ${editable?'draggable="true"':''} style="margin-bottom:8px;padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:var(--panel);display:flex;align-items:center;gap:10px;${editable?'cursor:pointer;':''}${hl.frame?'box-shadow:0 0 0 2px '+escapeHtml(hl.frameColor||hl.border||'#3b82f6')+';':''}" ${editable?'title="Click to edit  Drag to reorder"':''}>
      ${editable?'<span class="catGrip"><svg width="8" height="14" viewBox="0 0 8 14" fill="currentColor"><circle cx="2" cy="2" r="1.2"/><circle cx="6" cy="2" r="1.2"/><circle cx="2" cy="7" r="1.2"/><circle cx="6" cy="7" r="1.2"/><circle cx="2" cy="12" r="1.2"/><circle cx="6" cy="12" r="1.2"/></svg></span>':''}
      <div style="flex:1;min-width:0;">
        <div style="display:flex;align-items:center;gap:8px;">
          ${swatchHtml}
          <b style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${hl.emoji?escapeHtml(hl.emoji)+' ':''}${escapeHtml(f.label||f.id)}</b>
          <span style="font-family:var(--mono);font-size:10px;opacity:.35;flex-shrink:0;">${escapeHtml(f.id)}</span>${isLikelyAutoId(f) ? '<span class="autoTag" style="font-size:8px;padding:0 4px;">auto</span>' : ''}
        </div>
        <div style="font-size:11px;line-height:1.5;opacity:.8;margin-top:4px;">${rulesSummary}</div>
        ${f.note?`<div style="font-size:11px;opacity:.6;margin-top:2px;">${escapeHtml(f.note)}</div>`:''}
      </div>
      <div style="display:flex;align-items:center;gap:6px;flex-shrink:0;">
        <label class="toggle" style="font-size:11px;display:inline-flex;align-items:center;" title="Toggle this filter on/off"><input type="checkbox" class="fToggle" data-fid="${escapeHtml(f.id)}" ${isActive?'checked':''}/>Active</label>
        ${editable?`<div class="catActions"><button class="btn catMoveBtn" data-act="moveUp" data-fidx="${idx}" title="Move up" ${isFirst?'disabled':''}><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="9" x2="6" y2="3"/><polyline points="3.5,5.5 6,3 8.5,5.5"/></svg></button>
        <button class="btn catMoveBtn" data-act="moveDown" data-fidx="${idx}" title="Move down" ${isLast?'disabled':''}><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="3" x2="6" y2="9"/><polyline points="3.5,6.5 6,9 8.5,6.5"/></svg></button></div>`:''}
      </div>
    </div>`;
  }).join('');
  body.classList.toggle('catEditActive', !!__filterEditId);

  // Wire events
  body.querySelectorAll('.fToggle').forEach(cb=>{
    cb.addEventListener('change', (e)=>{
      e.stopPropagation();
      const fid = cb.dataset.fid;
      if(cb.checked){ if(!state.activeFilterIds.includes(fid)) state.activeFilterIds.push(fid); }
      else { state.activeFilterIds = state.activeFilterIds.filter(x=>x!==fid); }
      renderActiveFilterChips();
      updateFilterBadge();
      refreshViewer();
    });
  });

  //  move buttons
  body.querySelectorAll('.catMoveBtn').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(!state.editorMode) return;
      const fidx = Number(btn.dataset.fidx);
      const dir = btn.dataset.act === 'moveUp' ? -1 : 1;
      const pos = sortedIdxs.indexOf(fidx);
      const swapPos = pos + dir;
      if(swapPos < 0 || swapPos >= sortedIdxs.length) return;
      const otherIdx = sortedIdxs[swapPos];
      pushUndo();
      const tmp = cat[fidx].priority;
      cat[fidx].priority = cat[otherIdx].priority;
      cat[otherIdx].priority = tmp;
      checkDirtyState();
      renderFiltersManager();
      renderActiveFilterChips();
    });
  });

  // Drag-and-drop reorder (tag-style)
  let __fDragSortPos = null;
  let __fDragTime = 0;
  body.querySelectorAll('.filterCard[draggable]').forEach(card=>{
    card.addEventListener('dragstart', (e)=>{
      __fDragSortPos = Number(card.dataset.sortPos);
      __fDragTime = Date.now();
      card.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    });
    card.addEventListener('dragend', ()=>{
      card.style.opacity = '';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      __fDragSortPos = null;
    });
    card.addEventListener('dragover', (e)=>{
      e.preventDefault(); e.dataTransfer.dropEffect = 'move';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      card.classList.add('dragOver');
    });
    card.addEventListener('dragleave', ()=>{ card.classList.remove('dragOver'); });
    card.addEventListener('drop', (e)=>{
      e.preventDefault(); card.classList.remove('dragOver');
      const fromPos = __fDragSortPos;
      const toPos = Number(card.dataset.sortPos);
      if(fromPos === null || fromPos === toPos) return;
      const reordered = [...sortedIdxs];
      const [moved] = reordered.splice(fromPos, 1);
      reordered.splice(toPos, 0, moved);
      pushUndo();
      reordered.forEach((catIdx, newPos) => { cat[catIdx].priority = newPos + 1; });
      checkDirtyState();
      renderFiltersManager();
      renderActiveFilterChips();
    });
  });

  // Click-to-edit
  body.querySelectorAll('.filterCard').forEach(card=>{
    if(!card.draggable) return; // not editable
    card.addEventListener('click', async (e)=>{
      if(!state.editorMode) return;
      if(e.target.closest('.catMoveBtn') || e.target.closest('.fToggle') || e.target.closest('label')) return;
      if(Date.now() - __fDragTime < 300) return;
      if(!await guardFilterAbandon()) return;
      __filterEditId = card.dataset.fid;
      __filterIsNew = false;
      // Store snapshot for dirty checking
      const f = cat.find(x => x.id === __filterEditId);
      __filterEditSnapshot = f ? JSON.stringify(f) : null;
      renderFiltersManager();
    });
  });

  wireFilterEditCard(body);
}

function summarizeRules(rules, depth){
  if(!rules || !rules.length) return '';
  return rules.map((r, i)=>{
    const joinHtml = i > 0 ? ` <span style="color:var(--accent);font-weight:700;">${(r.join||'and').toUpperCase()}</span> ` : '';
    if(r.type === 'group'){
      return `${joinHtml}( ${summarizeRules(r.rules||[])} )`;
    }
    const fd = getFilterFieldOptions().find(x=>x.id===r.field);
    return `${joinHtml}<span style="opacity:.8">${escapeHtml(fd?fd.label:r.field||'?')}</span> ${escapeHtml(r.op||'')} <b>${escapeHtml(r.value||'')}</b>`;
  }).join('');
}

function renderFilterEditCard(f, idx){
  const hl = f.highlight || {};
  const rules = f.rules || [];
  const fieldOpts = getFilterFieldOptions().filter(x=>!x.id.startsWith('filter:'+f.id));

  const rulesHtml = renderRulesEditor(rules, fieldOpts, '');

  const EMOJI_PICKS = ['','','','','','','','','','','','','','','','','',''];

  return `<div class="catCard filterEditCard" data-fid="${escapeHtml(f.id)}" style="margin-bottom:8px;padding:12px 14px;border-radius:10px;border:2px solid var(--accent);background:var(--panel);">
    <div class="kv" style="grid-template-columns:50px 1fr;margin-bottom:8px;">
      <div class="k">Label<span class="req">*</span></div><div class="v"><input class="inp feLabel" value="${escapeHtml(f.label||'')}" placeholder="Filter name" style="font-size:13px;font-weight:700;"/></div>
      <div class="k">Id <span class="autoTag" data-auto="id">auto</span></div><div class="v" style="display:flex;align-items:center;"><input class="inp feId" value="${__filterIsNew ? '' : escapeHtml(f.id||'')}" placeholder="auto" style="font-family:var(--mono);font-size:11px;flex:1;"/></div>
    </div>
    <div class="feRules">${rulesHtml}</div>
    <div style="display:flex;gap:6px;margin:6px 0 10px;">
      <button class="btn feAddCond" style="font-size:11px;">+ Condition</button>
      <button class="btn feAddGroup" style="font-size:11px;">+ Group ( )</button>
    </div>
    <div style="font-size:11px;opacity:.6;margin-bottom:6px;">Highlight style <span style="opacity:.6;font-size:10px;"> drag a swatch onto another to copy its color</span></div>
    <div class="feStyleBar">
      <div class="feStyleItem" data-color-cls="feBg" draggable="true" title="Background tint  Drag to copy color">
        <input type="checkbox" class="feBgOn" ${(hl.bgEnabled!==false)?'checked':''}/>
        <input type="color" class="feBg feColor feColorSwatch" value="${hl.bg||'#3b82f6'}"/>
        <span class="feStyleLabel">Background</span>
      </div>
      <div class="feStyleItem" data-color-cls="feBorder" draggable="true" title="Left border stripe  Drag to copy color">
        <input type="checkbox" class="feBorderOn" ${(hl.borderEnabled!==false)?'checked':''}/>
        <input type="color" class="feBorder feColor feColorSwatch" value="${hl.border||'#3b82f6'}"/>
        <span class="feStyleLabel">Stripe</span>
      </div>
      <div class="feStyleItem" data-color-cls="feEdge" draggable="true" title="Arrow color  Drag to copy color">
        <input type="checkbox" class="feEdgeOn" ${hl.edgeEnabled?'checked':''}/>
        <input type="color" class="feEdge feColor feColorSwatch" value="${hl.edgeColor||'#3b82f6'}"/>
        <span class="feStyleLabel">Mapping line</span>
      </div>
      <div class="feStyleItem" data-color-cls="feFrameColor" draggable="true" title="Frame outline  Drag to copy color">
        <input type="checkbox" class="feFrame" ${hl.frame?'checked':''}/>
        <input type="color" class="feFrameColor feColor feColorSwatch" value="${hl.frameColor||hl.border||'#3b82f6'}"/>
        <span class="feStyleLabel">Frame</span>
      </div>
      <div class="feStyleSep"></div>
      <label class="toggle" style="font-size:11px;"><input type="checkbox" class="feBold" ${hl.bold?'checked':''}/>Bold</label>
      <div class="feStyleSep"></div>
      <div style="display:flex;align-items:center;gap:3px;font-size:11px;">
        <input class="inp feEmoji" value="${escapeHtml(hl.emoji||'')}" style="width:32px;font-size:13px;text-align:center;padding:2px;" maxlength="4" placeholder=""/>
        <button class="btn feEmojiPick" style="font-size:11px;padding:2px 5px;" title="Pick emoji"></button>
      </div>
      <div class="feStyleSep"></div>
      <button class="btn feColorPalette" style="font-size:11px;padding:2px 5px;" title="Show color presets"></button>
    </div>
    <div class="feColorPalettePanel" style="display:none;margin:6px 0 8px;padding:6px 8px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);">
      <div style="display:flex;align-items:center;gap:6px;">
        ${TAG_COLOR_PRESETS.map(p=>`<div class="fePresetSwatch" draggable="true" data-color="${p.value}" title="${p.name}  drag onto swatch or click to apply" style="width:22px;height:22px;border-radius:6px;background:${p.value};cursor:grab;border:1px solid rgba(255,255,255,.15);transition:transform .1s;flex-shrink:0;"></div>`).join('')}
        <div style="font-size:9px;opacity:.35;white-space:nowrap;line-height:1.4;flex-shrink:0;margin-left:4px;">click = all active channels<br/>drag = single swatch</div>
      </div>
    </div>
    <div class="feEmojiPicker" style="display:none;flex-wrap:wrap;gap:2px;margin:6px 0 8px;justify-content:space-between;">
      ${EMOJI_PICKS.map(e=>`<button class="feEmojiOption" data-emoji="${e}" style="font-size:16px;padding:3px 5px;border:1px solid transparent;border-radius:6px;background:transparent;cursor:pointer;transition:all .1s;" title="${e}">${e}</button>`).join('')}
      <button class="feEmojiOption" data-emoji="" style="font-size:11px;padding:3px 6px;border:1px solid var(--border);border-radius:6px;background:transparent;cursor:pointer;color:var(--muted);" title="Clear emoji"></button>
    </div>
    <input class="inp feNote" value="${escapeHtml(f.note||'')}" placeholder="Note (optional)" style="width:100%;font-size:11px;margin-bottom:8px;"/>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap;">
      ${__filterIsNew ? '' : '<button class="btn feDel" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
      <span style="flex:1;"></span>
      <button class="btn feCancel">Cancel</button>
      <button class="btn btnSave feSave">Save</button>
    </div>
  </div>`;
}

// Render rules editor recursively (conditions + groups)
function renderRulesEditor(rules, fieldOpts, pathPrefix){
  if(!rules || !rules.length) return '<div style="opacity:.5;font-size:11px;padding:4px 0;">No conditions  matches everything.</div>';
  return rules.map((r, ri)=>{
    const path = pathPrefix ? pathPrefix+'.'+ri : ''+ri;
    const joinHtml = ri > 0 ? `<div style="display:flex;align-items:center;margin:2px 0 4px ${pathPrefix?'4':'12'}px;">
      <select class="inp ruleJoin" data-path="${path}" style="width:60px;font-size:10px;font-weight:700;color:var(--accent);background:transparent;border:1px dashed var(--accent);border-radius:4px;padding:1px 4px;cursor:pointer;">
        <option value="and" ${(r.join||'and')==='and'?'selected':''}>AND</option><option value="or" ${r.join==='or'?'selected':''}>OR</option>
      </select>
    </div>` : '';

    if(r.type === 'group'){
      const innerHtml = renderRulesEditor(r.rules || [], fieldOpts, path);
      return `${joinHtml}<div class="condGroup" data-path="${path}">
        <div class="condGroupHead" style="display:flex;align-items:center;gap:4px;margin-bottom:4px;">
          <span class="condDragHandle" draggable="true" data-path="${path}" title="Drag to reorder"></span>
          <span style="font-size:10px;opacity:.5;font-weight:700;">GROUP</span>
          <span style="flex:1;"></span>
          <button class="btn ruleAddCond" data-path="${path}" style="font-size:10px;">+ Cond</button>
          <button class="btn ruleAddGroup" data-path="${path}" style="font-size:10px;">+ Group</button>
          <span class="condActions" style="display:flex;gap:2px;align-items:center;">
            <button class="btn ruleActBtn ruleUp" data-path="${path}" title="Move up"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="8" x2="5" y2="2"/><polyline points="3,4 5,2 7,4"/></svg></button>
            <button class="btn ruleActBtn ruleDown" data-path="${path}" title="Move down"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="2" x2="5" y2="8"/><polyline points="3,6 5,8 7,6"/></svg></button>
            <button class="btn ruleActBtn ruleIndent" data-path="${path}" title="Indent into previous group"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="2" y1="5" x2="8" y2="5"/><polyline points="6,3 8,5 6,7"/></svg></button>
            <button class="btn ruleActBtn ruleOutdent" data-path="${path}" title="Outdent from group"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="5" x2="2" y2="5"/><polyline points="4,3 2,5 4,7"/></svg></button>
            <button class="btn ruleActBtn ruleDel" data-path="${path}" title="Delete group"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"><line x1="2.5" y1="2.5" x2="7.5" y2="7.5"/><line x1="7.5" y1="2.5" x2="2.5" y2="7.5"/></svg></button>
          </span>
        </div>
        ${innerHtml}
      </div>`;
    }

    const fd = fieldOpts.find(x=>x.id===r.field) || fieldOpts[0] || {};
    const ops = getOperators(fd.valueType||'text');
    const needsValue = !['boolean','typeSelect'].includes(fd.valueType) && !['is_set','is_not_set','yes','no','is_field','is_group'].includes(r.op);
    return `${joinHtml}<div class="condRow" data-path="${path}" style="display:flex;gap:4px;align-items:center;margin-bottom:2px;">
      <span class="condDragHandle" draggable="true" data-path="${path}" title="Drag to reorder"></span>
      <select class="inp ruleField" data-path="${path}" style="flex:1;font-size:11px;">
        ${fieldOpts.map(o=>`<option value="${escapeHtml(o.id)}" ${o.id===r.field?'selected':''}>${escapeHtml(o.label)}</option>`).join('')}
      </select>
      <select class="inp ruleOp" data-path="${path}" style="flex:0 0 120px;font-size:11px;">
        ${ops.map(o=>`<option value="${escapeHtml(o.id)}" ${o.id===r.op?'selected':''}>${escapeHtml(o.label)}</option>`).join('')}
      </select>
      ${needsValue ? renderRuleValueInput(fd, r, path) : '<span style="flex:1;"></span>'}
      <span class="condActions" style="display:flex;gap:2px;align-items:center;flex-shrink:0;">
        <button class="btn ruleActBtn ruleUp" data-path="${path}" title="Move up"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="8" x2="5" y2="2"/><polyline points="3,4 5,2 7,4"/></svg></button>
        <button class="btn ruleActBtn ruleDown" data-path="${path}" title="Move down"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="2" x2="5" y2="8"/><polyline points="3,6 5,8 7,6"/></svg></button>
        <button class="btn ruleActBtn ruleIndent" data-path="${path}" title="Indent into previous group"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="2" y1="5" x2="8" y2="5"/><polyline points="6,3 8,5 6,7"/></svg></button>
        <button class="btn ruleActBtn ruleOutdent" data-path="${path}" title="Outdent from group"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="5" x2="2" y2="5"/><polyline points="4,3 2,5 4,7"/></svg></button>
        <button class="btn ruleActBtn ruleDel" data-path="${path}" title="Remove"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"><line x1="2.5" y1="2.5" x2="7.5" y2="7.5"/><line x1="7.5" y1="2.5" x2="2.5" y2="7.5"/></svg></button>
      </span>
    </div>`;
  }).join('');
}

function renderRuleValueInput(fd, rule, path){
  if(fd.valueType === 'tagSelect'){
    const tags = ensureTagCatalog();
    return `<select class="inp ruleVal" data-path="${path}" style="flex:1;font-size:11px;"><option value=""></option>
      ${tags.map(t=>`<option value="${escapeHtml(t.id)}" ${t.id===rule.value?'selected':''}>${escapeHtml((t.abbr||'')+'  '+t.label)}</option>`).join('')}</select>`;
  }
  if(fd.valueType === 'transformSelect'){
    const transforms = ensureTransformCatalog();
    return `<select class="inp ruleVal" data-path="${path}" style="flex:1;font-size:11px;"><option value=""></option>
      ${transforms.map(t=>`<option value="${escapeHtml(t.id)}" ${t.id===rule.value?'selected':''}>${escapeHtml((t.abbr||t.id)+'  '+t.label)}</option>`).join('')}</select>`;
  }
  if(fd.valueType === 'attrSelect'){
    const attrCat = ensureCustomAttributeCatalog();
    const a = attrCat.find(x=>x.id===fd.attrId);
    const vals = a?.values || [];
    return `<select class="inp ruleVal" data-path="${path}" style="flex:1;font-size:11px;"><option value=""></option>
      ${vals.map(v=>`<option value="${escapeHtml(v.id)}" ${v.id===rule.value?'selected':''}>${escapeHtml(_catalogItemLabel(v))}</option>`).join('')}</select>`;
  }
  return `<input class="inp ruleVal" data-path="${path}" value="${escapeHtml(rule.value||'')}" placeholder="Value" style="flex:1;font-size:11px;"/>`;
}

function wireFilterEditCard(container){
  const card = container.querySelector('.filterEditCard');
  if(!card) return;
  const fid = card.dataset.fid;
  const cat = ensureFilterCatalog();
  const filter = cat.find(x=>x.id===fid);
  if(!filter) return;
  if(!filter.rules) filter.rules = [];

  // Resolve dot-path "0.2.1"  { arr, idx } into the rules tree
  function resolvePath(path){
    const parts = path.split('.').map(Number);
    let arr = filter.rules;
    for(let i = 0; i < parts.length - 1; i++){
      const r = arr[parts[i]];
      if(r && r.type === 'group') arr = r.rules || (r.rules = []);
      else return null;
    }
    return { arr, idx: parts[parts.length - 1] };
  }

  // Add condition at root
  card.querySelector('.feAddCond')?.addEventListener('click', ()=>{
    const fields = getFilterFieldOptions();
    const nr = { field: fields[0]?.id||'tag', op: getOperators(fields[0]?.valueType||'text')[0]?.id||'has', value:'' };
    if(filter.rules.length > 0) nr.join = 'and';
    filter.rules.push(nr);
    renderFiltersManager();
  });

  // Add group at root
  card.querySelector('.feAddGroup')?.addEventListener('click', ()=>{
    const ng = { type: 'group', rules: [] };
    if(filter.rules.length > 0) ng.join = 'and';
    filter.rules.push(ng);
    renderFiltersManager();
  });

  // Add condition inside a group
  card.querySelectorAll('.ruleAddCond').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref) return;
      const group = ref.arr[ref.idx];
      if(!group || group.type !== 'group') return;
      if(!group.rules) group.rules = [];
      const fields = getFilterFieldOptions();
      const nr = { field: fields[0]?.id||'tag', op: getOperators(fields[0]?.valueType||'text')[0]?.id||'has', value:'' };
      if(group.rules.length > 0) nr.join = 'and';
      group.rules.push(nr);
      renderFiltersManager();
    });
  });

  // Add group inside a group
  card.querySelectorAll('.ruleAddGroup').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref) return;
      const group = ref.arr[ref.idx];
      if(!group || group.type !== 'group') return;
      if(!group.rules) group.rules = [];
      const ng = { type: 'group', rules: [] };
      if(group.rules.length > 0) ng.join = 'and';
      group.rules.push(ng);
      renderFiltersManager();
    });
  });

  // Delete rule (condition or group)
  card.querySelectorAll('.ruleDel').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref) return;
      ref.arr.splice(ref.idx, 1);
      if(ref.arr.length > 0 && ref.arr[0].join) delete ref.arr[0].join;
      renderFiltersManager();
    });
  });

  // Helper: fix join connectors after mutations (first item has no join, rest get 'and' if missing)
  function fixJoins(arr){
    arr.forEach((r,i)=>{
      if(i===0) delete r.join;
      else if(!r.join) r.join = 'and';
    });
  }

  // Move up
  card.querySelectorAll('.ruleUp').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref || ref.idx <= 0) return;
      const [item] = ref.arr.splice(ref.idx, 1);
      ref.arr.splice(ref.idx - 1, 0, item);
      fixJoins(ref.arr);
      renderFiltersManager();
    });
  });

  // Move down
  card.querySelectorAll('.ruleDown').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref || ref.idx >= ref.arr.length - 1) return;
      const [item] = ref.arr.splice(ref.idx, 1);
      ref.arr.splice(ref.idx + 1, 0, item);
      fixJoins(ref.arr);
      renderFiltersManager();
    });
  });

  // Indent (move into previous sibling group)
  card.querySelectorAll('.ruleIndent').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const ref = resolvePath(btn.dataset.path);
      if(!ref || ref.idx <= 0) return;
      const prev = ref.arr[ref.idx - 1];
      if(!prev || prev.type !== 'group') return; // can only indent into a group
      const [item] = ref.arr.splice(ref.idx, 1);
      if(!prev.rules) prev.rules = [];
      if(prev.rules.length > 0) item.join = item.join || 'and';
      else delete item.join;
      prev.rules.push(item);
      fixJoins(ref.arr);
      renderFiltersManager();
    });
  });

  // Outdent (move out of parent group to grandparent level)
  card.querySelectorAll('.ruleOutdent').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const path = btn.dataset.path;
      const dotIdx = path.lastIndexOf('.');
      if(dotIdx < 0) return; // already at root, can't outdent
      const parentPath = path.substring(0, dotIdx);
      const parentRef = resolvePath(parentPath);
      if(!parentRef) return;
      const group = parentRef.arr[parentRef.idx];
      if(!group || group.type !== 'group') return;
      const localIdx = parseInt(path.substring(dotIdx + 1), 10);
      if(isNaN(localIdx) || localIdx < 0 || localIdx >= (group.rules||[]).length) return;
      const [item] = group.rules.splice(localIdx, 1);
      fixJoins(group.rules);
      // Insert after the parent group in grandparent array
      item.join = 'and'; // always join with AND when outdenting
      parentRef.arr.splice(parentRef.idx + 1, 0, item);
      fixJoins(parentRef.arr);
      renderFiltersManager();
    });
  });

  // Join change
  card.querySelectorAll('.ruleJoin').forEach(sel=>{
    sel.addEventListener('change', ()=>{
      const ref = resolvePath(sel.dataset.path);
      if(ref) ref.arr[ref.idx].join = sel.value;
    });
  });

  // Field change
  card.querySelectorAll('.ruleField').forEach(sel=>{
    sel.addEventListener('change', ()=>{
      const ref = resolvePath(sel.dataset.path);
      if(!ref) return;
      const fields = getFilterFieldOptions();
      const fd = fields.find(x=>x.id===sel.value) || fields[0];
      ref.arr[ref.idx].field = sel.value;
      ref.arr[ref.idx].op = getOperators(fd.valueType)[0]?.id || '';
      ref.arr[ref.idx].value = '';
      renderFiltersManager();
    });
  });

  // Op change
  card.querySelectorAll('.ruleOp').forEach(sel=>{
    sel.addEventListener('change', ()=>{
      const ref = resolvePath(sel.dataset.path);
      if(ref) ref.arr[ref.idx].op = sel.value;
      renderFiltersManager();
    });
  });

  // Value change
  card.querySelectorAll('.ruleVal').forEach(el=>{
    const evt = el.tagName === 'SELECT' ? 'change' : 'input';
    el.addEventListener(evt, ()=>{
      const ref = resolvePath(el.dataset.path);
      if(ref) ref.arr[ref.idx].value = el.value;
    });
  });

  // --- Condition DnD reorder / indent ---
  {
    let __condDragPath = null;

    function isDescendant(parentPath, childPath){
      return childPath.startsWith(parentPath + '.');
    }

    function clearCondDragClasses(){
      card.querySelectorAll('.condDragOver-above,.condDragOver-below,.condDragOver-into,.condDragging').forEach(el=>{
        el.classList.remove('condDragOver-above','condDragOver-below','condDragOver-into','condDragging');
      });
    }

    card.querySelectorAll('.condDragHandle').forEach(handle=>{
      handle.addEventListener('dragstart', (e)=>{
        __condDragPath = handle.dataset.path;
        const row = handle.closest('.condRow, .condGroup');
        if(row){
          // Use entire row as drag ghost (captured before opacity change)
          try{
            const rect = row.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            e.dataTransfer.setDragImage(row, x, y);
          }catch(ex){}
          // Delay dim so browser captures ghost at full opacity
          setTimeout(()=> row.classList.add('condDragging'), 0);
        }
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/x-cond-path', __condDragPath);
      });
      handle.addEventListener('dragend', ()=>{
        __condDragPath = null;
        clearCondDragClasses();
      });
    });

    card.querySelectorAll('.condRow, .condGroup').forEach(el=>{
      el.addEventListener('dragover', (e)=>{
        if(!__condDragPath) return;
        const targetPath = el.dataset.path;
        if(!targetPath || targetPath === __condDragPath) return;
        if(isDescendant(__condDragPath, targetPath)) return;
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'move';
        clearCondDragClasses();

        const rect = el.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const isGroup = el.classList.contains('condGroup');

        if(isGroup){
          // Top 25% = above, bottom 25% = below, middle = into
          if(y < rect.height * 0.25) el.classList.add('condDragOver-above');
          else if(y > rect.height * 0.75) el.classList.add('condDragOver-below');
          else el.classList.add('condDragOver-into');
        } else {
          if(y < rect.height * 0.5) el.classList.add('condDragOver-above');
          else el.classList.add('condDragOver-below');
        }
      });

      el.addEventListener('dragleave', (e)=>{
        // Only clear if leaving the element entirely (not entering a child)
        if(!el.contains(e.relatedTarget)){
          el.classList.remove('condDragOver-above','condDragOver-below','condDragOver-into');
        }
      });

      el.addEventListener('drop', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        const targetPath = el.dataset.path;
        if(!__condDragPath || !targetPath || targetPath === __condDragPath) return;
        if(isDescendant(__condDragPath, targetPath)) return;

        // Determine position from CSS classes
        let position = 'after';
        if(el.classList.contains('condDragOver-above')) position = 'before';
        else if(el.classList.contains('condDragOver-into')) position = 'into';

        // Resolve both paths BEFORE any mutation
        const srcRef = resolvePath(__condDragPath);
        const tgtRef = resolvePath(targetPath);
        if(!srcRef || !tgtRef){ clearCondDragClasses(); return; }
        const srcItem = srcRef.arr[srcRef.idx];
        if(!srcItem){ clearCondDragClasses(); return; }

        // Remove from source
        srcRef.arr.splice(srcRef.idx, 1);
        if(srcRef.arr.length > 0 && srcRef.arr[0].join) delete srcRef.arr[0].join;

        // Adjust target index if same array and source was before target
        let adjIdx = tgtRef.idx;
        if(srcRef.arr === tgtRef.arr && srcRef.idx < tgtRef.idx) adjIdx--;

        if(position === 'into'){
          const group = tgtRef.arr[adjIdx];
          if(group && group.type === 'group'){
            if(!group.rules) group.rules = [];
            if(group.rules.length > 0) srcItem.join = srcItem.join || 'and';
            else delete srcItem.join;
            group.rules.push(srcItem);
          }
        } else {
          const insertIdx = position === 'after' ? adjIdx + 1 : adjIdx;
          if(insertIdx > 0) srcItem.join = srcItem.join || 'and';
          else delete srcItem.join;
          tgtRef.arr.splice(insertIdx, 0, srcItem);
          if(tgtRef.arr.length > 0 && tgtRef.arr[0].join) delete tgtRef.arr[0].join;
          if(tgtRef.arr.length > 1 && !tgtRef.arr[1].join) tgtRef.arr[1].join = 'and';
        }
        __condDragPath = null;
        clearCondDragClasses();
        renderFiltersManager();
      });
    });
  }

  // Color swatch DnD copy
  {
    let __swatchDragCls = null;
    card.querySelectorAll('.feStyleItem[draggable]').forEach(item => {
      item.addEventListener('dragstart', (e) => {
        __swatchDragCls = item.dataset.colorCls;
        item.classList.add('feSwatchDragging');
        e.dataTransfer.effectAllowed = 'copy';
        e.dataTransfer.setData('text/plain', '');
      });
      item.addEventListener('dragend', () => {
        item.classList.remove('feSwatchDragging');
        card.querySelectorAll('.feStyleItem').forEach(i => i.classList.remove('feSwatchDragOver'));
        __swatchDragCls = null;
      });
      item.addEventListener('dragover', (e) => {
        if(!__swatchDragCls || __swatchDragCls === item.dataset.colorCls) return;
        e.preventDefault(); e.dataTransfer.dropEffect = 'copy';
        card.querySelectorAll('.feStyleItem').forEach(i => i.classList.remove('feSwatchDragOver'));
        item.classList.add('feSwatchDragOver');
      });
      item.addEventListener('dragleave', () => { item.classList.remove('feSwatchDragOver'); });
      item.addEventListener('drop', (e) => {
        e.preventDefault(); item.classList.remove('feSwatchDragOver');
        if(!__swatchDragCls || __swatchDragCls === item.dataset.colorCls) return;
        const src = card.querySelector('.' + __swatchDragCls);
        const tgt = card.querySelector('.' + item.dataset.colorCls);
        if(src && tgt){ tgt.value = src.value; tgt.dispatchEvent(new Event('input',{bubbles:true})); }
      });
    });
  }

  // Emoji picker toggle
  card.querySelector('.feEmojiPick')?.addEventListener('click', (e)=>{
    e.preventDefault();
    const picker = card.querySelector('.feEmojiPicker');
    if(picker) picker.style.display = picker.style.display === 'none' ? 'flex' : 'none';
  });

  // Emoji picker options
  card.querySelectorAll('.feEmojiOption').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.preventDefault();
      const emoji = btn.dataset.emoji || '';
      const inp = card.querySelector('.feEmoji');
      if(inp) inp.value = emoji;
      const picker = card.querySelector('.feEmojiPicker');
      if(picker) picker.style.display = 'none';
    });
  });

  // Color palette toggle
  card.querySelector('.feColorPalette')?.addEventListener('click', (e)=>{
    e.preventDefault();
    const panel = card.querySelector('.feColorPalettePanel');
    if(panel) panel.style.display = panel.style.display === 'none' ? 'flex' : 'none';
  });

  // Color palette presets  drag onto any feStyleItem to set its color
  card.querySelectorAll('.fePresetSwatch').forEach(swatch=>{
    swatch.addEventListener('dragstart', (e)=>{
      e.dataTransfer.setData('text/plain', swatch.dataset.color);
      e.dataTransfer.effectAllowed = 'copy';
      swatch.style.transform = 'scale(1.15)';
    });
    swatch.addEventListener('dragend', ()=>{
      swatch.style.transform = '';
    });
    // Also allow click to apply to all enabled channels
    swatch.addEventListener('click', ()=>{
      const color = swatch.dataset.color;
      card.querySelectorAll('.feStyleItem').forEach(item=>{
        const cb = item.querySelector('input[type="checkbox"]');
        const inp = item.querySelector('.feColorSwatch');
        if(inp && cb && cb.checked){ inp.value = color; inp.dispatchEvent(new Event('input',{bubbles:true})); }
      });
    });
  });

  // feStyleItems accept drops from preset swatches
  card.querySelectorAll('.feStyleItem').forEach(item=>{
    item.addEventListener('dragover', (e)=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      item.classList.add('feSwatchDragOver');
    });
    item.addEventListener('dragleave', ()=>{
      item.classList.remove('feSwatchDragOver');
    });
    item.addEventListener('drop', (e)=>{
      e.preventDefault();
      item.classList.remove('feSwatchDragOver');
      const color = e.dataTransfer.getData('text/plain');
      if(color && /^#[0-9a-fA-F]{6}$/.test(color)){
        const inp = item.querySelector('.feColorSwatch');
        if(inp){ inp.value = color; inp.dispatchEvent(new Event('input',{bubbles:true})); }
      }
    });
  });

  // Save
  card.querySelector('.feSave')?.addEventListener('click', ()=>{
    const newLabel = card.querySelector('.feLabel').value.trim();
    if(!newLabel){ customAlert('Please enter a label.'); card.querySelector('.feLabel')?.focus(); return; }
    if(__filterIsNew){
      // Remove placeholder before snapshot so undo doesn't include it
      const cat = ensureFilterCatalog();
      const fi = cat.indexOf(filter);
      if(fi >= 0) cat.splice(fi, 1);
      recordChange();
      if(fi >= 0) cat.splice(fi, 0, filter);
    } else pushUndo();
    filter.label = newLabel;
    filter.note = card.querySelector('.feNote').value.trim();
    filter._autoId = card.__filterAutoId ? card.__filterAutoId() : false;
    // Handle ID change
    let newId = sanitizeManualId(card.querySelector('.feId')?.value||'');
    if(!newId) newId = transliterate(newLabel).toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'') || filter.id;
    if(newId !== filter.id){
      const cat = ensureFilterCatalog();
      const conflict = cat.some(x => x.id === newId && x !== filter);
      if(conflict){
        setGlobalStatus('Filter ID conflict  not changed.');
      } else {
        const oldId = filter.id;
        // Update activeFilterIds reference
        const afi = state.activeFilterIds.indexOf(oldId);
        if(afi >= 0) state.activeFilterIds[afi] = newId;
        filter.id = newId;
      }
    }
    delete filter.conditions; delete filter.logic; // clean legacy
    filter.highlight = {
      bg: card.querySelector('.feBg').value,
      border: card.querySelector('.feBorder').value,
      edgeColor: card.querySelector('.feEdge').value,
      frameColor: card.querySelector('.feFrameColor').value,
      bgEnabled: card.querySelector('.feBgOn').checked,
      borderEnabled: card.querySelector('.feBorderOn').checked,
      edgeEnabled: card.querySelector('.feEdgeOn').checked,
      bold: card.querySelector('.feBold').checked,
      frame: card.querySelector('.feFrame').checked,
      emoji: card.querySelector('.feEmoji').value.trim(),
    };
    __filterEditId = null;
    __filterEditSnapshot = null;
    __filterIsNew = false;
    checkDirtyState();
    renderFiltersManager();
    renderActiveFilterChips();
    refreshViewer();
  });

  // Cancel
  card.querySelector('.feCancel')?.addEventListener('click', ()=>{
    if(__filterIsNew){
      // Remove unsaved new filter
      const i = cat.findIndex(x=>x.id===fid);
      if(i>=0) cat.splice(i,1);
    } else if(__filterEditSnapshot){
      const snap = JSON.parse(__filterEditSnapshot);
      if(snap.rules) filter.rules = snap.rules;
    }
    __filterEditId = null;
    __filterEditSnapshot = null;
    __filterIsNew = false;
    renderFiltersManager();
  });

  // Delete
  card.querySelector('.feDel')?.addEventListener('click', async ()=>{
    if(!__filterIsNew){
      const ok = await customConfirm(`Delete filter "${filter.label||filter.id}"?`);
      if(!ok) return;
      pushUndo();
    }
    const i = cat.findIndex(x=>x.id===fid);
    if(i>=0) cat.splice(i,1);
    state.activeFilterIds = state.activeFilterIds.filter(x=>x!==fid);
    __filterEditId = null;
    __filterEditSnapshot = null;
    __filterIsNew = false;
    checkDirtyState();
    renderFiltersManager();
    renderActiveFilterChips();
    updateFilterBadge();
    refreshViewer();
  });
  wireDirtyHighlight(card, card.querySelector('.feSave'), filterFormIsDirty, ()=> !!(card.querySelector('.feLabel')?.value||'').trim());

  // Auto-id from label: keep updating as long as user hasn't manually edited the ID
  {
    const labelInp = card.querySelector('.feLabel');
    const idInp = card.querySelector('.feId');
    const idAutoTag = card.querySelector('[data-auto="id"]');
    if(labelInp && idInp){
      const slugify = (s)=> transliterate(s).trim().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
      const initIdLocal = idInp.value.trim();
      let lastAutoId = (filter && filter._autoId) ? initIdLocal : '';
      const refreshTag = ()=>{
        if(!idAutoTag) return;
        const on = lastAutoId !== '';
        idAutoTag.style.display = on ? '' : 'none';
        idAutoTag.classList.toggle('clickable', on);
      };
      refreshTag();
      if(idAutoTag){ idAutoTag.title = 'Click to freeze ID'; idAutoTag.addEventListener('click', ()=>{
        lastAutoId = '';
        refreshTag();
      }); }
      labelInp.addEventListener('input', ()=>{
        const cur = idInp.value.trim();
        if(!cur || cur === lastAutoId){
          const autoId = slugify(labelInp.value) || '';
          if(autoId){ idInp.value = autoId; lastAutoId = autoId; }
        }
        refreshTag();
      });
      idInp.addEventListener('input', ()=>{
        if(!idInp.value.trim()){
          const autoId = slugify(labelInp.value) || '';
          idInp.value = autoId;
          lastAutoId = autoId;
        } else {
          lastAutoId = '';
        }
        refreshTag();
      });
      // Expose auto state for save handler
      card.__filterAutoId = ()=> lastAutoId !== '';
      if(__filterIsNew) setTimeout(()=> labelInp.focus(), 50);
    }
  }
}

// ---- Toolbar active filter chips ----
function renderActiveFilterChips(){
  const wrap = document.getElementById('filterChips');
  if(!wrap) return;
  const cat = ensureFilterCatalog();
  if(cat.length === 0){
    wrap.innerHTML = '<span style="opacity:.4;font-size:11px;">No saved filters. Open <b>Catalogs  Filters</b> to create.</span>';
    return;
  }
  const sorted = [...cat].sort((a,b)=>{
    const pa = typeof a.priority==='number'?a.priority:9999;
    const pb = typeof b.priority==='number'?b.priority:9999;
    return pa-pb;
  });
  wrap.innerHTML = sorted.map(f=>{
    const hl = f.highlight || {};
    const active = state.activeFilterIds.includes(f.id);
    const swatch = hl.bg || hl.border || '#3b82f6';
    return `<span class="filterChip${active?' active':''}" data-fid="${escapeHtml(f.id)}" style="cursor:pointer;display:inline-flex;align-items:center;gap:4px;padding:2px 8px;border-radius:999px;font-size:11px;font-family:var(--mono);border:1.5px solid ${active?escapeHtml(swatch):'var(--border)'};background:${active?escapeHtml(swatch)+'28':'transparent'};color:var(--text);transition:all .15s;user-select:none;" title="Click to toggle filter: ${escapeHtml(f.label)}">${hl.emoji?escapeHtml(hl.emoji)+' ':''}${escapeHtml(f.label||f.id)}</span>`;
  }).join('');

  wrap.querySelectorAll('.filterChip').forEach(ch=>{
    ch.addEventListener('click', (e)=>{
      e.stopPropagation(); // Prevent group toggle (DOM rebuild detaches e.target)
      const fid = ch.dataset.fid;
      if(state.activeFilterIds.includes(fid)){
        state.activeFilterIds = state.activeFilterIds.filter(x=>x!==fid);
      } else {
        state.activeFilterIds.push(fid);
      }
      renderActiveFilterChips();
      updateFilterBadge();
      refreshViewer();
    });
  });
}

function updateFilterBadge(){
  const badge = document.getElementById('filterBadge');
  const toggleBtn = document.getElementById('tbFilterToggle');
  const count = state.activeFilterIds.length + (state.onlyMapped?1:0) + (state.search?1:0);
  if(badge){
    if(count > 0){ badge.textContent = count; badge.style.display = ''; }
    else { badge.style.display = 'none'; }
  }
  // Keep toggle button highlighted if filters are active even when bar is hidden
  if(toggleBtn){
    const bar = document.getElementById('tbFilterBar');
    const barVisible = bar && bar.style.display !== 'none';
    toggleBtn.classList.toggle('active', barVisible || count > 0);
  }
}

function hasActiveFilters(){
  return state.activeFilterIds.length > 0;
}

// Evaluate all active filters against a node
// Returns: { match: boolean, highlights: [{filterId, highlight}] }
function evaluateActiveFilters(node){
  if(!hasActiveFilters()) return { match: true, highlights: [] };
  const cat = ensureFilterCatalog();
  const highlights = [];
  let anyMatch = false, allMatch = true;
  // Iterate in catalog order (priority)  NOT activation order
  const sorted = [...cat].sort((a,b)=>{
    const pa = typeof a.priority==='number'?a.priority:9999;
    const pb = typeof b.priority==='number'?b.priority:9999;
    return pa-pb;
  });
  for(const f of sorted){
    if(!state.activeFilterIds.includes(f.id)) continue;
    if(evaluateFilter(node, f.id)){
      highlights.push({ filterId: f.id, highlight: f.highlight || {} });
      anyMatch = true;
    } else {
      allMatch = false;
    }
  }
  const match = state.filterLogic === 'and' ? allMatch : anyMatch;
  return { match, highlights };
}

// Get edge color if both endpoints match an active filter with edgeColor
// Dynamic SVG markers for filter edge coloring
const __filterMarkerCache = new Map();
function getOrCreateFilterMarker(color, isStart){
  const key = (isStart?'s:':'e:') + color;
  if(__filterMarkerCache.has(key)) return __filterMarkerCache.get(key);
  const svg = document.getElementById('svgOverlay');
  const defs = svg?.querySelector('defs');
  if(!defs) return '';
  const id = 'filterArrow_' + (isStart?'s_':'e_') + color.replace('#','');
  const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
  marker.setAttribute('id', id);
  marker.setAttribute('markerWidth', '14');
  marker.setAttribute('markerHeight', '14');
  marker.setAttribute('markerUnits', 'userSpaceOnUse');
  marker.setAttribute('orient', isStart ? 'auto-start-reverse' : 'auto');
  marker.setAttribute('refX', '0');
  marker.setAttribute('refY', '7');
  marker.setAttribute('viewBox', '0 0 14 14');
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M0,2.6 L0,11.4 L13,7 z');
  path.setAttribute('fill', color);
  marker.appendChild(path);
  defs.appendChild(marker);
  const url = `url(#${id})`;
  __filterMarkerCache.set(key, url);
  return url;
}

function getOrCreateFilterDotMarker(color){
  const key = 'd:' + color;
  if(__filterMarkerCache.has(key)) return __filterMarkerCache.get(key);
  const svg = document.getElementById('svgOverlay');
  const defs = svg?.querySelector('defs');
  if(!defs) return '';
  const id = 'filterDot_' + color.replace('#','');
  const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
  marker.setAttribute('id', id);
  marker.setAttribute('markerWidth', '8');
  marker.setAttribute('markerHeight', '8');
  marker.setAttribute('markerUnits', 'userSpaceOnUse');
  marker.setAttribute('refX', '4');
  marker.setAttribute('refY', '4');
  marker.setAttribute('viewBox', '0 0 8 8');
  const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  circle.setAttribute('cx', '4');
  circle.setAttribute('cy', '4');
  circle.setAttribute('r', '3');
  circle.setAttribute('fill', color);
  marker.appendChild(circle);
  defs.appendChild(marker);
  const url = `url(#${id})`;
  __filterMarkerCache.set(key, url);
  return url;
}

function getFilterEdgeColor(fromId, toId, consolidatedEdges){
  if(!hasActiveFilters()) return '';
  const cat = ensureFilterCatalog();
  const sorted = [...cat].sort((a,b)=>{
    const pa = typeof a.priority==='number'?a.priority:9999;
    const pb = typeof b.priority==='number'?b.priority:9999;
    return pa-pb;
  });
  // Direct check on the visible endpoints
  const fromNode = IDX?.nodeById?.get(fromId);
  const toNode = IDX?.nodeById?.get(toId);
  if(fromNode && toNode){
    for(const f of sorted){
      if(!state.activeFilterIds.includes(f.id)) continue;
      if(!f.highlight?.edgeEnabled || !f.highlight?.edgeColor) continue;
      if(evaluateFilter(fromNode, f.id) && evaluateFilter(toNode, f.id)) return f.highlight.edgeColor;
    }
  }
  // For consolidated arrows (collapsed groups), check if ANY constituent edge matches
  if(consolidatedEdges && consolidatedEdges.length > 0){
    for(const f of sorted){
      if(!state.activeFilterIds.includes(f.id)) continue;
      if(!f.highlight?.edgeEnabled || !f.highlight?.edgeColor) continue;
      for(const ce of consolidatedEdges){
        const fn = IDX?.nodeById?.get(ce.from);
        const tn = IDX?.nodeById?.get(ce.to);
        if(fn && tn && evaluateFilter(fn, f.id) && evaluateFilter(tn, f.id)){
          return f.highlight.edgeColor;
        }
      }
    }
  }
  return '';
}

/* =========================
   Edge color scheme (auto-coloring by property)
========================= */
const SCHEME_PALETTE = [
  ...TAG_COLOR_PRESETS.map(p=>p.value),
  '#ec4899', // Pink
  '#8b5cf6', // Violet
  '#0ea5e9', // Sky
  '#10b981', // Emerald
  '#eab308', // Yellow
  '#ef4444', // Red
  '#6366f1', // Indigo
  '#d946ef', // Fuchsia
  '#78716c', // Stone
  '#2dd4bf', // Teal light
];
let __edgeSchemeMap = new Map(); // value  color

function getEdgeSchemeColor(edge){
  const scheme = state.edgeColorScheme;
  if(!scheme) return '';
  let val = '';
  let customColor = ''; // from tag.color or value.color
  if(scheme === 'cardinality'){
    val = (edge.cardinality||'').trim() || '';
  } else if(scheme === 'transform'){
    const trs = Array.isArray(edge.transforms) ? edge.transforms : [];
    val = trs.length ? transformRefId(trs[0]) : '';
    if(val !== ''){
      const t = ensureTransformCatalog().find(x=>x.id===val);
      if(t && t.color && t.colorEnabled !== false) customColor = t.color;
    }
  } else if(scheme === 'srcTag'){
    const node = IDX?.nodeById?.get(edge.from);
    const tags = sortTagIdsByPriority(normalizeNodeTags(node||{}));
    val = tags.length ? tags[0] : '';
    if(val !== ''){
      const t = tagById(val);
      if(t && t.color && t.colorEnabled !== false) customColor = t.color;
    }
  } else if(scheme === 'tgtTag'){
    const node = IDX?.nodeById?.get(edge.to);
    const tags = sortTagIdsByPriority(normalizeNodeTags(node||{}));
    val = tags.length ? tags[0] : '';
    if(val !== ''){
      const t = tagById(val);
      if(t && t.color && t.colorEnabled !== false) customColor = t.color;
    }
  } else if(scheme.startsWith('srcAttr:')){
    const attrId = scheme.slice(8);
    const node = IDX?.nodeById?.get(edge.from);
    const raw = node?.customAttributes?.[attrId];
    val = Array.isArray(raw) ? raw[0]||'' : (raw||'');
    if(val !== ''){
      const v = customValueById(attrId, val);
      if(v && v.color && v.colorEnabled !== false) customColor = v.color;
    }
  } else if(scheme.startsWith('tgtAttr:')){
    const attrId = scheme.slice(8);
    const node = IDX?.nodeById?.get(edge.to);
    const raw = node?.customAttributes?.[attrId];
    val = Array.isArray(raw) ? raw[0]||'' : (raw||'');
    if(val !== ''){
      const v = customValueById(attrId, val);
      if(v && v.color && v.colorEnabled !== false) customColor = v.color;
    }
  }
  if(!val) return '';
  if(!__edgeSchemeMap.has(val)){
    __edgeSchemeMap.set(val, customColor || SCHEME_PALETTE[__edgeSchemeMap.size % SCHEME_PALETTE.length]);
  }
  return __edgeSchemeMap.get(val);
}

function buildEdgeSchemeLegend(){
  const legend = document.getElementById('edgeColorLegend');
  if(!legend) return;
  if(!state.edgeColorScheme || __edgeSchemeMap.size === 0){
    legend.style.display = 'none';
    legend.innerHTML = '';
    return;
  }
  legend.style.display = 'block';
  const scheme = state.edgeColorScheme;
  let html = '';
  for(const [val, color] of __edgeSchemeMap.entries()){
    let label = val;
    // Resolve IDs to human-readable labels
    if(scheme === 'transform'){
      const t = ensureTransformCatalog().find(x=>x.id===val);
      if(t) label = t.abbr ? `${t.abbr}  ${t.label}` : t.label;
    } else if(scheme === 'srcTag' || scheme === 'tgtTag'){
      const t = tagById(val);
      if(t) label = t.label || val;
    } else if(scheme.startsWith('srcAttr:') || scheme.startsWith('tgtAttr:')){
      const attrId = scheme.split(':')[1];
      const v = customValueById(attrId, val);
      if(v) label = v.label || val;
    }
    html += `<div style="display:flex;align-items:center;gap:6px;margin:2px 0;">
      <span style="width:12px;height:12px;border-radius:3px;background:${escapeHtml(color)};flex-shrink:0;border:1px solid rgba(255,255,255,.15);"></span>
      <span style="opacity:.8;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(label)}</span>
    </div>`;
  }
  legend.innerHTML = html;
}

function rebuildEdgeSchemeOptions(){
  const container = document.getElementById('edgeColorSelector');
  if(!container) return;
  // Remove old dynamic attribute buttons
  container.querySelectorAll('.dockOpt[data-dynamic]').forEach(o=>o.remove());
  container.querySelectorAll('.edgeSchemeAttrSep').forEach(o=>o.remove());
  // Add custom attribute options
  const cat = ensureCustomAttributeCatalog();
  if(cat.length){
    const sep = document.createElement('div');
    sep.className = 'edgeSchemeAttrSep';
    sep.style.cssText = 'width:100%;border-top:1px solid var(--border);margin:2px 0;';
    container.appendChild(sep);
    cat.forEach(a=>{
      const btn = document.createElement('button');
      btn.className = 'dockOpt';
      btn.dataset.scheme = 'srcAttr:'+a.id;
      btn.dataset.dynamic = '1';
      btn.title = 'Source ' + (a.label||a.id);
      btn.innerHTML = `<svg width="16" height="10" viewBox="0 0 16 10"><circle cx="2.5" cy="5" r="2.5" fill="#22c55e"/><line x1="5" y1="5" x2="13" y2="5" stroke="#22c55e" stroke-width="1.5"/><polygon points="12,2 16,5 12,8" fill="#22c55e"/></svg><span>${(a.abbr||a.label||a.id).slice(0,3)}</span>`;
      if(state.edgeColorScheme === 'srcAttr:'+a.id) btn.classList.add('active');
      container.appendChild(btn);
    });
    cat.forEach(a=>{
      const btn = document.createElement('button');
      btn.className = 'dockOpt';
      btn.dataset.scheme = 'tgtAttr:'+a.id;
      btn.dataset.dynamic = '1';
      btn.title = 'Target ' + (a.label||a.id);
      btn.innerHTML = `<svg width="16" height="10" viewBox="0 0 16 10"><line x1="1" y1="5" x2="11" y2="5" stroke="#06b6d4" stroke-width="1.5"/><polygon points="10,2 14,5 10,8" fill="#06b6d4"/><circle cx="2.5" cy="5" r="2.5" fill="none" stroke="#06b6d4" stroke-width="1"/></svg><span>${(a.abbr||a.label||a.id).slice(0,3)}</span>`;
      if(state.edgeColorScheme === 'tgtAttr:'+a.id) btn.classList.add('active');
      container.appendChild(btn);
    });
  }
  // Sync active state on static buttons
  container.querySelectorAll('.dockOpt:not([data-dynamic])').forEach(b=>{
    b.classList.toggle('active', b.dataset.scheme === state.edgeColorScheme);
  });
}

function refreshEdgeColorScheme(){
  __edgeSchemeMap = new Map();
  if(state.edgeColorScheme && IDX && IDX.edges){
    for(const e of IDX.edges) getEdgeSchemeColor(e);
  }
  buildEdgeSchemeLegend();
}

/* =========================
   Filtering (Search + OnlyMapped + Metadata)
========================= */
function applyVisibility(){
  const term = norm(state.search);
  const useDim = state.filterMode === 'dim' && (hasActiveFilters() || !!term || state.onlyMapped);
  const useHighlightOnly = state.filterMode === 'highlight' && (hasActiveFilters() || !!term || state.onlyMapped);

  // Clear previous filter styles
  if(IDX && IDX.elementById){
    for(const el of IDX.elementById.values()){
      el.classList.remove('filterDimmed');
      el.style.removeProperty('--filter-bg');
      el.style.removeProperty('--filter-border');
      el.style.removeProperty('--filter-frame');
      el.classList.remove('filterHighlight','filterBold','filterFrame');
      // Clean up injected emojis
      el.querySelectorAll('.filterEmoji').forEach(e=>e.remove());
      const label = el.querySelector(':scope > .row .label');
      if(label) delete label.dataset.filterEmoji;
    }
  }

  function nodeSearchMatch(node){
    if(!term) return true;
    const hay = `${node.label ?? ""} ${node.id}`;
    return norm(hay).includes(term);
  }

  function setNodeVisibility(nodeId){
    const node = IDX.nodeById.get(nodeId);
    const el = IDX.elementById.get(nodeId);
    if(!node || !el) return false;

    let visible = false;
    let matches = false; // tracks if node actually matches criteria (for parent groups)

    if(node.type === "field"){
      const mappedOk = !state.onlyMapped || IDX.mappedFields.has(nodeId);
      const searchOk = !term || nodeSearchMatch(node);
      const { match: filterOk, highlights } = evaluateActiveFilters(node);

      matches = mappedOk && searchOk && (hasActiveFilters() ? filterOk : true);

      if(useHighlightOnly){
        visible = true;
        el.classList.toggle("hidden", false);
      } else if(useDim){
        visible = true;
        el.classList.toggle("hidden", false);
        if(!matches) el.classList.add('filterDimmed');
      } else if(hasActiveFilters()){
        visible = mappedOk && searchOk && filterOk;
        el.classList.toggle("hidden", !visible);
      } else {
        visible = mappedOk && searchOk;
        el.classList.toggle("hidden", !visible);
      }

      // Apply highlight styles from matching filters
      if(visible && highlights.length > 0) applyFilterHighlight(el, highlights);
    } else {
      let childVisible = false;
      let anyChildMatch = false;
      let anyChildFilterMatch = false;
      for(const child of (node.children || [])){
        const cv = setNodeVisibility(child.id);
        if(cv.visible) childVisible = true;
        if(cv.matches) anyChildMatch = true;
        if(hasActiveFilters()){
          const cn = IDX.nodeById.get(child.id);
          if(cn && evaluateActiveFilters(cn).match) anyChildFilterMatch = true;
        }
      }
      const groupSearchOk = !term || nodeSearchMatch(node);
      const { match: groupFilterOk, highlights } = evaluateActiveFilters(node);

      matches = (groupSearchOk || anyChildMatch) && (hasActiveFilters() ? (groupFilterOk || anyChildFilterMatch) : true);

      if(useHighlightOnly){
        visible = true;
        el.classList.toggle("hidden", false);
      } else if(useDim){
        visible = true;
        el.classList.toggle("hidden", false);
        if(!matches) el.classList.add('filterDimmed');
      } else if(hasActiveFilters()){
        visible = (groupSearchOk || childVisible) && (groupFilterOk || anyChildFilterMatch);
        el.classList.toggle("hidden", !visible);
      } else {
        visible = groupSearchOk || childVisible;
        el.classList.toggle("hidden", !visible);
      }

      if(visible && highlights.length > 0) applyFilterHighlight(el, highlights);

      if(term && (childVisible || anyChildMatch)){
        toggleCollapse(nodeId, false);
      }
    }

    return { visible, matches };
  }

  for(const col of IDX.columns){
    const kids = (col.schema && Array.isArray(col.schema.children)) ? col.schema.children : [];
    for(const ch of kids){ setNodeVisibility(ch.id); }
  }
}

function applyFilterHighlight(el, highlights){
  if(!highlights || !highlights.length) return;
  el.classList.add('filterHighlight');
  const hl = highlights[0].highlight || {}; // first = highest priority for colors/style
  if(hl.bgEnabled !== false && hl.bg) el.style.setProperty('--filter-bg', hl.bg + '33');
  if(hl.borderEnabled !== false && hl.border) el.style.setProperty('--filter-border', hl.border);
  else el.style.setProperty('--filter-border', 'transparent');
  if(hl.bold) el.classList.add('filterBold');
  if(hl.frame){
    el.classList.add('filterFrame');
    el.style.setProperty('--filter-frame', hl.frameColor || hl.border || hl.bg || '#3b82f6');
  }
  // Collect emojis from ALL matching filters (not just highest priority)
  const allEmojis = highlights.map(h=>(h.highlight||{}).emoji).filter(Boolean);
  if(allEmojis.length){
    const label = el.querySelector(':scope > .row .label');
    if(label && !label.dataset.filterEmoji){
      const combined = [...new Set(allEmojis)].join('');
      label.dataset.filterEmoji = combined;
      label.insertAdjacentHTML('afterbegin', `<span class="filterEmoji">${escapeHtml(combined)} </span>`);
    }
  }
}

/* =========================
   Highlighting
========================= */
function clearHighlightClasses(){
  for(const el of IDX.elementById.values()){
    el.classList.remove("active","connected","connectedParent","dimmed");
  }
}

function dimAll(){
  if(state.selectionDim === 'off') return;
  for(const el of IDX.elementById.values()){
    if(!el.classList.contains("hidden")) el.classList.add("dimmed");
  }
}

function computeHighlightForNode(nodeId){
  // selectedFields: fields under the node (node can be group or field)
  const selectedFields = new Set(IDX.nodeFieldDescendants.get(nodeId) || []);

  // connectedFields: full mapping chain (graph traversal) from selected fields
  const connectedFields = new Set(selectedFields);
  const q = [...selectedFields];
  while(q.length){
    const cur = q.shift();
    const adj = IDX.adjacency.get(cur);
    if(!adj) continue;
    for(const other of adj){
      if(!connectedFields.has(other)){
        connectedFields.add(other);
        q.push(other);
      }
    }
  }
  return { selectedFields, connectedFields };
}

// Directed chain traversal: 'upstream' follows mappings backwards (who maps TO me),
// 'downstream' follows mappings forwards (where do I map TO).
// direction: 'upstream' | 'downstream' | 'both'
function computeDirectedChain(nodeId, direction){
  const seeds = new Set(IDX.nodeFieldDescendants.get(nodeId) || []);
  const result = new Set(seeds);
  const q = [...seeds];

  // Build directed adjacency maps on first call / invalidate with edge count
  if(!computeDirectedChain._cache || computeDirectedChain._edgeCount !== IDX.edges.length){
    const upMap = new Map();   // field -> Set of fields that map TO it (upstream)
    const downMap = new Map(); // field -> Set of fields it maps TO (downstream)
    for(const e of IDX.edges){
      if(!downMap.has(e.from)) downMap.set(e.from, new Set());
      downMap.get(e.from).add(e.to);
      if(!upMap.has(e.to)) upMap.set(e.to, new Set());
      upMap.get(e.to).add(e.from);
    }
    computeDirectedChain._cache = { upMap, downMap };
    computeDirectedChain._edgeCount = IDX.edges.length;
  }
  const { upMap, downMap } = computeDirectedChain._cache;

  while(q.length){
    const cur = q.shift();
    const neighbors = [];
    if(direction === 'upstream' || direction === 'both'){
      const up = upMap.get(cur);
      if(up) for(const n of up) neighbors.push(n);
    }
    if(direction === 'downstream' || direction === 'both'){
      const down = downMap.get(cur);
      if(down) for(const n of down) neighbors.push(n);
    }
    for(const nb of neighbors){
      if(!result.has(nb)){
        result.add(nb);
        q.push(nb);
      }
    }
  }
  return result;
}


function updateColumnHeaderSelectionStyles(){
  const panels = Array.from(columnsRow.querySelectorAll('.panel'));
  for(const p of panels){
    const colId = p.dataset.columnId;
    const header = p.querySelector('.panelHeader');
    if(!header) continue;
    header.classList.toggle('selected', state.lockedId===colId);
  }
}
function applyHighlight(){
  const edgeFocusId = state.selectedEdgeId || state.hoverEdgeId;
  const hasMulti = state.multiSelection.size > 0;
  const nodeId = edgeFocusId ? null : (hasMulti ? null : currentEffectiveId());
  if(edgeFocusId){ state.lockedId = null; state.hoverId = null; state.multiSelection.clear(); }
  clearHighlightClasses();
 updateColumnHeaderSelectionStyles();
  if(!nodeId && !edgeFocusId && !hasMulti){
    setViewerStatus("Hover a node to preview mappings. Click to lock selection.");
    detailsMeta.textContent = "Project";
    const d = state.data || {};
    const sub = (d.subtitle||'').trim();
    const desc = (d.description||'').trim();
    const author = (d.author||'').trim();
    const org = (d.organization||'').trim();
    const contact = (d.contact||'').trim();
    const url = (d.url||'').trim();
    const ver = (d.projectVersion||'').trim();
    const dt = (d.date||'').trim();
    const hasInfo = sub || desc || author || org || contact || url || ver || dt;
    const infoRows = [
      sub ? `<div class="k">Subtitle</div><div class="v">${escapeHtml(sub)}</div>` : '',
      author ? `<div class="k">Author</div><div class="v">${escapeHtml(author)}</div>` : '',
      org ? `<div class="k">Organization</div><div class="v">${escapeHtml(org)}</div>` : '',
      contact ? `<div class="k">Contact</div><div class="v">${escapeHtml(contact)}</div>` : '',
      url ? `<div class="k">URL</div><div class="v"><a href="${escapeHtml(url)}" target="_blank" rel="noopener" style="color:var(--accent);word-break:break-all;">${escapeHtml(url)}</a></div>` : '',
      ver ? `<div class="k">Version</div><div class="v">${escapeHtml(ver)}</div>` : '',
      dt ? `<div class="k">Date</div><div class="v">${escapeHtml(dt)}</div>` : '',
    ].filter(Boolean).join('\n');
    detailsBody.innerHTML = `<div style="padding:2px 0;">
      ${infoRows ? `<div class="kv" style="grid-template-columns:90px 1fr;margin-bottom:6px;">${infoRows}</div>` : ''}
      ${desc ? `<div style="white-space:pre-wrap;font-size:12px;line-height:1.6;color:var(--text);opacity:.85;margin:6px 0 10px;">${escapeHtml(desc)}</div>` : ''}
      <div class="empty" style="margin-top:6px;">${hasInfo ? 'Select' : 'Hover'} a node, column, or mapping to see its details here.${state.editorMode ? ' Click  to edit project properties.' : ''}</div>
    </div>`;
    scheduleArrowsUpdate();
    return;
  }

  let selectedFields, connectedFields;
  if(edgeFocusId){
    let e = IDX.edges.find(x=>x.id===edgeFocusId);
    
    // If not found in real edges, check virtual edges
    if(!e && edgeFocusId.startsWith('virtual:')){
      const virtualEdges = findChainsThoughHiddenColumns();
      e = virtualEdges.find(x=>x.id===edgeFocusId);
    }
    
    if(e){
      // Check if this is a consolidated arrow (from SVG path metadata or cache)
      const pathEl = Array.from(edgesLayer.querySelectorAll('path.edge')).find(p => p.dataset.edgeId === edgeFocusId);
      const cache = (state._consolidatedEdgeCache && state._consolidatedEdgeCache.edgeId === edgeFocusId) ? state._consolidatedEdgeCache : null;
      const consolidated = pathEl?.__consolidated || cache?.consolidated;
      
      // Only use consolidated highlighting if the fields are still collapsed
      // If they've been expanded, just highlight the single selected edge
      const fromVisible = isVisibleNodeId(e.from);
      const toVisible = isVisibleNodeId(e.to);
      const fieldsAreExpanded = fromVisible && toVisible;
      
      // If consolidated AND fields are still collapsed, compute highlights for ALL edges
      if(consolidated && consolidated.length > 1 && !fieldsAreExpanded){
        const allConnected = new Set();
        const allSelected = new Set();
        
        for(const edge of consolidated){
          const a = computeHighlightForNode(edge.from);
          const b = computeHighlightForNode(edge.to);
          allSelected.add(edge.from);
          allSelected.add(edge.to);
          for(const f of a.connectedFields) allConnected.add(f);
          for(const f of b.connectedFields) allConnected.add(f);
        }
        
        selectedFields = allSelected;
        connectedFields = allConnected;
      } else {
        // Single edge or fields are expanded - compute highlights for just this edge
        const a = computeHighlightForNode(e.from);
        const b = computeHighlightForNode(e.to);
        selectedFields = new Set([e.from, e.to]);
        connectedFields = new Set([...a.connectedFields, ...b.connectedFields]);
      }
    } else { selectedFields = new Set(); connectedFields = new Set(); }
  } else if(hasMulti){
    // Multi-select: combine highlights for all selected nodes
    selectedFields = new Set();
    connectedFields = new Set();
    for(const nid of state.multiSelection){
      const tmp = computeHighlightForNode(nid);
      if(state.multiSelectArrowMode === 'direct'){
        // Direct-only: selected fields highlighted, but no chain following
        for(const f of tmp.selectedFields) selectedFields.add(f);
        for(const f of tmp.selectedFields) connectedFields.add(f);
        // Add only immediate neighbors (not full chain)
        for(const f of tmp.selectedFields){
          const adj = IDX.adjacency.get(f);
          if(adj) for(const other of adj) connectedFields.add(other);
        }
      } else {
        // Chain mode (default): full chain for all selected nodes
        for(const f of tmp.selectedFields) selectedFields.add(f);
        for(const f of tmp.connectedFields) connectedFields.add(f);
      }
    }
  } else {
    const tmp = computeHighlightForNode(nodeId);
    if(state.multiSelectArrowMode === 'direct'){
      selectedFields = tmp.selectedFields;
      connectedFields = new Set(tmp.selectedFields);
      for(const f of tmp.selectedFields){
        const adj = IDX.adjacency.get(f);
        if(adj) for(const other of adj) connectedFields.add(other);
      }
    } else {
      selectedFields = tmp.selectedFields; connectedFields = tmp.connectedFields;
    }
  }
  dimAll();

  // Determine which fields to visually highlight
  const fieldsToHighlight = (state.multiSelectArrowMode === 'selected') ? selectedFields : connectedFields;

  // Standard highlight: connected (or selected-only) fields
  for(const fid of fieldsToHighlight){
    const el = IDX.elementById.get(fid);
    if(el && !el.classList.contains('hidden')){
      el.classList.add('connected');
      el.classList.remove('dimmed');
    }
  }

  // Un-dim directly selected group nodes and their descendant groups
  // (groups aren't in fieldsToHighlight since it only has leaf fields)
  const directlySelected = new Set(state.multiSelection);
  if(nodeId) directlySelected.add(nodeId);
  for(const nid of directlySelected){
    const el = IDX.elementById.get(nid);
    if(el && el.classList.contains('group') && !el.classList.contains('hidden')){
      el.classList.add('connected');
      el.classList.remove('dimmed');
    }
  }
  // Also un-dim intermediate subgroups that are descendants of a selected group
  if(directlySelected.size > 0){
    for(const [id, el] of IDX.elementById.entries()){
      if(directlySelected.has(id)) continue;
      if(!el.classList.contains('group') || el.classList.contains('hidden')) continue;
      // Walk up parent chain to see if this group is inside a selected group
      let pid = IDX.parentById.get(id);
      while(pid){
        if(directlySelected.has(pid)){
          el.classList.add('connected');
          el.classList.add('connectedParent');
          el.classList.remove('dimmed');
          break;
        }
        pid = IDX.parentById.get(pid);
      }
    }
  }

  // Highlight ancestor groups that contain highlighted fields
  for(const [id, el] of IDX.elementById.entries()){
    if(el.classList.contains('hidden')) continue;
    if(fieldsToHighlight.has(id)) continue; // already highlighted directly
    const fields = IDX.nodeFieldDescendants.get(id) || [];
    let hasConn = false;
    for(const f of fields){
      if(fieldsToHighlight.has(f)) { hasConn = true; break; }
    }
    if(hasConn){
      const isGroup = el.classList.contains('group');
      const isCollapsed = isGroup && el.classList.contains('collapsed');
      if(isCollapsed){
        // Collapsed groups stand in for their children  always highlight + un-dim
        el.classList.add('connected');
        el.classList.remove('dimmed');
      } else if(state.selectionDim === 'keepParents' || state.selectionDim === 'off'){
        // Parents/Off mode: expanded groups get subtle highlight + un-dimmed
        el.classList.add('connected');
        el.classList.add('connectedParent');
        el.classList.remove('dimmed');
      }
      // selectionDim 'all': expanded parents stay dimmed
    }
  }

  // When focusing an edge, mark both endpoints ACTIVE (yellow)
  if(edgeFocusId){
    let ee = IDX.edges.find(x=>x.id===edgeFocusId);
    
    // If not found in real edges, check virtual edges
    if(!ee && edgeFocusId.startsWith('virtual:')){
      const virtualEdges = findChainsThoughHiddenColumns();
      ee = virtualEdges.find(x=>x.id===edgeFocusId);
    }
    
    if(ee){
      // Check if we should use redirected IDs (collapsed groups) or actual field IDs
      const pathEl = Array.from(edgesLayer.querySelectorAll('path.edge')).find(p => p.dataset.edgeId === edgeFocusId);
      const ehCache = (state._consolidatedEdgeCache && state._consolidatedEdgeCache.edgeId === edgeFocusId) ? state._consolidatedEdgeCache : null;
      let fromIdToHighlight = ee.from;
      let toIdToHighlight = ee.to;
      
      // Only use redirected IDs if the fields are actually not visible (still in collapsed groups)
      // If they've been expanded, use the actual field IDs
      const cachedFromId = pathEl?.__fromId || ehCache?.fromId;
      const cachedToId = pathEl?.__toId || ehCache?.toId;
      if(cachedFromId && cachedToId){
        // Check if the actual fields are visible now
        const fromVisible = isVisibleNodeId(ee.from);
        const toVisible = isVisibleNodeId(ee.to);
        
        // Only use redirected IDs if the original fields are not visible
        if(!fromVisible) fromIdToHighlight = cachedFromId;
        if(!toVisible) toIdToHighlight = cachedToId;
      }
      
      [fromIdToHighlight, toIdToHighlight].forEach((fid, i)=>{
        const el2 = IDX.elementById.get(fid);
        if(el2 && !el2.classList.contains('hidden')){
          // If this endpoint was redirected to a collapsed group, use 'connected' not 'active'
          const isRedirected = (i === 0 && fid !== ee.from) || (i === 1 && fid !== ee.to);
          if(isRedirected){
            el2.classList.add('connected');
          } else {
            el2.classList.add('active');
            el2.classList.remove('connected');
          }
          el2.classList.remove('dimmed');
        }
      });
    }
  }
// Special highlight: ONLY the directly selected node(s) (skip when an edge is focused)
if(!edgeFocusId){
  if(hasMulti){
    for(const nid of state.multiSelection){
      const nEl = IDX.elementById.get(nid);
      if(nEl && !nEl.classList.contains('hidden')){
        nEl.classList.add('active');
        nEl.classList.remove('connected');
        nEl.classList.remove('dimmed');
      }
    }
  } else {
    const nEl = IDX.elementById.get(nodeId);
    if(nEl && !nEl.classList.contains('hidden')){
      nEl.classList.add('active');
      nEl.classList.remove('connected');
      nEl.classList.remove('dimmed');
    }
  }
}
  if(hasMulti){
    setViewerStatus(`Multi-selection: ${state.multiSelection.size} nodes  selected fields: ${selectedFields.size}  connected: ${connectedFields.size}`);
    updateDetailsMulti(state.multiSelection, selectedFields);
  } else {
    const mode = state.hoverId ? "Hover" : "Selection";
    const lock = state.lockedId ? "LOCKED" : "preview";
    setViewerStatus(`${mode} (${lock}): ${nodeId}  selected fields: ${selectedFields.size}  connected fields: ${connectedFields.size}`);
    updateDetails(nodeId, selectedFields);
  }
  scheduleArrowsUpdate();
  _scheduleDriftCheck();
}

/* =========================
   Details panel (grouped + effective vs alternatives)
========================= */
function edgeTooltip(edge){
  const tlist = (edge.transforms && edge.transforms.length) ? edge.transforms.map(formatTransformRef).join('  ') : '';
  const eDir = edge.direction || 'forward';
  const arrow = eDir === 'none' ? '' : eDir === 'both' ? '' : '';
  const dirLabel = eDir === 'both' ? 'Direction: Bidirectional' : eDir === 'none' ? 'Direction: Linked (directionless)' : '';
  return [
    `${edge.from} ${arrow} ${edge.to}`,
    dirLabel,
    edge.label ? `Label: ${edge.label}` : "",
    edge.cardinality ? `Cardinality: ${edge.cardinality}` : "",
    tlist ? `Transform: ${tlist}` : "",
    (edge.default !== "" && edge.default !== undefined) ? `Default: ${edge.default}` : "",
    (edge.tags && edge.tags.length) ? `Tags: ${edge.tags.map(tid => { const td = tagById(tid); return td ? (tagDisplayLabel(td)||td.label||td.id) : tid; }).join(', ')}` : "",
    edge.note ? `Note: ${edge.note}` : "",
  ].filter(Boolean).join("\n");
}


function edgeTagAttrRowsHtml(rule){
  let h = '';
  if(rule?.tags && rule.tags.length){
    const chips = rule.tags.map(tid=>{
      const td = tagById(tid);
      const lbl = td ? (tagDisplayLabel(td)||td.label||td.id) : tid;
      const c = td ? tagColor(td) : '';
      return `<span class="tagChip" ${c ? `style="--c:${c};" data-color="1"` : ''}>${escapeHtml(lbl)}</span>`;
    }).join(' ');
    h += `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Tags</span><span class="dtRowV" style="display:flex;gap:4px;flex-wrap:wrap;">${chips}</span></div>`;
  }
  const ca = rule?.customAttributes || {};
  const caKeys = Object.keys(ca);
  if(caKeys.length){
    const chips = [];
    caKeys.sort().forEach(aid=>{
      const raw = ca[aid];
      const a = customAttrById(aid) || {id:aid,label:aid,abbr:''};
      const vals = Array.isArray(raw) ? raw : [raw];
      vals.forEach(vid=>{
        const v = customValueById(aid, vid) || {id:vid,label:vid};
        chips.push(`<span class="tagChip">${escapeHtml((customAttrAbbr(a)||aid) + ': ' + (v.label||v.id))}</span>`);
      });
    });
    if(chips.length) h += `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Custom</span><span class="dtRowV" style="display:flex;gap:4px;flex-wrap:wrap;">${chips.join(' ')}</span></div>`;
  }
  return h;
}

function badgeHtml(edge){
  const parts = [];
  if(edge.cardinality) parts.push(`<span class="tag" title="Cardinality">${escapeHtml(edge.cardinality)}</span>`);
  const tarr = (edge.transforms && edge.transforms.length) ? edge.transforms : [];
  if(tarr.length){
    parts.push(`<span class="tag" title="Transforms">${escapeHtml(short(tarr.map(formatTransformRef).join('  '), 34))}</span>`);
  }
  if(edge.default !== "" && edge.default !== undefined) parts.push(`<span class="tag" title="Default">${escapeHtml(short(edge.default, 16))}</span>`);
  if(edge.tags && edge.tags.length){
    edge.tags.forEach(tid=>{
      const td = tagById(tid);
      const lbl = td ? (tagDisplayLabel(td)||td.label||td.id) : tid;
      const c = td ? tagColor(td) : '';
      parts.push(`<span class="tag" title="Tag: ${escapeHtml(td?.label||tid)}" ${c ? `style="background:${c};color:#fff;opacity:.85;"` : ''}>${escapeHtml(lbl)}</span>`);
    });
  }
return parts.join('\n');
}





// Render readonly tag chips for a node (Details pane)

function miniNodeCard(nodeId){
  const node = IDX.nodeById.get(nodeId);
  if(!node) return '';
  const isField = node.type === 'field';
  const colId = columnOf(nodeId) || '';
  const colIdx = IDX.columnIndex.get(colId);
  const colObj = (colIdx !== undefined) ? IDX.columns[colIdx] : null;
  const colLabel = colObj ? (colObj.label || colObj.id) : colId;
  
  // Mapping summary
  const selectedFields = isField ? [nodeId] : (IDX.nodeFieldDescendants.get(nodeId) || []);
  const fieldSet = new Set(selectedFields);
  let inCount = 0, outCount = 0;
  const candidates = isField ? (IDX.edgesByField.get(nodeId) || []) : IDX.edges;
  const seen = new Set();
  for(const e of candidates){
    if(!e || seen.has(e.id)) continue;
    if(!isField && !(fieldSet.has(e.from) || fieldSet.has(e.to))) continue;
    seen.add(e.id);
    if(fieldSet.has(e.from) && !fieldSet.has(e.to)) outCount++;
    if(fieldSet.has(e.to) && !fieldSet.has(e.from)) inCount++;
  }
  
  const label = node.label || nodeId;
  const note = (node.note || '').trim();
  const childCount = (!isField && node.children) ? node.children.length : 0;
  
  // Tags
  const tagIds = sortTagIdsByPriority(normalizeNodeTags(node));
  const chips = tagIds.length ? tagIds.slice(0, 5).map(tid => {
    const td = tagById(tid) || { id:tid, label:tid, abbr:tid.slice(0,1).toUpperCase(), color:'#3b82f6' };
    return `<span class="tagChip" data-color="1" style="--c:${tagColor(td)};">${escapeHtml(tagDisplayLabel(td)||td.id)}</span>`;
  }).join(' ') : '';
  
  // Custom attributes
  let attrsHtml = '';
  if(node.customAttributes){
    const keys = Object.keys(node.customAttributes || {});
    if(keys.length){
      attrsHtml = keys.sort().map(aid => {
        const raw = node.customAttributes[aid];
        const a = customAttrById(aid) || { id:aid, label:aid };
        const vals = Array.isArray(raw) ? raw : [raw];
        const valueTags = vals.map(vid => {
          const v = customValueById(aid, vid) || { id:vid, label:vid };
          return `<span class="dtAttrVal">${escapeHtml(_catalogItemLabel(v))}</span>`;
        }).join('');
        return `<div class="dtAttrGroup"><span class="dtAttrLabel">${escapeHtml(a.label||a.id)}</span>${valueTags}</div>`;
      }).join('');
    }
  }
  
  const typeLabel = isField ? 'field' : 'group';
  return `
    <div class="box clickable" data-jump-id="${escapeHtml(nodeId)}" style="margin-bottom:8px;cursor:pointer;">
      <div class="dtHero" style="padding-bottom:6px;">
        <div class="dtName" style="font-size:14px;">${escapeHtml(label)}</div>
        <span class="dtType${isField?'':' group'}" style="font-size:8px;padding:2px 6px;">${escapeHtml(typeLabel)}</span>
      </div>
      <div class="dtRow" style="padding:3px 2px;">
        <span class="dtRowK" style="min-width:28px;">ID</span>
        <span class="dtRowV"><span class="dtId">${escapeHtml(nodeId)}${isLikelyAutoId(node) ? '<span class="autoTag" style="font-size:7px;padding:0 3px;">auto</span>' : ''}</span></span>
      </div>
      <div class="dtStatRow" style="padding:3px 0;">
        <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${inCount}</span><span class="dtStatL">in</span></span>
        <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${outCount}</span><span class="dtStatL">out</span></span>
        ${childCount ? `<span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${childCount}</span><span class="dtStatL">ch</span></span>` : ''}
      </div>
      ${note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(note)}</div>` : ''}
      ${tagIds.length ? `<div class="dtChipWrap" style="padding:2px 0;">${chips}</div>` : ''}
      ${attrsHtml ? `<div style="padding:1px 0;">${attrsHtml}</div>` : ''}
    </div>`;
}

function tagsHtmlForDetails(node){
  if(!node) return '';
  const tags = sortTagIdsByPriority(normalizeNodeTags(node));
  if(!tags.length) return '';
  const chips = tags.map(tid => {
    const td = tagById(tid) || { id: tid, label: tid, abbr: (tid||'').slice(0,1).toUpperCase(), color: DEFAULT_TAG_COLOR };
    const title = (td.label || td.id || '') + (td.note ? ('  ' + td.note) : '');
    const abbr  = tagDisplayLabel(td);
    const color = tagColor(td);
    return `<span class="tagChip" title="${escapeHtml(title)}" data-color="1" style="--c:${escapeHtml(color)}">${escapeHtml(abbr)}</span>`;
  }).join('');
  return `<div class="tagStrip" style="flex-wrap:wrap;">${chips}</div>`;
}


function updateDetailsMulti(selectedIds, selectedFieldsSet){
  const nodes = [];
  const byCol = new Map();
  let fields = 0, groups = 0;
  for(const nid of selectedIds){
    const n = IDX.nodeById.get(nid);
    if(!n) continue;
    nodes.push(n);
    if(n.type === 'field') fields++; else groups++;
    const col = columnOf(nid);
    if(!byCol.has(col)) byCol.set(col, []);
    byCol.get(col).push(n);
  }

  // Count edges involving selected fields
  const allFields = new Set();
  for(const nid of selectedIds){
    const descendants = IDX.nodeFieldDescendants.get(nid) || [];
    for(const f of descendants) allFields.add(f);
  }
  let inCount = 0, outCount = 0, internalCount = 0, linkedCount = 0;
  const seenEdges = new Set();
  for(const e of IDX.edges){
    if(seenEdges.has(e.id)) continue;
    const fromIn = allFields.has(e.from);
    const toIn = allFields.has(e.to);
    if(!fromIn && !toIn) continue;
    seenEdges.add(e.id);
    const dir = e.direction || 'forward';
    if(dir === 'none'){ linkedCount++; }
    else if(fromIn && toIn) internalCount++;
    else if(dir === 'both'){ outCount++; inCount++; }
    else if(fromIn) outCount++;
    else inCount++;
  }

  detailsMeta.textContent = `${selectedIds.size} selected`;

  // Build node list
  let nodeList = '';
  const showNodes = nodes;
  for(const n of showNodes){
    const colId = columnOf(n.id||'');
    const colIdx = IDX.columnIndex.get(colId);
    const colObj = colIdx !== undefined ? IDX.columns[colIdx] : null;
    const colLabel = colObj ? (colObj.label || colObj.id) : '';
    const icon = nodeIcon(n.type);
    nodeList += `<div class="miniCard" style="cursor:pointer;padding:4px 6px;border-radius:4px;margin:1px 0;font-size:11.5px;display:flex;align-items:center;gap:6px;" data-jump-id="${escapeHtml(n.id||'')}">
      <span style="opacity:.45;display:flex;align-items:center;">${icon}</span>
      <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(n.label || n.id || '?')}</span>
      <span style="opacity:.35;font-size:10px;">${escapeHtml(colLabel)}</span>
    </div>`;
  }

  // Collect edges involving selected fields for the edge section
  const internalEdges = [], inboundEdges = [], outboundEdges = [], linkedEdges = [];
  for(const e of IDX.edges){
    const fromIn = allFields.has(e.from);
    const toIn = allFields.has(e.to);
    if(!fromIn && !toIn) continue;
    const dir = e.direction || 'forward';
    if(dir === 'none'){
      if(fromIn || toIn) linkedEdges.push(e);
    } else if(fromIn && toIn) internalEdges.push(e);
    else if(dir === 'both'){
      // Bidirectional: appears in both inbound and outbound
      outboundEdges.push(e);
      inboundEdges.push(e);
    }
    else if(fromIn) outboundEdges.push(e);
    else inboundEdges.push(e);
  }
  // Deduplicate for counts (bidirectional edges may appear in both in/out)
  const _allEdgeSet = new Set([...internalEdges, ...outboundEdges, ...inboundEdges, ...linkedEdges]);
  const allRelatedEdges = [..._allEdgeSet];

  // === ACTIONS SECTION (top) ===
  let actionsHtml = '';
  if(state.editorMode){
    let mappingActionsHtml = '';
    if(allRelatedEdges.length > 0){
      const hasTransforms = allRelatedEdges.some(e=>(e.transforms||[]).length > 0);
      mappingActionsHtml = `
      <div class="msCard danger">
        <div class="msCardHead">
          <span>Mapping actions</span><span class="msCount">${allRelatedEdges.length}</span>
        </div>
        <div id="bulkDeleteWrap">
          <button class="msActBtn danger" id="bulkDeleteEdgesBtn"><span class="msIco"></span>Delete mappings<span class="msArrow"></span></button>
        </div>
        <button class="msActBtn" id="bulkAddTransform"><span class="msIco"></span>Transforms</button>
        ${hasTransforms ? `<div id="bulkClearTWrap">
          <button class="msActBtn danger" id="bulkClearTransformsBtn"><span class="msIco"></span>Clear transforms<span class="msArrow"></span></button>
        </div>` : ''}
      </div>`;
    }

    actionsHtml = `<div class="msBulk">
      <div class="msCard">
        <div class="msCardHead">
          <span>Node actions</span><span class="msCount">${selectedIds.size}</span>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;">
          <button class="msActBtn danger" id="bulkDeleteBtn"><span class="msIco"></span>Delete</button>
          <button class="msActBtn" id="bulkMapBtn"><span class="msIco"></span>Map to</button>
          <button class="msActBtn" id="bulkTagBtn"><span class="msIco"></span>Set tags</button>
          <button class="msActBtn" id="bulkAttrBtn"><span class="msIco"></span>Set attribute</button>
        </div>
      </div>
      ${mappingActionsHtml}
    </div>`;
  }

  // Count transforms per edge type
  const countTransforms = (edges) => edges.reduce((n, e) => n + (normalizeTransforms(e.transforms)||[]).length, 0);
  const inTransformCount = countTransforms(inboundEdges);
  const outTransformCount = countTransforms(outboundEdges);
  const intTransformCount = countTransforms(internalEdges);
  const lnkTransformCount = countTransforms(linkedEdges);
  const fmtT = (count) => count > 0 ? `${count} transform${count===1?'':'s'}` : '';

  // === STATISTICS ===
  const totalMappings = inCount + outCount + internalCount + linkedCount;
  const totalTransforms = inTransformCount + outTransformCount + intTransformCount + lnkTransformCount;
  let edgeStatCards = '';
  if(inCount) edgeStatCards += `<div class="msStat"><div class="msStatLabel">Inbound</div><div class="msStatVal">${inCount}</div>${inTransformCount ? `<div class="msStatSub">${fmtT(inTransformCount)}</div>` : ''}</div>`;
  if(outCount) edgeStatCards += `<div class="msStat"><div class="msStatLabel">Outbound</div><div class="msStatVal">${outCount}</div>${outTransformCount ? `<div class="msStatSub">${fmtT(outTransformCount)}</div>` : ''}</div>`;
  if(internalCount) edgeStatCards += `<div class="msStat"><div class="msStatLabel">Internal</div><div class="msStatVal">${internalCount}</div>${intTransformCount ? `<div class="msStatSub">${fmtT(intTransformCount)}</div>` : ''}</div>`;
  if(linkedCount) edgeStatCards += `<div class="msStat"><div class="msStatLabel">Linked</div><div class="msStatVal">${linkedCount}</div>${lnkTransformCount ? `<div class="msStatSub">${fmtT(lnkTransformCount)}</div>` : ''}</div>`;

  const statsHtml = `
    <div class="msStatGrid">
      <div class="msStat"><div class="msStatLabel">Fields</div><div class="msStatVal">${fields}</div></div>
      <div class="msStat"><div class="msStatLabel">Groups</div><div class="msStatVal">${groups}</div></div>
      ${edgeStatCards}
    </div>`;

  // === COLUMN BREAKDOWN ===
  let colChips = '';
  for(const [colId, colNodes] of byCol.entries()){
    const colIdx = IDX.columnIndex.get(colId);
    const colObj = colIdx !== undefined ? IDX.columns[colIdx] : null;
    const colLabel = colObj ? (colObj.label || colObj.id) : (colId || '?');
    const colColor = colObj?.color || '#6b7280';
    colChips += `<span class="msColChip">
      <span class="msColDot" style="background:${escapeHtml(colColor)};color:${escapeHtml(colColor)};"></span>
      <span style="opacity:.6;">${escapeHtml(colLabel)}</span>
      <span class="msColCount">${colNodes.length}</span>
    </span>`;
  }
  const colHtml = `<div style="display:flex;flex-wrap:wrap;gap:5px;margin-top:8px;">${colChips}</div>`;

  // === NODE LIST ===
  const _nodesCollapsed = state._multiCollapsed.nodes;
  const nodeListHtml = `<div style="border-top:1px solid var(--border);padding-top:6px;margin-top:8px;">
    <div data-collapse-toggle="nodes" style="font-size:10px;opacity:.5;margin-bottom:4px;cursor:pointer;user-select:none;display:flex;align-items:center;gap:4px;">
      <span style="font-size:8px;display:inline-block;transition:transform .15s;${_nodesCollapsed?'transform:rotate(-90deg);':''}">\u25BE</span>
      Selected nodes (${nodes.length})
    </div>
    <div data-collapse-body="nodes" style="${_nodesCollapsed?'display:none;':''}">${nodeList}</div>
  </div>`;

  // === EDGE LIST ===
  let edgeListSection = '';
  if(allRelatedEdges.length > 0){
    const _mapCollapsed = state._multiCollapsed.mappings;
    const secDefs = [
      { label: 'Internal', key: 'mapInternal', edges: internalEdges, color: 'rgba(168,85,247,.5)' },
      { label: 'Outbound', key: 'mapOutbound', edges: outboundEdges, color: 'rgba(59,130,246,.5)' },
      { label: 'Inbound', key: 'mapInbound', edges: inboundEdges, color: 'rgba(34,197,94,.5)' },
      { label: 'Linked', key: 'mapLinked', edges: linkedEdges, color: 'rgba(148,163,184,.5)' }
    ];
    let edgeListHtml = '';
    for(const sec of secDefs){
      if(!sec.edges.length) continue;
      const subCollapsed = state._multiCollapsed[sec.key];
      edgeListHtml += `<div>
        <div data-collapse-toggle="${sec.key}" style="font-size:9px;text-transform:uppercase;letter-spacing:.5px;opacity:.35;margin:6px 0 2px;padding-left:2px;cursor:pointer;user-select:none;display:flex;align-items:center;gap:4px;">
          <span style="font-size:7px;display:inline-block;transition:transform .15s;${subCollapsed?'transform:rotate(-90deg);':''}">\u25BE</span>
          ${sec.label} (${sec.edges.length})
        </div>
        <div data-collapse-body="${sec.key}" style="${subCollapsed?'display:none;':''}">`;
      for(const edge of sec.edges){
        const eDir = edge.direction || 'forward';
        // Determine display order based on section perspective
        let displayFrom = edge.from, displayTo = edge.to;
        if(eDir === 'both'){
          // Outbound: selected node on left; Inbound: selected node on right
          if(sec.key === 'mapOutbound' && !allFields.has(edge.from) && allFields.has(edge.to)){
            displayFrom = edge.to; displayTo = edge.from;
          } else if(sec.key === 'mapInbound' && allFields.has(edge.from) && !allFields.has(edge.to)){
            displayFrom = edge.to; displayTo = edge.from;
          }
        } else if(eDir === 'none'){
          // Linked: selected node on left
          if(!allFields.has(edge.from) && allFields.has(edge.to)){
            displayFrom = edge.to; displayTo = edge.from;
          }
        }
        const fromNode = IDX.nodeById.get(displayFrom);
        const toNode = IDX.nodeById.get(displayTo);
        const fromLabel = fromNode ? (fromNode.label || displayFrom) : displayFrom;
        const toLabel = toNode ? (toNode.label || displayTo) : displayTo;
        const transformCount = (edge.transforms||[]).length;
        const transformBadge = transformCount > 0 ? `<span style="font-size:9px;opacity:.4;padding:1px 4px;border:1px solid var(--border);border-radius:4px;">${transformCount}T</span>` : '';
        const arrowSym = eDir === 'none' ? '' : eDir === 'both' ? '' : '';
        const dirBadge = eDir === 'both' ? '<span style="font-size:8px;opacity:.35;padding:0 2px;" title="Bidirectional"></span>' : eDir === 'none' ? '<span style="font-size:8px;opacity:.35;padding:0 2px;" title="Linked"></span>' : '';
        edgeListHtml += `<div class="miniCard" style="cursor:pointer;padding:4px 6px;border-radius:4px;margin:1px 0;font-size:11px;display:flex;align-items:center;gap:5px;" data-edge-select="${escapeHtml(edge.id)}">
          <span style="width:4px;height:4px;border-radius:50%;background:${sec.color};flex-shrink:0;"></span>
          <span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:40%;">${escapeHtml(fromLabel)}</span>
          <span style="opacity:.3;font-size:9px;">${arrowSym}</span>
          <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(toLabel)}</span>
          ${dirBadge}
          ${transformBadge}
        </div>`;
      }
      edgeListHtml += `</div></div>`;
    }
    edgeListSection = `<div style="border-top:1px solid var(--border);padding-top:6px;margin-top:8px;">
      <div data-collapse-toggle="mappings" style="font-size:10px;opacity:.5;margin-bottom:2px;cursor:pointer;user-select:none;display:flex;align-items:center;gap:4px;">
        <span style="font-size:8px;display:inline-block;transition:transform .15s;${_mapCollapsed?'transform:rotate(-90deg);':''}">\u25BE</span>
        Mappings (${allRelatedEdges.length})
      </div>
      <div data-collapse-body="mappings" style="${_mapCollapsed?'display:none;':''}">${edgeListHtml}</div>
    </div>`;
  }

  detailsBody.innerHTML = `<div style="padding:2px 0;">
    ${actionsHtml}
    ${statsHtml}
    ${colHtml}
    ${nodeListHtml}
    ${edgeListSection}
  </div>`;

  // Collapsible section toggles
  detailsBody.querySelectorAll('[data-collapse-toggle]').forEach(hdr=>{
    hdr.addEventListener('click', ()=>{
      const key = hdr.dataset.collapseToggle;
      const body = detailsBody.querySelector(`[data-collapse-body="${key}"]`);
      if(!body) return;
      const collapsed = body.style.display === 'none';
      body.style.display = collapsed ? '' : 'none';
      const caret = hdr.querySelector('span');
      if(caret) caret.style.transform = collapsed ? '' : 'rotate(-90deg)';
      state._multiCollapsed[key] = !collapsed;
    });
  });

  // Click to jump to a node
  detailsBody.querySelectorAll('[data-jump-id]').forEach(el=>{
    el.addEventListener('click', ()=>{
      const id = el.dataset.jumpId;
      if(id){ lockSelection(id); scrollIntoView(id); }
    });
  });

  // Click an edge row to select it
  detailsBody.querySelectorAll('[data-edge-select]').forEach(el=>{
    el.addEventListener('click', ()=>{
      const eid = el.dataset.edgeSelect;
      if(eid) selectEdge(eid);
    });
  });

  // Wire up bulk actions
  if(state.editorMode){
    const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
    if(bulkDeleteBtn) bulkDeleteBtn.addEventListener('click', async ()=>{
      // Count children inside selected groups
      let childFieldCount = 0, childGroupCount = 0;
      for(const nid of selectedIds){
        const node = IDX.nodeById.get(nid);
        if(!node || node.type !== 'group') continue;
        (function walk(n){ if(!n) return; (n.children||[]).forEach(c=>{
          if(c.type==='field') childFieldCount++;
          else if(c.type==='group') childGroupCount++;
          walk(c);
        }); })(node);
      }
      const childParts = [];
      if(childFieldCount) childParts.push(childFieldCount + ' child field' + (childFieldCount>1?'s':''));
      if(childGroupCount) childParts.push(childGroupCount + ' child group' + (childGroupCount>1?'s':''));
      const childInfo = childParts.length ? `\nThis includes ${childParts.join(' and ')} inside selected groups.` : '';
      // Count affected mappings
      const allFieldIds = new Set();
      for(const nid of selectedIds){
        const node = IDX.nodeById.get(nid);
        if(node) for(const f of collectFieldIdsFromNode(node)) allFieldIds.add(f);
      }
      const mapCount = (state.data.mappings||[]).filter(m => m && (allFieldIds.has(m.from) || allFieldIds.has(m.to))).length;
      const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
      const ok = await customConfirm(`Delete ${selectedIds.size} selected node${selectedIds.size>1?'s':''}?${childInfo}${mapInfo}\n\nThis action can be undone with Ctrl+Z.`);
      if(!ok) return;
      pushUndo();
      const idsToDelete = [...selectedIds];
      removeMappingsReferencingInState(allFieldIds);
      // Remove nodes from column schemas
      for(const nid of idsToDelete){
        const col = columnOf(nid);
        if(!col) continue;
        const colData = findColumnById(col);
        if(!colData || !colData.schema) continue;
        const loc = locateNode(colData.schema, nid);
        if(loc && loc.siblings && loc.idx !== null){
          loc.siblings.splice(loc.idx, 1);
        }
      }
      state.multiSelection.clear();
      state.lockedId = null;
      state.hoverId = null;
      markDirty();
      renderAll();
      setGlobalStatus(`Deleted ${idsToDelete.length} nodes.`);
    });

    const bulkTagBtn = document.getElementById('bulkTagBtn');
    if(bulkTagBtn) bulkTagBtn.addEventListener('click', ()=>{ showBulkTagModal([...selectedIds]); });

    const bulkAttrBtn = document.getElementById('bulkAttrBtn');
    if(bulkAttrBtn) bulkAttrBtn.addEventListener('click', ()=>{ showBulkAttrModal([...selectedIds]); });

    const bulkMapBtn = document.getElementById('bulkMapBtn');
    if(bulkMapBtn) bulkMapBtn.addEventListener('click', ()=>{ showBulkMapModal([...selectedIds]); });

    // --- Scope dropdown helper (inline expansion) ---
    function toggleScopeMenu(wrapId, btnEl, options, onPick){
      const wrap = document.getElementById(wrapId);
      if(!wrap) return;
      const existing = wrap.querySelector('.scopeMenu');
      if(existing){ existing.remove(); btnEl.dataset.open = ''; return; }
      // Close any other open scope menus
      document.querySelectorAll('.scopeMenu').forEach(m=>m.remove());
      document.querySelectorAll('[data-open="1"]').forEach(b=>b.dataset.open='');
      btnEl.dataset.open = '1';
      const menu = document.createElement('div');
      menu.className = 'scopeMenu';
      menu.style.cssText = 'display:flex;flex-direction:column;gap:1px;margin-top:4px;border:1px solid var(--border);border-radius:6px;overflow:hidden;';
      for(const opt of options){
        if(!opt.count) continue;
        const row = document.createElement('button');
        row.className = 'btn';
        row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;width:100%;border:none;border-radius:0;font-size:11px;padding:6px 10px;text-align:left;';
        row.innerHTML = `<span>${opt.label}</span><span style="opacity:.4;font-family:var(--mono);font-size:10px;">${opt.badge || opt.count}</span>`;
        row.addEventListener('click', (e)=>{ e.stopPropagation(); menu.remove(); btnEl.dataset.open = ''; onPick(opt); });
        menu.appendChild(row);
      }
      wrap.appendChild(menu);
      const closeMenu = (e)=>{ if(!wrap.contains(e.target)){ menu.remove(); btnEl.dataset.open = ''; document.removeEventListener('click', closeMenu, true); } };
      setTimeout(()=> document.addEventListener('click', closeMenu, true), 0);
    }

    // --- Delete mappings dropdown ---
    const delEdgesBtn = document.getElementById('bulkDeleteEdgesBtn');
    if(delEdgesBtn) delEdgesBtn.addEventListener('click', ()=>{
      const opts = [];
      if(internalEdges.length) opts.push({ id:'internal', label:'Internal', count:internalEdges.length, edges:internalEdges });
      if(inboundEdges.length) opts.push({ id:'inbound', label:'Inbound', count:inboundEdges.length, edges:inboundEdges });
      if(outboundEdges.length) opts.push({ id:'outbound', label:'Outbound', count:outboundEdges.length, edges:outboundEdges });
      if(linkedEdges.length) opts.push({ id:'linked', label:'Linked', count:linkedEdges.length, edges:linkedEdges });
      if(opts.length > 1) opts.push({ id:'all', label:'All', count:allRelatedEdges.length, edges:allRelatedEdges });
      if(opts.length === 1){ opts[0].label = 'All'; }
      toggleScopeMenu('bulkDeleteWrap', delEdgesBtn, opts, async (opt)=>{
        const ok = await customConfirm(`Delete ${opt.count} ${opt.label.toLowerCase()} mapping${opt.count>1?'s':''}?`);
        if(!ok) return;
        pushUndo();
        const killPairs = new Set(opt.edges.map(e=>e.from+'|'+e.to));
        state.data.mappings = (state.data.mappings||[]).filter(m=> m && !killPairs.has(m.from+'|'+m.to));
        markDirty(); renderAll(); applyHighlight();
        setGlobalStatus(`Deleted ${opt.count} ${opt.label.toLowerCase()} mappings.`);
      });
    });

    const addTransformBtn = document.getElementById('bulkAddTransform');
    if(addTransformBtn) addTransformBtn.addEventListener('click', ()=>{
      showBulkTransformModal({ internal: internalEdges, inbound: inboundEdges, outbound: outboundEdges, linked: linkedEdges });
    });

    // --- Clear transforms dropdown ---
    const clearTBtn = document.getElementById('bulkClearTransformsBtn');
    if(clearTBtn) clearTBtn.addEventListener('click', ()=>{
      const withT = (edges) => edges.filter(e=>(e.transforms||[]).length > 0);
      const tCount = (edges) => edges.reduce((n,e)=> n + (normalizeTransforms(e.transforms)||[]).length, 0);
      const opts = [];
      if(withT(internalEdges).length) opts.push({ id:'internal', label:'Internal', count:withT(internalEdges).length, badge:`${withT(internalEdges).length}  ${tCount(internalEdges)}T`, tCount:tCount(internalEdges), edges:withT(internalEdges) });
      if(withT(inboundEdges).length) opts.push({ id:'inbound', label:'Inbound', count:withT(inboundEdges).length, badge:`${withT(inboundEdges).length}  ${tCount(inboundEdges)}T`, tCount:tCount(inboundEdges), edges:withT(inboundEdges) });
      if(withT(outboundEdges).length) opts.push({ id:'outbound', label:'Outbound', count:withT(outboundEdges).length, badge:`${withT(outboundEdges).length}  ${tCount(outboundEdges)}T`, tCount:tCount(outboundEdges), edges:withT(outboundEdges) });
      if(withT(linkedEdges).length) opts.push({ id:'linked', label:'Linked', count:withT(linkedEdges).length, badge:`${withT(linkedEdges).length}  ${tCount(linkedEdges)}T`, tCount:tCount(linkedEdges), edges:withT(linkedEdges) });
      const allWith = withT(allRelatedEdges);
      if(opts.length > 1 && allWith.length) opts.push({ id:'all', label:'All', count:allWith.length, badge:`${allWith.length}  ${tCount(allRelatedEdges)}T`, tCount:tCount(allRelatedEdges), edges:allWith });
      if(opts.length === 1){ opts[0].label = 'All'; }
      toggleScopeMenu('bulkClearTWrap', clearTBtn, opts, async (opt)=>{
        const ok = await customConfirm(`Clear ${opt.tCount} transform${opt.tCount>1?'s':''} from ${opt.count} ${opt.label.toLowerCase()} mapping${opt.count>1?'s':''}?`);
        if(!ok) return;
        pushUndo();
        for(const edge of opt.edges){
          const mapping = (state.data.mappings||[]).find(m=> m && m.from===edge.from && m.to===edge.to);
          if(mapping) mapping.transforms = [];
        }
        markDirty(); renderAll(); applyHighlight();
        setGlobalStatus(`Cleared transforms from ${opt.count} ${opt.label.toLowerCase()} mappings.`);
      });
    });
  }
}

function updateDetails(nodeId, selectedFieldsSet){
  /* EDGE-FOCUS OVERRIDE */
  const edgeId = state.selectedEdgeId || state.hoverEdgeId;
  if(edgeId){
    const isHoverOnly = !state.selectedEdgeId && !!state.hoverEdgeId;
    // In editor mode: hover uses viewer preview, selected uses editor
    if(state.editorMode && typeof renderSelectedEdgeEditor==="function"){
      if(isHoverOnly && typeof renderSelectedEdgeViewer==="function"){
        renderSelectedEdgeViewer(edgeId);
      } else {
        renderSelectedEdgeEditor();
      }
      return;
    } else if(state.tab==="viewer" && typeof renderSelectedEdgeViewer==="function"){
      renderSelectedEdgeViewer(edgeId);
      return;
    }
  }
  const node = IDX.nodeById.get(nodeId);
  const locked = (state.lockedId === nodeId);
  detailsMeta.textContent = locked ? "locked" : (state.hoverId ? "hover" : "preview");

  const isFieldNode = node?.type === "field";
  const selectedFields = new Set(selectedFieldsSet || []);

  const inbound = [];
  const outbound = [];
  const linked = [];
  const seen = new Set();
  const candidates = isFieldNode ? (IDX.edgesByField.get(nodeId) || []) : IDX.edges;

  for(const e of candidates){
    if(!e || seen.has(e.id)) continue;
    if(!isFieldNode){
      if(!(selectedFields.has(e.from) || selectedFields.has(e.to))) continue;
    }
    seen.add(e.id);
    const dir = e.direction || 'forward';
    if(dir === 'none'){
      // Directionless: always linked
      if(selectedFields.has(e.from) || selectedFields.has(e.to)) linked.push(e);
    } else if(dir === 'both'){
      // Bidirectional: show in both inbound and outbound
      if(selectedFields.has(e.from) && !selectedFields.has(e.to)){ outbound.push(e); inbound.push(e); }
      else if(selectedFields.has(e.to) && !selectedFields.has(e.from)){ inbound.push(e); outbound.push(e); }
    } else {
      // Forward: normal classification
      if(selectedFields.has(e.from) && !selectedFields.has(e.to)) outbound.push(e);
      if(selectedFields.has(e.to) && !selectedFields.has(e.from)) inbound.push(e);
    }
  }

  inbound.sort(compareEdgesSimple);
  outbound.sort(compareEdgesSimple);
  linked.sort(compareEdgesSimple);

  const summaryParts = [`Inbound: ${inbound.length}`, `Outbound: ${outbound.length}`];
  if(linked.length) summaryParts.push(`Linked: ${linked.length}`);
  const summary = summaryParts.join('  ');

  function otherEnd(edge, dir){
    if(dir === 'linked'){
      // For linked edges, show the other end relative to the current node
      return selectedFields.has(edge.from) ? edge.to : edge.from;
    }
    return dir==='out' ? edge.to : edge.from;
  }

  function item(edge, dir){
    const jump = otherEnd(edge, dir);
    const jumpNode = IDX.nodeById.get(jump);
    const jumpLabel = jumpNode?.label ?? jump;
    const side = columnOf(jump) ?? "node";
    const title = escapeHtml(edgeTooltip(edge));
    const eDir = edge.direction || 'forward';
    // Perspective-aware route: selected node on left for outbound, right for inbound
    let dFrom = edge.from, dTo = edge.to;
    if(eDir === 'both' || eDir === 'none'){
      if(dir === 'out' && !selectedFields.has(edge.from) && selectedFields.has(edge.to)){ dFrom = edge.to; dTo = edge.from; }
      else if(dir === 'in' && selectedFields.has(edge.from) && !selectedFields.has(edge.to)){ dFrom = edge.to; dTo = edge.from; }
      else if(dir === 'linked' && !selectedFields.has(edge.from) && selectedFields.has(edge.to)){ dFrom = edge.to; dTo = edge.from; }
    }
    const arrowSym = eDir === 'none' ? '' : eDir === 'both' ? '' : '';
    const route = `${dFrom} ${arrowSym} ${dTo}`;
    const prefix = dir === 'linked' ? '' : dir === 'out' ? 'out' : 'in';
    const dirBadge = eDir === 'both' ? '<span class="pill" style="opacity:.6;" title="Bidirectional"></span>' : eDir === 'none' ? '<span class="pill" style="opacity:.6;" title="Linked"></span>' : '';
    return `
      <li class="item" data-jump-id="${escapeHtml(jump)}" data-edge-id="${escapeHtml(edge.id)}" title="${title}">
        <span class="pill">${escapeHtml(side)}</span>
        <span class="pill">${escapeHtml(prefix)}</span>
        ${dirBadge}
 <span class=\"itemBreak\"></span>
        <span class="txt">${escapeHtml(jumpLabel)}</span>
        ${badgeHtml(edge)}
        ${edge.label ? `<span class="tag" title="Label" style="font-weight:600;font-size:10px;opacity:.85;">${escapeHtml(edge.label)}</span>` : ''}
        <span class="route">${escapeHtml(route)}</span>${(edge.note && String(edge.note).trim()) ? `<span class="mapNote">${escapeHtml(short(edge.note, 120))}</span>` : ``}
      </li>
    `;
  }

  function section(title, arr, dir, collapsed){
    const cls = collapsed ? 'collapsed' : '';
    return `
      <div class="box detailSection ${cls}">
        <h3 class="detailSectionHead"><span>${escapeHtml(title)}</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${arr.length}</span></h3>
        <div class="detailSectionBody">
        ${arr.length ? `<ul class="list">${arr.map(e => item(e, dir)).join("\n")}</ul>` : `<div class="empty">None.</div>`}
        </div>
      </div>
    `;
  }

  // Children section for groups
  let childrenHtml = '';
  if(!isFieldNode && node && Array.isArray(node.children) && node.children.length){
    const childCards = node.children.map(ch => miniNodeCard(ch.id)).join('');
    childrenHtml = `
      <div class="box detailSection collapsed">
        <h3 class="detailSectionHead"><span>Children</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${node.children.length}</span></h3>
        <div class="detailSectionBody" style="padding-top:8px;">
          ${childCards}
        </div>
      </div>
    `;
  }

  const defaultCollapsed = !isFieldNode;

  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtHero">
        <div class="dtName">${escapeHtml(node?.label ?? "")}</div>
        <span class="dtType${node?.type==='group' ? ' group' : ''}">${escapeHtml(node?.type ?? "")}</span>
      </div>
      <div class="dtRow">
        <span class="dtRowK">ID</span>
        <span class="dtRowV"><span class="dtId">${escapeHtml(nodeId)}${isLikelyAutoId(node) ? '<span class="autoTag">auto</span>' : ''}</span></span>
      </div>
      ${(() => {
        const _colId = columnOf(nodeId);
        const _colIdx = IDX.columnIndex.get(_colId);
        const _colObj = _colIdx !== undefined ? IDX.columns[_colIdx] : null;
        const _colLabel = _colObj ? (_colObj.label || _colObj.id) : _colId;
        return _colId ? `<div class="dtRow"><span class="dtRowK">Column</span><span class="dtRowV">${escapeHtml(_colLabel)}${_colLabel !== _colId ? ` <span style="font-family:var(--mono);font-size:10px;opacity:.35;">  ${escapeHtml(_colId)}</span>` : ''}</span></div>` : '';
      })()}
      ${(node && node.note && String(node.note).trim()) ? `<div class="dtNote">${escapeHtml(node.note)}</div>` : ''}
      ${(node && node.color) ? `<div class="dtRow">
        <span class="dtRowK">Color</span>
        <span class="dtRowV"><span class="dtColorSwatch" style="background:${escapeHtml(node.color)};"></span> <span style="font-family:var(--mono);font-size:11px;opacity:.55;">${escapeHtml(node.color)}</span></span>
      </div>` : ''}
      <div class="dtStatRow">
        <span class="dtStatChip"><span class="dtStatN">${inbound.length}</span><span class="dtStatL">in</span></span>
        <span class="dtStatChip"><span class="dtStatN">${outbound.length}</span><span class="dtStatL">out</span></span>
      </div>
${(node && Array.isArray(node.tags) && node.tags.length) ? `<div class="dtChipWrap">${tagsHtmlForDetails(node)}</div>` : ''}
${(node && node.customAttributes && Object.keys(node.customAttributes||{}).length) ? `<div style="padding:2px 0;">${Object.keys(node.customAttributes).sort().map(aid=>{
      const raw = node.customAttributes[aid];
      const a = customAttrById(aid)||{id:aid,label:aid};
      const vals = Array.isArray(raw) ? raw : [raw];
      const valueTags = vals.map(vid=>{
        const v = customValueById(aid, vid)||{id:vid,label:vid};
        return `<span class="dtAttrVal">${escapeHtml(_catalogItemLabel(v))}</span>`;
      }).join('');
      return `<div class="dtAttrGroup"><span class="dtAttrLabel">${escapeHtml(a.label||a.id)}</span>${valueTags}</div>`;
    }).join('')}</div>` : ''}
    </div>
    ${childrenHtml}
    ${section('Inbound mappings', inbound, 'in', defaultCollapsed)}
    ${section('Outbound mappings', outbound, 'out', defaultCollapsed)}
    ${linked.length ? section('Linked (directionless)', linked, 'linked', defaultCollapsed) : ''}
  `;

  // Wire collapsible section toggles
  detailsBody.querySelectorAll('.detailSectionHead').forEach(h => {
    h.style.cursor = 'pointer';
    h.addEventListener('click', () => {
      h.closest('.detailSection').classList.toggle('collapsed');
    });
  });

  detailsBody.querySelectorAll('[data-jump-id]').forEach(li => {
  li.addEventListener('click', () => {
    const eid = li.getAttribute('data-edge-id');
    if(eid){ selectEdge(eid); } else {
      const id = li.dataset.jumpId; lockSelection(id); scrollIntoView(id);
    }
  });
});
}


function scrollIntoView(nodeId){
  const el = IDX.elementById.get(nodeId);
  if(!el || el.classList.contains("hidden")) return;

  // expand ancestors
  let p = IDX.parentById.get(nodeId);
  while(p){
    toggleCollapse(p, false);
    p = IDX.parentById.get(p);
  }

  const row = IDX.rowById.get(nodeId);
 // If the node is a column root (not rendered), scroll the whole panel into view
 if(!row){
   const panel = IDX.panelByColumnId.get(nodeId);
   if(panel){ panel.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' }); }
   scheduleArrowsUpdate();
   return;
 }
  if(row){
    row.scrollIntoView({ behavior: "smooth", block: "center", inline: "nearest" });
  }
  scheduleArrowsUpdate();
}

/* =========================
   Interactions
========================= */
// Centralized edge selection (clears node selection + editor snapshots)
function selectEdge(eid){
  if(!eid) return;
  
  // Toggle: if already selected, clear selection
  if(state.selectedEdgeId === eid){
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    state._consolidatedEdgeCache = null;
    state._selectedEdgeEndpoints = null;
    try{ if(IDX && IDX.elementById){ IDX.elementById.forEach(el=>{ el.classList && el.classList.remove('active','connected','dimmed'); }); } }catch(e){}
    if(state.editorMode){
      try{ clearEdgeEditSession({clearSelection:true}); }catch(e){}
    }
    renderAll(); // includes applyHighlight
    return;
  }
  
  try{ if(IDX && IDX.elementById){ IDX.elementById.forEach(el=>{ el.classList && el.classList.remove('active','connected','dimmed'); }); } }catch(e){}
  let __nodeEditReverted = false;
  if(state.editorMode){
    try{ clearEdgeEditSession({clearSelection:false}); }catch(e){}
    try{ if(typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'){ revertEditSnapshot(); __nodeEditReverted = true; checkDirtyState(); } }catch(e){}
    __editSnapshot = null;
    state.selectedColumnId = null;
  }
  // clear any node selection/hover
  state.lockedId = null;
  state.hoverId = null;
  state.multiSelection.clear();
  state.selectedEdgeId = eid;
  state.hoverEdgeId = null;
  // Cache edge endpoints for multi-select transition
  const _selE = IDX.edges.find(x=>x.id===eid);
  state._selectedEdgeEndpoints = _selE ? { from: _selE.from, to: _selE.to } : null;
  
  // If we reverted a node edit, we must rebuild columns to clear stale tag pills etc.
  if(__nodeEditReverted){
    renderAll(); // includes applyHighlight + updateDetails + scheduleArrowsUpdate
  } else {
    applyHighlight(); // includes updateDetails + scheduleArrowsUpdate
  }
}

function lockSelection(nodeId, evt){
  // Commit any active inline rename before changing selection
  if(__inlineRename && __inlineRename.nodeId !== nodeId) commitInlineRename();
  // Capture edge endpoints BEFORE clearing, so Ctrl+click can preserve them
  const _prevEdgeEndpoints = state._selectedEdgeEndpoints || null;
  state._selectedEdgeEndpoints = null;
  // Close any mapping edit session when focusing a node (Editor mode).
  // Don't use clearSelection  lockSelection manages node selection itself.
  if(state.editorMode){ clearEdgeEditSession(); }
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state._consolidatedEdgeCache = null;

  const isCtrl = evt && (evt.ctrlKey || evt.metaKey);
  const isShift = evt && evt.shiftKey;
  const isAlt = evt && evt.altKey;

  // --- Chain select: Alt+click (full), Alt+Shift (upstream), Alt+Ctrl/Cmd (downstream) ---
  if(isAlt){
    // Clear edit sessions (guard already prompted in row click handler)
    __editSnapshot = null;
    __edgeEditSession = null;
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;

    // Determine direction
    const direction = (isShift && !isCtrl) ? 'upstream'
                    : (isCtrl && !isShift) ? 'downstream'
                    : 'both';

    // Gather current selection set
    const currentSel = new Set(state.multiSelection);
    if(state.lockedId) currentSel.add(state.lockedId);

    if(direction === 'both'){
      // Full chain select: original bidirectional logic
      // Compute the connected fields for the entire current selection
      const currentConnected = new Set();
      for(const nid of currentSel){
        const tmp = computeHighlightForNode(nid);
        for(const f of tmp.connectedFields) currentConnected.add(f);
      }

      const alreadySelected = currentSel.has(nodeId);
      const isConnected = currentConnected.has(nodeId);

      if(!alreadySelected && isConnected && currentSel.size > 0){
        // Connected but not selected  find path from clicked node to nearest selected node
        const visited = new Map();
        const queue = [nodeId];
        visited.set(nodeId, null);
        let foundTarget = null;
        while(queue.length > 0){
          const cur = queue.shift();
          if(cur !== nodeId && currentSel.has(cur)){
            foundTarget = cur;
            break;
          }
          const adj = IDX.adjacency.get(cur);
          if(adj){
            for(const nb of adj){
              if(!visited.has(nb)){
                visited.set(nb, cur);
                queue.push(nb);
              }
            }
          }
        }
        if(foundTarget !== null){
          let cur = foundTarget;
          while(cur !== null){
            currentSel.add(cur);
            cur = visited.get(cur);
          }
        } else {
          currentSel.add(nodeId);
        }
      } else {
        // Already selected OR not connected  add entire chain
        const chain = computeHighlightForNode(nodeId);
        for(const f of chain.connectedFields) currentSel.add(f);
      }
    } else {
      // Directional chain select (upstream or downstream)
      const directedNodes = computeDirectedChain(nodeId, direction);
      for(const f of directedNodes) currentSel.add(f);
    }

    // Always include the clicked node itself and all its descendants (including child groups)
    currentSel.add(nodeId);
    const clickedNode = IDX.nodeById.get(nodeId);
    if(clickedNode && clickedNode.children){
      const stack = [...clickedNode.children];
      while(stack.length){
        const n = stack.pop();
        currentSel.add(n.id);
        if(n.children) stack.push(...n.children);
      }
    }

    // Apply to state
    state.multiSelection = currentSel;
    state.lockedId = null;
    if(state.multiSelection.size === 1){
      state.lockedId = [...state.multiSelection][0];
      state.multiSelection.clear();
    }
    state.hoverId = null;
    state.nodeEditorAttrFocus = '';
    state._lastClickedNodeId = nodeId;
    applyHighlight();
    return;
  }

  // --- Multi-select: Ctrl/Cmd+click ---
  if(isCtrl){
    // Capture lockedId before cleanup
    const _prevLocked = state.lockedId;
    // Clear edit sessions (guard already prompted in row click handler)
    __editSnapshot = null;
    __edgeEditSession = null;
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    // If there's a single lockedId and multiSelection is empty, seed it
    if(state.multiSelection.size === 0 && _prevLocked && _prevLocked !== nodeId){
      state.multiSelection.add(_prevLocked);
    }
    // Preserve selected edge endpoints into multi-selection
    if(_prevEdgeEndpoints){
      state.multiSelection.add(_prevEdgeEndpoints.from);
      state.multiSelection.add(_prevEdgeEndpoints.to);
    }
    // Toggle this node in the set
    if(state.multiSelection.has(nodeId)){
      state.multiSelection.delete(nodeId);
    } else {
      state.multiSelection.add(nodeId);
      state._lastClickedNodeId = nodeId; // move anchor for Shift+click range
    }
    // If multi-selection reduced to 0, clear; if 1, convert to single lock
    if(state.multiSelection.size === 0){
      state.lockedId = null;
    } else if(state.multiSelection.size === 1){
      state.lockedId = [...state.multiSelection][0];
      state.multiSelection.clear();
    } else {
      state.lockedId = null; // multi takes over
    }
    state.hoverId = null;
    state.nodeEditorAttrFocus = '';
    applyHighlight();
    return;
  }

  // --- Multi-select: Shift+click (range within column) ---
  if(isShift && state._lastClickedNodeId){
    // Clear edit sessions (guard already prompted in row click handler)
    __editSnapshot = null;
    __edgeEditSession = null;
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    // Preserve selected edge endpoints
    if(_prevEdgeEndpoints){
      state.multiSelection.add(_prevEdgeEndpoints.from);
      state.multiSelection.add(_prevEdgeEndpoints.to);
    }
    const lastCol = columnOf(state._lastClickedNodeId);
    const thisCol = columnOf(nodeId);
    if(lastCol && lastCol === thisCol){
      // Get visible order of nodes in this column's tree
      const panel = IDX.panelByColumnId.get(lastCol);
      if(panel){
        const allRows = Array.from(panel.querySelectorAll('.row[data-node-id]'));
        const visibleIds = allRows
          .filter(r => !r.closest('.hidden') && r.offsetParent !== null)
          .map(r => r.dataset.nodeId);
        const idxA = visibleIds.indexOf(state._lastClickedNodeId);
        const idxB = visibleIds.indexOf(nodeId);
        if(idxA >= 0 && idxB >= 0){
          const start = Math.min(idxA, idxB);
          const end = Math.max(idxA, idxB);
          // Seed with existing lockedId if needed
          if(state.multiSelection.size === 0 && state.lockedId){
            state.multiSelection.add(state.lockedId);
          }
          for(let i = start; i <= end; i++){
            state.multiSelection.add(visibleIds[i]);
          }
          state.lockedId = null;
          state.hoverId = null;
          state.nodeEditorAttrFocus = '';
          applyHighlight();
          return;
        }
      }
    }
  }

  // --- Normal single click (original behavior) ---
  // Clear multi-selection on normal click
  if(state.multiSelection.size > 0){
    state.multiSelection.clear();
  }

  // DESELECT_AS_CANCEL: if node editor has pending snapshot and user deselects the same node, treat as Cancel.
  let didCancelEdit = false;
  if(state.editorMode && state.lockedId===nodeId && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node' && __editSnapshot.id===nodeId){
    cancelEditAndDeselect();
    didCancelEdit = true;
    // Don't return - but we'll skip toggle logic below since cancel already deselected
  }

  // If a mapping editor is open, close it (Cancel behavior) before changing focus.
  if(state.editorMode && state.selectedEdgeId){
    clearEdgeEditSession({clearSelection:true});
  }

  // If we are editing a node (snapshot exists) and the user clicks a different node,
  // abandon the pending node edits (like Cancel) but keep the new focus change.
  let reverted = false;
  try{
    if(state.editorMode && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'
      && state.lockedId && state.lockedId!==nodeId){
      revertEditSnapshot();
      __editSnapshot = null;
      reverted = true;
      checkDirtyState();
    }
  }catch(e){ /* safe no-op */ }

  // Toggle logic: if already locked on this node, unlock; otherwise lock
  // Skip if we just canceled an edit (already deselected)
  if(!didCancelEdit){
    if(state.lockedId === nodeId){
      // Reset attribute editor UI focus when clearing selection.
      if(state) state.nodeEditorAttrFocus = '';
      state.lockedId = null;
      state.hoverId = null;
    } else {
      // Reset attribute editor UI focus when switching nodes.
      if(state) state.nodeEditorAttrFocus = '';
      state.lockedId = nodeId;
      state.hoverId = null;
    }
  }

  // Track last clicked node for shift+click range
  state._lastClickedNodeId = nodeId;

  // We must re-render if we reverted, because the UI may have been updated live while editing.
  if(reverted){
    renderAll();
  }
  applyHighlight();
}

function attachTreeInteractions(treeEl){
  // hover preview
  let _hoverOutTimer = null;
  treeEl.addEventListener("mouseover", (e) => {
    if(state.panMode) return;
    if(state._lassoActive) return;
    if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
    if(state.__hoverCooldownUntil && Date.now() < state.__hoverCooldownUntil) return;
    const row = e.target.closest(".row");
    if(!row) return;
    const id = row.dataset.nodeId;
    if(!id) return;
    if(IDX.elementById.get(id)?.classList.contains("hidden")) return;
    if(_hoverOutTimer){ clearTimeout(_hoverOutTimer); _hoverOutTimer = null; }
    state.hoverId = id;
    applyHighlight();
  });

  treeEl.addEventListener("mouseout", (e) => {
    if(state.panMode) return;
    if(state._lassoActive) return;
    if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
    const row = e.target.closest(".row");
    if(!row) return;
    const related = e.relatedTarget;
    if(related && row.contains(related)) return;
    if(_hoverOutTimer) clearTimeout(_hoverOutTimer);
    _hoverOutTimer = setTimeout(() => {
      _hoverOutTimer = null;
      if(!state.hoverId) return;
      state.hoverId = null;
      applyHighlight();
    }, 32);
  });

  // click: caret collapses, row locks selection
  treeEl.addEventListener("click", async (e) => {
    const caret = e.target.closest(".caret");
    if(caret){
      const id = caret.dataset.caretFor;
      if(id) toggleCollapse(id, null);
      e.stopPropagation();
      return;
    }
    const row = e.target.closest(".row");
    if(!row) return;
    const id = row.dataset.nodeId;
    if(!id) return;
    if(IDX.elementById.get(id)?.classList.contains("hidden")) return;
    if(state.editorMode && nodeEditIsDirty() && __editSnapshot?.id !== id){
      if(!await guardNodeAbandon()) return;
      revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
    }
    if(state.editorMode && edgeEditIsDirty()){
      const eid = __edgeEditSession?.edgeId || '';
      if(!await guardAbandonEdit('mapping', eid)) return;
    }
    lockSelection(id, e);
  });

  // Right-click: open node context menu at cursor position (Editor mode)
  treeEl.addEventListener("contextmenu", (e) => {
    const row = e.target.closest(".row");
    if(!row) return;
    if(!state.editorMode) return;
    // Find the  menu button inside this row's .rowActions
    const menuBtn = row.querySelector('.rowActions .miniBtn[title="Actions"]');
    if(!menuBtn || !menuBtn.__menuItems) return;
    e.preventDefault();
    // Select the node if not already selected
    const id = row.dataset.nodeId;
    if(id && state.lockedId !== id){
      state.selectedColumnId = null;
      state.selectedEdgeId = null;
      state.lockedId = id;
      state.hoverId = null;
      applyHighlight();
    }
    // Open menu at cursor position
    openCtxMenu(menuBtn.__menuItems, menuBtn, { x: e.clientX, y: e.clientY });
  });

  // arrows update on scroll
  treeEl.addEventListener("scroll", () => scheduleArrowsUpdate(), { passive: true });
}

/* =========================
   Arrows (multi-column)
   - Can connect any columns (non-adjacent supported)
   - Optional scope toggles (same-column, distant) reduce clutter
   - Default: show only arrows for highlighted selection (unless arrow mode is All)
========================= */
let arrowRaf = null;

function scheduleArrowsUpdate(){
  if(!state.arrowsOn) return;
  if(arrowRaf) return;
  arrowRaf = requestAnimationFrame(() => {
    arrowRaf = null;
    drawArrows();
  });
}

window.addEventListener("resize", () => scheduleArrowsUpdate(), { passive: true });
columnsScroller.addEventListener("scroll", () => scheduleArrowsUpdate(), { passive: true });
// Redraw arrows when scroller area changes (panel resize, dock changes)
if(typeof ResizeObserver !== 'undefined'){
  new ResizeObserver(() => scheduleArrowsUpdate()).observe(columnsScroller);
}

// Click empty space in viewer  deselect node/edge (Cancel if editing)
columnsScroller.addEventListener("click", (e) => {
  if(state.panMode) return;
  // Skip if lasso just completed
  if(state._lassoJustCompleted && Date.now() - state._lassoJustCompleted < 200) return;
  // Only fire if click is directly on background areas, not on nodes/rows/buttons/inputs
  const t = e.target;
  if(t.closest('.row') || t.closest('.btn') || t.closest('input') || t.closest('select') ||
     t.closest('label') || t.closest('.panelHeader') || t.closest('.tagChip') ||
     t.closest('.rowActions') || t.closest('.caret') || t.closest('path') || t.closest('svg')) return;
  // Don't deselect if a modal is open
  if(document.querySelector('.modal.active')) return;
  if(state.lockedId || state.selectedEdgeId || state.selectedColumnId || state.multiSelection.size > 0){
    if(state.editorMode && __editSnapshot && __editSnapshot.data){
      cancelEditAndDeselect();
    } else if(state.editorMode && state.selectedEdgeId){
      clearEdgeEditSession({clearSelection:true});
      state.lockedId = null;
      state.hoverId = null;
      state.multiSelection.clear();
      state.__hoverCooldownUntil = Date.now() + 300;
      applyHighlight();
    } else {
      state.lockedId = null;
      state.hoverId = null;
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
      state.selectedColumnId = null;
      state.multiSelection.clear();
      state.__hoverCooldownUntil = Date.now() + 300;
      applyHighlight();
    }
  }
});

// Right-click on column header: open column context menu at cursor position (Editor mode)
columnsScroller.addEventListener("contextmenu", (e) => {
  const header = e.target.closest(".panelHeader");
  if(!header) return;
  if(!state.editorMode) return;
  const panel = header.closest(".panel");
  if(!panel) return;
  const colId = panel.dataset.columnId;
  if(!colId) return;
  e.preventDefault();
  // Select the column
  if(state.selectedColumnId !== colId || state.lockedId !== colId){
    selectColumn(colId);
  }
  // Open column menu at cursor position
  const menuBtn = header.querySelector('.colActions .miniBtn[title="Column actions"]');
  openColumnMenu(menuBtn || header, colId, { x: e.clientX, y: e.clientY });
});

function isVisibleNodeId(id){
  const el = IDX.elementById.get(id);
  if(!el || el.classList.contains("hidden")) return false;
  const row = IDX.rowById.get(id);
  if(!row || !row.offsetParent) return false; // hidden by collapsed parent
  
  // Check if the node's column is hidden
  const col = columnOf(id);
  if(col && state.hiddenColumns && state.hiddenColumns.has(col)) return false;
  
  return true;
}

// Pre-computed map of columnId  { top, bottom } in SVG coords for clamping.
// Set at the start of drawArrows(), cleared after.
let __treeClipBounds = null;

function anchorPoint(nodeId, svgRect, zoomFactor){
  const row = IDX.rowById.get(nodeId);
  if(!row) return null;
  const r = row.getBoundingClientRect();
  const z = zoomFactor || 1;
  const rawY = ((r.top + r.height/2) - svgRect.top) / z;
  const left = { x: (r.left - svgRect.left) / z, y: rawY };
  const right = { x: (r.right - svgRect.left) / z, y: rawY };

  // Clamp to column tree visible area when row is scrolled out of view
  let clamped = null; // 'above' | 'below' | null
  if(__treeClipBounds){
    const colId = columnOf(nodeId);
    const bounds = colId && __treeClipBounds.get(colId);
    if(bounds){
      if(rawY < bounds.top){
        left.y = bounds.top;
        right.y = bounds.top;
        clamped = 'above';
      } else if(rawY > bounds.bottom){
        left.y = bounds.bottom;
        right.y = bounds.bottom;
        clamped = 'below';
      }
    }
  }
  return { left, right, clamped };
}


function bezier(p1, p2, fromClamped, toClamped){
  const dist = Math.abs(p2.x - p1.x);
  const dx = Math.max(40, dist * 0.35);
  // Default horizontal control points
  let c1x = p1.x + (p2.x > p1.x ? dx : -dx);
  let c1y = p1.y;
  let c2x = p2.x - (p2.x > p1.x ? dx : -dx);
  let c2y = p2.y;
  // Clamped: control point approaches vertically (toward the other endpoint)
  if(fromClamped){
    c1x = p1.x;
    c1y = p1.y + (p2.y > p1.y ? dx : -dx);
  }
  if(toClamped){
    c2x = p2.x;
    c2y = p2.y + (p1.y > p2.y ? dx : -dx);
  }
  return `M ${p1.x.toFixed(1)} ${p1.y.toFixed(1)} C ${c1x.toFixed(1)} ${c1y.toFixed(1)}, ${c2x.toFixed(1)} ${c2y.toFixed(1)}, ${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
}

function orthoPath(p1, p2, midX){
  // simple orthogonal routing: horizontal -> vertical -> horizontal
  const mx = midX;
  return `M ${p1.x.toFixed(1)} ${p1.y.toFixed(1)} L ${mx.toFixed(1)} ${p1.y.toFixed(1)} L ${mx.toFixed(1)} ${p2.y.toFixed(1)} L ${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
}

// Arrowhead geometry tuning (must match marker path tip X: 12.5)
const ARROW_TIP_LEN = 13; // px in userSpaceOnUse
// Adjust a clamped endpoint: snap x to column edge, back off y for triangle base
// side: 'left' or 'right'  which side of the column this endpoint connects from
const CLAMP_TRI_SZ = 5;
function _adjustClampedEndpoint(p, nodeId, clampDir, side){
  if(!clampDir || !__treeClipBounds) return p;
  const colId = columnOf(nodeId);
  const bounds = colId && __treeClipBounds.get(colId);
  if(!bounds) return p;
  // Snap X to column edge; Y stays at clamped position from anchorPoint
  const nx = side === 'left' ? bounds.left : bounds.right;
  return { x: nx, y: p.y };
}

// Draw a small directional indicator (/) at a clamped arrow endpoint
function _drawClampIndicator(parent, x, y, direction, color){
  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.classList.add('clampIndicator');
  const sz = 5;
  let points;
  if(direction === 'above'){
    // Triangle pointing UP   base at y, tip at y - 2*sz
    points = `${x},${y - sz*2} ${x - sz},${y} ${x + sz},${y}`;
  } else {
    // Triangle pointing DOWN   base at y, tip at y + 2*sz
    points = `${x - sz},${y} ${x + sz},${y} ${x},${y + sz*2}`;
  }
  const tri = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
  tri.setAttribute('points', points);
  tri.setAttribute('fill', color || 'rgba(255,255,255,.25)');
  tri.setAttribute('stroke', 'none');
  g.appendChild(tri);
  parent.appendChild(g);
  return g;
}

// Remove any existing clamp indicators for a path
function _clearClampIndicators(path){
  if(path.__clampFrom){ try{ path.__clampFrom.remove(); }catch{} path.__clampFrom = null; }
  if(path.__clampTo){ try{ path.__clampTo.remove(); }catch{} path.__clampTo = null; }
}

// Draw center-opposing arrows () at midpoint of path for consolidated two-forwards
function _drawMidOpposingArrows(parent, pathEl, colorFwd, colorRev){
  if(!colorRev) colorRev = colorFwd; // fallback to single color
  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.classList.add('midArrows');
  try {
    const len = pathEl.getTotalLength();
    const mid = pathEl.getPointAtLength(len * 0.5);
    // Get tangent by sampling nearby points
    const dt = Math.min(2, len * 0.01);
    const pBefore = pathEl.getPointAtLength(len * 0.5 - dt);
    const pAfter = pathEl.getPointAtLength(len * 0.5 + dt);
    const angle = Math.atan2(pAfter.y - pBefore.y, pAfter.x - pBefore.x);
    
    // Match SVG marker exactly: 13px long, 8.8px wide (M0,2.6 L0,11.4 L13,7 z)
    const arrowLen = 13;
    const baseHalf = 4.4; // half of 8.8
    const tipGap = 1; // tiny gap between the two tips at center
    
    // Forward arrow ()  tip points INWARD toward center from target side
    // This represents the fromIdtoId direction
    const fTipX = mid.x + Math.cos(angle) * tipGap;
    const fTipY = mid.y + Math.sin(angle) * tipGap;
    const fBaseCX = mid.x + Math.cos(angle) * (tipGap + arrowLen);
    const fBaseCY = mid.y + Math.sin(angle) * (tipGap + arrowLen);
    const fBL = { x: fBaseCX + Math.cos(angle + Math.PI/2) * baseHalf, y: fBaseCY + Math.sin(angle + Math.PI/2) * baseHalf };
    const fBR = { x: fBaseCX + Math.cos(angle - Math.PI/2) * baseHalf, y: fBaseCY + Math.sin(angle - Math.PI/2) * baseHalf };
    
    const tri1 = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    tri1.setAttribute('points', `${fTipX},${fTipY} ${fBL.x},${fBL.y} ${fBR.x},${fBR.y}`);
    tri1.setAttribute('fill', colorRev); // target-side arrow = reverse edge color
    tri1.setAttribute('stroke', 'none');
    g.appendChild(tri1);
    
    // Reverse arrow ()  tip points INWARD toward center from source side
    // This represents the toIdfromId direction
    const rTipX = mid.x - Math.cos(angle) * tipGap;
    const rTipY = mid.y - Math.sin(angle) * tipGap;
    const rBaseCX = mid.x - Math.cos(angle) * (tipGap + arrowLen);
    const rBaseCY = mid.y - Math.sin(angle) * (tipGap + arrowLen);
    const rBL = { x: rBaseCX + Math.cos(angle + Math.PI/2) * baseHalf, y: rBaseCY + Math.sin(angle + Math.PI/2) * baseHalf };
    const rBR = { x: rBaseCX + Math.cos(angle - Math.PI/2) * baseHalf, y: rBaseCY + Math.sin(angle - Math.PI/2) * baseHalf };
    
    const tri2 = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    tri2.setAttribute('points', `${rTipX},${rTipY} ${rBL.x},${rBL.y} ${rBR.x},${rBR.y}`);
    tri2.setAttribute('fill', colorFwd); // source-side arrow = forward edge color
    tri2.setAttribute('stroke', 'none');
    g.appendChild(tri2);
  } catch(ex) {}
  parent.appendChild(g);
  return g;
}

// Resolve custom color for a single edge (filter > scheme > custom)
function _resolveEdgeColor(edge){
  if(!edge) return '';
  // Filter color
  if(hasActiveFilters()){
    const cat = ensureFilterCatalog();
    const sorted = [...cat].sort((a,b)=>(typeof a.priority==='number'?a.priority:9999)-(typeof b.priority==='number'?b.priority:9999));
    const fn = IDX?.nodeById?.get(edge.from);
    const tn = IDX?.nodeById?.get(edge.to);
    if(fn && tn){
      for(const f of sorted){
        if(!state.activeFilterIds.includes(f.id)) continue;
        if(!f.highlight?.edgeEnabled || !f.highlight?.edgeColor) continue;
        if(evaluateFilter(fn, f.id) && evaluateFilter(tn, f.id)) return f.highlight.edgeColor;
      }
    }
  }
  // Scheme color
  const sc = getEdgeSchemeColor(edge);
  if(sc) return sc;
  // Custom color
  return edge.color || '';
}

// Get colors for consolidated two-forward pair: { fwdColor, revColor }
// fwd = fromIdtoId edge, rev = toIdfromId edge
function _getConsolidatedPairColors(fromId, toId, consolidatedEdges, fallback){
  let fwdColor = fallback, revColor = fallback;
  if(consolidatedEdges && consolidatedEdges.length >= 2){
    for(const ce of consolidatedEdges){
      const clr = _resolveEdgeColor(ce);
      if(clr){
        if(ce.from === fromId && ce.to === toId) fwdColor = clr;
        else if(ce.from === toId && ce.to === fromId) revColor = clr;
      }
    }
  }
  return { fwdColor, revColor };
}

// Create a split gradient for a specific path
function _applySplitGradient(svg, pathEl, p1, p2, color1, color2){
  let defs = svg.querySelector('defs');
  if(!defs){ defs = document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.prepend(defs); }
  // Clean up previous gradient for this path
  if(pathEl.__splitGradId){
    const old = defs.querySelector('#' + pathEl.__splitGradId);
    if(old) old.remove();
  }
  const uid = 'sg_' + (Math.random().toString(36).slice(2,8));
  const grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
  grad.id = uid;
  grad.setAttribute('gradientUnits','userSpaceOnUse');
  grad.setAttribute('x1', p1.x); grad.setAttribute('y1', p1.y);
  grad.setAttribute('x2', p2.x); grad.setAttribute('y2', p2.y);
  const s1 = document.createElementNS('http://www.w3.org/2000/svg','stop');
  s1.setAttribute('offset','50%'); s1.setAttribute('stop-color', color1);
  const s2 = document.createElementNS('http://www.w3.org/2000/svg','stop');
  s2.setAttribute('offset','50%'); s2.setAttribute('stop-color', color2);
  grad.appendChild(s1); grad.appendChild(s2);
  defs.appendChild(grad);
  pathEl.__splitGradId = uid;
  return `url(#${uid})`;
}
function _clearSplitGradient(pathEl){
  if(pathEl.__splitGradId){
    try{ document.getElementById(pathEl.__splitGradId)?.remove(); }catch{}
    pathEl.__splitGradId = null;
  }
}

function _clearMidArrows(path){
  if(path.__midArrows){ try{ path.__midArrows.remove(); }catch{} path.__midArrows = null; }
}

function adjustEndForArrow(p1, p2, len=ARROW_TIP_LEN){
  // Keep the arrow tip vertically centered on the target row.
  // We only shift along X so the marker tip lands on the element edge,
  // while the line end stays at the base midpoint and Y remains at the row center.
  const dx = p2.x - p1.x;
  const dir = dx === 0 ? 0 : Math.sign(dx);
  return { x: p2.x - dir * len, y: p2.y };
}


function isAdjacentColumns(fromId, toId){
  const fc = columnOf(fromId);
  const tc = columnOf(toId);
  if(!fc || !tc) return false;
  const fi = visualColumnIndex(fc);
  const ti = visualColumnIndex(tc);
  if(fi < 0 || ti < 0) return false;
  return Math.abs(fi - ti) === 1;
}

/** Check if an edge passes arrow scope filters (same-column, distant) */
function edgeScopeVisible(fromId, toId){
  const fc = columnOf(fromId);
  const tc = columnOf(toId);
  if(!fc || !tc) return true;
  const fi = visualColumnIndex(fc);
  const ti = visualColumnIndex(tc);
  if(fi < 0 || ti < 0) return true;
  const span = Math.abs(fi - ti);
  if(span === 0 && !state.showSameColumn) return false;
  if(span > 1 && !state.showDistant) return false;
  return true;
}

// Returns the visual index of a column (skipping hidden columns)
function visualColumnIndex(colId){
  let vi = 0;
  for(const c of IDX.columns){
    if(state.hiddenColumns.has(c.id)) continue;
    if(c.id === colId) return vi;
    vi++;
  }
  return -1;
}


function findCollapsedParent(nodeId){
  // Walk up the parent chain to find the first VISIBLE collapsed group
  let currentId = nodeId;
  while(currentId){
    const parent = IDX.parentById.get(currentId);
    if(!parent) break;
    if(isCollapsedGroup(parent)){
      // Check if this collapsed parent is itself visible
      // If it's visible, this is our target
      // If it's not visible, keep walking up
      const parentEl = IDX.elementById.get(parent);
      if(parentEl && parentEl.offsetParent){
        // Parent is visible, use it
        return parent;
      }
      // Parent is not visible (hidden by its own collapsed parent), keep walking
    }
    currentId = parent;
  }
  return null;
}

function isCollapsedGroup(nodeId){
  const el = IDX.elementById.get(nodeId);
  if(!el) return false;
  // Check if element has 'collapsed' class (for groups)
  return el.classList.contains('collapsed');
}

function hasHiddenColumnsBetween(fromColId, toColId){
  if(fromColId === toColId) return false;
  
  const fromIdx = IDX.columnIndex.get(fromColId);
  const toIdx = IDX.columnIndex.get(toColId);
  if(fromIdx === undefined || toIdx === undefined) return false;
  
  const minIdx = Math.min(fromIdx, toIdx);
  const maxIdx = Math.max(fromIdx, toIdx);
  
  // Check if any column between fromIdx and toIdx is hidden
  for(let i = minIdx + 1; i < maxIdx; i++){
    const col = IDX.columns[i];
    if(col && state.hiddenColumns.has(col.id)){
      return true;
    }
  }
  return false;
}

// Find mapping chains that go through hidden columns
// Returns array of virtual edges: {from, to, chain: [edge1, edge2, ...], throughHiddenColumn: true}
function findChainsThoughHiddenColumns(){
  const virtualEdges = [];
  const processedPairs = new Set();
  
  // Recursive chain follower that handles branching through hidden columns
  function followChain(lastVisibleField, currentFieldId, chain, visited){
    if(visited.has(currentFieldId)) return; // cycle protection
    visited.add(currentFieldId);
    const col = columnOf(currentFieldId);
    if(!col) return;
    
    if(!state.hiddenColumns.has(col)){
      // Reached a visible column  emit virtual edge if chain went through hidden
      if(chain.length > 1){
        if(lastVisibleField === currentFieldId) return; // skip self-loops
        const pairKey = `${lastVisibleField}${currentFieldId}`;
        if(!processedPairs.has(pairKey)){
          processedPairs.add(pairKey);
          virtualEdges.push({
            from: lastVisibleField,
            to: currentFieldId,
            chain: [...chain],
            throughHiddenColumn: true,
            id: `virtual:${pairKey}`
          });
        }
      }
      return;
    }
    
    // Current field is in a hidden column  find ALL outgoing edges and branch
    const outgoing = IDX.edges.filter(e => e.from === currentFieldId);
    if(outgoing.length === 0) return; // dead end
    
    for(const nextEdge of outgoing){
      followChain(lastVisibleField, nextEdge.to, [...chain, nextEdge], visited);
    }
  }
  
  // For each edge starting from a visible column, try to follow chains
  for(const startEdge of IDX.edges){
    const startCol = columnOf(startEdge.from);
    if(!startCol || state.hiddenColumns.has(startCol)) continue; // Start must be visible
    
    const toCol = columnOf(startEdge.to);
    if(!toCol || !state.hiddenColumns.has(toCol)) continue; // Only interested if target is hidden
    
    // Start following the chain from the hidden target
    followChain(startEdge.from, startEdge.to, [startEdge], new Set([startEdge.from]));
  }
  
  return virtualEdges;
}


function drawArrows(){
  if(!state.arrowsOn) { 
    edgesLayer.querySelectorAll('.clampIndicator').forEach(el => el.remove());
    edgesLayer.querySelectorAll('.midArrows').forEach(el => el.remove());
    edgesLayer.innerHTML = ""; 
    __treeClipBounds = null; 
    return; 
  }

  // Pre-compute visible tree bounds for each column (for scroll clamping)
  __treeClipBounds = new Map();
  for(const col of IDX.columns){
    if(state.hiddenColumns.has(col.id)) continue;
    const panel = IDX.panelByColumnId.get(col.id);
    if(!panel) continue;
    const tree = panel.querySelector('.tree');
    if(!tree) continue;
    const tr = tree.getBoundingClientRect();
    const pr = panel.getBoundingClientRect();
    // Add a small inset so clamped arrows don't land exactly on the edge
    const inset = 6;
    // Store screen coords; converted to SVG coords after svgRect is available
    __treeClipBounds.set(col.id, { 
      screenTop: tr.top + inset, screenBottom: tr.bottom - inset,
      screenLeft: pr.left, screenRight: pr.right
    });
  }
  // Remove all mapping labels and clamp indicators  they are recreated each pass
  edgesLayer.querySelectorAll('text.edgeLabel').forEach(el => el.remove());
  edgesLayer.querySelectorAll('.clampIndicator').forEach(el => el.remove());
  edgesLayer.querySelectorAll('.midArrows').forEach(el => el.remove());
  // Reset SVG size before measuring to prevent self-inflating scrollWidth
  svgOverlay.style.width = '0';
  svgOverlay.style.height = '0';
  svgOverlay.setAttribute("width", 0);
  svgOverlay.setAttribute("height", 0);
  const zoomFactor = parseFloat(columnsScroller.style.zoom) || 1;
  const fullW = Math.max(columnsRow.scrollWidth, columnsScroller.clientWidth);
  const fullH = Math.max(columnsRow.scrollHeight, columnsScroller.clientHeight);
  svgOverlay.setAttribute("width", fullW);
  svgOverlay.setAttribute("height", fullH);
  svgOverlay.style.width = fullW + "px";
  svgOverlay.style.height = fullH + "px";
  const svgRect = svgOverlay.getBoundingClientRect();

  // Convert tree clip bounds from screen coords to SVG coords
  for(const [colId, bounds] of __treeClipBounds){
    bounds.top = (bounds.screenTop - svgRect.top) / zoomFactor;
    bounds.bottom = (bounds.screenBottom - svgRect.top) / zoomFactor;
    bounds.left = (bounds.screenLeft - svgRect.left) / zoomFactor;
    bounds.right = (bounds.screenRight - svgRect.left) / zoomFactor;
  }

  const effectiveNode = currentEffectiveId();
  const hasMulti = state.multiSelection.size > 0;
  // Pre-compute rightmost visible column for same-column arrow direction
  const __visColIds = IDX.columns.filter(c => !state.hiddenColumns.has(c.id)).map(c => c.id);
  const __rightmostColId = __visColIds.length ? __visColIds[__visColIds.length - 1] : null;
  const edgeFocusId = state.selectedEdgeId || state.hoverEdgeId;
  let highlightFields = null;
  let activeFields = null;
  if(hasMulti){
    // Multi-select: combine highlights for all selected nodes
    const allSelected = new Set();
    const allConnected = new Set();
    for(const nid of state.multiSelection){
      const { selectedFields, connectedFields } = computeHighlightForNode(nid);
      if(state.multiSelectArrowMode === 'direct'){
        for(const f of selectedFields){ allSelected.add(f); allConnected.add(f); }
        for(const f of selectedFields){
          const adj = IDX.adjacency.get(f);
          if(adj) for(const other of adj) allConnected.add(other);
        }
      } else {
        for(const f of selectedFields) allSelected.add(f);
        for(const f of connectedFields) allConnected.add(f);
      }
    }
    highlightFields = (state.multiSelectArrowMode === 'selected') ? allSelected : allConnected;
    activeFields = allSelected;
  } else if(effectiveNode){
    const { selectedFields, connectedFields } = computeHighlightForNode(effectiveNode);
    if(state.multiSelectArrowMode === 'direct'){
      const directConnected = new Set(selectedFields);
      for(const f of selectedFields){
        const adj = IDX.adjacency.get(f);
        if(adj) for(const other of adj) directConnected.add(other);
      }
      highlightFields = (state.multiSelectArrowMode === 'selected') ? selectedFields : directConnected;
    } else {
      highlightFields = (state.multiSelectArrowMode === 'selected') ? selectedFields : connectedFields;
    }
    activeFields = IDX.fieldIds.has(effectiveNode) ? selectedFields : new Set();
  } else if(edgeFocusId){
    // Check both real edges and virtual edges
    let ee = IDX.edges.find(x=>x.id===edgeFocusId);
    
    // If not found in real edges, check virtual edges
    if(!ee && edgeFocusId.startsWith('virtual:')){
      const virtualEdges = findChainsThoughHiddenColumns();
      ee = virtualEdges.find(x=>x.id===edgeFocusId);
    }
    
    if(ee){
      // Check if this edge has consolidated metadata (from path or edge object)
      // We need to check the path that will be drawn, but paths haven't been created yet...
      // So we compute it the same way: check if any endpoint will be redirected to collapsed group
      let needsConsolidatedCheck = false;
      let fromVisible = isVisibleNodeId(ee.from);
      let toVisible = isVisibleNodeId(ee.to);
      
      if(!fromVisible || !toVisible){
        // At least one endpoint might be redirected - might need consolidated handling
        needsConsolidatedCheck = true;
      }
      
      // If might be consolidated, find all edges with same redirected endpoints
      let edgesToHighlight = [ee];
      if(needsConsolidatedCheck){
        // Find all edges that will consolidate to the same arrow
        const allEdgesGrouped = new Map();
        for(const e of IDX.edges){
          let fid = e.from;
          let tid = e.to;
          
          if(!isVisibleNodeId(fid)){
            const cp = findCollapsedParent(fid);
            if(cp) fid = cp;
          }
          if(!isVisibleNodeId(tid)){
            const cp = findCollapsedParent(tid);
            if(cp) tid = cp;
          }
          
          const key = `${fid}${tid}`;
          if(!allEdgesGrouped.has(key)) allEdgesGrouped.set(key, []);
          allEdgesGrouped.get(key).push(e);
        }
        
        // Find which group ee belongs to
        let eeFid = ee.from;
        let eeTid = ee.to;
        if(!fromVisible){
          const cp = findCollapsedParent(eeFid);
          if(cp) eeFid = cp;
        }
        if(!toVisible){
          const cp = findCollapsedParent(eeTid);
          if(cp) eeTid = cp;
        }
        const eeKey = `${eeFid}${eeTid}`;
        edgesToHighlight = allEdgesGrouped.get(eeKey) || [ee];
      }
      
      // Compute highlights for all edges in the group
      const allConnected = new Set();
      const allSelected = new Set();
      for(const edge of edgesToHighlight){
        const a = computeHighlightForNode(edge.from);
        const b = computeHighlightForNode(edge.to);
        allSelected.add(edge.from);
        allSelected.add(edge.to);
        for(const f of a.connectedFields) allConnected.add(f);
        for(const f of b.connectedFields) allConnected.add(f);
      }
      
      highlightFields = (state.multiSelectArrowMode === 'selected') ? allSelected : allConnected;
      activeFields = allSelected;
    }
  }
  const shouldDimEdges = !!(highlightFields && state.selectionDim !== 'off');
  // if not "all arrows" and no selection, show none
  if(!state.allArrows && !effectiveNode && !edgeFocusId && !hasMulti){
    // fade out existing arrows smoothly and disable hitboxes
    Array.from(edgesLayer.querySelectorAll('path.edge')).forEach(path=>{
      path.classList.add('fadeOut');
      if(path.__hitbox) path.__hitbox.style.pointerEvents = 'none';
      _clearClampIndicators(path);
      _clearMidArrows(path);
      setTimeout(()=>{ 
        if(path.__hitbox) path.__hitbox.remove();
        path.remove(); 
      }, 180);
    });
    return;
  }

  // mark existing as not alive; we'll flip to alive when we (re)use them
  const existing = new Map();
  Array.from(edgesLayer.querySelectorAll('path.edge')).forEach(p=>{
    existing.set(p.dataset.edgeId, p);
    p.__alive = false;
  });

  const candidates = [];
  const collapsedGroupPairs = new Map(); // Track arrows between collapsed groups
  const bidirectionalFieldPairs = new Map(); // Track bidirectional field mappings
  
  // Find chains through hidden columns and create virtual edges
  const virtualEdges = findChainsThoughHiddenColumns();
  virtualEdges.forEach(ve => {
  });
  
  // Combine real edges with virtual edges for processing
  const allEdgesToProcess = [...IDX.edges, ...virtualEdges];
  
  for(const e of allEdgesToProcess){
    // Check visibility and redirect to collapsed groups if needed
    let fromId = e.from;
    let toId = e.to;
    let fromRedirected = false;
    let toRedirected = false;
    
    // If 'from' node is not visible, check if it's hidden by a collapsed parent
    if(!isVisibleNodeId(fromId)){
      const collapsedParent = findCollapsedParent(fromId);
      if(collapsedParent){
        fromId = collapsedParent;
        fromRedirected = true;
      } else {
        continue; // Skip if not visible and no collapsed parent
      }
    }
    
    // If 'to' node is not visible, check if it's hidden by a collapsed parent
    if(!isVisibleNodeId(toId)){
      const collapsedParent = findCollapsedParent(toId);
      if(collapsedParent){
        toId = collapsedParent;
        toRedirected = true;
      } else {
        continue; // Skip if not visible and no collapsed parent
      }
    }
    
    const isDotted = fromRedirected || toRedirected;
    const bothCollapsed = fromRedirected && toRedirected;
    const anyCollapsed = fromRedirected || toRedirected;
    
    // If any endpoint is redirected to collapsed group, consolidate by redirected endpoints
    // This handles:
    // 1. Both endpoints collapsed (A collapsed  B collapsed)
    // 2. One visible field  multiple fields in collapsed group (A  B collapsed)
    // 3. Multiple fields in collapsed group  one visible field (A collapsed  B)
    if(anyCollapsed){
      const pairKey = `${fromId}${toId}`;
      if(!collapsedGroupPairs.has(pairKey)){
        collapsedGroupPairs.set(pairKey, []);
      }
      collapsedGroupPairs.get(pairKey).push(e);
      // We'll process these separately below
      continue;
    }
    
    // Check for bidirectional field mappings
    // This includes:
    // 1. Both endpoints visible (not redirected)
    // 2. One endpoint redirected to collapsed group (hybrid case)
    const pairKey = `${fromId}${toId}`;
    const reversePairKey = `${toId}${fromId}`;
    
    // Check if reverse mapping exists (checking original field IDs)
    const reverseExists = IDX.edges.some(edge => 
      edge.from === e.to && edge.to === e.from
    );
    
    if(reverseExists && !bothCollapsed){
      // Add to bidirectional pairs (even if one is redirected)
      if(!bidirectionalFieldPairs.has(pairKey)){
        bidirectionalFieldPairs.set(pairKey, []);
      }
      bidirectionalFieldPairs.get(pairKey).push(e);
      continue; // Process later
    }
    
    if(!edgeScopeVisible(fromId, toId)) continue;
    if(!state.allArrows && highlightFields){
      if(!highlightFields.has(e.from) && !highlightFields.has(e.to)) continue;
    }
    const aFrom = anchorPoint(fromId, svgRect, zoomFactor);
    const aTo = anchorPoint(toId, svgRect, zoomFactor);
    if(!aFrom || !aTo) continue;
    const fCol = columnOf(fromId);
    const tCol = columnOf(toId);
    const fi = visualColumnIndex(fCol);
    const ti = visualColumnIndex(tCol);
    if(fi < 0 || ti < 0) continue;
    let p1, p2, fromSide, toSide;
    if(fi < ti){ p1 = aFrom.right; p2 = aTo.left; fromSide='right'; toSide='left'; }
    else if(fi > ti){ p1 = aFrom.left; p2 = aTo.right; fromSide='left'; toSide='right'; }
    else { const __isRM = fCol === __rightmostColId; p1 = __isRM ? aFrom.left : aFrom.right; p2 = __isRM ? aTo.left : aTo.right; fromSide = __isRM?'left':'right'; toSide = fromSide; }
    // Snap clamped endpoints to column edge
    if(aFrom.clamped) p1 = _adjustClampedEndpoint(p1, fromId, aFrom.clamped, fromSide);
    if(aTo.clamped) p2 = _adjustClampedEndpoint(p2, toId, aTo.clamped, toSide);
    // Back off the path end so the marker tip lands exactly on the element edge
    const _eDir = e.direction || 'forward';
    if(_eDir === 'none'){
      // Dot markers are centered  no back-off needed
    } else {
      if(!aTo.clamped) p2 = adjustEndForArrow(p1, p2);
      if(_eDir === 'both' && !aFrom.clamped) p1 = adjustEndForArrow(p2, p1);
    }
    const span = Math.abs(fi - ti);
    const key = `${Math.min(fi,ti)}-${Math.max(fi,ti)}-${span}`;
    // Skip if both endpoints are scrolled out of view  no useful info
    if(aFrom.clamped && aTo.clamped) continue;
    candidates.push({ e, p1, p2, fi, ti, span, key, isDotted, fromId, toId, edgeCount: 1, fromClamped: aFrom.clamped, toClamped: aTo.clamped });
  }
  
  // Process collapsed group pairs - create one representative arrow per pair
  for(const [pairKey, edges] of collapsedGroupPairs.entries()){
    if(edges.length === 0) continue;
    
    // Use the first edge as representative
    const e = edges[0];
    const [fromId, toId] = pairKey.split('');
    
    // Skip self-referencing arrows (both fields collapsed into the same group)
    if(fromId === toId) continue;
    
    // Check if there's a reverse pair (bidirectional)
    const reversePairKey = `${toId}${fromId}`;
    const isBidirectional = collapsedGroupPairs.has(reversePairKey);
    
    
    // Only process each pair once (skip the reverse)
    if(isBidirectional && fromId > toId){
      continue; // Skip reverse pair
    }
    
    if(!edgeScopeVisible(fromId, toId)) continue;
    
    // For consolidated arrows, show if ANY of the edges would be visible
    // Don't apply the highlight filter - consolidated arrows are structural
    if(!state.allArrows && highlightFields){
      // Check if this consolidated arrow is related to current selection
      // Show it if the collapsed groups are selected/hovered, OR if any constituent edge matches
      const groupsMatch = (highlightFields.has(fromId) || highlightFields.has(toId));
      const anyEdgeMatch = edges.some(edge => 
        highlightFields.has(edge.from) || highlightFields.has(edge.to)
      );
      // For bidirectional, also check reverse edges
      let reverseEdgeMatch = false;
      if(isBidirectional){
        const reverseEdges = collapsedGroupPairs.get(reversePairKey) || [];
        reverseEdgeMatch = reverseEdges.some(edge =>
          highlightFields.has(edge.from) || highlightFields.has(edge.to)
        );
      }
      if(!groupsMatch && !anyEdgeMatch && !reverseEdgeMatch) continue;
    }
    
    const aFrom = anchorPoint(fromId, svgRect, zoomFactor);
    const aTo = anchorPoint(toId, svgRect, zoomFactor);
    if(!aFrom || !aTo) continue;
    if(aFrom.clamped && aTo.clamped) continue;
    const fCol = columnOf(fromId);
    const tCol = columnOf(toId);
    const fi = visualColumnIndex(fCol);
    const ti = visualColumnIndex(tCol);
    if(fi < 0 || ti < 0) continue;
    let p1, p2, fromSide, toSide;
    if(fi < ti){ p1 = aFrom.right; p2 = aTo.left; fromSide='right'; toSide='left'; }
    else if(fi > ti){ p1 = aFrom.left; p2 = aTo.right; fromSide='left'; toSide='right'; }
    else { const __isRM = fCol === __rightmostColId; p1 = __isRM ? aFrom.left : aFrom.right; p2 = __isRM ? aTo.left : aTo.right; fromSide = __isRM?'left':'right'; toSide = fromSide; }
    if(aFrom.clamped) p1 = _adjustClampedEndpoint(p1, fromId, aFrom.clamped, fromSide);
    if(aTo.clamped) p2 = _adjustClampedEndpoint(p2, toId, aTo.clamped, toSide);
    
    const _eDirB2 = e.direction || 'forward';
    const _isConsBidi2 = isBidirectional && _eDirB2 !== 'both';
    // Don't back off endpoints for consolidated two-forwards (no endpoint markers)
    if(!_isConsBidi2 && _eDirB2 !== 'none'){
      if(!aTo.clamped) p2 = adjustEndForArrow(p1, p2);
    }
    
    // For true bidirectional (direction: 'both'), adjust p1 for marker-start
    if(_eDirB2 === 'both' && !aFrom.clamped){
      p1 = adjustEndForArrow(p2, p1);
    }
    
    const span = Math.abs(fi - ti);
    const key = `${Math.min(fi,ti)}-${Math.max(fi,ti)}-${span}`;
    
    // Combine edges from both directions if bidirectional
    let allEdges = [...edges];
    if(isBidirectional){
      const reverseEdges = collapsedGroupPairs.get(reversePairKey) || [];
      allEdges = [...edges, ...reverseEdges];
    }
    
    // Note: For collapsed groups, we store consolidated info here since it's dynamic
    // (depends on which groups are currently collapsed)
    e.__consolidated = allEdges;
    e.__isBidirectional = isBidirectional;
    e.__fromId = fromId;
    e.__toId = toId;
    
    candidates.push({ 
      e, 
      p1, p2, fi, ti, span, key, 
      isDotted: true, 
      fromId, toId, 
      edgeCount: allEdges.length,
      consolidatedEdges: allEdges,
      isBidirectional, // Store for marker selection
      fromClamped: aFrom.clamped, toClamped: aTo.clamped
    });
  }
  
  // Process bidirectional field pairs - create one arrow with dual heads
  for(const [pairKey, edges] of bidirectionalFieldPairs.entries()){
    if(edges.length === 0) continue;
    
    const e = edges[0];
    const [fromId, toId] = pairKey.split('');
    
    // Check if reverse pair exists
    const reversePairKey = `${toId}${fromId}`;
    const isBidirectional = bidirectionalFieldPairs.has(reversePairKey);
    
    // Only process each pair once (skip the reverse)
    if(isBidirectional && fromId > toId) continue;
    
    // Check if either endpoint is redirected (hybrid case with collapsed group)
    const fromRedirected = fromId !== e.from;
    const toRedirected = toId !== e.to;
    const isDotted = fromRedirected || toRedirected;
    
    if(!edgeScopeVisible(fromId, toId)) continue;
    if(!state.allArrows && highlightFields){
      const anyMatch = edges.some(edge => 
        highlightFields.has(edge.from) || highlightFields.has(edge.to)
      );
      if(isBidirectional){
        const reverseEdges = bidirectionalFieldPairs.get(reversePairKey) || [];
        const reverseMatch = reverseEdges.some(edge =>
          highlightFields.has(edge.from) || highlightFields.has(edge.to)
        );
        if(!anyMatch && !reverseMatch) continue;
      } else if(!anyMatch) continue;
    }
    
    const aFrom = anchorPoint(fromId, svgRect, zoomFactor);
    const aTo = anchorPoint(toId, svgRect, zoomFactor);
    if(!aFrom || !aTo) continue;
    if(aFrom.clamped && aTo.clamped) continue;
    const fCol = columnOf(fromId);
    const tCol = columnOf(toId);
    const fi = visualColumnIndex(fCol);
    const ti = visualColumnIndex(tCol);
    if(fi < 0 || ti < 0) continue;
    let p1, p2, fromSide, toSide;
    if(fi < ti){ p1 = aFrom.right; p2 = aTo.left; fromSide='right'; toSide='left'; }
    else if(fi > ti){ p1 = aFrom.left; p2 = aTo.right; fromSide='left'; toSide='right'; }
    else { const __isRM = fCol === __rightmostColId; p1 = __isRM ? aFrom.left : aFrom.right; p2 = __isRM ? aTo.left : aTo.right; fromSide = __isRM?'left':'right'; toSide = fromSide; }
    if(aFrom.clamped) p1 = _adjustClampedEndpoint(p1, fromId, aFrom.clamped, fromSide);
    if(aTo.clamped) p2 = _adjustClampedEndpoint(p2, toId, aTo.clamped, toSide);
    
    const _eDirB3 = e.direction || 'forward';
    const _isConsBidi = isBidirectional && _eDirB3 !== 'both';
    // Don't back off endpoints for consolidated two-forwards (no endpoint markers)
    if(!_isConsBidi && _eDirB3 !== 'none'){
      if(!aTo.clamped) p2 = adjustEndForArrow(p1, p2);
    }
    
    const span = Math.abs(fi - ti);
    const key = `${Math.min(fi,ti)}-${Math.max(fi,ti)}-${span}`;
    
    // For true bidirectional (direction: 'both'), adjust p1 for marker-start
    if(_eDirB3 === 'both' && !aFrom.clamped){
      p1 = adjustEndForArrow(p2, p1);
    }
    // For consolidated two-forwards, no p1 offset  center opposing arrows handle visual
    
    // Combine edges from both directions
    let allEdges = [...edges];
    if(isBidirectional){
      const reverseEdges = bidirectionalFieldPairs.get(reversePairKey) || [];
      allEdges = [...edges, ...reverseEdges];
    }
    
    // Note: __consolidated is already set on the edge by markConsolidatedEdges()
    // We just use it here for drawing
    
    candidates.push({
      e,
      p1, p2, fi, ti, span, key,
      isDotted, // Use dotted line if one endpoint is redirected to collapsed group
      fromId, toId,
      edgeCount: allEdges.length,
      consolidatedEdges: allEdges,
      isBidirectional,
      fromClamped: aFrom.clamped, toClamped: aTo.clamped
    });
  }
  
  // Lane assignment for distant (span>1) and same-column edges
  const bucket = new Map();
  for(const c of candidates){
    if(c.span > 1 || c.span === 0){
      if(!bucket.has(c.key)) bucket.set(c.key, []);
      bucket.get(c.key).push(c);
    }
  }
  const laneIndex = new Map();
  for(const [k, arr] of bucket.entries()){
    arr.sort((a,b)=> a.e.id.localeCompare(b.e.id));
    arr.forEach((c, i)=> laneIndex.set(c.e.id, { i, n: arr.length }));
  }

  for(const c of candidates){
    const { e, p1, p2, span, isDotted: collapsedDotted, fromId, toId, edgeCount, consolidatedEdges, isBidirectional, fromClamped, toClamped } = c;
    const isClamped = !!(fromClamped || toClamped);
    
    if(consolidatedEdges && consolidatedEdges.length > 1){
    }
    
    const isConsolidated = consolidatedEdges && consolidatedEdges.length > 1;
    
    let inHL = false;
    let inActive = false;
    
    if(isConsolidated){
      // For consolidated arrows, check if ANY of the constituent edges match the highlight
      inHL = highlightFields && consolidatedEdges.some(edge => 
        highlightFields.has(edge.from) && highlightFields.has(edge.to)
      );
      inActive = activeFields && consolidatedEdges.some(edge =>
        activeFields.has(edge.from) && activeFields.has(edge.to)
      );
      
    } else {
      // Regular arrow or virtual edge - check endpoints
      inHL = highlightFields && (highlightFields.has(e.from) && highlightFields.has(e.to));
      inActive = (state.selectedEdgeId===e.id) || (state.hoverEdgeId===e.id) || (activeFields && activeFields.has(e.from) && activeFields.has(e.to));
      
      // Debug logging for arrows that should be highlighted
      if(highlightFields && (highlightFields.has(e.from) || highlightFields.has(e.to))){
      }
    }

    // Check if this is a virtual edge (chain through hidden column)
    const isHiddenChain = e.throughHiddenColumn === true;
    
    // Determine dash pattern based on what's happening:
    // - Collapsed group only: 5,5 (medium dashes)
    // - Hidden chain only: 2,6 (small dots)
    // - Both collapsed AND hidden chain: 5,5,2,6 (dash-dot pattern)
    let dashPattern = null;
    if(collapsedDotted && isHiddenChain){
      dashPattern = '5,5,2,6'; // Dash-dot for both
    } else if(collapsedDotted){
      dashPattern = '5,5'; // Medium dashes for collapsed only
    } else if(isHiddenChain){
      dashPattern = '2,6'; // Small dots for hidden chain only
    }

    let d = "";
    
    if(span === 0){
      // Same-column mapping: curve that loops out
      // Direction depends on anchor side (right for most columns, left for rightmost)
      const colId = columnOf(fromId);
      const isRightSide = colId !== __rightmostColId;
      
      const lane = laneIndex.get(e.id);
      const n = lane ? lane.n : 1;
      const i = lane ? lane.i : 0;
      const fan = (i - (n - 1) / 2) * 14;
      const yDist = Math.abs(p2.y - p1.y);
      const baseBulge = Math.min(60, Math.max(30, yDist * 0.35));
      
      if(isRightSide){
        const p2Adj = toClamped ? p2 : { x: p2.x + ARROW_TIP_LEN, y: p2.y };
        const p1Adj = isBidirectional ? (fromClamped ? p1 : { x: p1.x + ARROW_TIP_LEN, y: p1.y }) : p1;
        const bulge = Math.max(p1Adj.x, p2Adj.x) + baseBulge + fan;
        // Control points: vertical approach for clamped ends
        const c1x = fromClamped ? p1Adj.x : bulge;
        const c1y = fromClamped ? p1Adj.y + (p2Adj.y > p1Adj.y ? baseBulge : -baseBulge) : p1Adj.y;
        const c2x = toClamped ? p2Adj.x : bulge;
        const c2y = toClamped ? p2Adj.y + (p1Adj.y > p2Adj.y ? baseBulge : -baseBulge) : p2Adj.y;
        d = `M ${p1Adj.x.toFixed(1)} ${p1Adj.y.toFixed(1)} C ${c1x.toFixed(1)} ${c1y.toFixed(1)}, ${c2x.toFixed(1)} ${c2y.toFixed(1)}, ${p2Adj.x.toFixed(1)} ${p2Adj.y.toFixed(1)}`;
      } else {
        const p2Adj = toClamped ? p2 : { x: p2.x - ARROW_TIP_LEN, y: p2.y };
        const p1Adj = isBidirectional ? (fromClamped ? p1 : { x: p1.x - ARROW_TIP_LEN, y: p1.y }) : p1;
        const bulge = Math.min(p1Adj.x, p2Adj.x) - baseBulge - fan;
        const c1x = fromClamped ? p1Adj.x : bulge;
        const c1y = fromClamped ? p1Adj.y + (p2Adj.y > p1Adj.y ? baseBulge : -baseBulge) : p1Adj.y;
        const c2x = toClamped ? p2Adj.x : bulge;
        const c2y = toClamped ? p2Adj.y + (p1Adj.y > p2Adj.y ? baseBulge : -baseBulge) : p2Adj.y;
        d = `M ${p1Adj.x.toFixed(1)} ${p1Adj.y.toFixed(1)} C ${c1x.toFixed(1)} ${c1y.toFixed(1)}, ${c2x.toFixed(1)} ${c2y.toFixed(1)}, ${p2Adj.x.toFixed(1)} ${p2Adj.y.toFixed(1)}`;
      }
    } else {
      // All cross-column mappings (adjacent, distant, collapsed): smooth bezier
      d = bezier(p1, p2, fromClamped, toClamped);
    }

    // Compute tooltip text (used for both new and existing paths)
    let tooltipText = edgeTooltip(e);
    if(consolidatedEdges && consolidatedEdges.length > 1){
      tooltipText = `${consolidatedEdges.length} mappings:\n${consolidatedEdges.map(edge => `${edge.from}  ${edge.to}`).join('\n')}`;
    } else if(isHiddenChain && e.chain){
      const hiddenCols = [];
      for(const chainEdge of e.chain){
        const fromCol = columnOf(chainEdge.from);
        const toCol = columnOf(chainEdge.to);
        if(fromCol && state.hiddenColumns.has(fromCol)){
          const col = IDX.columns[IDX.columnIndex.get(fromCol)];
          if(col && !hiddenCols.includes(col.label || col.id)) hiddenCols.push(col.label || col.id);
        }
        if(toCol && state.hiddenColumns.has(toCol)){
          const col = IDX.columns[IDX.columnIndex.get(toCol)];
          if(col && !hiddenCols.includes(col.label || col.id)) hiddenCols.push(col.label || col.id);
        }
      }
      tooltipText = `Indirect link through hidden column${hiddenCols.length > 1 ? 's' : ''}: ${hiddenCols.join(', ')}\n${e.chain.map(edge => `${edge.from}  ${edge.to}`).join('  ')}\n\nClick to reveal hidden columns and select the first edge.`;
    }

    let path = existing.get(e.id);
    if(path){
      // Update geometry + classes; mark alive
      path.setAttribute('d', d);
      path.__alive = true;
      path.classList.toggle('hl', !!inHL);
      path.classList.toggle('active', !!inActive);
      const hideEdge = !!(highlightFields) && (state.multiSelectArrowMode === 'selected' || state.multiSelectArrowMode === 'direct') && !state.allArrows;
      path.classList.toggle('dimmed', !!(shouldDimEdges && !inHL && !inActive && !hideEdge));
      path.classList.toggle('fadeOut', !!(!inHL && !inActive && hideEdge));
      
      // Set dash pattern
      if(dashPattern){
        path.setAttribute('stroke-dasharray', dashPattern);
      } else {
        path.removeAttribute('stroke-dasharray');
      }
      
      // Store consolidated edges info for click handler
      path.__consolidated = consolidatedEdges;
      path.__fromId = fromId;
      path.__toId = toId;
      path.__isBidirectional = isBidirectional;
      path.__isHiddenChain = isHiddenChain;
      path.__chainEdges = isHiddenChain ? e.chain : null;
      
      let marker = inActive ? 'url(#arrowActive)' : (inHL ? 'url(#arrowHL)' : 'url(#arrowDefault)');
      if(state.editorMode && state.selectedEdgeId===e.id){ marker = 'url(#arrowActive)'; }
      
      const edgeDir = e.direction || 'forward';
      const isConsolidatedBidi = isBidirectional && edgeDir !== 'both'; // two separate forwards
      
      // Determine markers based on direction
      if(edgeDir === 'none'){
        // Directionless: dot markers at both ends
        const dotEnd = inActive ? 'url(#dotActive)' : (inHL ? 'url(#dotHL)' : 'url(#dotDefault)');
        if(state.editorMode && state.selectedEdgeId===e.id){
          path.setAttribute('marker-start', 'url(#dotActive)');
          path.setAttribute('marker-end', 'url(#dotActive)');
        } else {
          path.setAttribute('marker-start', dotEnd);
          path.setAttribute('marker-end', dotEnd);
        }
      } else if(edgeDir === 'both'){
        // True bidirectional: arrow markers at both ends
        const startMarker = inActive ? 'url(#arrowStartActive)' : (inHL ? 'url(#arrowStartHL)' : 'url(#arrowStartDefault)');
        if(state.editorMode && state.selectedEdgeId===e.id){ 
          path.setAttribute('marker-start', 'url(#arrowStartActive)');
        } else {
          path.setAttribute('marker-start', startMarker);
        }
        path.setAttribute('marker-end', marker);
      } else if(isConsolidatedBidi){
        // Consolidated two-forwards: NO endpoint arrows, center arrows drawn separately
        path.removeAttribute('marker-start');
        path.removeAttribute('marker-end');
      } else {
        // Forward: arrow at end only
        path.removeAttribute('marker-start');
        path.setAttribute('marker-end', marker);
      }
      path.classList.toggle('selected', !!(state.editorMode && state.selectedEdgeId===e.id));
      
      // Edge coloring priority: filter > scheme > per-edge custom
      const fEdgeColor = getFilterEdgeColor(fromId, toId, consolidatedEdges);
      const schemeEdgeColor = !fEdgeColor ? getEdgeSchemeColor(e) : '';
      const customEdgeColor = (!fEdgeColor && !schemeEdgeColor && e.color) ? e.color : '';
      const edgeColor = fEdgeColor || schemeEdgeColor || customEdgeColor;
      
      // For consolidated two-forwards: resolve per-edge colors for split rendering
      _clearSplitGradient(path);
      let _consFwd = '', _consRev = '';
      const _isConsSplit = isConsolidatedBidi && !inHL && !inActive && !(state.editorMode && state.selectedEdgeId===e.id);
      if(_isConsSplit){
        const _pair = _getConsolidatedPairColors(fromId, toId, consolidatedEdges, '');
        _consFwd = _pair.fwdColor;
        _consRev = _pair.revColor;
        // Fill default line color for edges without custom colors
        const _defLine = 'rgba(255,255,255,.15)';
        if(_consFwd && !_consRev) _consRev = _defLine;
        if(_consRev && !_consFwd) _consFwd = _defLine;
      }
      const _doSplit = _isConsSplit && _consFwd && _consRev && _consFwd !== _consRev;
      
      if(_doSplit){
        path.style.stroke = _applySplitGradient(edgesLayer.closest('svg'), path, p1, p2, _consFwd, _consRev);
      } else if(edgeColor && !inHL && !inActive){
        path.style.stroke = edgeColor;
        if(!isConsolidatedBidi){
          if(edgeDir === 'none'){
            const dotM = getOrCreateFilterDotMarker(edgeColor);
            path.setAttribute('marker-start', dotM);
            path.setAttribute('marker-end', dotM);
          } else {
            path.setAttribute('marker-end', getOrCreateFilterMarker(edgeColor, false));
            if(edgeDir === 'both') path.setAttribute('marker-start', getOrCreateFilterMarker(edgeColor, true));
          }
        }
      } else { path.style.removeProperty('stroke'); }
      if(isClamped && !inHL && !inActive){
        path.style.opacity = '0.25';
      } else {
        path.style.removeProperty('opacity');
      }
      
      // Clamped endpoint indicators: replace arrowhead with / chevron at column edge
      // Only show indicator where an arrowhead would normally be:
      //   forward: target only | both: both ends | none/consolidated: neither
      _clearClampIndicators(path);
      const _showClampTo = toClamped && !isConsolidatedBidi && edgeDir !== 'none';
      const _showClampFrom = fromClamped && edgeDir === 'both';
      if(_showClampTo){
        path.removeAttribute('marker-end');
        const clrT = (!inHL && !inActive && edgeColor) ? edgeColor : (inActive ? 'rgba(255,208,92,.95)' : (inHL ? 'rgba(59,130,246,.92)' : 'rgba(255,255,255,.25)'));
        path.__clampTo = _drawClampIndicator(edgesLayer, p2.x, p2.y, toClamped, clrT);
        if(isClamped && !inHL && !inActive) path.__clampTo.style.opacity = '0.4';
      }
      if(_showClampFrom){
        path.removeAttribute('marker-start');
        const clrF = (!inHL && !inActive && edgeColor) ? edgeColor : (inActive ? 'rgba(255,208,92,.95)' : (inHL ? 'rgba(59,130,246,.92)' : 'rgba(255,255,255,.25)'));
        path.__clampFrom = _drawClampIndicator(edgesLayer, p1.x, p1.y, fromClamped, clrF);
        if(isClamped && !inHL && !inActive) path.__clampFrom.style.opacity = '0.4';
      }
      
      // Center-opposing arrows for consolidated two-forwards ()
      _clearMidArrows(path);
      if(isConsolidatedBidi){
        const isSelected = !!(state.editorMode && state.selectedEdgeId===e.id);
        const _defMidClr = (inActive || isSelected) ? 'rgba(255,208,92,.85)' : inHL ? 'rgba(59,130,246,.85)' : 'rgba(255,255,255,.15)';
        // Use per-edge colors when available and not in HL/active/selected state
        let midFwd = _defMidClr, midRev = _defMidClr;
        if(!inHL && !inActive && !isSelected){
          midFwd = _consFwd || edgeColor || _defMidClr;
          midRev = _consRev || edgeColor || _defMidClr;
        }
        path.__midArrows = _drawMidOpposingArrows(edgesLayer, path, midFwd, midRev);
        if(isClamped && !inHL && !inActive) path.__midArrows.style.opacity = '0.4';
      }
      
      // Update tooltip on path
      const pathTitle = path.querySelector('title');
      if(pathTitle) pathTitle.textContent = tooltipText;
      
      // Update hitbox if it exists
      if(path.__hitbox){
        path.__hitbox.setAttribute('d', d);
        path.__hitbox.style.pointerEvents = 'stroke';
        // Update hitbox consolidated info too
        path.__hitbox.__consolidated = consolidatedEdges;
        path.__hitbox.__fromId = fromId;
        path.__hitbox.__toId = toId;
        path.__hitbox.__isBidirectional = isBidirectional;
        path.__hitbox.__isHiddenChain = isHiddenChain;
        path.__hitbox.__chainEdges = isHiddenChain ? e.chain : null;
        // Update tooltip text on hitbox
        const existingTitle = path.__hitbox.querySelector('title');
        if(existingTitle) existingTitle.textContent = tooltipText;
      }
      // Create label (all labels cleared at start of each pass)
      const _showLbl = e.label && !e.labelHidden && (state.showEdgeLabels === 'always' || (state.showEdgeLabels === 'highlight' && (inHL || inActive)));
      if(_showLbl){
        const lbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        lbl.classList.add('edgeLabel');
        lbl.dataset.edgeId = e.id;
        lbl.textContent = e.label;
        lbl.classList.toggle('hl', inHL);
        lbl.classList.toggle('active', inActive);
        lbl.classList.toggle('dimmed', shouldDimEdges && !inHL && !inActive);
        const hideLbl = !!(highlightFields) && (state.multiSelectArrowMode === 'selected' || state.multiSelectArrowMode === 'direct') && !state.allArrows;
        lbl.classList.toggle('fadeOut', !inHL && !inActive && hideLbl);
        if(edgeColor && !inHL && !inActive) lbl.style.fill = edgeColor;
        edgesLayer.appendChild(lbl);
        path.__label = lbl;
        try{
          const len = path.getTotalLength();
          const mid = path.getPointAtLength(len * 0.5);
          lbl.setAttribute('x', mid.x.toFixed(1));
          lbl.setAttribute('y', (mid.y - 7).toFixed(1));
        }catch(ex){}
      } else {
        path.__label = null;
      }
  } else {
      // Create new path (fade-in)
      path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', d);
      path.classList.add('edge');
      path.dataset.edgeId = e.id;
      if(state.editorMode && state.selectedEdgeId===e.id) path.classList.add('selected');
      if(inHL) path.classList.add('hl');
      if(inActive) path.classList.add('active');
      const hideEdge2 = !!(highlightFields) && (state.multiSelectArrowMode === 'selected' || state.multiSelectArrowMode === 'direct') && !state.allArrows;
      if(!inHL && !inActive && hideEdge2){
        path.classList.add('fadeOut');
      } else if(shouldDimEdges && !inHL && !inActive){
        path.classList.add('dimmed');
      }
      
      // Set dash pattern
      if(dashPattern){
        path.setAttribute('stroke-dasharray', dashPattern);
      }
      
      // Store consolidated edges info for click handler
      path.__consolidated = consolidatedEdges;
      path.__fromId = fromId;
      path.__toId = toId;
      path.__isBidirectional = isBidirectional;
      path.__isHiddenChain = isHiddenChain;
      path.__chainEdges = isHiddenChain ? e.chain : null;
      
      let marker = inActive ? 'url(#arrowActive)' : (inHL ? 'url(#arrowHL)' : 'url(#arrowDefault)');
      if(state.editorMode && state.selectedEdgeId===e.id){ marker = 'url(#arrowActive)'; }
      
      const edgeDir2 = e.direction || 'forward';
      const isConsolidatedBidi2 = isBidirectional && edgeDir2 !== 'both';
      
      if(edgeDir2 === 'none'){
        const dotEnd = inActive ? 'url(#dotActive)' : (inHL ? 'url(#dotHL)' : 'url(#dotDefault)');
        if(state.editorMode && state.selectedEdgeId===e.id){
          path.setAttribute('marker-start', 'url(#dotActive)');
          path.setAttribute('marker-end', 'url(#dotActive)');
        } else {
          path.setAttribute('marker-start', dotEnd);
          path.setAttribute('marker-end', dotEnd);
        }
      } else if(edgeDir2 === 'both'){
        const startMarker = inActive ? 'url(#arrowStartActive)' : (inHL ? 'url(#arrowStartHL)' : 'url(#arrowStartDefault)');
        if(state.editorMode && state.selectedEdgeId===e.id){ 
          path.setAttribute('marker-start', 'url(#arrowStartActive)');
        } else {
          path.setAttribute('marker-start', startMarker);
        }
        path.setAttribute('marker-end', marker);
      } else if(isConsolidatedBidi2){
        path.removeAttribute('marker-start');
        path.removeAttribute('marker-end');
      } else {
        path.setAttribute('marker-end', marker);
      }
      
      // Edge coloring priority: filter > scheme > per-edge custom
      const fEdgeColor2 = getFilterEdgeColor(fromId, toId, consolidatedEdges);
      const schemeEdgeColor2 = !fEdgeColor2 ? getEdgeSchemeColor(e) : '';
      const customEdgeColor2 = (!fEdgeColor2 && !schemeEdgeColor2 && e.color) ? e.color : '';
      const edgeColor2 = fEdgeColor2 || schemeEdgeColor2 || customEdgeColor2;
      
      // Consolidated split colors
      let _consFwd2 = '', _consRev2 = '';
      const _isConsSplit2 = isConsolidatedBidi2 && !inHL && !inActive;
      if(_isConsSplit2){
        const _pair2 = _getConsolidatedPairColors(fromId, toId, consolidatedEdges, '');
        _consFwd2 = _pair2.fwdColor;
        _consRev2 = _pair2.revColor;
        const _defLine2 = 'rgba(255,255,255,.15)';
        if(_consFwd2 && !_consRev2) _consRev2 = _defLine2;
        if(_consRev2 && !_consFwd2) _consFwd2 = _defLine2;
      }
      const _doSplit2 = _isConsSplit2 && _consFwd2 && _consRev2 && _consFwd2 !== _consRev2;
      
      if(_doSplit2){
        path.style.stroke = _applySplitGradient(edgesLayer.closest('svg'), path, p1, p2, _consFwd2, _consRev2);
      } else if(edgeColor2 && !inHL && !inActive){
        path.style.stroke = edgeColor2;
        if(!isConsolidatedBidi2){
          if(edgeDir2 === 'none'){
            const dotM2 = getOrCreateFilterDotMarker(edgeColor2);
            path.setAttribute('marker-start', dotM2);
            path.setAttribute('marker-end', dotM2);
          } else {
            path.setAttribute('marker-end', getOrCreateFilterMarker(edgeColor2, false));
            if(edgeDir2 === 'both') path.setAttribute('marker-start', getOrCreateFilterMarker(edgeColor2, true));
          }
        }
      }
      if(isClamped && !inHL && !inActive){
        path.style.opacity = '0.25';
      }
      
      // Clamped endpoint indicators: same rules as existing paths
      const _showClampTo2 = toClamped && !isConsolidatedBidi2 && edgeDir2 !== 'none';
      const _showClampFrom2 = fromClamped && edgeDir2 === 'both';
      if(_showClampTo2){
        path.removeAttribute('marker-end');
        const clrT2 = (!inHL && !inActive && edgeColor2) ? edgeColor2 : (inActive ? 'rgba(255,208,92,.95)' : (inHL ? 'rgba(59,130,246,.92)' : 'rgba(255,255,255,.25)'));
        path.__clampTo = _drawClampIndicator(edgesLayer, p2.x, p2.y, toClamped, clrT2);
        if(isClamped && !inHL && !inActive) path.__clampTo.style.opacity = '0.4';
      }
      if(_showClampFrom2){
        path.removeAttribute('marker-start');
        const clrF2 = (!inHL && !inActive && edgeColor2) ? edgeColor2 : (inActive ? 'rgba(255,208,92,.95)' : (inHL ? 'rgba(59,130,246,.92)' : 'rgba(255,255,255,.25)'));
        path.__clampFrom = _drawClampIndicator(edgesLayer, p1.x, p1.y, fromClamped, clrF2);
        if(isClamped && !inHL && !inActive) path.__clampFrom.style.opacity = '0.4';
      }

      // Center-opposing arrows for consolidated two-forwards ()
      if(isConsolidatedBidi2){
        const isSelected2 = !!(state.editorMode && state.selectedEdgeId===e.id);
        const _defMidClr2 = (inActive || isSelected2) ? 'rgba(255,208,92,.85)' : inHL ? 'rgba(59,130,246,.85)' : 'rgba(255,255,255,.15)';
        let midFwd2 = _defMidClr2, midRev2 = _defMidClr2;
        if(!inHL && !inActive && !isSelected2){
          midFwd2 = _consFwd2 || edgeColor2 || _defMidClr2;
          midRev2 = _consRev2 || edgeColor2 || _defMidClr2;
        }
        path.__midArrows = _drawMidOpposingArrows(edgesLayer, path, midFwd2, midRev2);
        if(isClamped && !inHL && !inActive) path.__midArrows.style.opacity = '0.4';
      }

      const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
      title.textContent = tooltipText;
      path.appendChild(title);
      path.style.pointerEvents='none';
      
      // Create invisible hitbox path for easier clicking
      const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      hitbox.setAttribute('d', d);
      hitbox.classList.add('edge-hitbox');
      hitbox.dataset.edgeId = e.id;
      hitbox.setAttribute('stroke', 'transparent');
      hitbox.setAttribute('stroke-width', '12');
      hitbox.setAttribute('fill', 'none');
      hitbox.style.pointerEvents = 'stroke';
      hitbox.style.cursor = 'pointer';
      
      // Copy tooltip to hitbox (since hitbox captures pointer events, path's <title> won't show)
      const hitTitle = document.createElementNS('http://www.w3.org/2000/svg', 'title');
      hitTitle.textContent = tooltipText;
      hitbox.appendChild(hitTitle);
      
      // Store consolidated info on hitbox
      hitbox.__consolidated = consolidatedEdges;
      hitbox.__fromId = fromId;
      hitbox.__toId = toId;
      hitbox.__isBidirectional = isBidirectional;
      hitbox.__isHiddenChain = isHiddenChain;
      hitbox.__chainEdges = isHiddenChain ? e.chain : null;
      
      // Event handlers on hitbox
      hitbox.addEventListener('click', async (evt)=>{ 
        evt.stopPropagation(); 

        // Alt+click on edge: chain select using same logic as Alt+click on node
        // Check Alt BEFORE Ctrl so Alt+Ctrl (downstream) works
        if(evt.altKey){
          // Guard dirty edits before transitioning to multi-select
          if(state.editorMode && nodeEditIsDirty()){
            if(!await guardNodeAbandon()) return;
            revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
          }
          if(state.editorMode && edgeEditIsDirty()){
            const eid = __edgeEditSession?.edgeId || '';
            if(!await guardAbandonEdit('mapping', eid)) return;
          }
          // Snapshot ALL relevant state before any cleanup destroys it
          const _snapLocked = state.lockedId;
          const _snapMulti = new Set(state.multiSelection);
          const _snapEP = state._selectedEdgeEndpoints;

          // Clear edit sessions (guard already prompted above)
          __editSnapshot = null;
          __edgeEditSession = null;

          const fromId = hitbox.__fromId || e.from;
          const toId = hitbox.__toId || e.to;
          const isShiftMod = evt.shiftKey;
          const isCtrlMod = evt.ctrlKey || evt.metaKey;
          const direction = (isShiftMod && !isCtrlMod) ? 'upstream'
                          : (isCtrlMod && !isShiftMod) ? 'downstream'
                          : 'both';

          // Build prior selection from snapshot (not from current state)
          const prevSel = new Set(_snapMulti);
          if(_snapLocked) prevSel.add(_snapLocked);
          if(_snapEP){ prevSel.add(_snapEP.from); prevSel.add(_snapEP.to); }

          // Start building new selection with both edge endpoints
          const currentSel = new Set(prevSel);
          currentSel.add(fromId);
          currentSel.add(toId);

          if(direction === 'both'){
            if(prevSel.size > 0){
              // Check connectivity from prevSel
              const currentConnected = new Set();
              for(const nid of prevSel){
                const tmp = computeHighlightForNode(nid);
                for(const f of tmp.connectedFields) currentConnected.add(f);
              }
              const fromConnected = currentConnected.has(fromId);
              const toConnected = currentConnected.has(toId);

              if(fromConnected || toConnected){
                // For each connected endpoint NOT already in prevSel, find path back
                for(const nid of [fromId, toId]){
                  if(prevSel.has(nid)) continue; // already selected, skip
                  if(!currentConnected.has(nid)) continue; // not connected, skip
                  const visited = new Map();
                  const queue = [nid];
                  visited.set(nid, null);
                  let foundTarget = null;
                  while(queue.length > 0){
                    const cur = queue.shift();
                    if(prevSel.has(cur)){ foundTarget = cur; break; }
                    const adj = IDX.adjacency.get(cur);
                    if(adj) for(const nb of adj){
                      if(!visited.has(nb)){ visited.set(nb, cur); queue.push(nb); }
                    }
                  }
                  if(foundTarget !== null){
                    let cur = foundTarget;
                    while(cur !== null){ currentSel.add(cur); cur = visited.get(cur); }
                  }
                }
              } else {
                // Not connected to existing selection  full chain
                for(const nid of [fromId, toId]){
                  const chain = computeHighlightForNode(nid);
                  for(const f of chain.connectedFields) currentSel.add(f);
                }
              }
            } else {
              // No prior selection  full chain from both endpoints
              for(const nid of [fromId, toId]){
                const chain = computeHighlightForNode(nid);
                for(const f of chain.connectedFields) currentSel.add(f);
              }
            }
          } else {
            // Directional chain select
            for(const nid of [fromId, toId]){
              const directed = computeDirectedChain(nid, direction);
              for(const f of directed) currentSel.add(f);
            }
          }

          // Apply  set state from scratch
          state.multiSelection = currentSel;
          state._selectedEdgeEndpoints = null;
          state.selectedEdgeId = null;
          state.hoverEdgeId = null;
          state.lockedId = null;
          state.hoverId = null;
          state.selectedColumnId = null;
          if(state.multiSelection.size === 1){
            state.lockedId = [...state.multiSelection][0];
            state.multiSelection.clear();
          }
          applyHighlight();
          return;
        }

        // Ctrl+click: add/remove both edge endpoints to/from multi-selection
        if(evt.ctrlKey || evt.metaKey){
          // Guard dirty edits before transitioning to multi-select
          if(state.editorMode && nodeEditIsDirty()){
            if(!await guardNodeAbandon()) return;
            revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
          }
          if(state.editorMode && edgeEditIsDirty()){
            const eid = __edgeEditSession?.edgeId || '';
            if(!await guardAbandonEdit('mapping', eid)) return;
          }
          // Snapshot state before cleanup destroys it
          const _snapLocked = state.lockedId;
          const _snapMulti = new Set(state.multiSelection);
          const _snapEP = state._selectedEdgeEndpoints;

          // Clear edit sessions (guard already prompted above)
          __editSnapshot = null;
          __edgeEditSession = null;

          const fromId = hitbox.__fromId || e.from;
          const toId = hitbox.__toId || e.to;
          
          // Build selection from snapshot
          const newSel = new Set(_snapMulti);
          if(_snapLocked) newSel.add(_snapLocked);
          if(_snapEP){ newSel.add(_snapEP.from); newSel.add(_snapEP.to); }
          
          // Toggle: if both endpoints already in selection, remove them
          const bothIn = newSel.has(fromId) && newSel.has(toId);
          if(bothIn){
            newSel.delete(fromId);
            newSel.delete(toId);
          } else {
            newSel.add(fromId);
            newSel.add(toId);
          }
          
          // Apply from scratch
          state.multiSelection = newSel;
          state._selectedEdgeEndpoints = null;
          state.selectedEdgeId = null;
          state.hoverEdgeId = null;
          state.lockedId = null;
          state.hoverId = null;
          state.selectedColumnId = null;
          if(state.multiSelection.size === 1){
            state.lockedId = [...state.multiSelection][0];
            state.multiSelection.clear();
          }
          applyHighlight();
          return;
        }

        if(state.editorMode && nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        if(state.editorMode && edgeEditIsDirty()){
          const eid = __edgeEditSession?.edgeId || '';
          if(!await guardAbandonEdit('mapping', eid)) return;
        }
        
        // Check if this is a chain through hidden column(s)
        if(hitbox.__isHiddenChain && hitbox.__chainEdges){
          // Unhide all columns involved in the chain
          const columnsToUnhide = new Set();
          for(const chainEdge of hitbox.__chainEdges){
            const fromCol = columnOf(chainEdge.from);
            const toCol = columnOf(chainEdge.to);
            if(fromCol && state.hiddenColumns.has(fromCol)) columnsToUnhide.add(fromCol);
            if(toCol && state.hiddenColumns.has(toCol)) columnsToUnhide.add(toCol);
          }
          
          // Unhide the columns
          for(const colId of columnsToUnhide){
            state.hiddenColumns.delete(colId);
          }
          
          // Redraw to show the full chain
          renderAll();
          applyHighlight();
          scheduleArrowsUpdate();
          
          // Optionally select the first edge in the chain
          if(hitbox.__chainEdges.length > 0){
            const firstEdgeInChain = hitbox.__chainEdges[0];
            setTimeout(() => selectEdge(firstEdgeInChain.id), 100);
          }
          return;
        }
        
        // Check if this is collapsed groups or bidirectional fields
        const firstEdge = hitbox.__consolidated && hitbox.__consolidated[0];
        const isCollapsedGroups = firstEdge && (hitbox.__fromId !== firstEdge.from || hitbox.__toId !== firstEdge.to);
        const isBidirectional = hitbox.__isBidirectional;
        
        
        // Always select consolidated arrows (both collapsed groups and bidirectional)
        // Details panel will show all mappings with click-to-edit/view functionality
        selectEdge(e.id);
        
      });
      hitbox.addEventListener('mouseenter', ()=>{
        if(state.panMode) return;
        if(state._lassoActive) return;
        if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
        state.hoverEdgeId = e.id; applyHighlight();
      });
      hitbox.addEventListener('mouseleave', ()=>{
        if(state.panMode) return;
        if(state._lassoActive) return;
        if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
        state.hoverEdgeId = null; applyHighlight();
      });
      
      // Append visible path first, then hitbox on top
      edgesLayer.appendChild(path);
      edgesLayer.appendChild(hitbox);
      
      // Edge label text (shown at midpoint of path)
      const _showLbl2 = e.label && !e.labelHidden && (state.showEdgeLabels === 'always' || (state.showEdgeLabels === 'highlight' && (inHL || inActive)));
      if(_showLbl2){
        const lbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        lbl.classList.add('edgeLabel');
        lbl.dataset.edgeId = e.id;
        lbl.textContent = e.label;
        if(inHL) lbl.classList.add('hl');
        if(inActive) lbl.classList.add('active');
        const hideEdgeLbl = !!(highlightFields) && (state.multiSelectArrowMode === 'selected' || state.multiSelectArrowMode === 'direct') && !state.allArrows;
        if(!inHL && !inActive && hideEdgeLbl) lbl.classList.add('fadeOut');
        else if(shouldDimEdges && !inHL && !inActive) lbl.classList.add('dimmed');
        if(edgeColor2 && !inHL && !inActive) lbl.style.fill = edgeColor2;
        edgesLayer.appendChild(lbl);
        path.__label = lbl;
        try{
          const len = path.getTotalLength();
          const mid = path.getPointAtLength(len * 0.5);
          lbl.setAttribute('x', mid.x.toFixed(1));
          lbl.setAttribute('y', (mid.y - 7).toFixed(1));
        }catch(ex){}
      }
      
      // Link hitbox to path for lifecycle management
      path.__hitbox = hitbox;
      
      // start transparent, then allow CSS to fade to target opacity
      path.style.opacity = '0';
      requestAnimationFrame(()=>{ path.style.opacity = ''; });
      path.__alive = true;
    }
  }

  // Fade out any paths not marked alive and disable their hitboxes
  const deadPaths = [];
  Array.from(edgesLayer.querySelectorAll('path.edge')).forEach(path=>{
    if(path.__alive) return;
    deadPaths.push(path.dataset.edgeId);
    // Remove immediately instead of fading - the fade causes the overlap issue
    _clearClampIndicators(path);
    _clearMidArrows(path);
    if(path.__hitbox) path.__hitbox.remove();
    path.remove();
  });
  if(deadPaths.length > 0){
  }

  // Z-order: re-append highlighted  active  selected VISUAL paths only (not hitboxes).
  // Moving hitboxes in DOM triggers mouseleave/mouseenter thrashing, so we leave them in place.
  const hlPaths = [];
  const activePaths = [];
  const selectedPaths = [];
  Array.from(edgesLayer.querySelectorAll('path.edge')).forEach(p=>{
    if(p.classList.contains('selected')) selectedPaths.push(p);
    else if(p.classList.contains('active')) activePaths.push(p);
    else if(p.classList.contains('hl')) hlPaths.push(p);
  });
  for(const p of hlPaths) { edgesLayer.appendChild(p); if(p.__clampTo) edgesLayer.appendChild(p.__clampTo); if(p.__clampFrom) edgesLayer.appendChild(p.__clampFrom); if(p.__midArrows) edgesLayer.appendChild(p.__midArrows); }
  for(const p of activePaths) { edgesLayer.appendChild(p); if(p.__clampTo) edgesLayer.appendChild(p.__clampTo); if(p.__clampFrom) edgesLayer.appendChild(p.__clampFrom); if(p.__midArrows) edgesLayer.appendChild(p.__midArrows); }
  for(const p of selectedPaths) { edgesLayer.appendChild(p); if(p.__clampTo) edgesLayer.appendChild(p.__clampTo); if(p.__clampFrom) edgesLayer.appendChild(p.__clampFrom); if(p.__midArrows) edgesLayer.appendChild(p.__midArrows); }
  // Move all labels above all paths for readability
  Array.from(edgesLayer.querySelectorAll('text.edgeLabel')).forEach(lbl => edgesLayer.appendChild(lbl));
}

/* =========================
   Tab navigation
========================= */
function setTab(name){
  state.tab = name;
  for(const [k, el] of Object.entries(views)){
    if(el) el.classList.toggle("active", k === name);
  }
  viewerControls.style.display = (name === "viewer") ? "flex" : "none";
  togglePopover(false);
  if(name === "viewer"){
    scheduleArrowsUpdate();
  }
}


// Docs modal
function openDocs(){
  buildDocs();
  const mask = document.getElementById('docsMask');
  const modal = document.getElementById('docsModal');
  if(mask) mask.classList.add('active');
  if(modal) modal.classList.add('active');
}
function closeDocs(){
  const mask = document.getElementById('docsMask');
  const modal = document.getElementById('docsModal');
  if(mask) mask.classList.remove('active');
  if(modal) modal.classList.remove('active');
}
const closeDocsBtn = document.getElementById('closeDocsBtn');
if(closeDocsBtn) closeDocsBtn.addEventListener('click', closeDocs);
const docsMask = document.getElementById('docsMask');
if(docsMask) docsMask.addEventListener('click', closeDocs);

// Bright mode toggle
(function(){
  const btn = document.getElementById('brightModeBtn');
  if(!btn) return;
  // Restore from localStorage
  try {
    if(localStorage.getItem('ms_brightMode') === '1'){
      document.body.classList.add('brightMode');
      btn.innerHTML = ICONS.moon;
      btn.title = 'Switch to dark mode';
    }
  } catch(e){}
  btn.addEventListener('click', ()=>{
    const on = document.body.classList.toggle('brightMode');
    btn.innerHTML = on ? ICONS.moon : ICONS.sun;
    btn.title = on ? 'Switch to dark mode' : 'Switch to bright mode';
    try { localStorage.setItem('ms_brightMode', on ? '1' : '0'); } catch(e){}
    // Redraw arrows after CSS settles  mode toggle can shift row positions
    setTimeout(()=> scheduleArrowsUpdate(), 50);
  });
})();

// === Details Panel Mode Manager ===
(function(){
  const MODES = ['left','right','bottom','float','hidden'];
  const DOCK_MODES = ['left','right','bottom']; // modes that can be snapped to
  const viewerGrid = document.querySelector('.viewerGrid');
  const detailsPanel = document.getElementById('detailsPanel');
  const detailsHeader = document.getElementById('detailsHeader');
  const resizeHandle = document.getElementById('resizeHandle');
  const resizeHandleH = document.getElementById('resizeHandleH');
  const closeBtn = document.getElementById('detailsCloseBtn');
  const panelModeSelector = document.getElementById('panelModeSelector');
  const snapIndicator = document.getElementById('snapIndicator');
  const dockActions = document.getElementById('detailsDockActions');

  if(!viewerGrid || !detailsPanel) return;

  // Restore from localStorage
  try {
    const saved = localStorage.getItem('ms_panelMode');
    // Migrate old 'side' to 'right'
    const migrated = saved === 'side' ? 'right' : saved;
    if(migrated && MODES.includes(migrated)) state.panelMode = migrated;
    const savedW = localStorage.getItem('ms_panelWidth');
    if(savedW) state.panelWidth = Math.max(424, Math.min(800, Number(savedW)));
    const savedH = localStorage.getItem('ms_panelHeight');
    if(savedH) state.panelHeight = Math.max(100, Math.min(600, Number(savedH)));
  } catch(e){}

  // Responsive auto-detect on first load
  if(!localStorage.getItem('ms_panelMode')){
    if(window.innerWidth < 1000) state.panelMode = 'bottom';
  }

  function updateSelectorHighlight(mode){
    if(!panelModeSelector) return;
    panelModeSelector.querySelectorAll('.dockOpt').forEach(b=>{
      b.classList.toggle('active', b.dataset.mode === mode);
    });
  }

  function positionResizeHandles(){
    if(!resizeHandle || !resizeHandleH) return;
    if(state.panelMode === 'right' || state.panelMode === 'left'){
      const detRect = detailsPanel.getBoundingClientRect();
      const gridRect = viewerGrid.getBoundingClientRect();
      if(state.panelMode === 'right'){
        resizeHandle.style.left = (detRect.left - gridRect.left - 6) + 'px';
      } else {
        resizeHandle.style.left = (detRect.right - gridRect.left - 6) + 'px';
      }
    } else if(state.panelMode === 'bottom'){
      const detRect = detailsPanel.getBoundingClientRect();
      const gridRect = viewerGrid.getBoundingClientRect();
      resizeHandleH.style.top = (detRect.top - gridRect.top - 6) + 'px';
    }
  }

  function applyPanelMode(mode, save){
    state.panelMode = mode;
    viewerGrid.setAttribute('data-panel', mode);
    updateSelectorHighlight(mode);

    // Reset inline styles and order
    detailsPanel.style.cssText = '';
    // Reset float-only state when leaving float mode
    detailsPanel.classList.remove('minimized');
    const _minBtn = document.getElementById('detailsMinBtn');
    if(_minBtn){ _minBtn.textContent = ''; _minBtn.title = 'Minimize panel'; }
    const _opPop = document.getElementById('opacityPopover');
    if(_opPop) _opPop.style.display = 'none';

    if(mode === 'right'){
      viewerGrid.style.gridTemplateColumns = `1fr ${state.panelWidth}px`;
      viewerGrid.style.gridTemplateRows = '1fr';
    } else if(mode === 'left'){
      viewerGrid.style.gridTemplateColumns = `${state.panelWidth}px 1fr`;
      viewerGrid.style.gridTemplateRows = '1fr';
    } else if(mode === 'bottom'){
      viewerGrid.style.gridTemplateColumns = '1fr';
      if(state.panelHeight){
        viewerGrid.style.gridTemplateRows = `1fr ${state.panelHeight}px`;
      } else {
        viewerGrid.style.gridTemplateRows = '1fr calc(30vh - 28px)';
      }
    } else if(mode === 'float'){
      viewerGrid.style.gridTemplateColumns = '1fr';
      viewerGrid.style.gridTemplateRows = '1fr';
      // Default position: bottom-right area of viewport
      let floatTop = window.innerHeight - 400;
      let floatLeft = window.innerWidth - 464;
      let floatW = 444, floatH = 380;
      try {
        const pos = JSON.parse(localStorage.getItem('ms_floatPos') || '{}');
        // Migrate old right/bottom format to top/left
        if(pos.right !== undefined && pos.top === undefined){
          pos.left = window.innerWidth - (pos.right || 16) - (pos.width || 444);
          pos.top = window.innerHeight - (pos.bottom || 16) - (pos.height || 380);
          delete pos.right; delete pos.bottom;
          localStorage.setItem('ms_floatPos', JSON.stringify(pos));
        }
        if(pos.top !== undefined) floatTop = pos.top;
        if(pos.left !== undefined) floatLeft = pos.left;
        if(pos.width) floatW = pos.width;
        if(pos.height) floatH = pos.height;
      } catch(e){}
      // Clamp so top stays on screen
      floatTop = Math.max(0, Math.min(floatTop, window.innerHeight - 60));
      floatLeft = Math.max(-floatW + 80, Math.min(floatLeft, window.innerWidth - 80));
      detailsPanel.style.top = floatTop + 'px';
      detailsPanel.style.left = floatLeft + 'px';
      detailsPanel.style.width = floatW + 'px';
      detailsPanel.style.height = floatH + 'px';
      // Start fully visible; mouseleave will apply inactive opacity
      detailsPanel.style.opacity = '1';
    } else {
      viewerGrid.style.gridTemplateColumns = '1fr';
      viewerGrid.style.gridTemplateRows = '1fr';
    }

    if(save !== false){
      try { localStorage.setItem('ms_panelMode', mode); } catch(e){}
    }
    renderDockActions(mode);
    setTimeout(()=>{ positionResizeHandles(); scheduleArrowsUpdate(); }, 60);
  }

  // SVG icon templates for dock actions
  const DOCK_ICONS = {
    left:   '<svg width="14" height="12" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="1" width="5" height="12" rx="1" fill="currentColor" opacity=".5"/></svg>',
    right:  '<svg width="14" height="12" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="10" y="1" width="5" height="12" rx="1" fill="currentColor" opacity=".5"/></svg>',
    bottom: '<svg width="14" height="12" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1"/><rect x="1" y="9" width="14" height="4" rx="1" fill="currentColor" opacity=".5"/></svg>',
    float:  '<svg width="14" height="12" viewBox="0 0 16 14"><rect x=".5" y=".5" width="15" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="1" stroke-dasharray="2,2" opacity=".5"/><rect x="5" y="3" width="9" height="8" rx="1.5" fill="currentColor" opacity=".4" stroke="currentColor" stroke-width=".7"/><path d="M3.5,5 L1.5,3 M1.5,3 L1.5,5 M1.5,3 L3.5,3" stroke="currentColor" stroke-width="1" fill="none" stroke-linecap="round" opacity=".7"/></svg>',
  };
  const DOCK_LABELS = { left:'Dock left', right:'Dock right', bottom:'Dock bottom', float:'Pop out' };

  // Dynamically render dock action buttons based on current mode
  function renderDockActions(mode){
    if(!dockActions) return;
    // Determine which actions to show: the alternatives to the current mode
    let actions = [];
    if(mode === 'right')  actions = ['left','bottom','float'];
    else if(mode === 'left')   actions = ['right','bottom','float'];
    else if(mode === 'bottom') actions = ['left','right','float'];
    else if(mode === 'float')  actions = ['left','bottom','right'];
    else { dockActions.innerHTML = ''; return; }

    dockActions.innerHTML = actions.map(a =>
      `<button class="dockAction" data-dock="${a}" title="${DOCK_LABELS[a] || a}">${DOCK_ICONS[a] || ''}</button>`
    ).join('');

    // Wire click handlers
    dockActions.querySelectorAll('.dockAction').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        const target = btn.dataset.dock;
        if(target && MODES.includes(target)) applyPanelMode(target, true);
      });
    });
  }

  // Wire Layout popover selector buttons
  if(panelModeSelector){
    panelModeSelector.querySelectorAll('.dockOpt').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        const mode = btn.dataset.mode;
        if(mode && MODES.includes(mode)) applyPanelMode(mode, true);
      });
    });
  }

  // Close button  hidden
  if(closeBtn){
    closeBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      applyPanelMode('hidden', true);
    });
  }

  // Default size button  reset panel dimensions
  const defaultBtn = document.getElementById('detailsDefaultBtn');
  if(defaultBtn){
    defaultBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      state.panelWidth = 444;
      state.panelHeight = null;
      try {
        localStorage.removeItem('ms_panelWidth');
        localStorage.removeItem('ms_panelHeight');
        localStorage.removeItem('ms_floatPos');
      } catch(ex){}
      applyPanelMode(state.panelMode, true);
      setTimeout(()=>{ positionResizeHandles(); scheduleArrowsUpdate(); }, 30);
    });
  }

  // === Minimize toggle (float mode only) ===
  const minBtn = document.getElementById('detailsMinBtn');
  if(minBtn){
    minBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const isMin = detailsPanel.classList.toggle('minimized');
      minBtn.textContent = isMin ? '' : '';
      minBtn.title = isMin ? 'Expand panel' : 'Minimize panel';
    });
  }

  // === Float panel: fade on mouse-leave ===
  let floatInactiveOpacity = 0.30;
  try {
    const saved = parseFloat(localStorage.getItem('ms_floatOpacity'));
    if(saved >= 0.1 && saved <= 1) floatInactiveOpacity = saved;
  } catch(e){}

  let _floatHovered = false;
  detailsPanel.addEventListener('mouseenter', ()=>{
    _floatHovered = true;
    if(state.panelMode === 'float') detailsPanel.style.opacity = '1';
  });
  detailsPanel.addEventListener('mouseleave', ()=>{
    _floatHovered = false;
    if(state.panelMode === 'float') detailsPanel.style.opacity = floatInactiveOpacity;
  });

  // === Opacity popover ===
  const opacityBtn = document.getElementById('detailsOpacityBtn');
  const opacityPop = document.getElementById('opacityPopover');
  const opacitySlider = document.getElementById('opacitySlider');
  const opacityVal = document.getElementById('opacityVal');
  if(opacityBtn && opacityPop && opacitySlider){
    opacitySlider.value = Math.round(floatInactiveOpacity * 100);
    if(opacityVal) opacityVal.textContent = Math.round(floatInactiveOpacity * 100) + '%';

    opacityBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const show = opacityPop.style.display === 'none';
      opacityPop.style.display = show ? 'block' : 'none';
      if(show){
        // Position above by default, flip below if not enough space
        const btnRect = opacityBtn.getBoundingClientRect();
        opacityPop.style.bottom = ''; opacityPop.style.top = '';
        opacityPop.style.marginBottom = ''; opacityPop.style.marginTop = '';
        const popH = opacityPop.offsetHeight;
        if(btnRect.top - popH - 6 < 4){
          // Not enough space above  show below
          opacityPop.style.top = '100%';
          opacityPop.style.marginTop = '6px';
        } else {
          // Show above
          opacityPop.style.bottom = '100%';
          opacityPop.style.marginBottom = '6px';
        }
      }
    });
    // Prevent slider interaction from triggering panel drag
    opacityPop.addEventListener('mousedown', (e)=> e.stopPropagation());
    opacitySlider.addEventListener('input', ()=>{
      floatInactiveOpacity = parseInt(opacitySlider.value) / 100;
      if(opacityVal) opacityVal.textContent = opacitySlider.value + '%';
      if(!_floatHovered && state.panelMode === 'float'){
        detailsPanel.style.opacity = floatInactiveOpacity;
      }
      try { localStorage.setItem('ms_floatOpacity', floatInactiveOpacity); } catch(e){}
    });
    // Close popover on outside click
    document.addEventListener('click', (e)=>{
      if(!opacityBtn.contains(e.target) && !opacityPop.contains(e.target)){
        opacityPop.style.display = 'none';
      }
    });
  }

  // === Side mode resize handle (horizontal  works for both left and right) ===
  if(resizeHandle){
    let startX = 0, startW = 0, dragging = false;
    resizeHandle.addEventListener('mousedown', (e)=>{
      if(state.panelMode !== 'right' && state.panelMode !== 'left') return;
      e.preventDefault();
      dragging = true;
      startX = e.clientX;
      startW = detailsPanel.getBoundingClientRect().width;
      resizeHandle.classList.add('active');
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const dir = (state.panelMode === 'right') ? -1 : 1;
      const delta = (e.clientX - startX) * dir;
      const newW = Math.max(424, Math.min(800, startW + delta));
      state.panelWidth = newW;
      if(state.panelMode === 'right'){
        viewerGrid.style.gridTemplateColumns = `1fr ${newW}px`;
      } else {
        viewerGrid.style.gridTemplateColumns = `${newW}px 1fr`;
      }
      // Keep handle glued to the cursor
      positionResizeHandles();
      scheduleArrowsUpdate();
    });
    document.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging = false;
      resizeHandle.classList.remove('active');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      try { localStorage.setItem('ms_panelWidth', String(state.panelWidth)); } catch(e){}
      setTimeout(()=>{ positionResizeHandles(); scheduleArrowsUpdate(); }, 30);
    });
  }

  // === Bottom mode resize handle (vertical) ===
  if(resizeHandleH){
    let startY = 0, startH = 0, dragging = false;
    resizeHandleH.addEventListener('mousedown', (e)=>{
      if(state.panelMode !== 'bottom') return;
      e.preventDefault();
      dragging = true;
      startY = e.clientY;
      startH = detailsPanel.getBoundingClientRect().height;
      resizeHandleH.classList.add('active');
      document.body.style.cursor = 'row-resize';
      document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const delta = startY - e.clientY;
      const newH = Math.max(100, Math.min(window.innerHeight * 0.7, startH + delta));
      state.panelHeight = newH;
      viewerGrid.style.gridTemplateRows = `1fr ${newH}px`;
      // Keep handle glued to the cursor
      positionResizeHandles();
      scheduleArrowsUpdate();
    });
    document.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging = false;
      resizeHandleH.classList.remove('active');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      try { localStorage.setItem('ms_panelHeight', String(state.panelHeight)); } catch(e){}
      setTimeout(()=>{ positionResizeHandles(); scheduleArrowsUpdate(); }, 30);
    });
  }

  // === Snap-to-edge detection ===
  const SNAP_THRESHOLD = 48; // px from edge to trigger snap
  function detectSnapZone(clientX, clientY){
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    if(clientX < SNAP_THRESHOLD) return 'left';
    if(clientX > vw - SNAP_THRESHOLD) return 'right';
    if(clientY > vh - SNAP_THRESHOLD) return 'bottom';
    return null;
  }

  function showSnapPreview(zone){
    if(!snapIndicator) return;
    const headerH = document.querySelector('header')?.getBoundingClientRect()?.height || 0;
    const mainPad = 14;
    // Reset all positioning
    snapIndicator.style.cssText = 'display:block;position:fixed;z-index:175;';
    if(zone === 'left'){
      snapIndicator.style.left = mainPad + 'px';
      snapIndicator.style.top = (headerH + mainPad) + 'px';
      snapIndicator.style.width = '35%';
      snapIndicator.style.height = `calc(100vh - ${headerH + mainPad*2}px)`;
    } else if(zone === 'right'){
      snapIndicator.style.right = mainPad + 'px';
      snapIndicator.style.top = (headerH + mainPad) + 'px';
      snapIndicator.style.width = '35%';
      snapIndicator.style.height = `calc(100vh - ${headerH + mainPad*2}px)`;
    } else if(zone === 'bottom'){
      snapIndicator.style.left = mainPad + 'px';
      snapIndicator.style.bottom = mainPad + 'px';
      snapIndicator.style.width = `calc(100vw - ${mainPad*2}px)`;
      snapIndicator.style.height = '35%';
    }
  }

  function hideSnapPreview(){
    if(snapIndicator) snapIndicator.style.display = 'none';
  }

  // === Floating panel drag  entire header is grab area with snap-to-edge ===
  if(detailsHeader){
    let startX = 0, startY = 0, startTop = 0, startLeft = 0, dragging = false;
    let currentSnap = null;

    detailsHeader.addEventListener('mousedown', (e)=>{
      if(state.panelMode !== 'float') return;
      if(e.target.closest('button') || e.target.closest('a') || e.target.closest('input')) return;
      e.preventDefault();
      dragging = true;
      currentSnap = null;
      const rect = detailsPanel.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      startTop = rect.top;
      startLeft = rect.left;
      document.body.style.cursor = 'move';
      document.body.style.userSelect = 'none';
    });

    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      // Clamp top so at least 40px of header stays visible
      const newTop = Math.max(-10, Math.min(window.innerHeight - 40, startTop + dy));
      const newLeft = Math.max(-detailsPanel.offsetWidth + 80, startLeft + dx);
      detailsPanel.style.top = newTop + 'px';
      detailsPanel.style.left = newLeft + 'px';

      // Snap detection
      const zone = detectSnapZone(e.clientX, e.clientY);
      if(zone !== currentSnap){
        currentSnap = zone;
        if(zone) showSnapPreview(zone);
        else hideSnapPreview();
      }
    });

    document.addEventListener('mouseup', (e)=>{
      if(!dragging) return;
      dragging = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      hideSnapPreview();

      // If snapped to an edge, dock there
      if(currentSnap && DOCK_MODES.includes(currentSnap)){
        applyPanelMode(currentSnap, true);
        currentSnap = null;
        return;
      }
      currentSnap = null;

      // Save floating position
      try {
        const rect = detailsPanel.getBoundingClientRect();
        localStorage.setItem('ms_floatPos', JSON.stringify({
          top: rect.top,
          left: rect.left,
          width: rect.width,
          height: rect.height
        }));
      } catch(e){}
    });
  }

  // === Float panel resize handle (custom corner drag) ===
  const floatResizeHandle = document.getElementById('floatResizeHandle');
  if(floatResizeHandle){
    let startX = 0, startY = 0, startW = 0, startH = 0, dragging = false;
    floatResizeHandle.addEventListener('mousedown', (e)=>{
      if(state.panelMode !== 'float') return;
      e.preventDefault();
      e.stopPropagation();
      dragging = true;
      const rect = detailsPanel.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      startW = rect.width;
      startH = rect.height;
      document.body.style.cursor = 'nwse-resize';
      document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const newW = Math.max(420, startW + (e.clientX - startX));
      const newH = Math.max(160, startH + (e.clientY - startY));
      detailsPanel.style.width = newW + 'px';
      detailsPanel.style.height = newH + 'px';
    });
    document.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      // Save size
      try {
        const rect = detailsPanel.getBoundingClientRect();
        const pos = JSON.parse(localStorage.getItem('ms_floatPos') || '{}');
        pos.width = rect.width;
        pos.height = rect.height;
        localStorage.setItem('ms_floatPos', JSON.stringify(pos));
      } catch(e){}
    });
  }

  // Keyboard shortcut: D to toggle panel (when not in input)
  document.addEventListener('keydown', (e)=>{
    if(e.target.closest('input, textarea, select, [contenteditable]')) return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;
    if(e.key === 'd' || e.key === 'D'){
      e.preventDefault();
      // Toggle: if hidden, restore last docked mode; if visible, hide
      if(state.panelMode === 'hidden'){
        const last = localStorage.getItem('ms_panelModeLast') || 'right';
        applyPanelMode(MODES.includes(last) && last !== 'hidden' ? last : 'right', true);
      } else {
        try { localStorage.setItem('ms_panelModeLast', state.panelMode); } catch(e){}
        applyPanelMode('hidden', true);
      }
    }
  });

  // Reposition handles on window resize + clamp float panel
  window.addEventListener('resize', ()=>{
    positionResizeHandles();
    if(window.innerWidth < 900 && (state.panelMode === 'right' || state.panelMode === 'left')){
      applyPanelMode('bottom', false);
    }
    // Keep float panel visible on screen
    if(state.panelMode === 'float'){
      const rect = detailsPanel.getBoundingClientRect();
      let changed = false;
      if(rect.top > window.innerHeight - 40){
        detailsPanel.style.top = (window.innerHeight - 40) + 'px';
        changed = true;
      }
      if(rect.left > window.innerWidth - 80){
        detailsPanel.style.left = (window.innerWidth - 80) + 'px';
        changed = true;
      }
      if(rect.top < -10){
        detailsPanel.style.top = '0px';
        changed = true;
      }
      if(changed){
        try {
          const r = detailsPanel.getBoundingClientRect();
          const pos = JSON.parse(localStorage.getItem('ms_floatPos') || '{}');
          pos.top = r.top; pos.left = r.left;
          localStorage.setItem('ms_floatPos', JSON.stringify(pos));
        } catch(e){}
      }
    }
  });

  // Apply initial mode
  applyPanelMode(state.panelMode, false);
})();

// === Pan mode for viewer (press P to toggle) ===
(function(){
  const scroller = document.getElementById('columnsScroller');
  if(!scroller) return;
  let panning = false;
  let startX = 0, startY = 0, scrollStartX = 0, scrollStartY = 0;

  function setPanMode(on){
    state.panMode = on;
    scroller.classList.toggle('panReady', on);
    if(on){
      // Clear any hover highlight
      if(state.hoverId || state.hoverEdgeId){
        state.hoverId = null;
        state.hoverEdgeId = null;
        applyHighlight();
      }
    }
    if(!on){
      panning = false;
      scroller.classList.remove('panning');
    }
    // Show status hint
    const status = document.getElementById('viewerStatus');
    if(status && on) status.textContent = 'Pan mode  drag to scroll, press P or Esc to exit';
    // Update pan toggle button
    const panBtn = document.getElementById('panToggleBtn');
    if(panBtn){
      panBtn.classList.toggle('active', on);
    }
  }

  // Pan toggle button
  const panToggleBtn = document.getElementById('panToggleBtn');
  if(panToggleBtn) panToggleBtn.addEventListener('click', ()=> setPanMode(!state.panMode));

  document.addEventListener('keydown', (e)=>{
    if(e.target.closest('input, textarea, select, [contenteditable]')) return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;
    if(e.key === 'p' || e.key === 'P'){
      e.preventDefault();
      setPanMode(!state.panMode);
    }
    if(e.key === 'Escape' && state.panMode){
      setPanMode(false);
    }
  });

  scroller.addEventListener('mousedown', (e)=>{
    if(!state.panMode) return;
    e.preventDefault();
    e.stopPropagation();
    panning = true;
    startX = e.clientX;
    startY = e.clientY;
    scrollStartX = scroller.scrollLeft;
    scrollStartY = scroller.scrollTop;
    scroller.classList.add('panning');
    scroller.classList.remove('panReady');
  });

  document.addEventListener('mousemove', (e)=>{
    if(!panning) return;
    scroller.scrollLeft = scrollStartX - (e.clientX - startX);
    scroller.scrollTop = scrollStartY - (e.clientY - startY);
  });

  document.addEventListener('mouseup', ()=>{
    if(!panning) return;
    panning = false;
    scroller.classList.remove('panning');
    if(state.panMode) scroller.classList.add('panReady');
  });

  window.addEventListener('blur', ()=>{
    if(state.panMode) setPanMode(false);
  });

  // During pan mode, forward wheel events to the column .tree under the cursor
  // (pointer-events:none on children blocks native wheel scrolling)
  scroller.addEventListener('wheel', (e)=>{
    if(!state.panMode) return;
    // Temporarily enable pointer-events to hit-test the real element
    scroller.classList.remove('panReady', 'panning');
    const el = document.elementFromPoint(e.clientX, e.clientY);
    scroller.classList.add(panning ? 'panning' : 'panReady');
    const tree = el && (el.closest('.tree') || (el.classList && el.classList.contains('tree') ? el : null));
    if(tree && tree.scrollHeight > tree.clientHeight){
      tree.scrollTop += e.deltaY;
      e.preventDefault();
    }
  }, {passive: false});
})();

// --- Marquee / lasso select ---
(function(){
  const scroller = document.getElementById('columnsScroller');
  const rectEl = document.getElementById('lassoRect');
  const lassoSvg = document.getElementById('lassoSvg');
  const lassoPoly = document.getElementById('lassoPolygon');
  if(!scroller || !rectEl) return;

  let active = false, startX = 0, startY = 0, dragging = false;
  let freeform = false; // Alt  freeform lasso
  let points = [];      // freeform path points [{x,y}]

  // Point-in-polygon (ray casting)
  function pointInPolygon(px, py, poly){
    let inside = false;
    for(let i = 0, j = poly.length - 1; i < poly.length; j = i++){
      const xi = poly[i].x, yi = poly[i].y;
      const xj = poly[j].x, yj = poly[j].y;
      if(((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)){
        inside = !inside;
      }
    }
    return inside;
  }

  // Convert client coords to scroller-space
  function toScrollerXY(e){
    const rect = scroller.getBoundingClientRect();
    const zoom = parseFloat(scroller.style.zoom) || 1;
    return {
      x: (e.clientX - rect.left) / zoom + scroller.scrollLeft,
      y: (e.clientY - rect.top) / zoom + scroller.scrollTop
    };
  }

  scroller.addEventListener('mousedown', (e) => {
    if(state.panMode) return;
    if(e.button !== 0) return;
    if(document.querySelector('.modal.active')) return;
    const t = e.target;
    if(t.closest('.row') || t.closest('.btn') || t.closest('input') || t.closest('select') ||
       t.closest('label') || t.closest('.panelHeader') || t.closest('.tagChip') ||
       t.closest('.rowActions') || t.closest('.caret') || t.closest('path') || t.closest('svg') ||
       t.closest('.modal') || t.closest('.tbPop') || t.closest('.popover')) return;
    const p = toScrollerXY(e);
    startX = p.x; startY = p.y;
    freeform = e.altKey;
    points = [p];
    active = true;
    dragging = false;
  });

  document.addEventListener('mousemove', (e) => {
    if(!active) return;
    const p = toScrollerXY(e);
    if(!dragging && Math.abs(p.x - startX) < 5 && Math.abs(p.y - startY) < 5) return;
    if(!dragging){
      dragging = true;
      state._lassoActive = true;
      // Suppress hover highlights during marquee/lasso
      state.hoverId = null;
      state.hoverEdgeId = null;
      scroller.classList.add('lassoActive');
      document.body.style.userSelect = 'none';
    }

    if(freeform){
      // Freeform lasso: collect points (skip if too close to last)
      const last = points[points.length - 1];
      const dx = p.x - last.x, dy = p.y - last.y;
      if(dx*dx + dy*dy > 16){ // min 4px distance
        points.push(p);
      }
      // Draw polygon
      const pts = points.map(pt => `${pt.x},${pt.y}`).join(' ');
      lassoPoly.setAttribute('points', pts);
      lassoSvg.style.display = 'block';
      lassoSvg.setAttribute('width', scroller.scrollWidth);
      lassoSvg.setAttribute('height', scroller.scrollHeight);
      rectEl.style.display = 'none';
    } else {
      // Rectangle marquee
      const left = Math.min(startX, p.x), top = Math.min(startY, p.y);
      rectEl.style.cssText = `display:block;position:absolute;left:${left}px;top:${top}px;width:${Math.abs(p.x-startX)}px;height:${Math.abs(p.y-startY)}px;border:1.5px dashed rgba(59,130,246,.7);background:rgba(59,130,246,.08);border-radius:2px;pointer-events:none;z-index:9999;`;
      lassoSvg.style.display = 'none';
    }
    e.preventDefault();
  });

  document.addEventListener('mouseup', async (e) => {
    if(!active) return;
    active = false;
    if(dragging) document.body.style.userSelect = '';
    const wasDragging = dragging;
    dragging = false;
    state._lassoActive = false;
    scroller.classList.remove('lassoActive');

    const wasFreeform = freeform;
    const wasRectVisible = rectEl.style.display === 'block';
    const wasLassoVisible = lassoSvg.style.display === 'block';
    rectEl.style.display = 'none';
    lassoSvg.style.display = 'none';

    if(!wasDragging || (!wasRectVisible && !wasLassoVisible)) return;

    const zoom = parseFloat(scroller.style.zoom) || 1;
    const sRect = scroller.getBoundingClientRect();
    const hits = new Set();

    if(wasFreeform && points.length >= 3){
      // Freeform: point-in-polygon on each node center
      for(const [nid, rowEl] of IDX.rowById.entries()){
        if(!rowEl.offsetParent) continue;
        const el = IDX.elementById.get(nid);
        if(el && el.classList.contains('hidden')) continue;
        const rr = rowEl.getBoundingClientRect();
        const cx = (rr.left - sRect.left + rr.width/2) / zoom + scroller.scrollLeft;
        const cy = (rr.top - sRect.top + rr.height/2) / zoom + scroller.scrollTop;
        if(pointInPolygon(cx, cy, points)) hits.add(nid);
      }
    } else if(!wasFreeform && wasRectVisible){
      // Rectangle: AABB intersection
      const p = toScrollerXY(e);
      const lassoL = Math.min(startX, p.x), lassoT = Math.min(startY, p.y);
      const lassoR = Math.max(startX, p.x), lassoB = Math.max(startY, p.y);
      for(const [nid, rowEl] of IDX.rowById.entries()){
        if(!rowEl.offsetParent) continue;
        const el = IDX.elementById.get(nid);
        if(el && el.classList.contains('hidden')) continue;
        const rr = rowEl.getBoundingClientRect();
        const nL = (rr.left - sRect.left) / zoom + scroller.scrollLeft;
        const nT = (rr.top - sRect.top) / zoom + scroller.scrollTop;
        const nR = nL + rr.width / zoom;
        const nB = nT + rr.height / zoom;
        if(nL < lassoR && nR > lassoL && nT < lassoB && nB > lassoT) hits.add(nid);
      }
    }

    if(hits.size > 0){
      if(state.editorMode && nodeEditIsDirty()){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      if(state.editorMode && edgeEditIsDirty()){
        const eid = __edgeEditSession?.edgeId || '';
        if(!await guardAbandonEdit('mapping', eid)) return;
      }
      if(state.editorMode && __editSnapshot){
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }

      // Clear any edge selection  marquee transitions to node multi-select
      // But preserve edge endpoints for Shift-add / Ctrl-subtract mode
      const _prevEdgeEP = state._selectedEdgeEndpoints;
      state._selectedEdgeEndpoints = null;
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
      state.selectedColumnId = null;

      const isAdd = e.shiftKey;
      const isSubtract = (e.ctrlKey || e.metaKey);

      if(isSubtract){
        if(state.lockedId && state.multiSelection.size === 0){
          state.multiSelection.add(state.lockedId);
          state.lockedId = null;
        }
        // Preserve edge endpoints into multi-select
        if(_prevEdgeEP && state.multiSelection.size === 0){
          state.multiSelection.add(_prevEdgeEP.from);
          state.multiSelection.add(_prevEdgeEP.to);
        }
        for(const nid of hits) state.multiSelection.delete(nid);
      } else if(isAdd){
        if(state.lockedId && state.multiSelection.size === 0){
          state.multiSelection.add(state.lockedId);
          state.lockedId = null;
        }
        // Preserve edge endpoints into multi-select
        if(_prevEdgeEP && state.multiSelection.size === 0){
          state.multiSelection.add(_prevEdgeEP.from);
          state.multiSelection.add(_prevEdgeEP.to);
        }
        for(const nid of hits) state.multiSelection.add(nid);
      } else {
        state.multiSelection.clear();
        state.lockedId = null;
        for(const nid of hits) state.multiSelection.add(nid);
      }
      state.hoverId = null;
      state._lassoJustCompleted = Date.now();
      applyHighlight();
    }
  });
})();




/* =========================
 Column manager (show/hide + reorder)
========================= */
function togglePopover(on){
  columnsPopover.classList.toggle('active', !!on);
}
function buildColumnsMenu(){
  if(!state.data) return;
  const cols = state.data.columns || [];
  const popTitle = document.querySelector('#columnsPopover .popTitle');
  if(popTitle) popTitle.textContent = 'Columns';
  columnsList.innerHTML = '';
  let __colDragIdx = null;

  const eyeOnSvg = '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><path d="M1 7s2.5-3.5 6-3.5S13 7 13 7s-2.5 3.5-6 3.5S1 7 1 7z"/><circle cx="7" cy="7" r="2"/></svg>';
  const eyeOffSvg = '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"><path d="M1 7s2.5-3.5 6-3.5S13 7 13 7s-2.5 3.5-6 3.5S1 7 1 7z"/><line x1="2" y1="12" x2="12" y2="2"/></svg>';
  const upSvg = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="9" x2="6" y2="3"/><polyline points="3.5,5.5 6,3 8.5,5.5"/></svg>';
  const downSvg = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="3" x2="6" y2="9"/><polyline points="3.5,6.5 6,9 8.5,6.5"/></svg>';
  const trashSvg = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><polyline points="1,3 11,3"/><path d="M4 3V1.5h4V3"/><path d="M2.5 3l.5 7.5a1 1 0 0 0 1 .9h4a1 1 0 0 0 1-.9L9.5 3"/></svg>';

  cols.forEach((c, idx) => {
    const isHidden = state.hiddenColumns.has(c.id);
    const row = document.createElement('div');
    row.className = 'colItem' + (isHidden ? ' colHidden' : '');
    row.dataset.colIdx = idx;

    if(state.editorMode){
      row.draggable = true;
      row.style.cursor = 'grab';
      row.addEventListener('dragstart', (e)=>{
        __colDragIdx = idx;
        row.style.opacity = '0.4';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', '');
      });
      row.addEventListener('dragend', ()=>{
        row.style.opacity = '';
        columnsList.querySelectorAll('.colItem').forEach(r=>r.classList.remove('dragOver'));
        __colDragIdx = null;
      });
      row.addEventListener('dragover', (e)=>{
        e.preventDefault(); e.dataTransfer.dropEffect = 'move';
        columnsList.querySelectorAll('.colItem').forEach(r=>r.classList.remove('dragOver'));
        row.classList.add('dragOver');
      });
      row.addEventListener('dragleave', ()=>{ row.classList.remove('dragOver'); });
      row.addEventListener('drop', (e)=>{
        e.preventDefault();
        row.classList.remove('dragOver');
        const toIdx = parseInt(row.dataset.colIdx);
        if(__colDragIdx === null || __colDragIdx === toIdx) return;
        recordChange();
        const [moved] = cols.splice(__colDragIdx, 1);
        cols.splice(toIdx, 0, moved);
        jsonArea.value = JSON.stringify(state.data, null, 2);
        rebuildStructuredList();
        renderAll();
        buildColumnsMenu();
      });
    }

    // Eye toggle (visibility)
    const eye = document.createElement('button');
    eye.className = 'colEyeBtn' + (isHidden ? ' colEyeOff' : '');
    eye.innerHTML = isHidden ? eyeOffSvg : eyeOnSvg;
    eye.title = isHidden ? 'Show column' : 'Hide column';
    eye.addEventListener('click', (e) => {
      e.stopPropagation();
      if(isHidden) state.hiddenColumns.delete(c.id);
      else state.hiddenColumns.add(c.id);
      state.selectedEdgeId = null; state.hoverEdgeId = null;
      state.lockedId = null; state.hoverId = null;
      renderAll();
      buildColumnsMenu();
      togglePopover(true);
    });

    // Color dot
    const dot = document.createElement('span');
    dot.className = 'colColorDot';
    if(c.color){
      dot.style.background = c.color;
      dot.style.borderColor = c.color;
    } else {
      dot.style.background = 'var(--border)';
    }

    // Label + ID
    const grow = document.createElement('div');
    grow.className = 'grow';
    grow.style.minWidth = '0';
    grow.innerHTML = `<div style="font-weight:700;font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(c.label || c.id)}</div>`+
                     `<div style="font-family:var(--mono);font-size:10px;opacity:.5;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(c.id)}</div>`;

    row.appendChild(eye);
    row.appendChild(dot);
    row.appendChild(grow);

    // Click row to toggle visibility
    row.addEventListener('click', (e)=>{
      if(e.target.closest('button')) return;
      eye.click();
    });
    if(!state.editorMode) row.style.cursor = 'pointer';

    if(state.editorMode){
      const actions = document.createElement('div');
      actions.className = 'colItemActions';

      const up = document.createElement('button');
      up.className = 'colMoveBtn';
      up.innerHTML = upSvg;
      up.title = 'Move earlier';
      up.disabled = idx === 0;
      up.addEventListener('click', (e) => {
        e.stopPropagation();
        if(idx<=0) return;
        recordChange();
        const a = cols[idx-1]; cols[idx-1] = cols[idx]; cols[idx] = a;
        jsonArea.value = JSON.stringify(state.data, null, 2);
        rebuildStructuredList();
        renderAll();
        buildColumnsMenu();
      });

      const down = document.createElement('button');
      down.className = 'colMoveBtn';
      down.innerHTML = downSvg;
      down.title = 'Move later';
      down.disabled = idx === cols.length-1;
      down.addEventListener('click', (e) => {
        e.stopPropagation();
        if(idx>=cols.length-1) return;
        recordChange();
        const a = cols[idx+1]; cols[idx+1] = cols[idx]; cols[idx] = a;
        jsonArea.value = JSON.stringify(state.data, null, 2);
        rebuildStructuredList();
        renderAll();
        buildColumnsMenu();
      });

      const del = document.createElement('button');
      del.className = 'colDelBtn';
      del.innerHTML = trashSvg;
      del.title = 'Delete column';
      del.addEventListener('click', async (e) => {
        e.stopPropagation();
        await deleteColumnById(c.id);
        buildColumnsMenu();
        togglePopover(true);
      });

      actions.appendChild(up);
      actions.appendChild(down);
      actions.appendChild(del);
      row.appendChild(actions);
    }
    columnsList.appendChild(row);
  });

  // Show/hide add column buttons inside popover
  const addBtnsWrap = document.getElementById('colPopAddBtns');
  if(addBtnsWrap) addBtnsWrap.style.display = state.editorMode ? 'inline-flex' : 'none';
  const nCols = cols.length;
  if(addColumnLeftBtn){
    addColumnLeftBtn.innerHTML = nCols === 0
      ? '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><line x1="6" y1="2" x2="6" y2="10"/><line x1="2" y1="6" x2="10" y2="6"/></svg>Add column'
      : '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><line x1="6" y1="2" x2="6" y2="10"/><line x1="2" y1="6" x2="10" y2="6"/></svg>Add left';
  }
  if(addColumnRightBtn){
    addColumnRightBtn.innerHTML = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.1" stroke-linecap="round"><line x1="6" y1="2" x2="6" y2="10"/><line x1="2" y1="6" x2="10" y2="6"/></svg>Add right';
    addColumnRightBtn.style.display = nCols > 0 ? '' : 'none';
  }
}
function hideUnmappedColumns(){
  const colHasMapped = new Map();
  IDX.columns.forEach(c => colHasMapped.set(c.id, false));
  for(const fid of IDX.mappedFields){
    const c = columnOf(fid);
    if(c) colHasMapped.set(c, true);
  }
  for(const [cid, has] of colHasMapped.entries()){
    if(!has) state.hiddenColumns.add(cid);
  }
  renderAll();
}
/* =========================
   Viewer control wiring
========================= */

// ----- Toolbar popover toggle system -----
{
  // Filter bar toggle (not a popover  simple show/hide)
  const filterToggleBtn = document.getElementById('tbFilterToggle');
  const filterBar = document.getElementById('tbFilterBar');
  if(filterToggleBtn && filterBar){
    filterToggleBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const show = filterBar.style.display === 'none';
      filterBar.style.display = show ? '' : 'none';
      filterToggleBtn.classList.toggle('active', show);
      // Focus search when opening
      if(show){ const si = document.getElementById('searchInput'); if(si) si.focus(); }
    });
  }

  const tbBtns = document.querySelectorAll('.tbRow2 > .tbBtn:not(#tbFilterToggle)');
  function closeAllPopovers(){
    document.querySelectorAll('.tbPop').forEach(p => p.classList.remove('open'));
    tbBtns.forEach(b => b.classList.remove('active'));
  }
  tbBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
      // Clicking a .btn inside popover  close popover (it's an action button like Export CSV)
      const innerBtn = e.target.closest('.tbPop .btn');
      if(innerBtn){ setTimeout(closeAllPopovers, 80); return; }
      // Clicking toggles/sliders inside popover  keep open
      if(e.target.closest('.tbPop')) return;
      e.stopPropagation();
      const pop = btn.querySelector('.tbPop');
      if(!pop) return;
      const isOpen = pop.classList.contains('open');
      closeAllPopovers();
      if(!isOpen){ pop.classList.add('open'); btn.classList.add('active'); }
    });
  });
  // Close popovers on outside click
  document.addEventListener('click', (e) => {
    if(!e.target.closest('.tbBtn')) closeAllPopovers();
  });
  // Close on Escape
  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape') closeAllPopovers();
  });
}

const goDocsBtn = document.getElementById('goDocsBtn');
if(goDocsBtn) goDocsBtn.addEventListener('click', ()=>{ if(typeof openDocs==='function') openDocs(); });

if(searchInput) searchInput.addEventListener("input", () => {
  state.search = searchInput.value || "";
  updateFilterBadge();
  refreshViewer();
});

if(clearFilterBtn) clearFilterBtn.addEventListener("click", () => {
  state.search = "";
  if(searchInput) searchInput.value = "";
  state.onlyMapped = false;
  if(onlyMappedToggle) onlyMappedToggle.checked = false;
  const omWrap = document.getElementById('onlyMappedWrap');
  if(omWrap) omWrap.classList.remove('active');
  state.activeFilterIds = [];
  state.filterMode = 'hide';
  updateFilterModeUI();
  state.filterLogic = 'or';
  updateFilterLogicUI();
  renderActiveFilterChips();
  updateFilterBadge();
  refreshViewer();
});

if(onlyMappedToggle) onlyMappedToggle.addEventListener("change", () => {
  state.onlyMapped = !!onlyMappedToggle.checked;
  const wrap = document.getElementById('onlyMappedWrap');
  if(wrap) wrap.classList.toggle('active', state.onlyMapped);
  updateFilterBadge();
  refreshViewer();
});

// Filter display mode selector (Hide | Dim | Highlight)
const filterModeGroup = document.getElementById('filterModeGroup');
const FILTER_MODES = ['hide', 'dim', 'highlight'];
function updateFilterModeUI(){
  if(!filterModeGroup) return;
  filterModeGroup.querySelectorAll('.fbOpt').forEach(b => {
    b.classList.toggle('active', b.dataset.fmode === state.filterMode);
  });
}
function updateFilterModeBtn(){ updateFilterModeUI(); }
if(filterModeGroup){
  filterModeGroup.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-fmode]');
    if(!btn) return;
    state.filterMode = btn.dataset.fmode;
    updateFilterModeUI();
    refreshViewer();
  });
}

// AND/OR logic selector
const filterLogicGroup = document.getElementById('filterLogicGroup');
function updateFilterLogicUI(){
  if(!filterLogicGroup) return;
  filterLogicGroup.querySelectorAll('.fbOpt').forEach(b => {
    b.classList.toggle('active', b.dataset.flogic === state.filterLogic);
  });
}
if(filterLogicGroup){
  filterLogicGroup.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-flogic]');
    if(!btn) return;
    state.filterLogic = btn.dataset.flogic;
    updateFilterLogicUI();
    refreshViewer();
  });
}

// Filter catalog modal
const filtersBtn = document.getElementById('filtersBtn');
const filtersMask = document.getElementById('filtersMask');
const filtersModal = document.getElementById('filtersModal');
const closeFiltersBtn = document.getElementById('closeFiltersBtn');
const addFilterBtn = document.getElementById('addFilterBtn');

function openFilters(){
  ensureFilterCatalog();
  __filterEditId = null;
  __filterEditSnapshot = null;
  renderFiltersManager();
  if(addFilterBtn) addFilterBtn.style.display = state.editorMode ? '' : 'none';
  filtersMask?.classList.add('active');
  filtersModal?.classList.add('active');
}
async function closeFilters(){
  if(__filterEditId && filterFormIsDirty()){
    const cat = ensureFilterCatalog();
    const f = cat.find(x => x.id === __filterEditId);
    if(!await guardAbandonEdit(f?.label || __filterEditId, __filterEditId)) return;
    // Revert in-place rule changes
    if(__filterEditSnapshot){
      const snap = JSON.parse(__filterEditSnapshot);
      if(f && snap.rules) f.rules = snap.rules;
    }
  }
  __filterEditId = null;
  __filterEditSnapshot = null;
  filtersMask?.classList.remove('active');
  filtersModal?.classList.remove('active');
  renderActiveFilterChips();
  refreshViewer();
}
if(filtersBtn) filtersBtn.addEventListener('click', openFilters);
if(closeFiltersBtn) closeFiltersBtn.addEventListener('click', closeFilters);
if(filtersMask) filtersMask.addEventListener('click', closeFilters);
if(addFilterBtn) addFilterBtn.addEventListener('click', async ()=>{
  if(!await guardFilterAbandon()) return;
  const cat = ensureFilterCatalog();
  const id = 'filter_' + Date.now().toString(36);
  const minPri = cat.reduce((m,f)=>Math.min(m, typeof f.priority==='number'?f.priority:0), 0);
  cat.push({
    id, label: '', note: '', priority: minPri - 1,
    rules: [{ field:'tag', op:'has', value:'' }],
    highlight: { bg:'#3b82f6', border:'#3b82f6', edgeColor:'#3b82f6', frameColor:'#3b82f6', bold:false, frame:false, emoji:'', bgEnabled:true, borderEnabled:true, edgeEnabled:false }
  });
  __filterEditId = id;
  __filterIsNew = true;
  const newF = cat[cat.length - 1];
  __filterEditSnapshot = JSON.stringify(newF);
  checkDirtyState();
  renderFiltersManager();
});

// Initialize chips
renderActiveFilterChips();
updateFilterBadge();

// Arrow mode selector (Selected | All | Off)
let updateArrowModeUI = ()=>{};
{
  const arrowModeSelector = document.getElementById('arrowModeSelector');
  updateArrowModeUI = function(){
    if(!arrowModeSelector) return;
    const mode = !state.arrowsOn ? 'off' : (state.allArrows ? 'all' : 'selected');
    arrowModeSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.amode === mode));
  };
  if(arrowModeSelector){
    arrowModeSelector.addEventListener('click', (e)=>{
      const opt = e.target.closest('[data-amode]');
      if(!opt) return;
      const mode = opt.dataset.amode;
      if(mode === 'off'){ state.arrowsOn = false; state.allArrows = false; }
      else if(mode === 'all'){ state.arrowsOn = true; state.allArrows = true; }
      else { state.arrowsOn = true; state.allArrows = false; }
      svgOverlay.style.display = state.arrowsOn ? "block" : "none";
      updateArrowModeUI();
      scheduleArrowsUpdate();
      _scheduleDriftCheck();
    });
  }
  // Arrow scope toggles
  if(showSameColToggle) showSameColToggle.addEventListener("change", () => {
    state.showSameColumn = !!showSameColToggle.checked;
    scheduleArrowsUpdate();
    _scheduleDriftCheck();
  });
  if(showDistantToggle) showDistantToggle.addEventListener("change", () => {
    state.showDistant = !!showDistantToggle.checked;
    scheduleArrowsUpdate();
    _scheduleDriftCheck();
  });
}

{
  const dimSelector = document.getElementById('dimModeSelector');
  if(dimSelector){
    dimSelector.addEventListener('click', (e)=>{
      const opt = e.target.closest('.dockOpt');
      if(!opt) return;
      const mode = opt.dataset.dim;
      if(!mode) return;
      state.selectionDim = mode;
      dimSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.remove('active'));
      opt.classList.add('active');
      refreshViewer();
    });
  }
  const multiArrowSel = document.getElementById('multiArrowModeSelector');
  if(multiArrowSel){
    multiArrowSel.addEventListener('click', (e)=>{
      const opt = e.target.closest('.dockOpt');
      if(!opt) return;
      const mode = opt.dataset.mode;
      if(!mode) return;
      state.multiSelectArrowMode = mode;
      multiArrowSel.querySelectorAll('.dockOpt').forEach(b => b.classList.remove('active'));
      opt.classList.add('active');
      refreshViewer();
    });
  }
}

// Edge color scheme
{
  const edgeColorSel = document.getElementById('edgeColorSelector');
  if(edgeColorSel){
    edgeColorSel.addEventListener('click', (e)=>{
      const opt = e.target.closest('.dockOpt');
      if(!opt) return;
      const scheme = opt.dataset.scheme;
      if(scheme === undefined) return;
      state.edgeColorScheme = scheme;
      edgeColorSel.querySelectorAll('.dockOpt').forEach(b => b.classList.remove('active'));
      opt.classList.add('active');
      refreshEdgeColorScheme();
      scheduleArrowsUpdate();
      _scheduleDriftCheck();
    });
    // Hover preview: temporarily show legend for hovered scheme
    let _hoverActive = false;
    edgeColorSel.addEventListener('mouseover', (e)=>{
      const opt = e.target.closest('.dockOpt');
      if(!opt) return;
      const scheme = opt.dataset.scheme;
      if(scheme === undefined) return;
      if(!scheme){ // "Off" button
        const legend = document.getElementById('edgeColorLegend');
        if(legend){ legend.style.display = 'none'; }
        _hoverActive = true;
        return;
      }
      // Temporarily compute + show legend for hovered scheme
      const savedScheme = state.edgeColorScheme;
      const savedMap = __edgeSchemeMap;
      __edgeSchemeMap = new Map();
      state.edgeColorScheme = scheme;
      if(IDX && IDX.edges) for(const edge of IDX.edges) getEdgeSchemeColor(edge);
      buildEdgeSchemeLegend();
      state.edgeColorScheme = savedScheme;
      __edgeSchemeMap = savedMap;
      _hoverActive = true;
    });
    edgeColorSel.addEventListener('mouseleave', ()=>{
      if(!_hoverActive) return;
      _hoverActive = false;
      buildEdgeSchemeLegend(); // restore to actual selection
    });
  }
}

if(wrapToggle) wrapToggle.addEventListener("change", () => {
  state.wrapColumns = !!wrapToggle.checked;
  const ind = document.getElementById('wrapIndicator');
  if(ind) ind.textContent = wrapToggle.checked ? 'ON' : 'OFF';
  const btn = document.getElementById('wrapToggleBtn');
  if(btn) btn.style.background = wrapToggle.checked ? 'rgba(59,130,246,.15)' : '';
  renderAll();
});
document.getElementById('wrapToggleBtn')?.addEventListener('click', ()=>{
  if(wrapToggle){ wrapToggle.checked = !wrapToggle.checked; wrapToggle.dispatchEvent(new Event('change')); }
});

// Node label display mode selectors
(function(){
  const tagSel = document.getElementById('tagPillsModeSelector');
  const attrSel = document.getElementById('attrPillsModeSelector');
  if(tagSel){
    tagSel.querySelectorAll('.dockOpt').forEach(b => {
      b.classList.toggle('active', b.dataset.tpm === (state.tagPillsMode || 'left'));
      b.addEventListener('click', ()=>{
        tagSel.querySelectorAll('.dockOpt').forEach(x => x.classList.remove('active'));
        b.classList.add('active');
        state.tagPillsMode = b.dataset.tpm;
        renderAll();
      });
    });
  }
  if(attrSel){
    attrSel.querySelectorAll('.dockOpt').forEach(b => {
      b.classList.toggle('active', b.dataset.apm === (state.attrPillsMode || 'left'));
      b.addEventListener('click', ()=>{
        attrSel.querySelectorAll('.dockOpt').forEach(x => x.classList.remove('active'));
        b.classList.add('active');
        state.attrPillsMode = b.dataset.apm;
        renderAll();
      });
    });
  }
  const edgeLabelSel = document.getElementById('edgeLabelModeSelector');
  if(edgeLabelSel){
    edgeLabelSel.querySelectorAll('.dockOpt').forEach(b=>{
      b.classList.toggle('active', b.dataset.elm === state.showEdgeLabels);
    });
    edgeLabelSel.addEventListener('click', (e)=>{
      const btn = e.target.closest('.dockOpt[data-elm]');
      if(!btn) return;
      state.showEdgeLabels = btn.dataset.elm;
      edgeLabelSel.querySelectorAll('.dockOpt').forEach(b=> b.classList.toggle('active', b.dataset.elm === state.showEdgeLabels));
      scheduleArrowsUpdate();
    });
  }
})();

// Node color mode selector
(function(){
  const ncmSelector = document.getElementById('nodeColorModeSelector');
  if(ncmSelector){
    ncmSelector.addEventListener('click', (e)=>{
      const btn = e.target.closest('.dockOpt[data-ncm]');
      if(!btn) return;
      const mode = btn.dataset.ncm;
      state.nodeColorMode = mode;
      ncmSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderAll();
    });
  }
})();


// 
// Views  saved viewer state bookmarks
// 

const VIEW_EMOJI_PICKS = ['','','','','','','','','','','','','','','','','','','','','','','',''];

function ensureViewCatalog(){
  if(!state.data) return [];
  if(!Array.isArray(state.data.viewCatalog)) state.data.viewCatalog = [];
  return state.data.viewCatalog;
}

// Tracking
let __activeViewId = null;
let __activeViewStateJSON = null;
let __applyingView = false; // guard to prevent drift detection during view application

// Inline edit state
let __viewEditIdx = -1;
let __viewIsNew = false;
let __viewEditSnapshot = null;

function captureViewState(){
  const collapsedGroups = [];
  if(IDX && IDX.elementById){
    for(const [id, el] of IDX.elementById.entries()){
      if(el.classList.contains('group') && el.classList.contains('collapsed')) collapsedGroups.push(id);
    }
  }
  let arrowMode = 'selected';
  if(!state.arrowsOn) arrowMode = 'off';
  else if(state.allArrows) arrowMode = 'all';
  const selection = [];
  if(state.lockedId && columnOf(state.lockedId)) selection.push(state.lockedId);
  if(state.multiSelection && state.multiSelection.size > 0){
    for(const id of state.multiSelection){ if(!selection.includes(id)) selection.push(id); }
  }
  return {
    activeFilterIds: [...state.activeFilterIds],
    filterMode: state.filterMode,
    filterLogic: state.filterLogic,
    onlyMapped: state.onlyMapped,
    search: state.search || '',
    selection,
    highlightMode: state.multiSelectArrowMode,
    arrowMode,
    showSameColumn: state.showSameColumn,
    showDistant: state.showDistant,
    selectionDim: state.selectionDim,
    hiddenColumns: [...state.hiddenColumns],
    collapsedGroups,
    edgeColorScheme: state.edgeColorScheme,
    nodeColorMode: state.nodeColorMode || 'all',
    showEdgeLabels: state.showEdgeLabels || 'always',
    tagPillsMode: state.tagPillsMode || 'left',
    attrPillsMode: state.attrPillsMode || 'left'
  };
}

function _viewStateMatchesCurrent(){
  if(!__activeViewStateJSON) return false;
  try { return JSON.stringify(captureViewState()) === __activeViewStateJSON; }
  catch(e){ return false; }
}
function _clearActiveViewIfDrifted(){
  if(__activeViewId && !_viewStateMatchesCurrent()){
    __activeViewId = null; __activeViewStateJSON = null; _syncViewNavButtons(); _updateViewPill();
  }
}
let __driftTimer = null;
function _scheduleDriftCheck(){
  if(__applyingView) return;
  clearTimeout(__driftTimer);
  __driftTimer = setTimeout(_clearActiveViewIfDrifted, 80);
}
function _syncViewNavButtons(){
  const prevBtn = document.getElementById('viewsRestorePrevBtn');
  const nextBtn = document.getElementById('viewsNextBtn');
  const navRow = document.getElementById('viewsNavRow');
  const cat = ensureViewCatalog();
  const idx = __activeViewId ? cat.findIndex(v => v.id === __activeViewId) : -1;
  const hasPrev = idx > 0;
  const hasNext = idx >= 0 && idx < cat.length - 1;
  if(prevBtn){ prevBtn.disabled = !hasPrev; prevBtn.style.opacity = hasPrev ? '' : '.3'; prevBtn.style.pointerEvents = hasPrev ? '' : 'none'; }
  if(nextBtn){ nextBtn.disabled = !hasNext; nextBtn.style.opacity = hasNext ? '' : '.3'; nextBtn.style.pointerEvents = hasNext ? '' : 'none'; }
  if(navRow) navRow.style.display = (idx >= 0) ? 'flex' : 'none';
}
function _applyView(view){
  if(!view || !view.state) return;
  __applyingView = true;
  applyViewState(view.state);
  __activeViewId = view.id;
  __activeViewStateJSON = JSON.stringify(captureViewState());
  __applyingView = false;
  _syncViewNavButtons();
  _updateViewPill();
  setGlobalStatus('Applied view: ' + (view.label || view.id));
}

function applyViewState(vs){
  if(!vs || !state.data) return;
  state.activeFilterIds = Array.isArray(vs.activeFilterIds) ? [...vs.activeFilterIds] : [];
  state.filterMode = vs.filterMode || 'hide';
  state.filterLogic = vs.filterLogic || 'or';
  state.onlyMapped = !!vs.onlyMapped;
  state.search = vs.search || '';
  if(vs.arrowMode === 'off'){ state.arrowsOn = false; state.allArrows = false; }
  else if(vs.arrowMode === 'all'){ state.arrowsOn = true; state.allArrows = true; }
  else { state.arrowsOn = true; state.allArrows = false; }
  state.showSameColumn = vs.showSameColumn !== false;
  state.showDistant = vs.showDistant !== false;
  state.multiSelectArrowMode = vs.highlightMode || 'chain';
  state.selectionDim = vs.selectionDim || 'all';
  state.edgeColorScheme = vs.edgeColorScheme || '';
  state.nodeColorMode = vs.nodeColorMode || 'all';
  state.showEdgeLabels = vs.showEdgeLabels || 'always';
  // Backward compat: boolean showTagPills/showAttrPills  mode strings
  if(vs.tagPillsMode) state.tagPillsMode = vs.tagPillsMode;
  else state.tagPillsMode = vs.showTagPills === false ? 'off' : 'left';
  if(vs.attrPillsMode) state.attrPillsMode = vs.attrPillsMode;
  else state.attrPillsMode = vs.showAttrPills === false ? 'off' : 'left';
  state.hiddenColumns = new Set(Array.isArray(vs.hiddenColumns) ? vs.hiddenColumns : []);
  state.lockedId = null; state.hoverId = null;
  state.selectedEdgeId = null; state.hoverEdgeId = null;
  state.selectedColumnId = null; state.multiSelection = new Set();
  __editSnapshot = null;
  const sel = Array.isArray(vs.selection) ? vs.selection : [];
  if(sel.length === 1) state.lockedId = sel[0];
  else if(sel.length > 1){ state.lockedId = sel[0]; for(let i=1;i<sel.length;i++) state.multiSelection.add(sel[i]); }

  const searchInput = document.getElementById('searchInput');
  if(searchInput) searchInput.value = state.search;
  const onlyMappedToggle = document.getElementById('onlyMappedToggle');
  if(onlyMappedToggle) onlyMappedToggle.checked = state.onlyMapped;
  if(typeof updateFilterModeUI === 'function') updateFilterModeUI();
  if(typeof updateFilterLogicUI === 'function') updateFilterLogicUI();
  if(typeof renderActiveFilterChips === 'function') renderActiveFilterChips();
  if(typeof updateFilterBadge === 'function') updateFilterBadge();
  const filterBar = document.getElementById('tbFilterBar');
  if(filterBar && (state.activeFilterIds.length || state.onlyMapped || state.search)) filterBar.style.display = '';
  if(typeof updateArrowModeUI === 'function') updateArrowModeUI();
  const svgOverlay = document.getElementById('svgOverlay');
  if(svgOverlay) svgOverlay.style.display = state.arrowsOn ? 'block' : 'none';
  const showSameColToggle = document.getElementById('showSameColToggle');
  const showDistantToggle = document.getElementById('showDistantToggle');
  if(showSameColToggle) showSameColToggle.checked = state.showSameColumn;
  if(showDistantToggle) showDistantToggle.checked = state.showDistant;
  const dimSelector = document.getElementById('dimModeSelector');
  if(dimSelector) dimSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.dim === state.selectionDim));
  const multiArrowSel = document.getElementById('multiArrowModeSelector');
  if(multiArrowSel) multiArrowSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.mode === state.multiSelectArrowMode));
  const edgeColorSel = document.getElementById('edgeColorSelector');
  if(edgeColorSel) edgeColorSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.scheme === state.edgeColorScheme));
  const ncmSelector = document.getElementById('nodeColorModeSelector');
  if(ncmSelector) ncmSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.ncm === state.nodeColorMode));
  const edgeLabelSel = document.getElementById('edgeLabelModeSelector');
  if(edgeLabelSel) edgeLabelSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.elm === state.showEdgeLabels));
  const tagPillsSel = document.getElementById('tagPillsModeSelector');
  if(tagPillsSel) tagPillsSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.tpm === (state.tagPillsMode || 'left')));
  const attrPillsSel = document.getElementById('attrPillsModeSelector');
  if(attrPillsSel) attrPillsSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.apm === (state.attrPillsMode || 'left')));

  renderAll();
  if(Array.isArray(vs.collapsedGroups)){
    const collapseSet = new Set(vs.collapsedGroups);
    if(IDX && IDX.elementById){
      for(const [id, el] of IDX.elementById.entries()){
        if(!el.classList.contains('group')) continue;
        const shouldCollapse = collapseSet.has(id);
        if(shouldCollapse && !el.classList.contains('collapsed')){
          el.classList.add('collapsed');
          const ch = el.querySelector(':scope > .children');
          if(ch) ch.style.display = 'none';
        } else if(!shouldCollapse && el.classList.contains('collapsed')){
          el.classList.remove('collapsed');
          const ch = el.querySelector(':scope > .children');
          if(ch) ch.style.display = '';
        }
      }
    }
  }
  refreshViewer();
  refreshEdgeColorScheme();
  scheduleArrowsUpdate();
  if(state.lockedId && state._scrollToSelection) scrollIntoView(state.lockedId);
  state._scrollToSelection = false;
}

//  View dirty checking 
function viewFormIsDirty(){
  if(__viewEditIdx < 0) return false;
  const body = document.getElementById('viewsBody');
  if(!body) return false;
  const card = body.querySelector('.catEditing');
  if(!card || !__viewEditSnapshot) return false;
  const snap = __viewEditSnapshot;
  const curLabel = (card.querySelector('[data-f="label"]')?.value||'').trim();
  const curEmoji = (card.querySelector('[data-f="emoji"]')?.value||'').trim();
  const curNote = (card.querySelector('[data-f="note"]')?.value||'').trim();
  return curLabel !== (snap.label||'').trim() || curEmoji !== (snap.emoji||'').trim() || curNote !== (snap.note||'').trim();
}

async function guardViewAbandon(){
  if(__viewIsNew){
    if(viewFormIsDirty()){
      const ok = await customConfirm('Discard new view?');
      if(!ok) return false;
    }
    const cat = ensureViewCatalog();
    if(__viewEditIdx >= 0 && __viewEditIdx < cat.length) cat.splice(__viewEditIdx, 1);
    __viewEditIdx = -1; __viewIsNew = false; __viewEditSnapshot = null;
    return true;
  }
  if(!viewFormIsDirty()) return true;
  const cat = ensureViewCatalog();
  const v = cat[__viewEditIdx];
  return await guardAbandonEdit(v?.label || 'view', v?.id || '');
}

function viewEditBegin(idx, isNew){
  const cat = ensureViewCatalog();
  const v = cat[idx];
  if(!v) return;
  __viewEditIdx = idx;
  __viewIsNew = !!isNew;
  __viewEditSnapshot = { label: v.label||'', emoji: v.emoji||'', note: v.note||'' };
}
function viewEditEnd(){
  __viewEditIdx = -1; __viewIsNew = false; __viewEditSnapshot = null;
}

//  Quick-apply dropdown 
function renderViewsQuickList(){
  const listEl = document.getElementById('viewsQuickList');
  if(!listEl) return;
  const cat = ensureViewCatalog();
  _clearActiveViewIfDrifted();
  if(!cat.length){
    listEl.innerHTML = '<div style="padding:8px 4px;opacity:.5;font-size:12px;">No saved views yet.</div>';
    return;
  }
  listEl.innerHTML = cat.map(v => {
    const isActive = v.id === __activeViewId;
    const noteAttr = v.note ? ` title="${escapeHtml(v.note)}"` : '';
    return `<button class="btn viewQuickBtn${isActive?' viewActive':''}" data-vid="${escapeHtml(v.id)}"${noteAttr} style="text-align:left;justify-content:flex-start;width:100%;display:flex;align-items:center;gap:6px;padding:6px 10px;${isActive?'background:rgba(59,130,246,.15);border-color:rgba(59,130,246,.4);':''}">
      <span style="flex-shrink:0;">${escapeHtml(v.emoji || '\uD83D\uDCCC')}</span>
      <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(v.label || v.id)}</span>
      ${isActive?'<span style="font-size:9px;opacity:.5;">\u25CF</span>':''}
    </button>`;
  }).join('');
  listEl.querySelectorAll('.viewQuickBtn').forEach(btn => {
    btn.addEventListener('click', ()=>{
      const vid = btn.dataset.vid;
      // Toggle off if clicking the active view
      if(vid === __activeViewId){
        __activeViewId = null; __activeViewStateJSON = null;
        _syncViewNavButtons(); _updateViewPill();
        renderViewsQuickList();
        setGlobalStatus('View deactivated  current state kept');
        const pop = document.getElementById('tbPopViews');
        if(pop) pop.classList.remove('open');
        return;
      }
      const view = cat.find(v => v.id === vid);
      if(!view) return;
      _applyView(view);
      const pop = document.getElementById('tbPopViews');
      if(pop) pop.classList.remove('open');
    });
  });
  _syncViewNavButtons();
}

// Prev/Next
document.getElementById('viewsRestorePrevBtn')?.addEventListener('click', ()=>{
  const cat = ensureViewCatalog();
  const idx = __activeViewId ? cat.findIndex(v => v.id === __activeViewId) : -1;
  if(idx > 0) _applyView(cat[idx - 1]);
  // At first view or no active view: do nothing
  const pop = document.getElementById('tbPopViews');
  if(pop) pop.classList.remove('open');
});
document.getElementById('viewsNextBtn')?.addEventListener('click', ()=>{
  const cat = ensureViewCatalog();
  const idx = __activeViewId ? cat.findIndex(v => v.id === __activeViewId) : -1;
  if(idx >= 0 && idx < cat.length - 1) _applyView(cat[idx + 1]);
  // At last view or no active view: do nothing
  const pop = document.getElementById('tbPopViews');
  if(pop) pop.classList.remove('open');
});

// , / .  Previous / Next view
document.addEventListener('keydown', (e)=>{
  if(e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) return;
  if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;
  if(e.key === ','){ e.preventDefault(); document.getElementById('viewsRestorePrevBtn')?.click(); }
  else if(e.key === '.'){ e.preventDefault(); document.getElementById('viewsNextBtn')?.click(); }
});

// "Save current view" opens catalog with new inline editor
document.getElementById('viewsSaveCurrentBtn')?.addEventListener('click', ()=>{
  const pop = document.getElementById('tbPopViews');
  if(pop) pop.classList.remove('open');
  if(!state.editorMode){ customAlert('Switch to Editor mode to save views.'); return; }
  _createNewView();
});

function _createNewView(){
  const cat = ensureViewCatalog();
  const id = 'view_' + Date.now().toString(36);
  cat.unshift({ id, label: '', note: '', emoji: '', _autoId: true, state: captureViewState() });
  viewEditBegin(0, true);
  openViews();
}

document.getElementById('viewsCatalogBtn')?.addEventListener('click', ()=> openViews());
document.getElementById('tbViews')?.addEventListener('click', ()=> renderViewsQuickList());

//  Views catalog modal 
const viewsMask = document.getElementById('viewsMask');
const viewsModal = document.getElementById('viewsModal');
const closeViewsBtn = document.getElementById('closeViewsBtn');
const addViewBtn = document.getElementById('addViewBtn');

function openViews(){
  ensureViewCatalog();
  renderViewsManager();
  if(addViewBtn) addViewBtn.style.display = state.editorMode ? '' : 'none';
  viewsMask?.classList.add('active');
  viewsModal?.classList.add('active');
}
async function closeViews(){
  if(__viewEditIdx >= 0){
    if(!await guardViewAbandon()) return;
    viewEditEnd();
  }
  viewsMask?.classList.remove('active');
  viewsModal?.classList.remove('active');
  renderViewsQuickList();
}
if(closeViewsBtn) closeViewsBtn.addEventListener('click', closeViews);
if(viewsMask) viewsMask.addEventListener('click', closeViews);
if(addViewBtn) addViewBtn.addEventListener('click', async ()=>{
  if(!state.editorMode) return;
  if(__viewEditIdx >= 0){
    if(!await guardViewAbandon()) return;
    viewEditEnd();
  }
  _createNewView();
});

function renderViewsManager(){
  const body = document.getElementById('viewsBody');
  if(!body) return;
  const cat = ensureViewCatalog();
  const editable = state.editorMode;
  if(!cat.length){
    body.innerHTML = `<div class="empty" style="padding:18px;">No saved views yet.${editable?' Click <b>Add view</b> to create one.':''}</div>`;
    return;
  }
  _clearActiveViewIfDrifted();

  body.innerHTML = cat.map((v, idx) => {
    const isFirst = idx === 0;
    const isLast = idx === cat.length - 1;
    const isActive = v.id === __activeViewId;
    const isEditing = __viewEditIdx === idx;
    const vs = v.state || {};

    if(isEditing){
      const _isNew = __viewIsNew;
      const label = escapeHtml(v.label||'');
      const emoji = escapeHtml(v.emoji||'');
      const note = escapeHtml(v.note||'');
      return `<div class="catCard catItem catEditing viewCard" data-vidx="${idx}" style="margin-bottom:8px;padding:14px;border-radius:10px;border:1px solid rgba(59,130,246,.5);background:var(--panel);box-shadow:0 0 0 2px rgba(59,130,246,.12);">
        <div class="kv" style="grid-template-columns:70px 1fr;gap:8px 10px;">
          <div class="k">Label<span class="req">*</span></div>
          <div class="v"><input class="inp" data-f="label" value="${_isNew ? '' : label}" placeholder="e.g. Full Overview"/></div>
          <div class="k">Emoji</div>
          <div class="v" style="display:flex;align-items:center;gap:6px;">
            <input class="inp" data-f="emoji" value="${_isNew ? '' : emoji}" placeholder="\u2014" style="width:48px;font-size:15px;text-align:center;padding:2px;" maxlength="4"/>
            <button class="btn veEmojiToggle" style="font-size:11px;padding:2px 5px;" title="Pick emoji">\uD83D\uDE00\u25BE</button>
          </div>
          <div class="k"></div>
          <div class="v">
            <div class="veEmojiPicker" style="display:none;flex-wrap:wrap;gap:2px;margin:2px 0 4px;">
              ${VIEW_EMOJI_PICKS.map(e => `<button class="feEmojiOption" data-emoji="${e}" style="font-size:16px;padding:3px 5px;border:1px solid transparent;border-radius:6px;background:transparent;cursor:pointer;transition:all .1s;" title="${e}">${e}</button>`).join('')}<button class="feEmojiOption" data-emoji="" style="font-size:11px;padding:3px 6px;border:1px solid var(--border);border-radius:6px;background:transparent;cursor:pointer;color:var(--muted);" title="Clear emoji">\u2715</button>
            </div>
          </div>
          <div class="k">Note</div>
          <div class="v"><input class="inp" data-f="note" value="${_isNew ? '' : note}" placeholder="Optional description"/></div>
        </div>
        <div style="font-size:11px;opacity:.4;margin-top:10px;line-height:1.5;">Snapshot captures the current viewer state. To change settings, adjust the viewer then click <svg width="12" height="12" viewBox="0 0 12 12" style="vertical-align:middle;opacity:.6;"><path d="M10 2.5A4.5 4.5 0 0 0 2.3 4" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/><path d="M2 9.5A4.5 4.5 0 0 0 9.7 8" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/><polyline points="10,0.5 10,3 7.5,3" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/><polyline points="2,11.5 2,9 4.5,9" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg> on the card.</div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
          ${_isNew ? '' : '<button class="btn" data-act="del" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
          <span style="flex:1;"></span>
          <button class="btn" data-act="cancel">Cancel</button>
          <button class="btn btnSave" data-act="save">Save</button>
        </div>
      </div>`;
    }

    // Collapsed card
    const parts = [];
    if(vs.activeFilterIds && vs.activeFilterIds.length) parts.push(vs.activeFilterIds.length + ' filter' + (vs.activeFilterIds.length>1?'s':''));
    if(vs.selection && vs.selection.length) parts.push(vs.selection.length + ' selected');
    if(vs.hiddenColumns && vs.hiddenColumns.length) parts.push(vs.hiddenColumns.length + ' col hidden');
    if(vs.onlyMapped) parts.push('mapped only');
    if(vs.arrowMode === 'all') parts.push('all arrows');
    if(vs.arrowMode === 'off') parts.push('arrows off');
    if(vs.edgeColorScheme) parts.push('color: ' + vs.edgeColorScheme);
    if(vs.collapsedGroups && vs.collapsedGroups.length) parts.push(vs.collapsedGroups.length + ' collapsed');
    const summary = parts.join(' \u00B7 ') || 'Default settings';

    return `<div class="catCard catItem viewCard" data-vidx="${idx}" ${editable?'draggable="true"':''} style="margin-bottom:8px;padding:10px 14px;border-radius:10px;border:1px solid ${isActive?'rgba(59,130,246,.5)':'var(--border)'};background:${isActive?'rgba(59,130,246,.07)':'var(--panel)'};display:flex;align-items:center;gap:10px;${editable?'cursor:pointer;':''}" ${editable?'title="Click to edit \u00B7 Drag to reorder"':''}>
      ${editable?'<span class="catGrip"><svg width="8" height="14" viewBox="0 0 8 14" fill="currentColor"><circle cx="2" cy="2" r="1.2"/><circle cx="6" cy="2" r="1.2"/><circle cx="2" cy="7" r="1.2"/><circle cx="6" cy="7" r="1.2"/><circle cx="2" cy="12" r="1.2"/><circle cx="6" cy="12" r="1.2"/></svg></span>':''}
      <div style="flex:1;min-width:0;">
        <div style="display:flex;align-items:center;gap:8px;">
          <span style="font-size:16px;">${escapeHtml(v.emoji || '\uD83D\uDCCC')}</span>
          <b style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(v.label || v.id)}</b>
          <span style="font-family:var(--mono);font-size:10px;opacity:.35;flex-shrink:0;">${escapeHtml(v.id)}</span>
          ${isActive?'<span style="font-size:8px;color:#3b82f6;">\u25CF active</span>':''}
        </div>
        <div style="font-size:11px;opacity:.6;margin-top:3px;">${escapeHtml(summary)}</div>
        ${v.note ? `<div style="font-size:11px;opacity:.5;margin-top:2px;">${escapeHtml(v.note)}</div>` : ''}
      </div>
      <div style="display:flex;align-items:center;gap:6px;flex-shrink:0;">
        ${isActive
          ? `<button class="btn viewApplyBtn viewDeactivateBtn" data-vidx="${idx}" title="Deactivate this view" style="padding:4px 12px;border-color:rgba(255,255,255,.15);"><svg width="11" height="11" viewBox="0 0 11 11" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" style="vertical-align:middle;opacity:.6;"><line x1="2" y1="2" x2="9" y2="9"/><line x1="9" y1="2" x2="2" y2="9"/></svg> Deactivate</button>`
          : `<button class="btn viewApplyBtn" data-vidx="${idx}" title="Apply this view" style="padding:4px 12px;"><svg width="11" height="11" viewBox="0 0 11 11" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;opacity:.6;"><polyline points="2,6 4.5,8.5 9,2.5"/></svg> Apply</button>`
        }
        ${editable ? `
          <button class="btn viewUpdateBtn" data-vidx="${idx}" title="Update snapshot with current viewer state" style="padding:4px 8px;"><svg width="12" height="12" viewBox="0 0 12 12" style="vertical-align:middle;"><path d="M10 2.5A4.5 4.5 0 0 0 2.3 4" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/><path d="M2 9.5A4.5 4.5 0 0 0 9.7 8" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/><polyline points="10,0.5 10,3 7.5,3" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/><polyline points="2,11.5 2,9 4.5,9" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
        ` : ''}
      </div>
    </div>`;
  }).join('');

  body.classList.toggle('catEditActive', __viewEditIdx >= 0);

  //  Wire inline edit card 
  const editCard = body.querySelector('.catEditing');
  if(editCard){
    const labelInp = editCard.querySelector('[data-f="label"]');
    const emojiInp = editCard.querySelector('[data-f="emoji"]');
    const noteInp = editCard.querySelector('[data-f="note"]');
    const saveBtn = editCard.querySelector('[data-act="save"]');

    // Emoji picker
    const pickerToggle = editCard.querySelector('.veEmojiToggle');
    const pickerEl = editCard.querySelector('.veEmojiPicker');
    if(pickerToggle && pickerEl){
      pickerToggle.addEventListener('click', (e)=>{
        e.stopPropagation();
        pickerEl.style.display = pickerEl.style.display === 'none' ? 'flex' : 'none';
      });
      pickerEl.addEventListener('click', (e)=>{
        const opt = e.target.closest('[data-emoji]');
        if(!opt) return;
        e.stopPropagation();
        if(emojiInp) emojiInp.value = opt.dataset.emoji;
        if(saveBtn && saveBtn.__dirtyUpdate) saveBtn.__dirtyUpdate();
      });
    }

    // Enter/Escape on inputs
    [labelInp, noteInp].forEach(inp => {
      if(!inp) return;
      inp.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){ e.preventDefault(); if(saveBtn && !saveBtn.disabled) saveBtn.click(); }
        if(e.key === 'Escape'){ e.preventDefault(); editCard.querySelector('[data-act="cancel"]')?.click(); }
      });
    });

    requestAnimationFrame(()=> labelInp?.focus());

    // Save
    if(saveBtn) saveBtn.addEventListener('click', ()=>{
      const cat = ensureViewCatalog();
      const v = cat[__viewEditIdx];
      if(!v) return;
      const newLabel = (labelInp?.value||'').trim();
      if(!newLabel){ customAlert('Please enter a label.'); labelInp?.focus(); return; }
      const newEmoji = (emojiInp?.value||'').trim();
      const newNote = (noteInp?.value||'').trim();
      const wasNew = __viewIsNew;
      if(wasNew) cat.splice(__viewEditIdx, 1);
      pushUndo();
      if(wasNew) cat.splice(__viewEditIdx, 0, v);
      v.label = newLabel;
      v.emoji = newEmoji || '\uD83D\uDCCC';
      v.note = newNote;
      checkDirtyState();
      viewEditEnd();
      renderViewsManager();
      renderViewsQuickList();
      setGlobalStatus((wasNew ? 'Saved' : 'Updated') + ' view: ' + newLabel);
    });

    // Cancel  no guard, just abandon
    editCard.querySelector('[data-act="cancel"]')?.addEventListener('click', ()=>{
      if(__viewIsNew){
        const cat = ensureViewCatalog();
        if(__viewEditIdx >= 0 && __viewEditIdx < cat.length) cat.splice(__viewEditIdx, 1);
      }
      viewEditEnd();
      renderViewsManager();
    });

    // Delete
    editCard.querySelector('[data-act="del"]')?.addEventListener('click', async ()=>{
      const cat = ensureViewCatalog();
      const v = cat[__viewEditIdx];
      if(!v) return;
      if(!await customConfirm('Delete view \u201c' + (v.label||v.id) + '\u201d?')) return;
      pushUndo();
      cat.splice(__viewEditIdx, 1);
      if(__activeViewId === v.id){ __activeViewId = null; __activeViewStateJSON = null; }
      checkDirtyState();
      viewEditEnd();
      renderViewsManager();
      renderViewsQuickList();
    });

    // Dirty highlight
    wireDirtyHighlight(editCard, saveBtn, viewFormIsDirty, ()=> !!(labelInp?.value||'').trim());
  }

  //  Wire collapsed cards 
  body.querySelectorAll('.viewApplyBtn').forEach(btn => {
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const v = cat[Number(btn.dataset.vidx)];
      if(!v) return;
      // Deactivate if this view is already active
      if(v.id === __activeViewId){
        __activeViewId = null; __activeViewStateJSON = null;
        _syncViewNavButtons(); _updateViewPill();
        renderViewsManager();
        setGlobalStatus('View deactivated  current state kept');
        return;
      }
      _applyView(v);
      renderViewsManager();
    });
  });

  body.querySelectorAll('.viewUpdateBtn').forEach(btn => {
    btn.addEventListener('click', async (e)=>{
      e.stopPropagation();
      const v = cat[Number(btn.dataset.vidx)];
      if(!v) return;
      const ok = await customConfirm('Update \u201c' + (v.label||v.id) + '\u201d snapshot with the current viewer state?');
      if(!ok) return;
      pushUndo();
      v.state = captureViewState();
      checkDirtyState();
      renderViewsManager();
      setGlobalStatus('Updated view: ' + (v.label || v.id));
    });
  });

  // DnD reorder
  let __vDragIdx = null;
  let __vDragTime = 0;
  body.querySelectorAll('.catItem:not(.catEditing)').forEach(card => {
    if(!card.draggable) return;
    card.addEventListener('dragstart', (e)=>{
      __vDragIdx = Number(card.dataset.vidx);
      __vDragTime = Date.now();
      card.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    });
    card.addEventListener('dragend', ()=>{
      card.style.opacity = '';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      __vDragIdx = null;
    });
    card.addEventListener('dragover', (e)=>{
      e.preventDefault(); e.dataTransfer.dropEffect = 'move';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      card.classList.add('dragOver');
    });
    card.addEventListener('dragleave', ()=>{ card.classList.remove('dragOver'); });
    card.addEventListener('drop', (e)=>{
      e.preventDefault(); card.classList.remove('dragOver');
      const fromIdx = __vDragIdx;
      const toIdx = Number(card.dataset.vidx);
      if(fromIdx === null || fromIdx === toIdx) return;
      pushUndo();
      const [moved] = cat.splice(fromIdx, 1);
      cat.splice(toIdx, 0, moved);
      checkDirtyState();
      renderViewsManager();
      renderViewsQuickList();
    });
  });

  // Click-to-edit
  body.querySelectorAll('.catItem:not(.catEditing)').forEach(card => {
    card.addEventListener('click', async (e)=>{
      if(!state.editorMode) return;
      if(e.target.closest('.viewApplyBtn') || e.target.closest('.viewUpdateBtn')) return;
      if(Date.now() - __vDragTime < 300) return;
      const idx = Number(card.dataset.vidx);
      if(__viewEditIdx >= 0){
        if(!await guardViewAbandon()) return;
        viewEditEnd();
      }
      viewEditBegin(idx, false);
      renderViewsManager();
    });
  });
}

//  View pill (main screen indicator) 
function _updateViewPill(){
  const pill = document.getElementById('viewPill');
  if(!pill) return;
  const cat = ensureViewCatalog();
  const view = __activeViewId ? cat.find(v => v.id === __activeViewId) : null;
  if(!view){
    pill.style.display = 'none';
    return;
  }
  pill.style.display = 'inline-flex';
  const emojiEl = document.getElementById('viewPillEmoji');
  const labelEl = document.getElementById('viewPillLabel');
  if(emojiEl) emojiEl.textContent = view.emoji || '\uD83D\uDCCC';
  if(labelEl) labelEl.textContent = view.label || view.id;
  // Prev/Next button visibility
  const idx = cat.indexOf(view);
  const prevBtn = document.getElementById('viewPillPrev');
  const nextBtn = document.getElementById('viewPillNext');
  if(prevBtn){ prevBtn.disabled = idx <= 0; prevBtn.style.opacity = idx > 0 ? '' : '.3'; }
  if(nextBtn){ nextBtn.disabled = idx >= cat.length - 1; nextBtn.style.opacity = idx < cat.length - 1 ? '' : '.3'; }
  // Populate select dropdown
  const sel = document.getElementById('viewPillSelect');
  if(sel){
    sel.innerHTML = cat.map(v => `<option value="${escapeHtml(v.id)}"${v.id===__activeViewId?' selected':''}>${escapeHtml(_catalogItemLabel(v))}</option>`).join('');
  }
}

(function(){
  const prevBtn = document.getElementById('viewPillPrev');
  const nextBtn = document.getElementById('viewPillNext');
  const closeBtn = document.getElementById('viewPillClose');
  const sel = document.getElementById('viewPillSelect');
  if(prevBtn) prevBtn.addEventListener('click', ()=> document.getElementById('viewsRestorePrevBtn')?.click());
  if(nextBtn) nextBtn.addEventListener('click', ()=> document.getElementById('viewsNextBtn')?.click());
  if(closeBtn) closeBtn.addEventListener('click', ()=>{
    // Just clear tracking  don't change any state
    __activeViewId = null; __activeViewStateJSON = null;
    _syncViewNavButtons(); _updateViewPill();
    setGlobalStatus('View deactivated  current state kept');
  });
  if(sel) sel.addEventListener('change', ()=>{
    const cat = ensureViewCatalog();
    const view = cat.find(v => v.id === sel.value);
    if(view) _applyView(view);
  });
})();

//  Reset view 
function resetViewState(){
  if(!state.data) return;
  state.activeFilterIds = [];
  state.filterMode = 'hide';
  state.filterLogic = 'or';
  state.onlyMapped = false;
  state.search = '';
  state.lockedId = null; state.hoverId = null;
  state.selectedEdgeId = null; state.hoverEdgeId = null;
  state.selectedColumnId = null;
  state.multiSelection = new Set();
  state.arrowsOn = true; state.allArrows = false;
  state.showSameColumn = true; state.showDistant = true;
  state.multiSelectArrowMode = 'chain';
  state.selectionDim = 'all';
  state.edgeColorScheme = '';
  state.nodeColorMode = 'all';
  state.tagPillsMode = 'left';
  state.attrPillsMode = 'left';
  state.hiddenColumns = new Set();
  __editSnapshot = null;
  __activeViewId = null; __activeViewStateJSON = null;

  // Sync UI controls
  const searchInput = document.getElementById('searchInput');
  if(searchInput) searchInput.value = '';
  const onlyMappedToggle = document.getElementById('onlyMappedToggle');
  if(onlyMappedToggle) onlyMappedToggle.checked = false;
  if(typeof updateFilterModeUI === 'function') updateFilterModeUI();
  if(typeof updateFilterLogicUI === 'function') updateFilterLogicUI();
  if(typeof renderActiveFilterChips === 'function') renderActiveFilterChips();
  if(typeof updateFilterBadge === 'function') updateFilterBadge();
  const filterBar = document.getElementById('tbFilterBar');
  if(filterBar) filterBar.style.display = 'none';
  if(typeof updateArrowModeUI === 'function') updateArrowModeUI();
  const svgOverlay = document.getElementById('svgOverlay');
  if(svgOverlay) svgOverlay.style.display = 'block';
  const showSameColToggle = document.getElementById('showSameColToggle');
  const showDistantToggle = document.getElementById('showDistantToggle');
  if(showSameColToggle) showSameColToggle.checked = true;
  if(showDistantToggle) showDistantToggle.checked = true;
  const dimSelector = document.getElementById('dimModeSelector');
  if(dimSelector) dimSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.dim === 'all'));
  const multiArrowSel = document.getElementById('multiArrowModeSelector');
  if(multiArrowSel) multiArrowSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.mode === 'chain'));
  const edgeColorSel = document.getElementById('edgeColorSelector');
  if(edgeColorSel) edgeColorSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.scheme === ''));
  const ncmSelector = document.getElementById('nodeColorModeSelector');
  if(ncmSelector) ncmSelector.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.ncm === 'all'));
  const tagPillsSel = document.getElementById('tagPillsModeSelector');
  if(tagPillsSel) tagPillsSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.tpm === 'left'));
  const attrPillsSel = document.getElementById('attrPillsModeSelector');
  if(attrPillsSel) attrPillsSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b.dataset.apm === 'left'));

  // Expand all collapsed groups
  renderAll();
  if(IDX && IDX.elementById){
    for(const [id, el] of IDX.elementById.entries()){
      if(el.classList.contains('group') && el.classList.contains('collapsed')){
        el.classList.remove('collapsed');
        const ch = el.querySelector(':scope > .children');
        if(ch) ch.style.display = '';
      }
    }
  }
  refreshViewer();
  refreshEdgeColorScheme();
  scheduleArrowsUpdate();
  _syncViewNavButtons(); _updateViewPill();
  setGlobalStatus('View reset to defaults');
}

document.getElementById('viewsResetBtn')?.addEventListener('click', ()=>{
  resetViewState();
  const pop = document.getElementById('tbPopViews');
  if(pop) pop.classList.remove('open');
});
document.getElementById('resetViewBtn')?.addEventListener('click', ()=>{
  resetViewState();
});

// Ctrl+Alt+0  Reset view
document.addEventListener('keydown', (e)=>{
  if((e.ctrlKey || e.metaKey) && e.altKey && !e.shiftKey && e.key === '0'){
    e.preventDefault();
    resetViewState();
  }
});

// Ctrl+Alt+S  Save current view (use e.code for Mac Option key compat)
document.addEventListener('keydown', (e)=>{
  if((e.ctrlKey || e.metaKey) && e.altKey && !e.shiftKey && e.code === 'KeyS'){
    e.preventDefault();
    document.getElementById('viewsSaveCurrentBtn')?.click();
  }
});

//  Keyboard shortcuts modal 
function openKbdShortcuts(){
  const body = document.getElementById('kbdShortcutsBody');
  if(!body) return;
  const isMac = _isMac;
  const mod = isMac ? '\u2318' : 'Ctrl';
  const alt = isMac ? '\u2325' : 'Alt';
  const del = isMac ? '\u232B' : 'Delete';
  const sections = [
    { title: 'Navigation', shortcuts: [
      ['\u2191 / \u2193', 'Move selection up / down in tree'],
      ['Space', 'Collapse / expand selected group(s)'],
    ]},
    { title: 'Selection  keyboard', shortcuts: [
      ['Shift+\u2191 / Shift+\u2193', 'Extend multi-selection up / down'],
      [mod+'+A', 'Select all visible nodes'],
      [mod+'+Shift+I', 'Invert selection'],
      ['Esc', 'Clear selection / close popover'],
    ]},
    { title: 'Selection  click modifiers', shortcuts: [
      [mod+'+Click', 'Toggle node in multi-selection'],
      ['Shift+Click', 'Range select within same column'],
      [alt+'+Click', 'Chain select (full chain, both directions)'],
      [alt+'+Shift+Click', 'Chain select upstream only (all sources)'],
      [alt+'+'+mod+'+Click', 'Chain select downstream only (all targets)'],
      ['Right-click node', 'Open context menu (Editor mode)'],
    ]},
    { title: 'Selection  edge click modifiers', shortcuts: [
      ['Click edge', 'Select edge (both endpoints highlighted)'],
      [mod+'+Click edge', 'Add edge endpoints to multi-selection'],
      [alt+'+Click edge', 'Chain select from edge endpoints (both directions)'],
      [alt+'+Shift+Click edge', 'Chain select upstream from edge'],
      [alt+'+'+mod+'+Click edge', 'Chain select downstream from edge'],
    ]},
    { title: 'Selection  marquee & lasso', shortcuts: [
      ['Drag on empty space', 'Rectangle marquee select (replaces selection)'],
      [alt+'+Drag on empty', 'Freeform lasso select (replaces selection)'],
      ['Shift+Drag / '+alt+'+Shift+Drag', 'Add to selection (marquee / lasso)'],
      [mod+'+Drag / '+alt+'+'+mod+'+Drag', 'Subtract from selection (marquee / lasso)'],
    ]},
    { title: 'Drag-and-drop modifiers (Editor)', shortcuts: [
      ['Drag (no modifier)', 'Move node to new position'],
      [alt+'+Drag', 'Map  create forward mapping'],
      [alt+'+Shift+Drag', 'Map   create bidirectional mapping'],
      [alt+'+Shift+'+mod+'+Drag', 'Map   create directionless link'],
      [mod+'+Drag', 'Copy  duplicate node at drop position'],
      [mod+'+'+alt+'+Drag', 'Copy+  copy node with its mappings'],
    ]},
    { title: 'Editing (Editor mode)', shortcuts: [
      [mod+'+\u2193 / '+mod+'+\u2191', 'Quick-create field below / above'],
      [mod+'+'+alt+'+\u2193 / '+mod+'+'+alt+'+\u2191', 'Quick-create group below / above'],
      [mod+'+\u2192', 'Add child field to selected group'],
      [alt+'+\u2191 / '+alt+'+\u2193', 'Move node(s) up / down'],
      [alt+'+\u2192 / '+alt+'+\u2190', 'Indent / outdent node(s)'],
      ['Tab / Shift+Tab', 'Indent / outdent (alternative)'],
      [mod+'+C / '+mod+'+V', 'Copy / paste node(s)'],
      [mod+'+D', 'Duplicate node(s)'],
      [mod+'+G', 'Group selected siblings'],
      [mod+'+Shift+G', 'Ungroup (dissolve group)'],
      ['F2 / Enter', 'Start inline rename / focus details editor'],
      [del, 'Delete selected node(s)'],
    ]},
    { title: 'Views', shortcuts: [
      [mod+'+'+alt+'+S', 'Save current view'],
      [',', 'Previous view'],
      ['.', 'Next view'],
      [mod+'+'+alt+'+0', 'Reset view to defaults'],
    ]},
    { title: 'Project', shortcuts: [
      [alt+'+N', 'New project'],
      [alt+'+O', 'Open project'],
      [alt+'+S', 'Save project'],
      [alt+'+E', 'Toggle editor mode'],
    ]},
    { title: 'Global', shortcuts: [
      [mod+'+K', 'Open command palette'],
      [mod+'+Z', 'Undo'],
      [mod+'+Shift+Z / '+mod+'+Y', 'Redo'],
      ['?', 'Open quick start guide'],
      ['P', 'Toggle pan mode'],
      ['D', 'Toggle details panel'],
    ]},
  ];
  body.innerHTML = sections.map(s => `
    <div style="margin-bottom:16px;">
      <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:.5px;opacity:.5;margin-bottom:6px;">${s.title}</div>
      ${s.shortcuts.map(([key, desc]) => `
        <div style="display:flex;align-items:center;gap:10px;padding:4px 0;font-size:13px;">
          <kbd style="font-family:var(--mono);font-size:11px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.1);border-radius:4px;padding:2px 7px;min-width:80px;text-align:center;white-space:nowrap;">${key}</kbd>
          <span style="opacity:.8;">${desc}</span>
        </div>
      `).join('')}
    </div>
  `).join('');

  document.getElementById('kbdShortcutsMask')?.classList.add('active');
  document.getElementById('kbdShortcutsModal')?.classList.add('active');
}
(function(){
  const mask = document.getElementById('kbdShortcutsMask');
  const modal = document.getElementById('kbdShortcutsModal');
  const closeBtn = document.getElementById('kbdShortcutsClose');
  const openBtn = document.getElementById('kbdShortcutsBtn');
  function close(){ mask?.classList.remove('active'); modal?.classList.remove('active'); }
  if(closeBtn) closeBtn.addEventListener('click', close);
  if(mask) mask.addEventListener('click', close);
  if(openBtn) openBtn.addEventListener('click', openKbdShortcuts);
})();

(function(){
  const widthSlider = document.getElementById('colWidthSlider');
  const widthVal = document.getElementById('colWidthVal');
  const gapSlider = document.getElementById('colGapSlider');
  const gapVal = document.getElementById('colGapVal');
  
  // Restore from localStorage
  try {
    const savedW = localStorage.getItem('ms_colWidth');
    const savedG = localStorage.getItem('ms_colGap');
    if(savedW){ widthSlider.value = savedW; widthVal.textContent = savedW; columnsRow.style.setProperty('--col-width', savedW + 'px'); }
    if(savedG){ gapSlider.value = savedG; gapVal.textContent = savedG; columnsRow.style.setProperty('--col-gap', savedG + 'px'); }
  } catch(e){}
  
  function applyWidth(v){
    columnsRow.style.setProperty('--col-width', v + 'px');
    widthVal.textContent = v;
    // Recalc min-width for scroll
    const visibleCols = IDX.columns.filter(c => !state.hiddenColumns.has(c.id));
    const minW = state.wrapColumns ? 0 : Math.max(920, visibleCols.length * (parseInt(v) + 20));
    columnsRow.style.minWidth = minW + 'px';
    try { localStorage.setItem('ms_colWidth', v); } catch(e){}
    scheduleArrowsUpdate();
  }
  function applyGap(v){
    columnsRow.style.setProperty('--col-gap', v + 'px');
    gapVal.textContent = v;
    try { localStorage.setItem('ms_colGap', v); } catch(e){}
    scheduleArrowsUpdate();
  }
  if(widthSlider){ widthSlider.addEventListener('input', ()=> applyWidth(widthSlider.value)); }
  if(gapSlider){ gapSlider.addEventListener('input', ()=> applyGap(gapSlider.value)); }

  // Inline reset buttons per slider
  const widthResetBtn = document.getElementById('colWidthReset');
  const gapResetBtn = document.getElementById('colGapReset');
  if(widthResetBtn){
    widthResetBtn.addEventListener('click', ()=>{
      if(widthSlider){ widthSlider.value = 300; applyWidth(300); }
    });
  }
  if(gapResetBtn){
    gapResetBtn.addEventListener('click', ()=>{
      if(gapSlider){ gapSlider.value = 20; applyGap(20); }
    });
  }

  // Zoom / density slider
  const zoomSlider = document.getElementById('colZoomSlider');
  const zoomVal = document.getElementById('colZoomVal');
  const zoomResetBtn = document.getElementById('colZoomReset');
  function applyZoom(v){
    const pct = Number(v);
    columnsScroller.style.zoom = (pct / 100);
    zoomVal.textContent = pct + '%';
    try { localStorage.setItem('ms_colZoom', v); } catch(e){}
    scheduleArrowsUpdate();
  }
  try {
    const savedZ = localStorage.getItem('ms_colZoom');
    if(savedZ){ zoomSlider.value = savedZ; applyZoom(savedZ); }
  } catch(e){}
  if(zoomSlider){ zoomSlider.addEventListener('input', ()=> applyZoom(zoomSlider.value)); }
  if(zoomResetBtn){
    zoomResetBtn.addEventListener('click', ()=>{
      if(zoomSlider){ zoomSlider.value = 100; applyZoom(100); }
    });
  }
})();

if(columnsBtn) columnsBtn.addEventListener("click", () => {
  buildColumnsMenu();
  togglePopover(!columnsPopover.classList.contains('active'));
});
if(closeColumnsBtn) closeColumnsBtn.addEventListener("click", () => togglePopover(false));
if(showAllColsBtn) showAllColsBtn.addEventListener("click", () => {
  state.hiddenColumns.clear();
  renderAll();
  buildColumnsMenu();
  togglePopover(true);
});
if(hideUnmappedColsBtn) hideUnmappedColsBtn.addEventListener("click", () => {
  hideUnmappedColumns();
  buildColumnsMenu();
  togglePopover(true);
});
document.addEventListener('click', (e) => {
  if(!columnsPopover.classList.contains('active')) return;
  const t = e.target;
  if(t === columnsBtn || t === showAllColumnsBtn || columnsPopover.contains(t)) return;
  // Don't close popover when interacting with modals/dialogs layered on top
  if(t.closest('.modal') || t.closest('.modalMask')) return;
  togglePopover(false);
});

function downloadText(name, mime, content){
  const blob = new Blob([content], {type: mime});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 600);
}
function csvEscape(v){
  const s = (v===null||v===undefined) ? '' : String(v);
  if(/[\n\r,\"]/g.test(s)) return '"' + s.replace(/\"/g,'""') + '"';
  return s;
}
if(exportCsvBtn) exportCsvBtn.addEventListener('click', () => {
  if(!state.data) return;
  const rows = [];
  rows.push(['from','to','fromColumn','toColumn','cardinality','default','transforms','note','direction'].join(','));
  for(const e of IDX.edges){
    if(!isVisibleNodeId(e.from) || !isVisibleNodeId(e.to)) continue;
    if(!edgeScopeVisible(e.from, e.to)) continue;
    rows.push([
      csvEscape(e.from), csvEscape(e.to),
      csvEscape(columnOf(e.from)||''), csvEscape(columnOf(e.to)||''),
      csvEscape(e.cardinality||''),
      csvEscape(e.default||''),
      csvEscape(formatTransform(e.transform)||''),
csvEscape(e.note||''),
csvEscape(e.direction||'forward')
    ].join(','));
  }
  downloadText('mappings.csv', 'text/csv;charset=utf-8', rows.join('\n'));
  setGlobalStatus('Exported CSV for currently visible mappings.');
});


if(exportReportBtn) exportReportBtn.addEventListener('click', () => {
  if(!state.data) return;
  const now = new Date().toISOString();
  const summary = `Columns: ${IDX.columns.length}  Fields: ${IDX.fieldIds.size}  Edges: ${IDX.edges.length}`;
  const edgeRows = [];
  for(const e of IDX.edges){
    if(!isVisibleNodeId(e.from) || !isVisibleNodeId(e.to)) continue;
    edgeRows.push(`<tr><td><code>${escapeHtml(e.from)}</code></td><td></td><td><code>${escapeHtml(e.to)}</code></td>`+
      `<td>${escapeHtml(e.cardinality||'')}</td><td>${escapeHtml(e.default||'')}</td>`+
      `<td>${escapeHtml(short(formatTransform(e.transform)||'', 80))}</td>`+
      `<td>${escapeHtml(short(e.note||'', 120))}</td></tr>`);
  }
  const html = `<!doctype html><html><head><meta charset='utf-8'/><meta name='viewport' content='width=device-width,initial-scale=1'/>`+
  `<title>Dunnode Report</title><style>body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:20px;color:#111}`+
  `h1{margin:0 0 6px 0} .muted{color:#555} table{border-collapse:collapse;width:100%;margin-top:14px}`+
  `th,td{border:1px solid #ddd;padding:8px;vertical-align:top;font-size:12px}`+
  `th{background:#f6f6f6;text-align:left} code{font-family:ui-monospace,Consolas,monospace;font-size:11px}`+
  `
/* --- Inline Editor Mode (2026-02) --- */
#editorOverlay{position:absolute; inset:0; z-index:30; pointer-events:none;}
body.editorMode #editorOverlay{pointer-events:none;}






/* Row hover actions */
.row .rowActions{margin-left:8px; display:flex; gap:6px; align-items:center; opacity:0; transition: opacity .12s ease;}
body.editorMode .row:hover .rowActions{opacity:1;}
body.editorMode .row.menuOpen .rowActions{display:flex !important; opacity:1 !important; pointer-events:auto !important;}
body.editorMode .active > .row .rowActions{display:flex !important; opacity:1 !important; pointer-events:auto !important;}
.miniBtn{border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.14); color: rgba(232,238,252,.92);
  width:24px; height:24px; border-radius:10px; cursor:pointer; font-weight:900; font-size:13px; line-height:1;
  display:flex; align-items:center; justify-content:center;}
.miniBtn:hover{background: rgba(255,255,255,.08);}
.miniBtn.danger{border-color: rgba(255,154,168,.38); background: rgba(255,154,168,.10);}
.miniBtn.danger:hover{background: rgba(255,154,168,.18);}

/* Tag chips (replace field/group badges) */
.tagStrip{display:flex;gap:6px;align-items:center;flex:0 0 auto;}
.tagChip{font-family: var(--mono); font-size: 10px; padding:2px 6px; border-radius:999px; border:1px solid rgba(59,130,246,.55); background: rgba(59,130,246,.18); color: rgba(232,238,252,.95); line-height:1;}
.tagChip[data-color]{border-color: color-mix(in srgb, var(--c) 70%, rgba(255,255,255,.12)); background: color-mix(in srgb, var(--c) 22%, transparent);}
/* Inline action menu */
.miniMenu{position:absolute; right: 6px; top: 30px; z-index: 999; border:1px solid rgba(255,255,255,.14); border-radius: 12px; background: rgba(11,16,32,.95); box-shadow: 0 18px 50px rgba(0,0,0,.45); padding: 6px; display:none; gap:6px;}
.miniMenu.active{display:flex;}
.miniMenu .miniBtn{width:auto;padding:6px 8px;border-radius:10px;}
/* Hover menus */

/* Tag create swatches */
.swatch{width:22px;height:22px;border-radius:8px;border:1px solid rgba(255,255,255,.18);cursor:pointer;box-shadow:0 10px 24px rgba(0,0,0,.25);}
.swatch:hover{transform: translateY(-1px);}
.swatch.sel{outline:2px solid rgba(255,255,255,.60); outline-offset:2px;}



/* Drag & drop */
body.editorMode .node.field .row{cursor: grab;}
body.editorMode .node.field .row:active{cursor: grabbing;}
.row.dropTarget{outline: 2px solid rgba(59,130,246,.80); background: rgba(59,130,246,.12);}
.row.illegal{cursor:not-allowed !important;}

/* Make SVG clickable in editor mode */
#svgOverlay{pointer-events:none;}
body.editorMode #svgOverlay{pointer-events:none;}
body.editorMode .edge{

 stroke-linecap: round;
 stroke-linejoin: round;pointer-events:none;}
body.editorMode .edge.selected{stroke: rgba(255,208,92,.98); stroke-width: 3.0;}



/* --- Mapping list hard overrides (v6_5): force field label on its own line --- */
.detailsBody .item{flex-wrap:wrap !important; align-items:flex-start !important;}
.detailsBody .item > .txt{flex: 1 1 100% !important; width:100% !important; display:block !important; margin-top:2px !important; font-weight:800;}
.detailsBody .item .itemActions{margin-left:auto !important;}
.detailsBody .item .pill, .detailsBody .item .tag{flex: 0 0 auto;}

.box.clickable{cursor:pointer;}
.box.clickable:hover{background: rgba(255,255,255,.06);}
body.brightMode .box.clickable:hover{background: rgba(0,0,0,.05);}

/* --- Drag ghost (visual-only) --- */
#dragGhost{
  position:fixed; z-index:3000; pointer-events:none; display:none;
  background:rgba(11,16,32,.96);
  border:1px solid rgba(255,255,255,.14);
  border-radius:10px; padding:6px 8px; color:#e8eefc;
  font:12px var(--sans); box-shadow:0 12px 32px rgba(0,0,0,.45);
  max-width:480px; opacity:.98;
}
#dragGhost .top {display:flex; align-items:center; gap:8px; margin-bottom:6px;}
#dragGhost .chip {
  font-family: var(--mono, ui-monospace, Consolas, monospace);
  font-size:10px; padding:2px 6px; border-radius:999px;
  border:1px solid rgba(255,255,255,.22); line-height:1;
  background:rgba(255,255,255,.06);
}
#dragGhost .chip.move { border-color:#3b82f6; background:rgba(59,130,246,.20); color:#fff; }
#dragGhost .chip.copy { border-color:#22c55e; background:rgba(34,197,94,.18); color:#fff; }
#dragGhost .chip.copyPlus { border-color:#84cc16; background:rgba(132,204,22,.20); color:#fff; }
#dragGhost .chip.map  { border-color:#f59e0b; background:rgba(245,158,11,.18); color:#fff; }
#dragGhost .chip.mapBidi { border-color:#a78bfa; background:rgba(167,139,250,.20); color:#e0d4ff; }
#dragGhost .chip.mapNone { border-color:#94a3b8; background:rgba(148,163,184,.18); color:#cbd5e1; }
#dragGhost .label { font-weight:900; letter-spacing:.2px; }
#dragGhost .body  { opacity:.92; }
#dragGhost .multiBadge {
  font-family: var(--mono, ui-monospace, Consolas, monospace);
  font-size:10px; font-weight:800; padding:2px 5px; border-radius:999px;
  background:rgba(255,255,255,.12); color:rgba(255,255,255,.85);
  line-height:1; display:none;
}


/* === Empty-column drop placeholder (v20.5) === */
body.editorMode .panel[data-empty="1"].dropOpen .emptyDrop { display: block; }
.emptyDrop { display: none;
  margin: 10px; border: 2px dashed rgba(59,130,246,.55); border-radius: 10px;
  padding: 12px 10px; color: rgba(232,238,252,.88); background: rgba(59,130,246,.08);
  font-size: 12px; text-align: center; user-select: none;
}
.emptyDrop.copy { border-color:#22c55e; background: rgba(34,197,94,.10); }
.emptyDrop.move { border-color:#3b82f6; background: rgba(59,130,246,.10); }


/* --- v23 header polish --- */
.brand .logo{filter:drop-shadow(0 2px 6px rgba(0,0,0,.25));}
.modeToggle.prominent{border-color: rgba(255,208,92,.55); background: rgba(255,208,92,.16);} 
.modeToggle.prominent:hover{background: rgba(255,208,92,.22);} 
.modeToggle.prominent input{accent-color:#f59e0b;}


/* v23.2.1: keep title visible when header wraps */
.brand{flex:1 1 260px; min-width:260px;}
.brand h1{display:block; max-width:48vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}


/* v23.2.2: ensure brand title remains visible */
.brand{flex:1 1 280px; min-width:260px}
.brand h1{display:block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:55vw}


/* v23.2.3b: ensure quick toolbar is visible and spaced */
#toolbarQuick{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 2px 0}
#toolbarQuick .btn{font-weight:700}

</style></head><body>`+
  `<h1>Dunnode  Exported report</h1><div class='muted'>Generated ${now}</div>`+
  `<div class='muted'>${escapeHtml(summary)}</div>`+
  `<h2>Mappings (visible in viewer at export time)</h2>`+
  `<table><thead><tr><th>From</th><th></th><th>To</th><th>Card</th><th>Default</th><th>Transforms</th><th>Note</th></tr></thead>`+
  `<tbody>${edgeRows.join('\n')}</tbody></table>`+
  `<h2>Embedded JSON</h2><pre><code>${escapeHtml(JSON.stringify(state.data, null, 2))}</code></pre>`+
  `</body></html>`;
  downloadText('mapping-report.html', 'text/html;charset=utf-8', html);
  setGlobalStatus('Exported HTML report.');
});

function openHelp(){
  helpBody.innerHTML = `
<div style="text-align:center;padding:18px 0 20px;margin-bottom:16px;border-bottom:1px solid var(--border);">
<div style="font-size:20px;font-weight:800;letter-spacing:1.2px;text-transform:uppercase;">Dunnode</div>
<div style="font-size:12px;font-weight:600;opacity:.5;letter-spacing:.4px;margin-top:2px;">Done. Now.</div>
<div style="font-size:11.5px;opacity:.45;margin-top:6px;">A lightweight mapping studio for complex flows.</div>
</div>
<h4 style="margin:0 0 6px;">1. Load data</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Load example</b> &mdash; try the built-in sample project to explore features.</li>
  <li><b>Open project</b> &mdash; load your own <code>.json</code> file.</li>
  <li><b>New project</b> &mdash; start with a blank two-column layout.</li>
</ul>

<h4 style="margin:14px 0 6px;">2. Explore mappings</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Hover</b> any field to see its mapping chain highlighted across all columns.</li>
  <li><b>Click</b> a field to lock the selection &mdash; scroll freely while connections stay visible.</li>
  <li><b>Click a mapping line</b> to inspect a specific mapping (cardinality, transforms, notes).</li>
  <li><b>Multi-select</b>: Ctrl/Cmd+click to toggle nodes. Shift+click for range within a column. Alt+click for chain select (Alt+Shift=upstream, Alt+Ctrl=downstream). Drag on empty space for marquee select (Shift=add, Ctrl/Cmd=subtract). Alt+drag for freeform lasso.</li>
  <li><b>Esc</b> clears selection and search.</li>
</ul>

<h4 style="margin:14px 0 6px;">3. Edit your model</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li>Toggle <b>Editor mode</b> (top-right) to unlock editing.</li>
  <li><b>Add nodes</b>: hover a row to reveal  (add child) and  (context menu) buttons. You can also <b>right-click</b> any node to open the context menu.</li>
  <li><b>Quick-create (keyboard)</b>: select a node and press <b>Ctrl+</b> (Cmd+) to insert a field below with inline rename. Type a label and press Enter, or press Ctrl+ again to rapid-fire more fields. <b>Ctrl+Alt+</b> for groups, <b>Ctrl+</b> for child nodes.</li>
  <li><b>Navigate</b>: <b>/</b> arrows move selection between nodes. <b>Shift+/</b> extends multi-selection. <b>Enter</b> focuses the label editor.</li>
  <li><b>Rearrange</b>: <b>Alt+/</b> moves node(s) up/down. <b>Alt+</b> indents (into sibling group above), <b>Alt+</b> outdents. All work on multi-selections of siblings.</li>
  <li><b>Clipboard</b>: <b>Ctrl+C/V</b> copy &amp; paste nodes (with mappings). <b>Ctrl+D</b> duplicates in-place. <b>Ctrl+G</b> wraps selection in a new group, <b>Ctrl+Shift+G</b> dissolves a group.</li>
  <li><b>Convert type</b>: right-click context menu () to convert a field to group or vice versa.</li>
  <li><b>Create mappings</b>: drag a field onto a field in another column.</li>
  <li><b>Edit properties</b>: click any field/mapping and use the Details pane on the right.</li>
  <li><b>Drag-and-drop</b>: reorder, move, copy, or map nodes using modifier keys:</li>
  <li style="list-style:none;margin-left:4px;font-size:11.5px;line-height:1.5;opacity:.85;">
    No modifier = Move &nbsp;&nbsp; Alt/Opt = Map &nbsp;&nbsp; Ctrl/Cmd = Copy &nbsp;&nbsp; Ctrl/Cmd+Alt/Opt = Copy with mappings &nbsp;&nbsp; Alt+Shift = Map  (bidirectional) &nbsp;&nbsp; Alt+Shift+Ctrl/Cmd = Map  (directionless)
  </li>
  <li><b>Multi-select drag</b>: with multiple nodes selected, drag any selected node to bulk Move, Copy, Copy+, or Map all selected nodes at once. Children of selected groups are automatically deduplicated.</li>
  <li><b>Ctrl+Z / Ctrl+Y</b> (Cmd on Mac) to undo and redo any change.</li>
  <li><b>Ctrl+A</b> (Cmd+A) &mdash; select all visible nodes. <b>Ctrl+Shift+I</b> (Cmd+Shift+I) &mdash; invert selection. Also in the Selection menu.</li>
  <li><b>Ctrl+K</b> (Cmd+K) &mdash; command palette: search all commands, jump to any node by name, or search the documentation.</li>
  <li><b>D</b> &mdash; toggle details panel. <b>P</b> &mdash; pan mode (drag to scroll). <b>Esc</b> &mdash; clear selection.</li>
  <li><b>Viewer toolbar</b>: icon buttons above the columns for pan mode, clear selection, and reset view.</li>
</ul>

<h4 style="margin:14px 0 6px;">4. Filter &amp; highlight</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li>Click the <b>Filter</b> toolbar button to open the filter bar &mdash; type to search nodes, toggle <b>Only mapped</b> to focus.</li>
  <li>Open the <b>Filters</b> catalog (from Catalogs menu) to create rule-based filters with colored highlights.</li>
  <li>Toggle active filters via checkboxes &mdash; chips appear in the filter bar.</li>
  <li><b>Display mode</b> (<b>Hide</b> / <b>Dim</b> / <b>Highlight</b>) &mdash; segmented selector controls how non-matching nodes appear.</li>
  <li><b>AND / OR</b> &mdash; segmented selector controls whether nodes must match ALL or ANY active filter. Search is always ANDed with filters.</li>
</ul>

<h4 style="margin:14px 0 6px;">5. Organize with catalogs</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Tags</b> &mdash; colored labels for nodes, mappings, and catalog items (e.g. Active, Draft, Retired). Assign emoji and choose Abbr/Emoji display mode. Drag to set priority order. Mark a tag as <b>Meta only</b> to use it purely as a category grouping header &mdash; it won&rsquo;t appear in node/mapping selectors but will group child tags, attributes, and transforms into labeled sections in their dropdowns.</li>
  <li><b>Transforms</b> &mdash; reusable data conversion steps attached to mappings (e.g. Trim, Uppercase). Supports per-instance parameters and emoji display.</li>
  <li><b>Custom attributes</b> &mdash; domain metadata on nodes and edges (e.g. Data Type, Sensitivity). Each attribute can have its own <b>color</b> (inherited by values without their own). Each value has a color with an <b>Apply</b> checkbox. Enable "Display on node" per attribute to show value pills on tree nodes. Inline value creation with drag-and-drop reordering.</li>
  <li><b>Filters</b> &mdash; rule-based visual highlights (see section 4 above). Also managed from the Catalogs toolbar menu.</li>
  <li><b>Views</b> &mdash; saved snapshots of the viewer state (filters, selection, mapping visibility, collapsed groups, hidden columns, mapping labels, display settings). Click <b>Views</b> in the toolbar to apply a saved view with one click. <b>Save current view</b> (<b>Ctrl+Alt+S</b>) bookmarks the current state. <b>,</b> / <b>.</b> navigate between views. <b>Reset view</b> (<b>Ctrl+Alt+0</b>) returns to clean defaults. A <b>view pill</b> indicator appears in the viewer header when a view is active.</li>
  <li><b>Inline editing</b> &mdash; click <b>Add</b> to create items directly inside the catalog list. Click any existing item to edit it in place. When creating a node, selecting "+ New tag" or "+ New attribute" opens a nested create modal &mdash; the node form is saved and restored automatically.</li>
  <li><b>Catalog import</b> &mdash; use the <b>Import</b> button inside any catalog modal or the Import toolbar menu to paste multiple tags, attributes (with values), or transforms at once. Supports plain text and tab-separated data. Upload a <code>.csv</code> / <code>.tsv</code> file as an alternative. Each import modal includes domain presets for one-click fills.</li>
  <li><b>Preset bundles</b> &mdash; use <b>Catalogs &rarr; Load preset bundle</b> to populate all three catalogs (tags, attributes, transforms) for a domain in one click. Four built-in bundles: Database, API/JSON, Data Governance, ETL/Integration.</li>
  <li><b>Auto-ID &amp; abbreviation</b> &mdash; ID and abbreviation auto-generate from the label as you type. A blue <b style="font-size:9px;padding:1px 4px;border-radius:4px;background:rgba(59,130,246,.15);color:rgba(130,180,255,.8);">auto</b> badge shows when a field is linked. Edit the field to override; clear it to re-link.</li>
  <li><b>Save / Cancel / Delete</b> &mdash; Save activates when you make changes. Label is required (marked with <span style="color:rgba(239,130,130,.7);font-weight:700;">*</span>) &mdash; Save stays disabled until a label is entered. New items have no Delete button.</li>
</ul>

<h4 style="margin:14px 0 6px;">6. Save &amp; share</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>New project</b> (<b>Alt+N</b>) &mdash; start blank. <b>Open project</b> (<b>Alt+O</b>) &mdash; load a JSON file.</li>
  <li><b>Save project</b> (<b>Alt+S</b>) &mdash; downloads your complete project as JSON. Blue button = unsaved changes.</li>
  <li><b>Editor mode</b> (<b>Alt+E</b>) &mdash; toggle inline editing on/off.</li>
  <li><b>Export CSV</b> &mdash; all visible mappings as a spreadsheet-ready file.</li>
  <li><b>Export report</b> &mdash; standalone HTML snapshot for stakeholders.</li>
  <li><b>Import</b> &mdash; toolbar menu to import fields into a column, create columns from text, or merge data from another Dunnode project file.</li>
</ul>

<h4 style="margin:14px 0 6px;">Useful tips</h4>
<ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.6">
  <li><b>Columns</b> &mdash; hide/show/reorder columns. Hide unused ones to reduce noise.</li>
  <li><b>Only mapped</b> &mdash; filter to fields that have mappings.</li>
  <li><b>Mapping visibility</b> &mdash; <b>Selected</b> (only hovered/selected), <b>All</b> (every mapping line), or <b>Off</b>.</li>
  <li><b>Mapping scope</b> &mdash; toggle same-column and distant mappings independently.</li>
  <li><b>Mapping labels</b> &mdash; add labels to mappings that render on the mapping line. Control visibility in Graph menu: <b>Always</b>, <b>Highlight</b> (only when connected to selection), or <b>Off</b>.</li>
  <li><b>Import fields</b> &mdash; paste dozens of fields at once from the column context menu ( &rarr; Import fields) or the Import toolbar menu. Supports plain text (one per line, indentation = nesting) and tab-separated data from spreadsheets.</li>
  <li><b>Import columns</b> &mdash; create multiple columns with fields in one go (Import &rarr; Import columns). Plain text: separate columns with blank lines. Tab-separated: use a <code>column</code> header to group rows into columns, with optional <code>parent</code>, <code>note</code>, <code>type</code> columns.</li>
  <li><b>Import from project</b> &mdash; merge columns and catalog items from another Dunnode JSON file (Import &rarr; Import from project). Cherry-pick which columns, tags, attributes, and transforms to bring in.</li>
  <li><b>Import SQL/DDL</b> &mdash; paste or upload SQL <code>CREATE TABLE</code> statements. Tables become columns, SQL columns become fields with auto-detected data types, keys, and constraints.</li>
  <li><b>Import CSV/TSV file</b> &mdash; upload a spreadsheet file and map its columns to roles (label, parent, note, tag, or attribute) with an interactive UI.</li>
  <li><b>Import mappings</b> &mdash; paste or upload a mapping table (source/target pairs) to create mappings between existing fields. Fields are resolved by ID, column.label, or label. Round-trips with CSV export.</li>
  <li><b> button</b> &mdash; edit project properties (title, author, description, etc.).</li>
  <li><b>Bright mode</b> &mdash; toggle light/dark theme.</li>
  <li><b>Unsaved changes</b> &mdash; Save buttons turn <span style="color:#f59e0b;font-weight:700;">yellow</span> when there are pending changes. Navigating away from unsaved edits prompts a confirmation.</li>
  <li><b>Dim others</b> (Selection menu) &mdash; choose how unselected nodes dim: <b>All</b>, <b>Parents</b> (keep groups visible), or <b>Off</b>.</li>
  <li><b>Highlight mode</b> (Selection menu) &mdash; <b>Chain</b> (full chain), <b>Direct</b> (adjacent only), or <b>Selected</b> (just the selection).</li>
  <li><b>Highlight colors</b> (Selection menu) &mdash; customize the Selected / Hovered and Connected highlight colors via picker or swatches. Live preview tester included. Colors saved to project file (Editor mode only).</li>
  <li><b>Zoom</b> (Layout popover) &mdash; scale the viewer from 50% to 150% for density control.</li>
  <li><b>Node &amp; mapping colors</b> &mdash; set a custom color on any field or mapping for at-a-glance visual coding.</li>
  <li><b>Color priority (nodes)</b> &mdash; Selection/hover &rarr; Filters &rarr; Node color (applied) &rarr; Parent group color &rarr; Column color &rarr; none. Set one color on a group to tint all its children; any child can override with its own.</li>
  <li><b>Color priority (mappings)</b> &mdash; Selection/hover &rarr; Filter color &rarr; Color-by scheme &rarr; Per-mapping manual color &rarr; default.</li>
  <li><b>Node color mode</b> (Layout popover) &mdash; choose which inheritance levels are active: <b>All</b>, <b>Groups</b> (column + group only), <b>Column</b> (column only), or <b>Off</b>.</li>
  <li><b>Color mappings by</b> &mdash; auto-color all mapping lines by cardinality, transform, tag, or custom attribute. Uses custom colors from tags and attribute values when available; falls back to palette. Opens a legend in the Graph popover.</li>
</ul>

<p style="margin:16px 0 0;font-size:12.5px;">For full details, open <b>Documentation</b> from the Help toolbar group.</p>
<div style="margin-top:14px;padding-top:10px;border-top:1px solid var(--border);text-align:center;">
<div style="font-size:12px;font-weight:700;opacity:.5;letter-spacing:.3px;">Dunnode. Done. Now.</div>
<div style="font-size:10px;opacity:.3;margin-top:4px;">v${APP_VERSION}</div>
</div>`;
  helpMask.classList.add('active');
  helpModal.classList.add('active');
}

// --- Release notes ---
const RELEASE_NOTES = [
  {
    version: '1.7.2',
    date: '2026-02-27',
    highlights: 'Highlight performance, seamless node hover, Chromium recommendation',
    changes: [
      '<b>Performance</b>: removed all CSS fade transitions from edge lines and node rows. Highlighting and dimming are now instant, eliminating hundreds of concurrent CSS animations during hover/highlight cycles in large projects',
      '<b>Seamless node hover</b>: hover-out events are now debounced with a 32ms window. When the mouse crosses the visual gap between rows, the highlight switches directly to the next row without flickering. Visual spacing is unchanged',
      '<b>Browser recommendation</b>: README updated to recommend Chromium-based browsers (Chrome, Edge, Brave, Arc, Opera). Firefox and Safari may work but are not officially supported',
    ]
  },
  {
    version: '1.7.1',
    date: '2026-02-27',
    highlights: 'Clamped indicator fix, split-color consolidated two-forwards',
    changes: [
      '<b>Clamped indicator fix</b>: scroll-clamped triangle indicators (/) now only appear where an arrowhead would normally be  target end for forward mappings, both ends for bidirectional. Source-only forward edges no longer show a spurious indicator',
      '<b>Split-color consolidated arrows</b>: when two forward mappings between the same pair have different custom colors, the consolidated line now renders as a half-and-half split at the midpoint  each half matches its respective edge color. The center-opposing arrowheads () also follow the same per-edge coloring',
      '<b>Split fallback</b>: when only one of the two forward mappings has a custom color, the other half uses the default line color instead of suppressing the split entirely',
    ]
  },
  {
    version: '1.7.0',
    date: '2026-02-27',
    highlights: 'Scroll-clamped arrows, edge direction system (forward / bidirectional / directionless), center-opposing arrows, drag modifier creation, perspective-aware detail panels',
    changes: [
      // Scroll-clamped arrows
      '<b>Scroll-clamped arrow endpoints</b>: when a mapped node scrolls out of view within its column, the arrow line clamps to the column header edge (scrolled above) or footer edge (scrolled below) with a directional triangle indicator (/) showing which direction the node is. Clamped endpoints approach vertically for a clean visual. Updates live during scroll',
      '<b>Z-ordering</b>: highlighted, active, and selected edges are drawn on top of other edges for better visibility',
      // Edge direction system
      '<b>Edge direction property</b>: mappings now have a <code>direction</code> field with three values: <b>forward</b> (default, ), <b>bidirectional</b> (), and <b>directionless</b> (). Each has a distinct visual silhouette',
      '<b>Bidirectional mappings ()</b>: a single edge representing a symmetric relationship  same transforms/tags/notes apply both ways. Arrow markers at both ends. Distinct from two separate forward mappings',
      '<b>Directionless links ()</b>: associations without implied flow  cross-references, see-also links. Dot markers at both ends, no arrowheads',
      '<b>Consolidated two-forwards ()</b>: when two separate forward mappings exist between the same pair (AB and BA), they draw as a single line with opposing arrowhead tips meeting at the center  visually distinct from a true bidirectional edge',
      '<b>Direction toggle</b>: 3-way button group ( /  / ) in the mapping editor between the From/To rows. Active state highlighted in blue',
      // Drag creation
      '<b>Modifier key creation</b>: <b>Alt+Shift+Drag</b> creates a bidirectional mapping. <b>Alt+Shift+Ctrl/Cmd+Drag</b> creates a directionless link. Normal <b>Alt+Drag</b> creates a forward mapping as before',
      '<b>Drag ghost badges</b>: ghost chip shows <b>MAP </b> in purple for bidirectional and <b>MAP </b> in slate for directionless, matching the existing MAP (amber) / COPY (green) / COPY+ (lime) color scheme',
      // Detail panels
      '<b>Bidirectional in both sections</b>: bidirectional edges appear in both Inbound and Outbound mapping lists (single-select and multi-select) with an  badge',
      '<b>Linked (directionless) section</b>: new collapsible section in node detail panels for directionless edges, with  badge and dedicated stat card',
      '<b>Perspective-aware display</b>: in mapping lists, the selected node always appears on the correct side  left for outbound, right for inbound  even for bidirectional and directionless edges',
      '<b>Direction in viewer panel</b>: edge viewer shows direction row for non-forward mappings ( Bidirectional or  Linked)',
      // Tooltips & export
      '<b>Direction in tooltips</b>: edge tooltips show direction label for bidirectional and directionless mappings',
      '<b>CSV export/import</b>: direction column added to CSV edge export. Import recognizes forward/both/none values',
      // Sample project & docs
      '<b>Sample project updated</b>: four new example mappings  two bidirectional (crew sync between Mission Control and Archive) and two directionless (cross-references between Lab and Observatory/Archive)',
      '<b>Keyboard shortcuts updated</b>: shortcuts reference, quick-start guide, help documentation, and status bar all include the new Alt+Shift and Alt+Shift+Ctrl/Cmd drag modifiers',
    ]
  },
  {
    version: '1.6.0',
    date: '2026-02-26',
    highlights: 'Import system (SQL DDL, CSV/TSV files, mappings, catalog items, preset bundles), meta-only category tags, comprehensive shortcuts reference, mapping terminology',
    changes: [
      // Import system
      '<b>SQL DDL import</b>: <b>Import  Import SQL/DDL</b> parses <code>CREATE TABLE</code> statements from pasted SQL or uploaded <code>.sql</code> files. Each table becomes a column; each SQL column becomes a field. Auto-detects data types, PRIMARY KEY, NOT NULL, UNIQUE, FOREIGN KEY, AUTO_INCREMENT, and DEFAULT values. Creates or reuses a <b>Data Type</b> attribute, <b>Nullable</b> attribute, and standard tags (Primary Key, Foreign Key, Required, Unique). Supports MySQL, PostgreSQL, SQL Server, and Oracle syntax including quoted identifiers, schema prefixes, and IF NOT EXISTS',
      '<b>CSV/TSV file import</b>: <b>Import  Import CSV/TSV file</b> uploads a file and shows an interactive column mapping UI. Each CSV column gets a role dropdown: Label, ID, Parent (nesting), Column (grouping), Note, Tag, Skip, or Custom attribute. Auto-detects common header names. Import into new columns (one per unique Column value) or an existing column. Supports comma, tab, and semicolon separators with quoted field parsing. Preview shows the resulting tree with attribute and tag badges',
      '<b>Import mappings</b>: <b>Import  Import mappings</b> creates mappings between existing fields from pasted text or uploaded CSV/TSV files. Multi-strategy field resolution: exact ID, <code>column.label</code>, or unambiguous label. Supports cardinality, labels, notes, defaults, tags, transforms, and extra columns as custom attributes. Compatible with <b>Export CSV</b> output for round-tripping. Preview shows each mapping with resolution status badges (ID / col.label / label / ambiguous / not found). Existing mappings are detected and skipped',
      '<b>Catalog import</b>: import tags, transforms, and attributes from pasted text or uploaded files. Supports plain lines (one per line, indented values for attributes) and tab-separated formats with auto-detection of known columns. Items matching by ID or label show status badges: <b>new</b>, <b>will update</b>, or <b>exists  no changes</b>. Matched items are merged (non-empty properties overwrite; attribute values are additive). TSV imports support an <code>id</code> column for custom IDs and a <code>tag</code>/<code>tags</code> column for category assignment',
      '<b>Preset bundles</b>: <b>Load preset bundle</b> in the Catalogs menu opens a picker with four domain presets  Database, API/JSON, Data Governance, and ETL/Integration. Each bundle populates tags, attributes, and transforms with domain-specific items in a single click. Per-catalog presets bar also available in individual import modals',
      // Import infrastructure
      '<b>TSV parent column</b>: field and column TSV imports recognize a <code>parent</code> column for building multi-level nested hierarchies with unlimited depth',
      '<b>TSV column import</b>: Import Columns supports tab-separated format with a <code>column</code> header that groups rows into separate columns, plus <code>parent</code> for nesting and extra columns for tags/attributes',
      '<b>Auto-create attributes</b>: unrecognized TSV columns in field and column imports automatically create custom attributes and values. Preview shows which attributes are new vs. existing',
      '<b>Tab indentation</b>: all import textareas intercept Tab/Shift+Tab for 4-space indent/outdent instead of browser focus change',
      '<b>Import file upload</b>: all import modals include a file upload button accepting .csv/.tsv/.txt files',
      // Meta-only tags
      '<b>Meta-only tags</b>: new <b>Meta only</b> checkbox on tags marks them as category headers. Meta-only tags are hidden from node/mapping tag selectors. Tag, attribute, and transform dropdowns group items under labeled optgroup sections when tagged with a meta-only tag',
      '<b>Category assignment</b>: catalog items (tags, attributes, transforms) can only be tagged with meta-only category tags. The catalog Category selector filters to meta-only tags only',
      // Shortcuts & UI
      '<b>Keyboard & mouse shortcuts reference</b>: expanded from 6 to 11 sections  now covers click modifiers (Ctrl/Shift/Alt+click for toggle, range, chain select), edge click modifiers (Alt+Shift upstream, Alt+Ctrl downstream), marquee & lasso (Shift to add, Ctrl to subtract, Alt for freeform, all combinable), and drag-and-drop modifiers (no mod = Move, Alt = Map, Ctrl = Copy, Ctrl+Alt = Copy+)',
      '<b>Mapping terminology</b>: all user-facing \"arrow\" and \"edge\" references updated to \"mapping\"  Graph menu headers (<b>Show mappings</b>, <b>Mapping scope</b>), button tooltips, filter editor labels, documentation headings, and quick-start guide',
      '<b>Mapping labels layout</b>: the Mapping labels selector in the Graph menu now uses full-width row format with title above, matching Show mappings and Mapping scope',
      '<b>Preset bundle fix</b>: applying a preset bundle no longer shows \"undefined\" in the status message',
    ]
  },
  {
    version: '1.5.0',
    date: '2026-02-25',
    highlights: 'Mapping tags & attributes, emoji display mode, mapping labels, bulk editing, attribute editor UX overhaul',
    changes: [
      // Edge metadata
      '<b>Mapping tags</b>: mappings now support tags from the shared tag catalog  same tags used on nodes. Add, remove, and manage tags directly in the mapping editor',
      '<b>Mapping custom attributes</b>: assign custom attribute values to mappings using the shared attribute catalog. Supports single-select and multi-select attributes, plus inline creation of new attributes and values',
      '<b>Mapping labels</b>: mappings now have a <b>Label</b> field  a short freeform text rendered directly on the mapping line in the viewer at the curve midpoint. Togglable via <b>Mapping labels</b> selector (Always / Highlight / Off) with icon buttons in the Graph menu. Label show/hide checkbox per mapping',
      '<b>Consolidated view</b>: tag and attribute chips displayed in consolidated and bidirectional edge cards for quick scanning. Tooltips and badge pills in node detail mapping lists',
      // Emoji system
      '<b>Emoji fields</b>: tags, transforms, custom attributes, and attribute values now have an optional emoji field with a curated picker palette ( button)',
      '<b>Display mode toggle</b>: each catalog item has an explicit <b>Abbr / Emoji</b> toggle controlling which label is shown in node pills, detail panels, filter chips, and transform badges. Auto-switches when emoji is set or cleared',
      // Bulk editing
      '<b>Bulk move</b> (<b>Alt+/</b>): move multiple contiguous siblings up or down as a block',
      '<b>Bulk indent/outdent</b> (<b>Alt+/</b>): indent or outdent multiple siblings at once',
      '<b>Copy &amp; paste</b> (<b>Ctrl+C/V</b>): copy selected node subtrees with deep clone and mapping duplication. Cross-column paste supported',
      '<b>Duplicate</b> (<b>Ctrl+D</b>): duplicate selected siblings in-place with full subtree and mapping clone',
      '<b>Group selection</b> (<b>Ctrl+G</b>): wrap contiguous selected siblings into a new named group',
      '<b>Ungroup</b> (<b>Ctrl+Shift+G</b>): dissolve groups  moves children to parent level. Now supports multi-selection (ungroups all selected groups at once)',
      '<b>Collapse/expand toggle</b> (<b>Space</b>): toggle on selected group(s), supports multi-selection',
      // Attribute editor UX
      '<b>Attribute editor redesign</b>: compact merged rows (Id+Abbr, Emoji+Display), collapsible emoji grid and color swatches behind  and  dropdown buttons',
      '<b>Inline value creator</b>: replaced "Add value" modal with inline input  type a label and press Enter. Auto-generates ID, abbreviation, and priority',
      '<b>Drag-and-drop value reordering</b>: grab the 6-dot handle to reorder values. Full-border blue highlight on drop target. Priority-based ordering',
      '<b>Catalog drag handles</b>: 6-dot grip icons on all catalog cards (filters, tags, attributes, views) indicating drag-to-reorder support',
      // Multi-select fixes
      '<b>Multi-select keyboard fix</b>: all shortcuts (duplicate, group, ungroup, move, indent, outdent, collapse) now work correctly with lasso/marquee multi-selections. Previously, lasso selection set lockedId=null which caused all shortcut guards to bail early',
      '<b>Browser shortcut conflict fix</b>: Ctrl+D and Ctrl+G now always preventDefault when the app is focused (outside input fields), preventing browser bookmark and find-next dialogs',
      // UX polish
      '<b>Auto-ID freeze</b>: clicking the <span class="autoTag" style="pointer-events:none;">auto</span> badge freezes the ID  stops following label changes. Clearing re-enables auto-follow',
      '<b>Context menu expanded</b>: Copy, Paste, Group selection, and Ungroup actions with keyboard shortcut hints',
      '<b>View scope expanded</b>: views now capture and restore mapping label display mode, tag pill visibility, and attribute pill visibility',
      '<b>Catalog naming consistency</b>: "Tag manager"  Tags catalog, "Transformation library"  Transforms catalog',
      '<b>Move button consistency</b>: disabled move arrows show dimmed instead of hidden across all catalogs',
    ]
  },
  {
    version: '1.4.1',
    date: '2026-02-24',
    highlights: 'Top bar icon revamp, columns popover redesign, keyboard shortcut reorganization, platform-aware shortcut display, catalog SVG icon buttons, view auto-deactivation',
    changes: [
      '<b>Top bar icons</b>: New, Open, and Save buttons now show SVG icons (document, folder, download arrow) with shortened labels. Bright/dark mode toggle uses proper sun/moon SVG icons. All icons match the app\'s consistent 1.2 stroke weight',
      '<b>Editor mode button</b>: replaced the checkbox+label toggle with a clean button that lights up with golden glow when active  no more checkbox. Pencil icon matches the edit icon from the SVG icon system',
      '<b>Columns popover redesign</b>: checkboxes replaced with eye/eye-off SVG toggle buttons, hidden columns shown at reduced opacity. Color dots show each column\'s assigned color. Move arrows and delete button use SVG icon buttons with dedicated styling. Footer buttons have icons. All elements have proper dark/bright mode support',
      '<b>Command palette icon</b>: restored the  looped-square icon as an SVG  four corner circles connected by a center square, matching the classic Mac command key symbol',
      '<b>New project shortcut</b>: changed from Ctrl+N to <b>Alt+N</b>  browsers hard-intercept Ctrl+N (new window) before JavaScript can cancel it',
      '<b>Keyboard shortcuts reorganized</b>: all project shortcuts now use the <b>Alt+</b> prefix (<b>Alt+N</b> new, <b>Alt+O</b> open, <b>Alt+S</b> save, <b>Alt+E</b> editor mode). View shortcuts: <b>Ctrl+Alt+S</b> save view, <b>,</b> / <b>.</b> previous/next view, <b>Ctrl+Alt+0</b> reset view. All tooltips, documentation, command palette, and keyboard shortcuts modal updated. Platform-aware display: Mac shows  symbols, Windows shows Ctrl/Alt/Shift',
      '<b>Navigation shortcuts corrected</b>: removed unimplemented / collapse/expand and Home/End shortcuts from the modal. Tab/Shift+Tab correctly documented as indent/outdent under "Editing (Editor mode only)" instead of column switching under Navigation',
      '<b>Columns button icon</b>: the Columns button above the viewer now shows the same two-column layout icon used by the Layout toolbar menu',
      '<b>Highlight colors icon</b>: replaced the abstract Venn diagram with a paint palette SVG icon for clearer meaning',
      '<b>Layout menu</b>: Wrap columns button moved below the Width/Gap/Zoom sliders with a separator line, keeping the slider controls grouped as the primary adjustment area',
      '<b>ICONS object expanded</b>: added <code>newDoc</code>, <code>openDoc</code>, <code>saveDoc</code>, <code>sun</code>, <code>moon</code>, <code>cmdPalette</code>, and <code>columns</code> icons for reuse across the app',
      '<b>Views catalog</b>: the Apply button now shows a  checkmark icon; when a view is active, the button changes to <b>Deactivate</b> with an  icon, matching the pill deactivate behavior. Clicking it toggles the view off while keeping the current state',
      '<b>Catalog move buttons</b>: all  text arrow buttons across Tags, Attributes, Filters, and filter condition rows are now SVG icon buttons with consistent sizing, styling, and hover states  matching the Columns popover design. Filter rule  and  buttons use the same icon system',
      '<b>Transforms sorted alphabetically</b>: the Transforms catalog now displays entries sorted by label when opened, making it easier to find transforms in larger libraries',
      '<b>Browser tab title</b>: changed from "Project  Dunnode" to "Dunnode  Project" so the brand is always visible in narrow browser tabs',
      '<b>Wrap columns spacing</b>: balanced padding above and below the Wrap columns button in the Layout menu  symmetric 8px gaps matching other layout sections',
      '<b>Mac keyboard fix</b>: Alt+letter project shortcuts (N/O/S/E) now use <code>e.code</code> instead of <code>e.key</code>  fixes Option+letter producing special characters (, , ) on Mac keyboards',
      '<b>Platform-aware shortcut display</b>: keyboard shortcuts modal, command palette hints, context menu hints, and tooltips now show Mac symbols () on Mac and Ctrl/Alt/Shift/Delete on Windows/Linux. Global <code>platformKbd()</code> utility and one-time tooltip patching at init',
      '<b>View navigation shortcuts</b>: previous/next view changed to plain <b>,</b> and <b>.</b> keys (no modifiers)  simple single-key shortcuts matching <b>?</b> for help, <b>P</b> for pan, <b>D</b> for details. Guarded against input fields',
      '<b>View nav edge behavior</b>: prev/next buttons are now greyed out (disabled, 30% opacity) instead of hidden when at the first or last view  no more visual gap in the Views menu. Keyboard shortcuts are no-ops at edges',
      '<b>View auto-deactivation</b>: changing any viewer state (selection, filters, search, arrows, collapse/expand, column visibility, color modes) now automatically deactivates the active view. Debounced 80ms drift check compares current state against the saved snapshot. Guard flag prevents false triggers during view application',
    ]
  },
  {
    version: '1.4.0',
    date: '2026-02-24',
    highlights: 'Views catalog with inline editing, SVG icon system, context menu redesign, keyboard shortcuts, reset view, view pill indicator',
    changes: [
      '<b>Views catalog</b>: save and restore viewer state snapshots  filters, selection, arrows, collapse state, hidden columns, mapping color scheme, node color mode, mapping label mode, tag/attribute pill visibility, and more. <b>Views</b> toolbar button for one-click apply. <b>Save current view</b> (<b>Alt+S</b>) captures current state. <b>Previous view / Next view</b> (<b>Alt+,</b> / <b>Alt+.</b>) navigate between saved views. Full catalog management with inline editing, emoji picker, drag-and-drop reordering, and update snapshot. Click an active view to deactivate (toggle off). Tooltips show view notes on hover. Four sample views in the example project',
      '<b>View pill indicator</b>: when a view is active, a compact pill appears in the viewer header showing the emoji + label with / navigation buttons, an  to deactivate, and a dropdown overlay for quick switching',
      '<b>Reset view</b> (<b>Alt+0</b>): clears all filters, search, selection, hidden columns, collapsed groups, arrows, mapping colors, node colors, and dim mode  returns to clean-slate state. Available in the Views menu, as an icon button in the viewer toolbar, and in the command palette',
      '<b>Project keyboard shortcuts</b>: <b>Ctrl+N</b> new project, <b>Ctrl+O</b> open project, <b>Ctrl+S</b> save project, <b>Ctrl+E</b> toggle editor mode. All shown in tooltips, command palette, and keyboard shortcuts modal',
      '<b>SVG icon system</b>: new shared <code>ICONS</code> object with 20+ monochrome SVG icons at consistent stroke weight. Replaces all Unicode text glyphs in context menus, toolbar buttons, dropdown menus, and the multi-select details panel. New <code>nodeIcon()</code> helper provides unified diamond (field) and rect-with-header (group) icons across the app',
      '<b>Context menu redesign</b>: tighter layout with section labels (Add, Insert, Arrange), keyboard shortcut hints, transparent backgrounds with hover fills, and SVG icons for every action. Delete uses colored text instead of colored background. Column and node menus both restructured',
      '<b>Toolbar menu revamp</b>: all toolbar buttons (Graph, Layout, Selection, Catalogs, Views, Export, Help) now use SVG icons instead of text glyphs. All dropdown menus now use the <code>selActionBtn</code> pattern with SVG icons  matching the Selection menu style established in v1.3.8',
      '<b>Viewer controls redesign</b>: icon buttons above the viewer are now grouped into logical capsules  View actions (pan, clear, reset) and History (undo, redo). All buttons use consistent SVG icons with hover/active states. History group shows/hides with editor mode',
      '<b>Layout wrap toggle</b>: the bare checkbox for "Wrap columns" is now a styled button matching the rest of the Layout menu, with an ON/OFF indicator',
      '<b>Keyboard shortcuts</b>: / arrow navigation, Shift+/ multi-select, Ctrl+/ quick-create field below/above with inline rename, Ctrl+Alt+/ for groups, Ctrl+ add child, Alt+/ move node, Tab/Shift+Tab indent/outdent, Enter to focus editor, Delete to remove node',
      '<b>Inline rename</b>: new nodes created via keyboard start with an inline label editor. Type a name and press Enter to commit, Escape to cancel (removes the node), or Ctrl+ to commit and create the next field  enabling rapid-fire schema building',
      '<b>Field  group conversion</b>: right-click context menu and command palette entries to convert fields to groups and vice versa (groups must be empty to convert to fields)',
      '<b>Cancel button fix</b>: Cancel in catalog editors now closes immediately without triggering the unsaved changes guard',
      '<b>Edit field/group fix</b>: the context menu "Edit field" / "Edit group" action no longer clears the selection  it directly focuses the node without toggle behavior',
      '<b>Opacity popover fix</b>: the floating panel\'s opacity slider now renders below the icon row when there is not enough space above (e.g. when the panel is at the top of the screen)',
      '<b>About dialog</b>: new tagline  <i>"Dunno where your data goes?"</i> above the DUNNODE wordmark',
      '<b>Filter selection clearing</b>: when filter mode is Hide and selected nodes become hidden, selection is automatically cleared',
      '<b>Enter/Escape in all dialogs</b>: Enter confirms and Escape cancels in all custom alert, confirm, and prompt dialogs',
      '<b>Column-level keyboard shortcuts</b>: when a column header is selected, Ctrl+/ adds fields to the top/bottom of the column. Arrow keys from column header jump to the first node',
      '<b>Browser tab title sync</b>: the browser tab title now reflects the project title',
      '<b>Mapping hiding fix</b>: Direct and Selected highlight modes now correctly hide non-highlighted edges when arrow mode is set to Selected'
    ]
  },
  {
    version: '1.3.9',
    date: '2026-02-23',
    highlights: 'Unified color editor UX, nested create modals, required field indicators, undo improvements',
    changes: [
      '<b>Unified color editor</b>: all color pickers now include a hex input field, preset swatches, and an <b>Apply</b> checkbox  across catalog managers (tags, transforms, attributes), create modals, and details panels. Typing a hex code auto-checks Apply and updates the picker',
      '<b>Create modal color support</b>: the create modal for transforms and custom attributes now includes the full color editor (swatches + picker + hex input + Apply checkbox). Tags always have color applied; other types start with Apply unchecked',
      '<b>Nested create modals</b>: selecting "+ New tag", "+ New attribute", or "+ New value" from the node create modal now opens a nested create modal instead of the full catalog manager. The node create modal\'s state is saved and restored after committing or cancelling the nested modal. New items are automatically added to the node being created',
      '<b>Required field indicators</b>: Label fields in all editors and create modals now show a red <b>*</b> asterisk. The Save button remains disabled until a label is provided  replaces the previous alert-based validation',
      '<b>Highlight colors undoable</b>: saving or deleting custom highlight colors now creates an undo snapshot. Ctrl+Z properly reverts highlight color changes',
      '<b>Undo catalog sync</b>: undo and redo now re-render all open catalog modals (tags, transforms, attributes, filters) and restore highlight CSS variables. Fixes ghost entries that appeared after undoing a catalog "Add" operation',
      '<b>Dim Off parent highlighting</b>: when Dim unselected is set to Off, connected parent groups now show the blue highlight  matching the behavior of Parents mode. Previously, parent groups were not highlighted in Off mode',
      '<b>Highlight colors preview labels</b>: the demo nodes in the highlight colors modal now read "Source" and "Target" instead of "source_id" and "target_id"',
      '<b>Dropdown reset on cancel</b>: selecting "+ New value" in the node editor attribute dropdown now resets the dropdown immediately, so cancelling the create modal leaves it at the default "Value" placeholder',
      '<b>Guard prompt labels</b>: dirty discard prompts for create modals now show friendly names ("custom attribute", "custom attribute value") instead of internal kind codes',
    ]
  },
  {
    version: '1.3.8',
    date: '2026-02-23',
    highlights: 'Selection menu redesign, highlight mode, enhanced dimming, branding & licensing, privacy section, Unicode transliteration',
    changes: [
      '<b>Selection menu redesign</b>: action buttons now have SVG icons and are reordered  Select all  Invert selection  Clear selection  Expand all  Collapse all. Cleaner visual hierarchy with grouped sections',
      '<b>Highlight mode (3-way)</b>: merged the old "Selection arrows" toggle and "Selected only" checkbox into a single <b>Chain</b> / <b>Direct</b> / <b>Selected</b> selector. <b>Chain</b> follows the full mapping chain across all columns, <b>Direct</b> shows only immediate neighbors, and <b>Selected</b> highlights only the selected node(s) with no connected fields. Applies to both single and multi-selections',
      '<b>Highlight parents removed</b>: the standalone "Highlight parents" toggle has been retired  its behavior is now baked into the <b>Parents</b> dim mode, which highlights ancestor groups with a subtle blue tint. In <b>All</b> dim mode, only directly connected fields are un-dimmed',
      '<b>Dim "All" fix</b>: expanded parent groups now correctly stay dimmed in All mode. Previously, parent highlighting was un-dimming them regardless, making All and Parents behave identically',
      '<b>Selected group highlighting</b>: selecting a group now properly un-dims the group node itself and all its descendant subgroups (e.g. selecting EXPERIMENT also un-dims SAMPLE_ANALYSIS)',
      '<b>Selected mode edge hiding</b>: in Selected highlight mode, non-highlighted edges are fully hidden instead of dimmed. When Show mappings is set to All, edges properly dim rather than disappear',
      '<b>Enhanced dimming contrast</b>: dimmed elements are now more transparent for better visual clarity  dark mode 0.30  0.22, bright mode 0.50  0.40',
      '<b>Column selection fix</b>: clicking a column header while in multi-select mode now properly clears the multi-selection and switches to column view',
      '<b>Unicode transliteration</b>: auto-generated IDs now convert accented characters to their ASCII equivalents (a, e, u, n, o) instead of stripping them. Applied across all ID generation  nodes, tags, transforms, attributes, filters, and export filenames',
      '<b>Favicon</b>: inline SVG and PNG fallback favicon  the Dunnode diamond icon appears in browser tabs',
      '<b>Branding headers</b>: Quick Start Guide and Documentation modals now open with the Dunnode logo, tagline ("Done. Now."), and description',
      '<b>MIT License</b>: full license text added to Documentation. Footer updated to " 2026 Olivr Bn  MIT License" with a clickable link. About modal shows "MIT Licensed" link  both scroll to the License section in docs',
      '<b>Privacy &amp; Data Handling</b>: new Documentation section confirming Dunnode runs entirely client-side with no server uploads or data transmission',
      '<b>About modal</b>: now includes dunnode.com link and "MIT Licensed  Runs entirely in your browser" notice',
      '<b>Version format</b>: standardized to "v1.3.8" (lowercase v prefix) across footer, About modal, docs, and release notes',
      '<b>Getting started updated</b>: first step now reads "Visit dunnode.com" as the primary entry point, with local HTML download as a secondary option',
      '<b>Sample data</b>: project properties now include contact email (hello@dunnode.com) and URL (https://dunnode.com)',
    ]
  },
  {
    version: '1.3.7',
    date: '2026-02-23',
    highlights: 'Arrow controls redesign, filter bar polish, mapping color hierarchy, command palette docs search, terminology sweep',
    changes: [
      '<b>Arrow mode selector</b>: the three arrow checkboxes (Arrows, All arrows, Adjacent-only) are replaced by a clean 3-way selector in the Graph menu  <b>Selected</b> (only hovered/selected), <b>All</b> (every arrow), or <b>Off</b>. Matches the "Dim unselected" and "Details panel" dock selector pattern',
      '<b>Mapping scope toggles</b>: new <b>Same-column</b> and <b>Distant</b> checkboxes in the Graph menu replace the old Adjacent-only toggle. Independently hide mappings within the same column or across non-adjacent columns  adjacent-column mappings are always shown when arrows are on',
      '<b>Mapping color priority</b>: revised hierarchy is now Selection highlight  Filter color  Color-by scheme  Per-mapping manual color (lowest). "Color mappings by" now takes priority over individual mapping colors, matching the node color inheritance philosophy',
      '<b>Mapping dimming fix</b>: colored mappings (scheme, filter, or manual) now properly dim when a selection is active. Previously, inline opacity overrode the CSS dimming class',
      '<b>Filter bar redesign</b>: the right section of the filter bar now uses segmented selectors  <b>Hide / Dim / Highlight</b> mode selector, <b>AND / OR</b> logic selector, and a pill-style <b>Only mapped</b> toggle. Replaces the old checkboxes and cycle button with a cleaner, more discoverable layout',
      '<b>Column header toning</b>: colored column headers now show a 2px accent line (down from 3px) and neutral-colored text  removes the doubled-up effect of colored text plus thick colored border',
      '<b>Command palette docs search</b>: typing 3+ characters now also searches the full Documentation  matching sections appear under a "Documentation" category with a snippet preview. Selecting a result opens the docs modal and scrolls to the relevant section. The Help category now includes a Documentation command alongside Quick Start, Release Notes, and About',
      '<b>Adjacent highlight removed</b>: the "Adjacent highlight" toggle in the Selection menu has been retired. Its functionality is now better served by the mapping scope toggles (Same-column / Distant) which control both drawing and visibility in a more intuitive way',
      '<b>Terminology sweep</b>: all user-facing text now consistently uses "mapping" instead of "edge"  detail panel headers, status bar counts, tooltips, export filenames, documentation, and changelog. Code internals retain "edge" as the correct graph theory term',
      '<b>Sample data refresh</b>: all five columns now have colors (Lab  emerald, Archive DB  slate, Obs  amber). New group-level colors on lab.personnel (pink), arch.fact_telemetry (sky blue), and arch.dim_crew (indigo). Seven mappings now have custom colors to showcase the color priority hierarchy',
      '<b>Select all / Invert selection</b>: previously hidden in the command palette, now surfaced as buttons in the Selection menu and as keyboard shortcuts  <b>Ctrl+A</b> (Cmd+A) selects all visible nodes, <b>Ctrl+Shift+I</b> (Cmd+Shift+I) inverts the current selection',
    ]
  },
  {
    version: '1.3.6',
    date: '2026-02-22',
    highlights: 'Column viewer, node color mode toggle, column header tint, bug fixes',
    changes: [
      '<b>Column viewer</b>: clicking a column header now shows a proper Column view in the details panel (label, ID, note, color, field/group/mapping counts) instead of incorrectly showing the root group node. Works in both viewer and editor mode',
      '<b>Column selection persistence</b>: toggling between viewer and editor mode no longer loses the column selection  the column stays selected and the details panel switches between column viewer and column editor automatically',
      '<b>Node color mode</b>: new "Node colors" section in the Layout popover with four modes  <b>All</b> (full inheritance), <b>Groups</b> (column + group colors only, no field overrides), <b>Column</b> (column colors only), <b>Off</b> (no background tinting). Styled with icon buttons matching the Dim unselected pattern',
      '<b>Column header tint</b>: column headers now display a subtle background tint in addition to the colored name and bottom border, making the column color more visible in the viewer',
    ]
  },
  {
    version: '1.3.5',
    date: '2026-02-22',
    highlights: 'Group color inheritance, updated sample data, documentation refresh',
    changes: [
      '<b>Group color inheritance</b>: groups with an applied color now cascade to all descendants. The full hierarchy is: Node color (applied)  nearest ancestor group color (applied)  Column color  none. This means a single color on a group can tint hundreds of children, and any child can override it with its own applied color',
      '<b>Sample data refresh</b>: the built-in Mars Mission example showcases color hierarchy  Mission Control (blue column), Crew group (red, overrides column), CommanderName field (amber, overrides group), Spacecraft Telemetry (purple column), Navigation subgroup (orange), Observatory Validation group (yellow). Attribute values include <code>colorEnabled</code> flags to demonstrate inheritance',
      '<b>Documentation updated</b>: Quick Start Guide, full Documentation, and JSON schema reference all updated to cover column colors, group color inheritance, attribute-level color, value Apply checkboxes, and the labelID auto-fill additions',
    ]
  },
  {
    version: '1.3.4',
    date: '2026-02-22',
    highlights: 'Color hierarchy: column colors, attribute colors, value colorEnabled, labelID auto-fill everywhere',
    changes: [
      '<b>Column colors</b>: columns now have an optional color with Apply checkbox. When applied, the column header is tinted and all child nodes without their own color inherit the column color as a subtle background',
      '<b>Attribute-level color</b>: attributes can now have their own color with swatch picker and Apply checkbox. When enabled, attribute values that don\u2019t have their own color applied will inherit the attribute\u2019s color for node pills',
      '<b>Attribute value Apply checkbox</b>: each value\u2019s color now has an explicit Apply toggle. Unchecked = color is stored but not used, inherits from attribute instead. For "Color mappings by", disabled value colors fall back to the default palette',
      '<b>Color hierarchy</b>: node background tint follows Node color (applied)  nearest ancestor color (applied)  Column color  none. A group with color applied cascades to all descendants until overridden by a child with its own applied color. Attribute value pill color follows Value color (applied)  Attribute color (applied)  none',
      '<b>LabelID auto-fill</b>: typing a label now auto-generates the ID (and abbreviation where applicable) in the column editor, node editor, and attribute value rows  matching the existing tag/transform pattern. "auto" badges show when values are auto-synced',
      '<b>Dirty detection fixes</b>: attribute value field edits (label, id, abbr, note), attribute color changes, and filter color changes now correctly activate the Save button',
    ]
  },
  {
    version: '1.3.3',
    date: '2026-02-21',
    highlights: 'Node attribute pills, transform colors, attribute ordering & display controls',
    changes: [
      '<b>Multi-select drag-and-drop</b>: when multiple nodes are selected, dragging any selected node performs the operation on all selected nodes at once. Same modifier keys apply: no modifier = Move, Alt = Map, Ctrl/Cmd = Copy, Ctrl/Cmd+Alt = Copy+',
      '<b>Multi MAP (Alt+drag)</b>: Alt-drag any selected node onto a non-selected field to create mappings from all selected fields to that target. Selection switches to the target field afterward',
      '<b>Multi MOVE</b>: drag selected nodes to reposition them together. Nodes maintain their original relative order. Automatic deduplication: children of selected groups are excluded since they move implicitly with their parent',
      '<b>Multi COPY / COPY+</b>: Ctrl-drag to duplicate all selected nodes at the drop location. Ctrl+Alt duplicates with mappings. Same deduplication and ordering rules as Move',
      '<b>Multi bin delete</b>: drag selected nodes to the  Delete zone to bulk-delete with confirmation. Shows affected mapping count',
      '<b>Transform custom color</b>: transforms now have an optional color field with swatch picker and hex input. Used by "Color mappings by  Transform" to override the default palette',
      '<b>Custom attribute ordering</b>: attributes and their values now have priority-based ordering with drag-and-drop reorder and / buttons, matching the tag catalog pattern',
      '<b>Attribute "Display on node"</b>: per-attribute checkbox controls whether its values appear as pills on tree nodes. Pill order: Tags first  Attributes by priority  Values by priority within each attribute',
      '<b>Value abbreviation</b>: each custom attribute value now has an optional abbreviation field. When set, the abbreviation is shown instead of the full label in node pills',
      '<b>Layout display toggles</b>: two new checkboxes in the Layout menu  "Display tags" and "Display attributes"  control visibility of tag and attribute pills on all nodes',
      '<b>Copy self-drop refinement</b>: copying a node before/after itself is allowed (duplicate in place), but copying into itself is blocked to prevent recursive nesting',
    ]
  },
  {
    version: '1.3.1',
    date: '2026-02-21',
    highlights: 'Unified editor UX: inline creation, smart auto-ID/abbr, dirty guards everywhere, "auto" indicators',
    changes: [
      '<b>Inline catalog creation</b>: adding a new tag, transform, or attribute opens an inline editor card at the top of the catalog list instead of a popup modal. Empty fields, auto-focused label, no Delete button for unsaved items',
      '<b>Unified Save/Cancel/Delete pattern</b>: all editors (catalog, filters, create modal, bulk modals) now follow the same pattern  Save (disabled until dirty), Cancel, and Delete (only for existing items). The old "Create X" buttons are replaced by a consistent "Save" button',
      '<b>Smart auto-ID from label</b>: typing a label auto-generates the ID in real time. Manually editing the ID stops the sync. Clearing the ID field re-derives it from the current label and resumes syncing. Works for all catalog items, filters, create modals, and transform param rows',
      '<b>Smart auto-abbreviation</b>: same sync logic applied to abbreviation fields  auto-fills from label, stops on manual edit, resumes on clear',
      '<b>Auto indicator badges</b>: a subtle blue <b>auto</b> pill appears next to ID and abbreviation fields when they are linked to the label. Disappears when manually overridden, reappears when cleared',
      '<b>Label validation</b>: all save handlers require a non-empty label  shows an alert and focuses the field if empty. Applies to tags, transforms, attributes, and filters',
      '<b>Dirty guards for new items</b>: cancelling or navigating away from an unsaved new item prompts "Discard new [kind]?" if the form has content, then removes the placeholder entry',
      '<b>Create modal dirty guards</b>: closing, cancelling, or clicking outside the create modal prompts if the form has content. Save button highlights when dirty',
      '<b>Bulk modal dirty tracking</b>: Apply buttons in bulk tag and bulk attribute modals now start inactive and highlight only when a change is made',
      '<b>Filter inline creation</b>: new filters start with an empty label and auto-generated ID, with the same Save/Cancel pattern and dirty guards as catalog items',
      '<b>ID regeneration on save</b>: saving any item with an empty ID field auto-generates the ID from the current label, whether the item is new or existing',
    ]
  },
  {
    version: '1.3.0',
    date: '2026-02-20',
    highlights: 'Multi-select with Ctrl+click, Shift+click range, bulk actions, and chain/direct arrow modes',
    changes: [
      '<b>Multi-select (Ctrl/Cmd+click)</b>: hold Ctrl (Cmd on Mac) and click nodes to add or remove them from a multi-selection. Works across columns',
      '<b>Shift+click range select</b>: hold Shift and click to select a range of visible nodes within the same column (from last clicked to current)',
      '<b>Alt+click chain select</b>: if the clicked node is connected to the current selection, adds it plus the entire path in between. If already selected or unconnected, adds the clicked node\u2019s full mapping chain',
      '<b>Directional chain select</b>: <b>Alt+Shift+click</b> selects upstream only (all sources), <b>Alt+Ctrl/Cmd+click</b> selects downstream only (all targets)',
      '<b>Marquee &amp; lasso select</b>: drag on empty viewer background to draw a selection rectangle. Hold Alt while dragging for freeform lasso. All nodes within the shape are selected. Hold Shift to add to existing selection, Ctrl/Cmd to subtract',
      '<b>Combined highlighting</b>: all selected nodes highlight their mapping chains simultaneously. Dimming, arrows, and chain-following work across the combined set',
      '<b>Highlight mode</b>: toggle between <b>Chain</b> (follow full mapping chain, default), <b>Direct</b> (show only immediate mappings), and <b>Selected</b> (highlight only the selection) in the Selection popover',
      '<b>Details panel summary</b>: when multiple nodes are selected, the details panel shows a count breakdown by type and column, mapping stats, and a scrollable node list',
      '<b>Bulk delete</b>: delete all selected nodes and their mappings with one click (undo supported)',
      '<b>Bulk tag assign</b>: add or remove tags across all selected nodes at once  checkboxes show current state (checked, unchecked, or indeterminate for partial)',
      '<b>Bulk set attribute</b>: set or clear a custom attribute value on all selected nodes',
      '<b>Bulk map to</b>: create mappings from all selected fields to a single target field  search by name or ID',
      '<b>Select all / Invert selection</b>: command palette commands to select all visible nodes or invert the current selection',
      '<b>Parameterized transforms</b>: transforms now support per-instance parameters. Catalog entries define a params schema (e.g. precision, fallback value, lookup table); each instance on a mapping can override the defaults. The same transform can be applied multiple times in a chain with different parameters',
      '<b>Transform params UI</b>: click a parameterized transform chip in the mapping editor to edit its parameters. Catalog editor now includes a params section to define parameter schemas (id, label, type, default)',
      '<b>Mapping color legend hover preview</b>: hovering any "Color mappings by" button temporarily shows its legend',
      '<b>Consistent context menu icons</b>: indent/outdent now use  /  (matching filter conditions), column move uses  / ',
    ]
  },
  {
    version: '1.2.5',
    date: '2026-02-20',
    highlights: 'Mapping dimming, visual adjacency, toolbar quick-actions, legend hover preview',
    changes: [
      '<b>Mapping dimming</b>: unrelated mappings now dim to match node dimming when a selection is active. Respects the 3-state dim mode (All / Parents / Off)',
      '<b>Active mapping z-ordering</b>: hovered or selected mappings always render on top of other mappings, fixing visual overlap in dense graphs',
      '<b>Visual column adjacency</b>: hidden columns are now skipped when calculating adjacency  two columns displayed side-by-side count as adjacent even if hidden columns exist between them',
      '<b>Node colors when dimmed</b>: custom node colors are now preserved (at reduced opacity) when dimmed instead of being stripped',
      '<b>Pan toggle button</b>:  four-way arrow icon in the toolbar for quick pan mode toggle',
      '<b>Clear selection button</b>:  icon in the toolbar to deselect  same as pressing Escape',
      '<b>Add column in Columns popover</b>: "Add column left/right" buttons moved into the Columns popover footer (editor mode)',
      '<b>Command palette background</b>: dark mode palette now uses a solid background matching other modals',
      '<b>Safari known limitation</b>: documented that drag-and-drop is not supported in Safari',
    ]
  },
  {
    version: '1.2.4',
    date: '2026-02-20',
    highlights: 'Command palette with fuzzy search for commands and nodes',
    changes: [
      '<b>Command palette</b>: press <b>Ctrl+K</b> (Cmd+K on Mac) or click the <b>&gt;_</b> button in the header to open a spotlight-style command bar',
      '<b>Fuzzy search</b>: type to filter all available commands (open catalogs, toggle modes, change panel layout, undo/redo, etc.) with match highlighting',
      '<b>Node search</b>: the palette also searches all nodes and fields by name or ID. Selecting a node expands parent groups, highlights it, and scrolls it into view',
      '<b>Keyboard navigation</b>:  to move, Enter to execute, Escape to close. Results grouped by Commands and Nodes & Fields',
      '<b>Shortcut hints</b>: commands show their keyboard shortcut when one exists (e.g. ?, D, Ctrl+Z)',
    ]
  },
  {
    version: '1.2.3',
    date: '2026-02-20',
    highlights: 'Custom attribute value colors with swatches, catalog overview color dots, create modal color picker',
    changes: [
      '<b>Attribute value color dots</b>: the Attributes catalog overview now shows a tiny colored dot next to each value that has a custom color assigned',
      '<b>Value editor color swatches</b>:  toggle button on each value row reveals a preset swatch panel (10 colors) for quick color selection  same pattern as the filter editor palette',
      '<b>Value color reset</b>:  icon next to each value\'s color picker clears the custom color and reverts to the uncolored default state',
      '<b>Create value modal color picker</b>: adding a new attribute value now includes the full color picker with swatches and hex input, auto-visible without a toggle.  reset icon included',
      '<b>Mapping coloring priority</b>: "Color mappings by" attribute modes use the value\'s custom color when set, falling back to the 20-color palette for uncolored values',
    ]
  },
  {
    version: '1.2.2',
    date: '2026-02-20',
    highlights: 'Highlight colors modal redesign with live preview, project JSON persistence, editor/viewer modes',
    changes: [
      '<b>Highlight colors modal redesign</b>: full editor workflow with Save / Cancel / Delete buttons matching the tag editor pattern. Close button in header with unsaved-changes guard',
      '<b>Project JSON persistence</b>: highlight colors saved as <code>_highlightColors</code> in project data  colors travel with the file. Omitted when defaults are active (clean JSON)',
      '<b>Live preview tester</b>: interactive source  target preview in the modal. Hover or click nodes and arrow to see exactly how chosen colors render for connected vs selected states',
      '<b>Editor / Viewer mode</b>: color pickers and swatches are read-only in Viewer mode with a hint to switch to Editor. Save/Cancel/Delete only appear in Editor mode',
      '<b>Delete with confirmation</b>: removes custom colors from project data and reverts to defaults with a confirm dialog',
      '<b>Per-row  reset</b>: inline reset icon per color row, sitting alongside swatches for quick default restore',
      '<b>Standard button styling</b>: Save uses <code>btnSave</code>/<code>btnDirty</code> classes (yellow highlight when dirty), Delete uses the standard pink border pattern',
    ]
  },
  {
    version: '1.2.1',
    date: '2026-02-20',
    highlights: 'Zoom slider, selection controls, highlight color customization, same-column arrow improvements',
    changes: [
      '<b>Zoom / density slider</b>: new Zoom control (50150%) in the Layout popover scales the entire viewer for fitting more or less content on screen. Persisted to localStorage with inline  reset',
      '<b>Dim mode selector</b>: "Dim others" replaced with a 3-mode icon selector: <b>All</b> (dim everything unselected), <b>Parents</b> (keep parent groups visible), <b>Off</b> (no dimming)',
      '<b>Dim unselected: Parents mode</b>: expanded parent groups of connected fields get a subtle blue highlight and remain visible. In All mode, only direct connections are shown. Collapsed groups are always highlighted regardless',
      '<b>Highlight mode: Selected</b>: limits highlighting to the directly selected node  suppresses the full mapping chain highlight and restricts which arrows are drawn',
      '<b>Adjacent highlight</b>: moved from Graph to Selection popover where it logically belongs',
      '<b>Highlight colors modal</b>: customize Connected (chain) and Selected (active) highlight colors via color picker and 10-color swatches',
      '<b>Mapping color scheme selector</b>: "Color mappings by" dropdown replaced with icon buttons matching the dock selector pattern  Off, Cardinality, Transform, Source tag, Target tag',
      '<b>Same-column arrows (rightmost)</b>: arrows in the rightmost column now loop to the left instead of right, preventing overflow clipping',
      '<b>Same-column sample mappings</b>: sample dataset now includes within-column mappings in Observatory and Science Lab',
      '<b>Collapse recalculates highlights</b>: toggling a group collapsed/expanded now recalculates highlight state correctly',
      '<b>CSS dim inheritance fix</b>: changed <code>.dimmed .row</code> to <code>.dimmed > .row</code> so dimmed parents no longer cascade to connected children',
      'Viewer right padding added for consistent spacing on the rightmost column border',
      'Arrow zoom compensation: coordinates divide by CSS zoom factor for correct alignment at any zoom level',
      'Documentation footer updated to match Quick Start Guide style with version number',
    ]
  },
  {
    version: '1.2.0',
    date: '2026-02-20',
    highlights: 'Dunnode rebrand, float panel overhaul, color picker UX, scroll/resize fixes',
    changes: [
      '<b>Rebrand to Dunnode</b>: new name, all-caps wordmark with tracking, tagline "Done. Now."',
      '<b>About modal</b>: new Help  About with branding, creator info, and contact',
      '<b>App footer</b>: persistent footer with copyright and version, visible in all panel dock modes',
      '<b>_app metadata</b>: JSON format changed from string to <code>{ name, version, schema }</code> object. Old files auto-migrated on load',
      '<b>Float panel overhaul</b>: top/left CSS anchoring (resize grows down-right naturally), custom corner resize handle with  indicator',
      '<b>6-dot drag grip</b>: float panel header shows a standard 23 dot grip icon instead of invisible drag bar',
      '<b>Pan mode (P key)</b>: toggle pan mode with P, cross-arrow cursor, drag to scroll viewport. Press P or Esc to exit',
      '<b>Resize handles</b>: thicker (14px), blue glow on hover, groove line indicator, follow cursor during drag',
      '<b>Color preset swatches</b>: inline row of 10 color swatches in node and mapping editors alongside the picker and Apply checkbox',
      '<b>Color persistence</b>: picker value preserved as <code>_pendingColor</code> when Apply is unchecked  survives save/reload',
      '<b>Tag manager color picker</b>: native <code>&lt;input type="color"&gt;</code> added alongside hex input and swatches, all bidirectionally synced',
      '<b>Filter mapping highlighting</b>: collapsed group arrows now inherit filter colors from constituent mappings',
      '<b>Live arrow redraw</b>: arrows update in real-time during bottom and side panel resize, not just on mouse-up',
      '<b>Scroll area fix</b>: SVG overlay no longer inflates scroll dimensions; ResizeObserver triggers redraw on any container resize',
      '<b>Details panel min-width</b>: increased to 360px to prevent UI collapse at narrow widths',
      '<b>Nested group support</b>: sample dataset includes SAMPLE_ANALYSIS nested group inside EXPERIMENT',
      '<b>Quick Start Guide</b>: updated with welcome message and closing tagline',
      '<b>Documentation</b>: updated JSON schema reference with new <code>_app</code> object format',
      'Sample project author changed to "Mars Systems Integration Team"',
      'Dirty detection now tracks color picker value independently of Apply checkbox state',
      'Project title input made smaller (14px) to give more visual weight to the app name',
    ]
  },
  {
    version: '1.1.1',
    date: '2026-02-19',
    highlights: 'Editor polish, new metadata fields, bug fixes',
    changes: [
      '<b>_app identity</b>: JSON files now include <code>_app: "Mapping Studio"</code> to identify the source application',
      '<b>Project properties</b>: added Contact and URL fields (URL renders as clickable link in details pane)',
      '<b>Filter ID field</b>: filter editor now has an editable ID field with conflict detection, matching tag/transform/attribute behavior. ID shown in viewer cards',
      '<b>Condition editor buttons</b>:     action buttons on each condition row and group header for move up, move down, indent into group, and outdent from group',
      '<b>Mapping color scheme palette</b>: extended from 10 to 20 distinct colors for better differentiation with many values',
      '<b>Catalog buttons hidden in viewer</b>: "Add tag/transform/attribute/filter" buttons are hidden in Viewer mode instead of showing an error',
      '<b>Toggle hover effect</b>: all toggle/checkbox controls now have hover highlighting in both dark and bright themes',
      '<b>Save button states</b>: Save buttons start greyed out (disabled appearance) when no changes are pending, including the Project Properties save button',
      'Mapping editor no longer shows false dirty state on open (undefined vs empty string normalization)',
      'Node and mapping color picker changes now correctly trigger dirty state on Save buttons',
      'New project / Load example / Open file now clears stale edit sessions, preventing phantom abandon-guard prompts',
      'Release notes now render HTML formatting (bold tags) correctly',
    ]
  },
  {
    version: '1.1.0',
    date: '2026-02-19',
    highlights: 'Filtering overhaul, unsaved-changes protection, UX polish',
    changes: [
      '<b>Filter system</b>: rule-based filters with recursive condition groups (AND/OR), priority ordering, and rich highlight styles (background, stripe, mapping color, frame, bold, emoji)',
      '<b>Filter catalog</b>: create, edit, reorder, delete filters with live preview. Priority-based evaluation with drag-and-drop and  button reordering',
      '<b>Filter bar</b>: toolbar toggle () with search input, Only mapped, display mode cycle, Filters AND/OR, Clear all, and active filter chips',
      '<b>Display mode cycle</b>: Hide  Dim  Highlight only. "Highlight only" keeps all nodes visible and just applies color styles to matches',
      '<b>Color palette</b>:  button in filter editor shows preset color swatches  click to apply to all enabled channels, or drag onto individual swatches',
      '<b>Unsaved-changes guard</b>: navigating away from edited nodes, columns, mappings, or catalog items prompts "Abandon unsaved changes?" Only fires when actual changes detected',
      '<b>Yellow Save buttons</b>: Save buttons turn gold when the form has pending changes vs. the snapshot. Reverts when user manually restores original values',
      '<b>Greyed-out catalog items</b>: while editing a tag/transform/attribute/filter, other items are dimmed and unclickable to prevent accidental switching',
      '<b>Details panel enhancements</b>: groups show rich Children cards with type, summary, tags, and attributes. Inbound/Outbound/Children sections are collapsible ( caret)',
      '<b>Undo/Redo guards</b>: Ctrl+Z/Y prompts if there are unsaved edits in the active editor before reverting state',
      '<b>EditorViewer mode guard</b>: switching to Viewer mode prompts if node or mapping edits are unsaved',
      '<b>Node ID dirty check</b>: changing a node or column ID field is now properly detected as a pending change',
      '<b>Node colors</b>: optional per-node color applied as subtle background tint on the viewer row. Shown in details pane. Overridden by filter/selection highlights',
      '<b>Mapping colors</b>: optional per-mapping color applied to arrow strokes. Filter mapping colors take priority, then custom mapping colors, then default',
      '<b>Color mappings by</b>: automatic arrow coloring by cardinality, first transform, source/target tag, or source/target custom attribute. Select in Graph popover; legend auto-generated',
      '<b>Selection dim toggle</b>: "Dim others" checkbox in Selection popover  uncheck to keep all nodes at full opacity when something is selected',
      '<b>Color palette</b>:  button in filter editor shows 10 preset swatches with drag-to-swatch and click-to-apply-all-channels',
      '<b>Condition DnD</b>: drag  handles in the filter condition editor to reorder conditions, move between groups, or indent into a group',
      'Rephrased "new project" and "load example" confirmation prompts to be clearer',
      'Filter AND/OR toggle relabeled to "Filters: AND" to clarify it only affects filters (search is always ANDed)',
      'Context menu toggle fix for column and node  buttons',
      'Escape key now cancels column edits and mapping drafts (previously only handled node edits)',
      'Indent/outdent now correctly preserves mappings by passing state.data to replaceIdsInMappings',
      'Filter badge (Escape) correctly resets to 0',
    ]
  },
  {
    version: '1.0.0',
    date: '2026-02-18',
    highlights: 'Initial release',
    changes: [
      'Multi-column schema viewer with nested tree structure and collapsible groups',
      'Bezier curve arrows across adjacent and non-adjacent columns with virtual edge discovery',
      'Full inline editor: create, edit, delete, move, indent/outdent nodes and columns',
      'Drag-and-drop support for nodes and columns',
      'Mapping editor with cardinality, default values, notes, and ordered transforms',
      'Tag catalog with color-coded chips, abbreviations, notes, and drag-to-reorder priority',
      'Transform catalog with abbreviations and notes',
      'Custom attribute catalog with multi/single-value modes and per-value notes',
      'All entity IDs independently editable with cascading rename across the full data model',
      'Hierarchical node IDs with auto-calculated path prefix and editable local segment',
      'Undo/redo with snapshot-based dirty tracking (save button reflects true state)',
      'Project properties modal: title, subtitle, author, organization, contact, URL, version, date, description',
      'App version and save timestamp stamped into JSON on every save',
      'Bright/dark mode with comprehensive theme coverage',
      'Column visibility controls, reordering, wrap mode for screenshots',
      'Arrow display modes: all, adjacent-only, highlight-only; plus adjacent-only highlight mode',
      'Details panel showing node metadata, mapping details, and project summary',
      'Tooltips on hover for nodes, mappings, and virtual mappings through hidden columns',
      'Context menus for columns and nodes with full action set',
      'CSV export of visible edges and HTML report export with embedded JSON',
      'Search/filter by text, filter by unmapped fields',
      'Inline Quick help, comprehensive Documentation page, and Release notes',
      'Sample dataset: Mars mission data pipeline across 5 systems (31 mappings, 3 tags, 8 transforms, 2 custom attributes)',
      'Keyboard shortcuts: Escape to deselect, ? for help, Ctrl+Z/Y for undo/redo',
    ]
  }
];

function openReleaseNotes(){
  const rnBody = document.getElementById('releaseNotesBody');
  const rnMask = document.getElementById('releaseNotesMask');
  const rnModal = document.getElementById('releaseNotesModal');
  if(!rnBody || !rnMask || !rnModal) return;

  const html = RELEASE_NOTES.map(r=>{
    const items = r.changes.map(c=>`<li>${c}</li>`).join('');
    return `<div style="margin-bottom:20px;">
      <h3 style="margin:0 0 4px 0;">v${escapeHtml(r.version)} <span style="font-weight:400;font-size:12px;opacity:.5;">${escapeHtml(r.date)}</span></h3>
      ${r.highlights ? `<p style="margin:0 0 8px 0;font-size:13px;font-style:italic;opacity:.7;">${escapeHtml(r.highlights)}</p>` : ''}
      <ul style="margin:0 0 0 18px;font-size:12.5px;line-height:1.65;">${items}</ul>
    </div>`;
  }).join('');

  rnBody.innerHTML = html;
  rnMask.classList.add('active');
  rnModal.classList.add('active');
}

function closeReleaseNotes(){
  const rnMask = document.getElementById('releaseNotesMask');
  const rnModal = document.getElementById('releaseNotesModal');
  if(rnMask) rnMask.classList.remove('active');
  if(rnModal) rnModal.classList.remove('active');
}

{
  const rnBtn = document.getElementById('releaseNotesBtn');
  const rnClose = document.getElementById('closeReleaseNotesBtn');
  const rnMask = document.getElementById('releaseNotesMask');
  if(rnBtn) rnBtn.addEventListener('click', openReleaseNotes);
  if(rnClose) rnClose.addEventListener('click', closeReleaseNotes);
  if(rnMask) rnMask.addEventListener('click', closeReleaseNotes);
  document.addEventListener('keydown', (e)=>{
    if(e.key==='Escape'){
      const docsM = document.getElementById('docsModal');
      if(docsM && docsM.classList.contains('active')){ e.preventDefault(); closeDocs(); return; }
      const rnModal = document.getElementById('releaseNotesModal');
      if(rnModal && rnModal.classList.contains('active')){ e.preventDefault(); closeReleaseNotes(); return; }
      const aboutM = document.getElementById('aboutModal');
      if(aboutM && aboutM.classList.contains('active')){ e.preventDefault(); closeAbout(); }
    }
  });

  // About modal
  const aboutBtn = document.getElementById('aboutBtn');
  const aboutModal = document.getElementById('aboutModal');
  const aboutMask = document.getElementById('aboutMask');
  const aboutClose = document.getElementById('aboutClose');
  function openAbout(){ aboutModal?.classList.add('active'); aboutMask?.classList.add('active'); const av=document.getElementById('aboutVersion'); if(av) av.textContent='v'+APP_VERSION; }
  function closeAbout(){ aboutModal?.classList.remove('active'); aboutMask?.classList.remove('active'); }
  if(aboutBtn){
    aboutBtn.addEventListener('click', ()=>{
      openAbout();
      // Close the help popover
      document.querySelectorAll('.tbPop').forEach(p => p.classList.remove('open'));
      document.querySelectorAll('.tbBtn').forEach(b => b.classList.remove('active'));
    });
  }
  if(aboutClose) aboutClose.addEventListener('click', closeAbout);
  if(aboutMask) aboutMask.addEventListener('click', closeAbout);
}

// --- Highlight colors modal ---
const HL_DEFAULTS = { connected: '#3b82f6', active: '#ffd05c' };
const HL_SWATCHES = [
  '#3b82f6','#06b6d4','#8b5cf6','#ec4899','#ef4444',
  '#f97316','#eab308','#22c55e','#14b8a6','#6366f1'
];
let __hlSnapshot = null; // { connected, active } at modal open

function hexToRgb(hex){
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return { r, g, b };
}

function applyHlCssVars(connHex, actHex){
  const root = document.documentElement;
  const c = hexToRgb(connHex);
  const a = hexToRgb(actHex);
  root.style.setProperty('--hl-bg', `rgba(${c.r},${c.g},${c.b},0.22)`);
  root.style.setProperty('--hl-br', `rgba(${c.r},${c.g},${c.b},0.88)`);
  root.style.setProperty('--line-hl', `rgba(${c.r},${c.g},${c.b},0.92)`);
  root.style.setProperty('--active-bg', `rgba(${a.r},${a.g},${a.b},0.26)`);
  root.style.setProperty('--active-br', `rgba(${a.r},${a.g},${a.b},0.78)`);
  root.style.setProperty('--line-active', `rgba(${a.r},${a.g},${a.b},0.95)`);
}

function getHlFromData(){
  const d = state.data?._highlightColors;
  return { connected: d?.connected || HL_DEFAULTS.connected, active: d?.active || HL_DEFAULTS.active };
}

function syncHlPickerUI(connHex, actHex){
  const cp = document.getElementById('hlConnectedPicker');
  const ap = document.getElementById('hlActivePicker');
  if(cp) cp.value = connHex;
  if(ap) ap.value = actHex;
  ['hlConnectedSwatches','hlActiveSwatches'].forEach((id, i)=>{
    const c = document.getElementById(id);
    if(!c) return;
    const hex = i === 0 ? connHex : actHex;
    c.querySelectorAll('.swatch').forEach(s => s.classList.toggle('sel', s.dataset.color === hex));
  });
}

function hlColorsIsDirty(){
  if(!__hlSnapshot) return false;
  const cp = document.getElementById('hlConnectedPicker');
  const ap = document.getElementById('hlActivePicker');
  return (cp?.value || HL_DEFAULTS.connected) !== __hlSnapshot.connected ||
         (ap?.value || HL_DEFAULTS.active) !== __hlSnapshot.active;
}

function hlUpdateSaveBtnState(){
  const saveBtn = document.getElementById('hlColorsSave');
  if(!saveBtn) return;
  saveBtn.classList.toggle('btnDirty', hlColorsIsDirty());
}

function restoreHlColors(){
  const hl = getHlFromData();
  applyHlCssVars(hl.connected, hl.active);
  syncHlPickerUI(hl.connected, hl.active);
  try {
    localStorage.setItem('ms_hlConnected', hl.connected);
    localStorage.setItem('ms_hlActive', hl.active);
  } catch(e){}
}

{
  const hlModal = document.getElementById('hlColorsModal');
  const hlMask = document.getElementById('hlColorsMask');
  const hlOpenBtn = document.getElementById('hlColorsBtn');
  const hlCloseBtn = document.getElementById('hlColorsClose');
  const hlSaveBtn = document.getElementById('hlColorsSave');
  const hlCancelBtn = document.getElementById('hlColorsCancel');
  const hlDeleteBtn = document.getElementById('hlColorsDelete');
  const hlConnPicker = document.getElementById('hlConnectedPicker');
  const hlActPicker = document.getElementById('hlActivePicker');
  const hlConnSwatches = document.getElementById('hlConnectedSwatches');
  const hlActSwatches = document.getElementById('hlActiveSwatches');
  const hlConnReset = document.getElementById('hlConnectedReset');
  const hlActReset = document.getElementById('hlActiveReset');

  function openHlColors(){
    const isEditor = state.editorMode;
    // Show/hide editor actions and viewer hint
    document.getElementById('hlColorsEditorActions').style.display = isEditor ? '' : 'none';
    document.getElementById('hlViewerHint').style.display = isEditor ? 'none' : '';
    // Disable/enable inputs
    const body = document.getElementById('hlColorsBody');
    body.querySelectorAll('input[type=color]').forEach(i=>{ i.disabled = !isEditor; i.style.opacity = isEditor ? '1' : '.5'; });
    body.querySelectorAll('.swatch').forEach(s=>{ s.style.pointerEvents = isEditor ? '' : 'none'; s.style.opacity = isEditor ? '1' : '.5'; });
    body.querySelectorAll('.hlEditOnly').forEach(el=>{ el.style.display = isEditor ? '' : 'none'; });
    // Take snapshot
    const hl = getHlFromData();
    __hlSnapshot = { connected: hl.connected, active: hl.active };
    syncHlPickerUI(hl.connected, hl.active);
    applyHlCssVars(hl.connected, hl.active);
    hlUpdateSaveBtnState();
    if(typeof hlTesterFullReset === 'function') hlTesterFullReset();
    hlModal?.classList.add('active');
    hlMask?.classList.add('active');
  }

  async function closeHlColors(force){
    if(!force && state.editorMode && hlColorsIsDirty()){
      const ok = await customConfirm('Abandon unsaved highlight color changes?');
      if(!ok) return;
      // Revert CSS to snapshot
      applyHlCssVars(__hlSnapshot.connected, __hlSnapshot.active);
      syncHlPickerUI(__hlSnapshot.connected, __hlSnapshot.active);
    } else if(!force && __hlSnapshot){
      // Viewer mode or no changes: still revert preview
      applyHlCssVars(__hlSnapshot.connected, __hlSnapshot.active);
      syncHlPickerUI(__hlSnapshot.connected, __hlSnapshot.active);
    }
    __hlSnapshot = null;
    hlModal?.classList.remove('active');
    hlMask?.classList.remove('active');
  }

  function hlPreview(){
    const conn = hlConnPicker?.value || HL_DEFAULTS.connected;
    const act = hlActPicker?.value || HL_DEFAULTS.active;
    applyHlCssVars(conn, act);
    hlUpdateSaveBtnState();
  }

  function hlPickSwatch(container, picker, hex){
    if(picker) picker.value = hex;
    if(container) container.querySelectorAll('.swatch').forEach(s => s.classList.toggle('sel', s.dataset.color === hex));
    hlPreview();
  }

  if(hlOpenBtn) hlOpenBtn.addEventListener('click', openHlColors);
  if(hlCloseBtn) hlCloseBtn.addEventListener('click', ()=> closeHlColors());
  if(hlMask) hlMask.addEventListener('click', ()=> closeHlColors());
  document.addEventListener('keydown', e=>{ if(e.key==='Escape' && hlModal?.classList.contains('active')) closeHlColors(); });

  // Save: persist to project data + close
  if(hlSaveBtn) hlSaveBtn.addEventListener('click', ()=>{
    const conn = hlConnPicker?.value || HL_DEFAULTS.connected;
    const act = hlActPicker?.value || HL_DEFAULTS.active;
    if(state.data){
      recordChange();
      if(conn === HL_DEFAULTS.connected && act === HL_DEFAULTS.active){
        delete state.data._highlightColors;
      } else {
        state.data._highlightColors = { connected: conn, active: act };
      }
    }
    try {
      localStorage.setItem('ms_hlConnected', conn);
      localStorage.setItem('ms_hlActive', act);
    } catch(e){}
    __hlSnapshot = { connected: conn, active: act };
    checkDirtyState();
    closeHlColors(true);
  });

  // Cancel: revert to snapshot + close
  if(hlCancelBtn) hlCancelBtn.addEventListener('click', ()=>{
    if(__hlSnapshot){
      applyHlCssVars(__hlSnapshot.connected, __hlSnapshot.active);
      syncHlPickerUI(__hlSnapshot.connected, __hlSnapshot.active);
    }
    __hlSnapshot = null;
    hlModal?.classList.remove('active');
    hlMask?.classList.remove('active');
  });

  // Delete: remove from data, revert to defaults
  if(hlDeleteBtn) hlDeleteBtn.addEventListener('click', async ()=>{
    const ok = await customConfirm('Remove custom highlight colors and revert to defaults?');
    if(!ok) return;
    recordChange();
    if(state.data) delete state.data._highlightColors;
    applyHlCssVars(HL_DEFAULTS.connected, HL_DEFAULTS.active);
    syncHlPickerUI(HL_DEFAULTS.connected, HL_DEFAULTS.active);
    try { localStorage.removeItem('ms_hlConnected'); localStorage.removeItem('ms_hlActive'); } catch(e){}
    __hlSnapshot = { connected: HL_DEFAULTS.connected, active: HL_DEFAULTS.active };
    checkDirtyState();
    closeHlColors(true);
  });

  // Live preview on picker change
  if(hlConnPicker) hlConnPicker.addEventListener('input', hlPreview);
  if(hlActPicker) hlActPicker.addEventListener('input', hlPreview);

  // Per-row resets
  if(hlConnReset) hlConnReset.addEventListener('click', ()=> hlPickSwatch(hlConnSwatches, hlConnPicker, HL_DEFAULTS.connected));
  if(hlActReset) hlActReset.addEventListener('click', ()=> hlPickSwatch(hlActSwatches, hlActPicker, HL_DEFAULTS.active));

  // Build swatches
  function buildHlSwatches(container, picker){
    if(!container) return;
    container.innerHTML = '';
    HL_SWATCHES.forEach(hex=>{
      const s = document.createElement('div');
      s.className = 'swatch';
      s.dataset.color = hex;
      s.style.cssText = 'width:18px;height:18px;border-radius:6px;flex-shrink:0;cursor:pointer;border:1px solid rgba(255,255,255,.12);transition:transform .1s;box-shadow:0 2px 8px rgba(0,0,0,.2);';
      s.style.background = hex;
      s.title = hex;
      s.addEventListener('click', ()=> hlPickSwatch(container, picker, hex));
      container.appendChild(s);
    });
  }

  buildHlSwatches(hlConnSwatches, hlConnPicker);
  buildHlSwatches(hlActSwatches, hlActPicker);

  // --- Tester preview ---
  let __hlTesterLocked = null; // null | 'source' | 'target' | 'edge'
  function hlTesterFullReset(){
    __hlTesterLocked = null;
    hlTesterApplyState(null);
  }
  function hlTesterApplyState(focus){
    // focus: null | 'source' | 'target' | 'edge'
    const src = document.getElementById('hlTesterSource');
    const tgt = document.getElementById('hlTesterTarget');
    const al = document.getElementById('hlTesterLine');
    const ah = document.getElementById('hlTesterHead');
    if(!focus){
      // Default: everything neutral
      if(src){ src.style.background = 'var(--panel)'; src.style.borderColor = 'var(--border)'; }
      if(tgt){ tgt.style.background = 'var(--panel)'; tgt.style.borderColor = 'var(--border)'; }
      if(al){ al.style.stroke = 'var(--line)'; } if(ah){ ah.style.fill = 'var(--line)'; }
    } else if(focus === 'source' || focus === 'target'){
      // Hover/click node: that node = active, other + edge = connected
      const act = focus === 'source' ? src : tgt;
      const conn = focus === 'source' ? tgt : src;
      if(act){ act.style.background = 'var(--active-bg)'; act.style.borderColor = 'var(--active-br)'; }
      if(conn){ conn.style.background = 'var(--hl-bg)'; conn.style.borderColor = 'var(--hl-br)'; }
      if(al){ al.style.stroke = 'var(--line-hl)'; } if(ah){ ah.style.fill = 'var(--line-hl)'; }
    } else if(focus === 'edge'){
      // Hover/click edge: edge = active, both nodes = active
      if(src){ src.style.background = 'var(--active-bg)'; src.style.borderColor = 'var(--active-br)'; }
      if(tgt){ tgt.style.background = 'var(--active-bg)'; tgt.style.borderColor = 'var(--active-br)'; }
      if(al){ al.style.stroke = 'var(--line-active)'; } if(ah){ ah.style.fill = 'var(--line-active)'; }
    }
  }
  {
    const testerSrc = document.getElementById('hlTesterSource');
    const testerTgt = document.getElementById('hlTesterTarget');
    const testerArrow = document.getElementById('hlTesterArrow');

    [['source', testerSrc], ['target', testerTgt], ['edge', testerArrow]].forEach(([which, el]) => {
      if(!el) return;
      el.addEventListener('mouseenter', ()=>{
        if(!__hlTesterLocked) hlTesterApplyState(which);
      });
      el.addEventListener('mouseleave', ()=>{
        if(!__hlTesterLocked) hlTesterApplyState(null);
      });
      el.addEventListener('click', ()=>{
        if(__hlTesterLocked === which){ __hlTesterLocked = null; hlTesterApplyState(null); }
        else { __hlTesterLocked = which; hlTesterApplyState(which); }
      });
    });
  }

  // Initial restore
  try {
    const sc = localStorage.getItem('ms_hlConnected');
    const sa = localStorage.getItem('ms_hlActive');
    if(sc || sa) applyHlCssVars(sc || HL_DEFAULTS.connected, sa || HL_DEFAULTS.active);
  } catch(e){}
}

// Set version label in header
{ const vl = document.getElementById('appVersionLabel'); if(vl) vl.textContent = 'v' + APP_VERSION; }

// Patch tooltips with platform-specific modifier keys
{
  if(_isMac){
    document.querySelectorAll('[title]').forEach(el => {
      let t = el.title;
      if(t.includes('Ctrl+') || t.includes('Alt+')){
        t = t.replace(/Ctrl\+Alt\+/g, '\u2318\u2325').replace(/Ctrl\+/g, '\u2318').replace(/Alt\+/g, '\u2325');
        el.title = t;
      }
    });
  }
}
{ const fl = document.getElementById('footerLicenseLink'); if(fl) fl.addEventListener('click', e => { e.preventDefault(); openDocs(); requestAnimationFrame(()=>{ const t = docsBody.querySelector('#doc-license'); if(t) t.scrollIntoView({ behavior:'smooth', block:'start' }); }); }); }
{ const al = document.getElementById('aboutLicenseLink'); if(al) al.addEventListener('click', e => { e.preventDefault(); closeAbout(); openDocs(); requestAnimationFrame(()=>{ const t = docsBody.querySelector('#doc-license'); if(t) t.scrollIntoView({ behavior:'smooth', block:'start' }); }); }); }


// --- Tag manager modal ---
// Catalog edit state (shared across all managers)
let __catalogEdit = { kind: null, idx: -1, snapshot: null, isNew: false };

function catalogEditBegin(kind, idx, snapshot, isNew){
  __catalogEdit = { kind, idx, snapshot: JSON.parse(JSON.stringify(snapshot)), isNew: !!isNew };
}
function catalogEditEnd(){
  __catalogEdit = { kind: null, idx: -1, snapshot: null, isNew: false };
}
function catalogIsEditing(kind, idx){
  return __catalogEdit.kind === kind && __catalogEdit.idx === idx;
}

// --- Dirty checking for catalog edit forms ---
function catalogFormIsDirty(){
  if(!__catalogEdit.kind || __catalogEdit.idx < 0 || !__catalogEdit.snapshot) return false;
  const snap = __catalogEdit.snapshot;
  const kind = __catalogEdit.kind;
  let containerId = kind==='tag' ? 'tagsBody' : kind==='transform' ? 'transformsBody' : kind==='attr' ? 'customAttrsBody' : null;
  if(!containerId) return false;
  const card = document.querySelector(`#${containerId} .catEditing`);
  if(!card) return false;
  const fields = card.querySelectorAll('.inp[data-f]');
  for(const f of fields){
    const key = f.dataset.f;
    if(key === 'colorSwatches') continue;
    // For new items, skip ID comparison (ID is auto-generated)
    if(key === 'id' && __catalogEdit.isNew) continue;
    const current = (f.value||'').trim();
    const original = String(snap[key]||'').trim();
    if(current !== original) return true;
  }
  // For transforms, also check param schema changes (add/remove/edit params)
  if(kind === 'transform'){
    const paramRows = card.querySelectorAll('.trParamRow');
    const currentParams = [];
    paramRows.forEach(row => {
      let pid = (row.querySelector('[data-pf="id"]')?.value||'').trim();
      const plabel = (row.querySelector('[data-pf="label"]')?.value||'').trim();
      const ptype = row.querySelector('[data-pf="type"]')?.value || 'text';
      const pdef = (row.querySelector('[data-pf="default"]')?.value||'').trim();
      if(!pid && plabel) pid = transliterate(plabel).toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
      if(pid) currentParams.push({ id: pid, label: plabel || pid, type: ptype, ...(pdef !== '' ? { default: ptype === 'number' ? Number(pdef) : pdef } : {}) });
    });
    const origParams = snap.params || [];
    if(JSON.stringify(currentParams) !== JSON.stringify(origParams)) return true;
  }
  // For attrs, also check in-place value changes, checkboxes, and displayOnNode
  if(kind === 'attr'){
    const cat = ensureCustomAttributeCatalog();
    const item = cat[__catalogEdit.idx];
    // Structural changes (add/remove values, priority reorder) are reflected in item.values
    if(item && (item.values||[]).length !== (snap.values||[]).length) return true;
    if(item && JSON.stringify((item.values||[]).map(v=>v.priority)) !== JSON.stringify((snap.values||[]).map(v=>v.priority))) return true;
    // Read DOM inputs for each value row to detect label/id/abbr/note/color edits
    const card2 = document.querySelector(`#customAttrsBody .catEditing`);
    if(card2){
      const origVals = snap.values || [];
      const valRows = card2.querySelectorAll('.attrValRow');
      for(const row of valRows){
        const vi = Number(row.dataset.vi);
        const ov = origVals[vi];
        if(!ov) return true; // new value added
        const curLabel = (row.querySelector('[data-vf="vlabel"]')?.value||'').trim();
        const curId = (row.querySelector('[data-vf="vid"]')?.value||'').trim();
        const curAbbr = (row.querySelector('[data-vf="vabbr"]')?.value||'').trim();
        const curNote = (row.querySelector('[data-vf="vnote"]')?.value||'').trim();
        if(curLabel !== (ov.label||'').trim()) return true;
        if(curId !== (ov.id||'').trim()) return true;
        if(curAbbr !== (ov.abbr||'').trim()) return true;
        if(curNote !== (ov.note||'').trim()) return true;
        // Emoji and display mode
        const curEmoji = (row.querySelector('[data-vf="vemoji"]')?.value||'').trim();
        if(curEmoji !== (ov.emoji||'').trim()) return true;
        const curDm = row.querySelector('.valDmBtn')?.dataset?.vdm || 'abbr';
        if(curDm !== (ov.displayMode||'abbr')) return true;
        // Color change via DOM checkbox and live object
        const curColorOn = row.querySelector('[data-vf="vcolorOn"]')?.checked;
        const origColorOn = ov.color ? (ov.colorEnabled !== false) : false;
        if(!!curColorOn !== !!origColorOn) return true;
        const curColor = item?.values?.[vi]?.color || '';
        const origColor = ov.color || '';
        if(curColor !== origColor) return true;
        // Auto-link state change
        if((row.dataset.autoId === '1') !== !!ov._autoId) return true;
        if((row.dataset.autoAbbr === '1') !== !!ov._autoAbbr) return true;
      }
      const multiCb = card2.querySelector('[data-f="multi"]');
      const displayCb = card2.querySelector('[data-f="displayOnNode"]');
      if(multiCb && !!multiCb.checked !== !!snap.multi) return true;
      if(displayCb && !!displayCb.checked !== !!snap.displayOnNode) return true;
      // Attribute-level color
      const attrColorPicker = card2.querySelector('[data-f="attrColorPicker"]');
      const attrColorOn = card2.querySelector('[data-f="attrColorOn"]');
      const origAttrColorOn = snap.color ? (snap.colorEnabled !== false) : false;
      if(attrColorOn && !!attrColorOn.checked !== !!origAttrColorOn) return true;
      if(attrColorPicker){
        const origAttrColor = snap.color || '#6b7280';
        if(attrColorPicker.value !== origAttrColor) return true;
      }
    }
  }
  // Auto-link state change
  if(__editorAutoId !== !!snap._autoId) return true;
  if(__editorAutoAbbr !== !!snap._autoAbbr) return true;
  // Display mode change (emoji vs abbr)
  if(__editorDisplayMode !== (snap.displayMode || 'abbr')) return true;
  // Tags-on-tags change
  const currentTags = _readCatTags(card);
  const origTags = snap.tags || [];
  if(JSON.stringify(currentTags) !== JSON.stringify(origTags)) return true;
  // metaOnly checkbox (tags only)
  if(kind === 'tag'){
    const metaCb = card.querySelector('[data-f="metaOnly"]');
    if(metaCb && !!metaCb.checked !== !!snap.metaOnly) return true;
  }
  return false;
}

// --- Dirty checking for filter edit ---
let __filterEditSnapshot = null;
function filterFormIsDirty(){
  if(!__filterEditId || !__filterEditSnapshot) return false;
  const cat = ensureFilterCatalog();
  const f = cat.find(x => x.id === __filterEditId);
  if(!f) return false;
  const snap = JSON.parse(__filterEditSnapshot);
  // Rules are modified in-place on the filter object
  if(JSON.stringify(f.rules||[]) !== JSON.stringify(snap.rules||[])) return true;
  // Form fields are not yet written back  check the DOM
  const card = document.querySelector('.filterEditCard');
  if(card){
    const curId = sanitizeManualId(card.querySelector('.feId')?.value||'');
    if(curId && curId !== (snap.id||'')) return true;
    if((card.querySelector('.feLabel')?.value||'').trim() !== (snap.label||'')) return true;
    if((card.querySelector('.feNote')?.value||'').trim() !== (snap.note||'')) return true;
    const hl = snap.highlight || {};
    if((card.querySelector('.feBg')?.value||'') !== (hl.bg||'')) return true;
    if((card.querySelector('.feBorder')?.value||'') !== (hl.border||'')) return true;
    if((card.querySelector('.feEdge')?.value||'') !== (hl.edgeColor||'')) return true;
    if((card.querySelector('.feFrameColor')?.value||'') !== (hl.frameColor||'')) return true;
    if(!!card.querySelector('.feBgOn')?.checked !== !!hl.bgEnabled) return true;
    if(!!card.querySelector('.feBorderOn')?.checked !== !!hl.borderEnabled) return true;
    if(!!card.querySelector('.feEdgeOn')?.checked !== !!hl.edgeEnabled) return true;
    if(!!card.querySelector('.feBold')?.checked !== !!hl.bold) return true;
    if(!!card.querySelector('.feFrame')?.checked !== !!hl.frame) return true;
    if((card.querySelector('.feEmoji')?.value||'').trim() !== (hl.emoji||'')) return true;
    // Auto-link state change
    if(card.__filterAutoId && card.__filterAutoId() !== !!snap._autoId) return true;
  }
  return false;
}

// --- Dirty checking for node/column edit ---
function nodeEditIsDirty(){
  if(!__editSnapshot || !__editSnapshot.data) return false;
  const { kind, id, data } = __editSnapshot;
  if(kind === 'column'){
    const col = findColumnById(id);
    if(!col) return false;
    const labelInp = document.getElementById('colLabel');
    const noteInp = document.getElementById('colNote');
    const idInp = document.getElementById('colId');
    // If DOM elements don't exist (editor was unmounted), can't be dirty
    if(!labelInp && !noteInp && !idInp) return false;
    if(labelInp && labelInp.value.trim() !== (data.label||'')) return true;
    if(noteInp && noteInp.value.trim() !== (data.note||'')) return true;
    if(idInp && idInp.value.trim() !== (data.id||'')) return true;
    if(__editorAutoId !== !!data._autoId) return true;
    // Color dirty check
    const colColorOnEl = document.getElementById('colColorOn');
    const colColorEl = document.getElementById('colColor');
    if(!colColorOnEl || !colColorEl) return false; // editor not mounted
    const colColorOn = colColorOnEl.checked;
    const colColorVal = colColorEl.value || '#3b82f6';
    const origColColor = data.color || '';
    const origColPickerVal = origColColor || data._pendingColor || '#3b82f6';
    if(colColorOn !== !!origColColor) return true;
    if(colColorVal !== origColPickerVal) return true;
    return false;
  } else if(kind === 'node'){
    const node = IDX?.nodeById?.get(id);
    if(!node) return false;
    const labelInp = document.getElementById('ndLabel');
    const noteInp = document.getElementById('ndNote');
    const idInp = document.getElementById('ndId');
    if(labelInp && labelInp.value.trim() !== (data.label||'')) return true;
    if(noteInp && noteInp.value.trim() !== (data.note||'')) return true;
    if(idInp){
      const origLocal = localIdSegment(data.id || id);
      if(idInp.value.trim() !== origLocal) return true;
    }
    if(__editorAutoId !== !!data._autoId) return true;
    const curTags = Array.isArray(node.tags) ? [...node.tags].sort().join(',') : '';
    const snapTags = Array.isArray(data.tags) ? [...data.tags].sort().join(',') : '';
    if(curTags !== snapTags) return true;
    // Color dirty check  detect picker change OR checkbox toggle independently
    const colorOn = document.getElementById('ndColorOn')?.checked;
    const colorVal = document.getElementById('ndColor')?.value || '#3b82f6';
    const origColor = data.color || '';
    const origPickerVal = origColor || data._pendingColor || '#3b82f6';
    if(colorOn !== !!origColor) return true;       // checkbox toggled
    if(colorVal !== origPickerVal) return true;     // picker value changed
    if(JSON.stringify(node.customAttributes||{}) !== JSON.stringify(data.customAttributes||{})) return true;
    return false;
  }
  return false;
}

// --- Generic abandon guard ---
async function guardAbandonEdit(label, id){
  const display = label ? `"${label}"` : '';
  // Strip internal edge counter prefix (e.g. "e23:fromto"  "from  to")
  let cleanId = id || '';
  if(/^e\d+:/.test(cleanId)) cleanId = cleanId.replace(/^e\d+:/, '').replace(//g, '  ');
  const idStr = cleanId ? ` (${cleanId})` : '';
  return await customConfirm(`Abandon unsaved changes on ${display}${idStr}?`);
}

// --- Guard for catalog edits ---
async function guardCatalogAbandon(){
  if(__catalogEdit.isNew){
    // New item that was never saved  always prompt if dirty, remove on abandon
    if(catalogFormIsDirty()){
      const ok = await customConfirm('Discard new ' + (CREATE_KIND_LABELS[__catalogEdit.kind] || __catalogEdit.kind || 'item') + '?');
      if(!ok) return false;
    }
    // Remove the unsaved new entry
    _removeCatalogNewEntry();
    catalogEditEnd();
    return true;
  }
  if(!catalogFormIsDirty()) return true;
  const snap = __catalogEdit.snapshot;
  const label = snap?.label || snap?.id || __catalogEdit.kind;
  const ok = await guardAbandonEdit(label, snap?.id);
  if(ok && __catalogEdit.kind === 'attr' && __catalogEdit.idx >= 0 && snap){
    // Revert in-place changes (values array, multi flag)
    const cat = ensureCustomAttributeCatalog();
    const item = cat[__catalogEdit.idx];
    if(item){
      item.values = snap.values ? JSON.parse(JSON.stringify(snap.values)) : [];
      item.multi = !!snap.multi;
    }
  }
  return ok;
}

function _removeCatalogNewEntry(){
  const { kind, idx } = __catalogEdit;
  if(idx < 0) return;
  if(kind === 'tag'){
    ensureTagCatalog().splice(idx, 1);
  } else if(kind === 'transform'){
    ensureTransformCatalog().splice(idx, 1);
  } else if(kind === 'attr'){
    ensureCustomAttributeCatalog().splice(idx, 1);
  }
}

function _wireLabelToId(card, kind, dataObj){
  const labelInp = card.querySelector('[data-f="label"]');
  const idInp = card.querySelector('[data-f="id"]');
  const abbrInp = card.querySelector('[data-f="abbr"]');
  if(!labelInp || !idInp) return;
  const isNew = __catalogEdit.isNew;

  const slugify = (raw)=>{
    if(kind === 'tag') return slugifyTagLabel(raw);
    if(kind === 'transform') return slugifyTransformLabel(raw);
    return idPartFromLabel(raw, {lower:true});
  };
  const autoAbbr = (raw)=>{
    if(kind === 'tag') return raw ? raw.slice(0,1).toUpperCase() : '';
    return raw ? raw.replace(/\s+/g,'').slice(0,2).toUpperCase() : '';
  };

  const idAutoTag = card.querySelector('[data-auto="id"]');
  const abbrAutoTag = card.querySelector('[data-auto="abbr"]');

  // Determine initial auto state from persisted flag  use actual ID value for backward compat
  const initIdLocal = idInp.value.trim();
  let lastAutoId = (dataObj && dataObj._autoId) ? initIdLocal : '';
  __editorAutoId = lastAutoId !== '';

  let lastAutoAbbr = '';
  if(abbrInp){
    const initAbbrLocal = abbrInp.value.trim();
    lastAutoAbbr = (dataObj && dataObj._autoAbbr) ? initAbbrLocal : '';
  }
  __editorAutoAbbr = lastAutoAbbr !== '';

  const refreshTags = ()=>{
    if(idAutoTag){ const on = lastAutoId !== ''; idAutoTag.style.display = on ? '' : 'none'; idAutoTag.classList.toggle('clickable', on); }
    if(abbrAutoTag){ const on = lastAutoAbbr !== ''; abbrAutoTag.style.display = on ? '' : 'none'; abbrAutoTag.classList.toggle('clickable', on); }
  };
  refreshTags();
  if(idAutoTag){ idAutoTag.title = 'Click to freeze ID'; idAutoTag.addEventListener('click', ()=>{
    lastAutoId = '';
    __editorAutoId = false;
    refreshTags();
  }); }
  if(abbrAutoTag){ abbrAutoTag.title = 'Click to freeze abbreviation'; abbrAutoTag.addEventListener('click', ()=>{
    lastAutoAbbr = '';
    __editorAutoAbbr = false;
    refreshTags();
  }); }

  labelInp.addEventListener('input', ()=>{
    const raw = labelInp.value.trim();
    const cur = idInp.value.trim();
    if(!cur || cur === lastAutoId){
      const autoId = slugify(raw) || '';
      if(autoId){ idInp.value = autoId; lastAutoId = autoId; }
    }
    __editorAutoId = lastAutoId !== '';
    if(abbrInp){
      const curAbbr = abbrInp.value.trim();
      if(!curAbbr || curAbbr === lastAutoAbbr){
        const a = autoAbbr(raw);
        if(a){ abbrInp.value = a; lastAutoAbbr = a; }
      }
    }
    __editorAutoAbbr = lastAutoAbbr !== '';
    refreshTags();
  });

  idInp.addEventListener('input', ()=>{
    if(!idInp.value.trim()){
      const autoId = slugify(labelInp.value.trim()) || '';
      idInp.value = autoId;
      lastAutoId = autoId;
    } else {
      lastAutoId = '';
    }
    __editorAutoId = lastAutoId !== '';
    refreshTags();
  });

  if(abbrInp){
    abbrInp.addEventListener('input', ()=>{
      if(!abbrInp.value.trim()){
        const a = autoAbbr(labelInp.value.trim());
        abbrInp.value = a;
        lastAutoAbbr = a;
      } else {
        lastAutoAbbr = '';
      }
      __editorAutoAbbr = lastAutoAbbr !== '';
      refreshTags();
    });
  }

  if(isNew) setTimeout(()=> labelInp.focus(), 50);
}

function _wireCatalogEmoji(card, dataObj){
  const emojiInp = card.querySelector('[data-f="emoji"]');
  const emojiGrid = card.querySelector('.catEmojiGrid');
  const dmWrap = card.querySelector('.catDmWrap');
  if(!emojiInp) return;
  if(emojiGrid){
    emojiGrid.innerHTML = CATALOG_EMOJI_PICKS.map(e=>`<button class="catEP" data-emoji="${e}" style="font-size:14px;padding:2px 4px;border:1px solid transparent;border-radius:5px;background:transparent;cursor:pointer;line-height:1;" title="${e}">${e}</button>`).join('') + '<button class="catEP" data-emoji="" style="font-size:10px;padding:2px 5px;border:1px solid var(--border);border-radius:5px;background:transparent;cursor:pointer;color:var(--muted);line-height:1;" title="Clear"></button>';
  }
  __editorDisplayMode = (dataObj && dataObj.displayMode) || 'abbr';
  const refreshDm = ()=>{
    if(!dmWrap) return;
    const has = !!emojiInp.value.trim();
    dmWrap.querySelectorAll('.catDmOpt').forEach(b=>{
      b.style.background = b.dataset.dm === __editorDisplayMode ? 'rgba(59,130,246,.25)' : 'transparent';
      if(b.dataset.dm === 'emoji') b.style.opacity = has ? '1' : '.4';
    });
  };
  card.querySelectorAll('.catEP').forEach(btn => btn.addEventListener('click', (e)=>{
    e.preventDefault();
    emojiInp.value = btn.dataset.emoji;
    if(btn.dataset.emoji && __editorDisplayMode === 'abbr') __editorDisplayMode = 'emoji';
    if(!btn.dataset.emoji && __editorDisplayMode === 'emoji') __editorDisplayMode = 'abbr';
    refreshDm();
  }));
  emojiInp.addEventListener('input', ()=>{
    if(emojiInp.value.trim() && __editorDisplayMode === 'abbr') __editorDisplayMode = 'emoji';
    if(!emojiInp.value.trim() && __editorDisplayMode === 'emoji') __editorDisplayMode = 'abbr';
    refreshDm();
  });
  if(dmWrap) dmWrap.addEventListener('click', (e)=>{
    const btn = e.target.closest('.catDmOpt');
    if(!btn) return;
    if(btn.dataset.dm === 'emoji' && !emojiInp.value.trim()) return;
    __editorDisplayMode = btn.dataset.dm;
    refreshDm();
  });
}

// --- Guard for filter edits ---
async function guardFilterAbandon(){
  if(__filterIsNew){
    if(filterFormIsDirty()){
      const ok = await customConfirm('Discard new filter?');
      if(!ok) return false;
    }
    // Remove the unsaved new filter
    const cat = ensureFilterCatalog();
    const i = cat.findIndex(x => x.id === __filterEditId);
    if(i >= 0) cat.splice(i, 1);
    __filterEditId = null;
    __filterEditSnapshot = null;
    __filterIsNew = false;
    return true;
  }
  if(!filterFormIsDirty()) return true;
  const cat = ensureFilterCatalog();
  const f = cat.find(x => x.id === __filterEditId);
  const ok = await guardAbandonEdit(f?.label || __filterEditId, __filterEditId);
  if(ok && f && __filterEditSnapshot){
    // Revert in-place rule changes
    const snap = JSON.parse(__filterEditSnapshot);
    if(snap.rules) f.rules = snap.rules;
  }
  return ok;
}

// --- Guard for node/column edits ---
async function guardNodeAbandon(){
  if(!nodeEditIsDirty()) return true;
  const { kind, id } = __editSnapshot;
  let label = id;
  if(kind === 'column'){
    const col = findColumnById(id);
    label = col?.label || id;
  } else if(kind === 'node'){
    const node = IDX?.nodeById?.get(id);
    label = node?.label || id;
  }
  return await guardAbandonEdit(label, id);
}

// --- Dirty-highlight helper: toggles .btnDirty on Save button when form is dirty ---
function wireDirtyHighlight(container, saveBtn, dirtyFn, canSaveFn){
  if(!container || !saveBtn || !dirtyFn) return;
  const update = ()=>{ 
    const dirty = dirtyFn();
    const canSave = canSaveFn ? canSaveFn() : true;
    saveBtn.classList.toggle('btnDirty', dirty && canSave);
  };
  container.addEventListener('input', update);
  container.addEventListener('change', update);
  // click catches tag chip add/remove, transform chips, checkbox labels, etc.
  container.addEventListener('click', ()=> setTimeout(update, 50));
  // Initial check
  update();
  // Expose updater so external code (tag toggles, transform adds) can trigger it
  saveBtn.__dirtyUpdate = update;
}

function renderTagsManager(){
  const cat = ensureTagCatalog();
  if(!tagsBody) return;
  if(!cat.length){
    tagsBody.innerHTML = '<div class="empty">' + (state.editorMode ? 'No tags yet. Click \u201cAdd tag\u201d.' : 'No tags defined.') + '</div>';
    return;
  }
  // Build sorted index array by priority
  const sortedIdxs = cat.map((_,i)=>i).sort((a,b)=>{
    const pa = typeof cat[a].priority==='number' ? cat[a].priority : 9999;
    const pb = typeof cat[b].priority==='number' ? cat[b].priority : 9999;
    return pa - pb;
  });
  const rows = sortedIdxs.map((idx, sortPos)=>{
    const t = cat[idx];
    const id = escapeHtml(t.id||'');
    const label = escapeHtml(t.label||'');
    const abbr = escapeHtml(t.abbr||'');
    const displayLbl = escapeHtml(tagDisplayLabel(t));
    const color = t.color || DEFAULT_TAG_COLOR;
    const note = escapeHtml(t.note||'');
    const isEditing = catalogIsEditing('tag', idx);
    const isFirst = sortPos === 0;
    const isLast = sortPos === sortedIdxs.length - 1;

    if(!isEditing){
      const editable = state.editorMode;
      return `<div class="mapCard catItem" data-tidx="${idx}" data-sort-pos="${sortPos}" ${editable?'draggable="true"':''} style="margin-bottom:10px;${editable?'cursor:pointer;':''}padding:12px 14px;display:flex;align-items:center;gap:10px;" ${editable?'title="Click to edit  Drag to reorder"':''}>
        ${editable?'<span class="catGrip"><svg width="8" height="14" viewBox="0 0 8 14" fill="currentColor"><circle cx="2" cy="2" r="1.2"/><circle cx="6" cy="2" r="1.2"/><circle cx="2" cy="7" r="1.2"/><circle cx="6" cy="7" r="1.2"/><circle cx="2" cy="12" r="1.2"/><circle cx="6" cy="12" r="1.2"/></svg></span>':''}
        <span class="tagChip" style="background:${escapeHtml(color)};color:#fff;font-size:12px;pointer-events:none;flex-shrink:0;">${displayLbl}</span>
        ${t.metaOnly ? '<span style="font-size:9px;padding:1px 5px;border-radius:4px;background:rgba(139,92,246,.15);color:rgba(139,92,246,.85);letter-spacing:.3px;flex-shrink:0;font-weight:600;">META</span>' : ''}
        <div style="flex:1;min-width:0;">
          <div style="display:flex;align-items:center;gap:8px;">
            <strong style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${label}</strong>
            <code style="font-size:10px;opacity:.5;flex-shrink:0;">${id}</code>${isLikelyAutoId(t) ? '<span class="autoTag" style="font-size:8px;padding:0 4px;">auto</span>' : ''}
          </div>
          ${note ? `<div class="empty" style="margin-top:4px;font-size:11px;">${note}</div>` : ''}
          ${_catTagPillsHtml(t.tags)}
        </div>
        ${editable ? `<div class="catActions"><button class="btn catMoveBtn" data-act="moveUp" data-tidx="${idx}" title="Move up" ${isFirst?'disabled':''}><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="9" x2="6" y2="3"/><polyline points="3.5,5.5 6,3 8.5,5.5"/></svg></button>
        <button class="btn catMoveBtn" data-act="moveDown" data-tidx="${idx}" title="Move down" ${isLast?'disabled':''}><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="3" x2="6" y2="9"/><polyline points="3.5,6.5 6,9 8.5,6.5"/></svg></button></div>` : ''}
      </div>`;
    }
    const _isNew = isEditing && __catalogEdit.isNew;
    return `<div class="mapCard catItem catEditing" data-tidx="${idx}" style="margin-bottom:12px;border-color:rgba(59,130,246,.5);padding:12px 14px;">
      <div class="kv" style="grid-template-columns: 70px 1fr;">
        <div class="k">Label<span class="req">*</span></div><div class="v"><input class="inp" data-f="label" value="${_isNew ? '' : label}" placeholder="e.g. Critical"/></div>
        <div class="k">Id <span class="autoTag" data-auto="id">auto</span></div>
        <div class="v" style="display:flex;gap:8px;align-items:center;">
          <input class="inp" data-f="id" value="${_isNew ? '' : id}" placeholder="auto" style="font-family:var(--mono);font-size:11px;flex:1;"/>
          <span style="font-size:10px;opacity:.35;flex-shrink:0;">Abbr</span><span class="autoTag" data-auto="abbr">auto</span>
          <input class="inp" data-f="abbr" value="${_isNew ? '' : abbr}" placeholder="S" style="width:55px;flex:0 0 auto;text-align:center;font-size:11px;"/>
        </div>
        <div class="k">Emoji</div>
        <div class="v" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
          <input class="inp" data-f="emoji" value="${_isNew ? '' : escapeHtml(cat[idx]?.emoji||'')}" style="width:48px;text-align:center;font-size:16px;flex:0 0 auto;" placeholder="" maxlength="4"/>
          <button class="btn catEmojiToggle" type="button" style="font-size:11px;padding:2px 5px;" title="Pick emoji"></button>
          <div class="catDmWrap" style="display:inline-flex;border:1px solid var(--border);border-radius:6px;overflow:hidden;flex-shrink:0;"><button class="catDmOpt" data-dm="abbr" style="padding:2px 10px;font-size:11px;border:none;cursor:pointer;background:${(cat[idx]?.displayMode==='emoji')?'transparent':'rgba(59,130,246,.25)'};color:var(--fg);transition:all .15s;">Abbr</button><button class="catDmOpt" data-dm="emoji" style="padding:2px 10px;font-size:11px;border:none;border-left:1px solid var(--border);cursor:pointer;background:${(cat[idx]?.displayMode==='emoji')?'rgba(59,130,246,.25)':'transparent'};color:var(--fg);opacity:${cat[idx]?.emoji?'1':'.4'};transition:all .15s;">Emoji</button></div>
        </div>
        <div class="k"></div>
        <div class="v"><div class="catEmojiGrid" style="display:none;flex-wrap:wrap;gap:2px;margin-top:2px;"></div></div>
        <div class="k">Color</div><div class="v"><div data-f="colorSwatches" style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px;"></div><div style="display:flex;align-items:center;gap:6px;"><input type="color" data-f="colorPicker" value="${escapeHtml(color||'#3b82f6')}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${(color && cat[idx]?.colorEnabled!==false)?'':'opacity:.3;'}"/><input class="inp" data-f="color" value="${escapeHtml(color)}" placeholder="#3b82f6" style="flex:1;"/><label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" data-f="colorOn" ${(color && cat[idx]?.colorEnabled!==false)?'checked':''}/> Apply</label></div></div>
        <div class="k">Note</div><div class="v"><input class="inp" data-f="note" value="${_isNew ? '' : note}" placeholder="optional"/></div>
        <div class="k">Note</div><div class="v"><input class="inp" data-f="note" value="${_isNew ? '' : note}" placeholder="optional"/></div>
        <div class="k">Meta only</div><div class="v" style="display:flex;align-items:center;gap:8px;"><label style="font-size:12px;cursor:pointer;display:flex;align-items:center;gap:5px;"><input type="checkbox" data-f="metaOnly" ${(!_isNew && cat[idx]?.metaOnly)?'checked':''}/> Category tag &mdash; organize catalogs only, not assignable to nodes/mappings</label></div>
        ${_catTagRowHtml(_isNew ? [] : cat[idx]?.tags, cat[idx]?.id)}
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap;">
        ${_isNew ? '' : '<button class="btn" data-act="del" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
        <span style="flex:1;"></span>
        <button class="btn" data-act="cancel">Cancel</button>
        <button class="btn btnSave" data-act="save">Save</button>
      </div>
    </div>`;
  }).join('\n');
  tagsBody.innerHTML = rows;
  tagsBody.classList.toggle('catEditActive', __catalogEdit.kind === 'tag' && __catalogEdit.idx >= 0);

  // Reorder button handlers (must be before click-to-edit so stopPropagation works)
  tagsBody.querySelectorAll('.catMoveBtn').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(!state.editorMode) return;
      const tidx = Number(btn.dataset.tidx);
      const dir = btn.dataset.act === 'moveUp' ? -1 : 1;
      const pos = sortedIdxs.indexOf(tidx);
      const swapPos = pos + dir;
      if(swapPos < 0 || swapPos >= sortedIdxs.length) return;
      const otherIdx = sortedIdxs[swapPos];
      recordChange();
      const tmp = cat[tidx].priority;
      cat[tidx].priority = cat[otherIdx].priority;
      cat[otherIdx].priority = tmp;
      renderTagsManager();
      renderAll();
    });
  });

  // Drag-and-drop reorder
  let __tagDragSortPos = null;
  let __tagDragTime = 0;
  tagsBody.querySelectorAll('.catItem:not(.catEditing)').forEach(card=>{
    card.addEventListener('dragstart', (e)=>{
      __tagDragSortPos = Number(card.dataset.sortPos);
      __tagDragTime = Date.now();
      card.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', ''); // required for Firefox
    });
    card.addEventListener('dragend', ()=>{
      card.style.opacity = '';
      tagsBody.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      __tagDragSortPos = null;
    });
    card.addEventListener('dragover', (e)=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      tagsBody.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      card.classList.add('dragOver');
    });
    card.addEventListener('dragleave', ()=>{
      card.classList.remove('dragOver');
    });
    card.addEventListener('drop', (e)=>{
      e.preventDefault();
      card.classList.remove('dragOver');
      const fromPos = __tagDragSortPos;
      const toPos = Number(card.dataset.sortPos);
      if(fromPos === null || fromPos === toPos) return;
      // Reassign priorities: reorder sortedIdxs, then assign sequential priorities
      const reordered = [...sortedIdxs];
      const [moved] = reordered.splice(fromPos, 1);
      reordered.splice(toPos, 0, moved);
      recordChange();
      reordered.forEach((catIdx, newPos) => { cat[catIdx].priority = newPos + 1; });
      renderTagsManager();
      renderAll();
    });
  });

  tagsBody.querySelectorAll('.catItem').forEach(card=>{
    const idx = Number(card.dataset.tidx);
    const isEditing = catalogIsEditing('tag', idx);
    if(!isEditing){
      card.addEventListener('click', async (e)=>{
        if(!state.editorMode) return;
        // Don't enter edit mode if clicking reorder buttons or just finished a drag
        if(e.target.closest('.catMoveBtn')) return;
        if(Date.now() - __tagDragTime < 300) return;
        const itemId = cat[idx]?.id; // capture before guard may shift indices
        if(!await guardCatalogAbandon()) return;
        catalogEditEnd();
        const freshIdx = cat.findIndex(t => t.id === itemId);
        if(freshIdx < 0) { renderTagsManager(); return; }
        catalogEditBegin('tag', freshIdx, cat[freshIdx]);
        renderTagsManager();
      });
      return;
    }
    // Build color swatches
    const sw = card.querySelector('[data-f="colorSwatches"]');
    const colorInp = card.querySelector('input[data-f="color"]');
    const colorPick = card.querySelector('input[data-f="colorPicker"]');
    const _kick = ()=>{ const s = card.querySelector('[data-act="save"]'); if(s && s.__dirtyUpdate) s.__dirtyUpdate(); };
    if(sw){
      const curColor = (colorInp?.value || DEFAULT_TAG_COLOR).trim();
      TAG_COLOR_PRESETS.forEach(p=>{
        const s = document.createElement('div');
        s.className = 'swatch' + (p.value===curColor ? ' sel' : '');
        s.style.background = p.value;
        s.title = p.name + ' ' + p.value;
        s.addEventListener('click', (e)=>{
          e.stopPropagation();
          if(colorInp){ colorInp.value = p.value; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
          if(colorPick){ colorPick.value = p.value; colorPick.style.opacity = '1'; }
          const colorOn = card.querySelector('[data-f="colorOn"]');
          if(colorOn) colorOn.checked = true;
          sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
          s.classList.add('sel');
          _kick();
        });
        sw.appendChild(s);
      });
      if(colorPick){
        colorPick.addEventListener('input', ()=>{
          if(colorInp) colorInp.value = colorPick.value;
          sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
          const colorOn = card.querySelector('[data-f="colorOn"]');
          if(colorOn) colorOn.checked = true;
          colorPick.style.opacity = '1';
          _kick();
        });
        colorPick.addEventListener('change', _kick);
      }
      if(colorInp) colorInp.addEventListener('input', ()=>{
        const v = (colorInp.value||'').trim();
        if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
          if(colorPick) colorPick.value = v;
          sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
          const colorOn = card.querySelector('[data-f="colorOn"]');
          if(colorOn) colorOn.checked = true;
          if(colorPick) colorPick.style.opacity = '1';
        }
        _kick();
      });
      // Apply checkbox
      const tagColorOn = card.querySelector('[data-f="colorOn"]');
      if(tagColorOn){
        tagColorOn.addEventListener('change', ()=>{
          if(colorPick) colorPick.style.opacity = tagColorOn.checked ? '1' : '.3';
          _kick();
        });
      }
    }
    // metaOnly checkbox kick
    const metaCb = card.querySelector('[data-f="metaOnly"]');
    if(metaCb) metaCb.addEventListener('change', _kick);
    // Save
    card.querySelector('[data-act="save"]')?.addEventListener('click', ()=>{
      const t = cat[idx]; if(!t) return;
      const newLabel = (card.querySelector('[data-f="label"]')?.value||'').trim() || t.label;
      if(!newLabel){ customAlert('Please enter a label.'); card.querySelector('[data-f="label"]')?.focus(); return; }
      let newId = sanitizeManualId(card.querySelector('[data-f="id"]')?.value||'');
      if(!newId) newId = slugifyTagLabel(newLabel) || t.id;
      const newAbbr = (card.querySelector('[data-f="abbr"]')?.value||'').trim();
      const newColor = (card.querySelector('[data-f="color"]')?.value||'').trim() || DEFAULT_TAG_COLOR;
      const newColorOn = card.querySelector('[data-f="colorOn"]')?.checked;
      const newNote = (card.querySelector('[data-f="note"]')?.value||'').trim();
      // For new items, remove placeholder before snapshot so undo doesn't include it
      if(__catalogEdit.isNew) cat.splice(idx, 1);
      recordChange();
      if(__catalogEdit.isNew) cat.splice(idx, 0, t);
      t.label = newLabel; t.abbr = newAbbr; t.color = newColor; t.note = newNote;
      t.colorEnabled = newColorOn !== false;
      t._autoId = __editorAutoId; t._autoAbbr = __editorAutoAbbr;
      t.emoji = (card.querySelector('[data-f="emoji"]')?.value||'').trim() || undefined;
      t.displayMode = __editorDisplayMode;
      t.tags = _readCatTags(card);
      if(!t.tags.length) delete t.tags;
      const newMetaOnly = card.querySelector('[data-f="metaOnly"]')?.checked || false;
      if(newMetaOnly) t.metaOnly = true; else delete t.metaOnly;
      if(newId !== t.id){
        const result = reIdTagInData(state.data, t.id, newId);
        if(result === t.id) setGlobalStatus('Tag ID conflict \u2014 not changed.');
      }
      catalogEditEnd(); renderTagsManager(); renderAll();
    });
    // Cancel
    card.querySelector('[data-act="cancel"]')?.addEventListener('click', ()=>{
      if(__catalogEdit.isNew) _removeCatalogNewEntry();
      catalogEditEnd(); renderTagsManager();
    });
    // Delete
    card.querySelector('[data-act="del"]')?.addEventListener('click', async ()=>{
      if(!__catalogEdit.isNew && !await customConfirm('Delete tag?')) return;
      if(!__catalogEdit.isNew) recordChange();
      const tid = cat[idx]?.id;
      cat.splice(idx,1);
      if(tid){ for(const n of IDX.nodeById.values()){ if(Array.isArray(n.tags)) n.tags = n.tags.filter(x=>x!==tid); } }
      catalogEditEnd(); renderAll(); renderTagsManager();
    });
    wireDirtyHighlight(card, card.querySelector('[data-act="save"]'), catalogFormIsDirty, ()=> !!(card.querySelector('[data-f="label"]')?.value||'').trim());
    _wireLabelToId(card, 'tag', cat[idx]);
    _wireCatalogEmoji(card, cat[idx]);
    _wireCatTagSelector(card);
    { const _tb = card.querySelector('.catEmojiToggle'); const _tg = card.querySelector('.catEmojiGrid');
      if(_tb && _tg) _tb.addEventListener('click', e=>{ e.preventDefault(); const v = _tg.style.display!=='none'; _tg.style.display = v?'none':'flex'; _tb.textContent = v?"":""; }); }
  });
}


// --- Transform manager modal ---
function renderTransformsManager(){
  const cat = ensureTransformCatalog();
  const body = document.getElementById('transformsBody');
  if(!body) return;
  if(!cat.length){
    body.innerHTML = '<div class="empty">' + (state.editorMode ? 'No transforms yet. Click \u201cAdd transform\u201d.' : 'No transforms defined.') + '</div>';
    return;
  }
  // Build sorted index array alphabetically by label (new items being edited pinned to top)
  const sortedIdxs = cat.map((_,i)=>i).sort((a,b)=>{
    const aEditing = catalogIsEditing('transform', a) && __catalogEdit.isNew;
    const bEditing = catalogIsEditing('transform', b) && __catalogEdit.isNew;
    if(aEditing) return -1;
    if(bEditing) return 1;
    const la = (cat[a].label||cat[a].id||'').toLowerCase();
    const lb = (cat[b].label||cat[b].id||'').toLowerCase();
    return la < lb ? -1 : la > lb ? 1 : 0;
  });
  body.innerHTML = sortedIdxs.map(idx => {
    const t = cat[idx];
    const id = escapeHtml(t.id||'');
    const label = escapeHtml(t.label||'');
    const abbr = escapeHtml(t.abbr||'');
    const trDispLbl = escapeHtml(transformDisplayLabel(t));
    const note = escapeHtml(t.note||'');
    const isEditing = catalogIsEditing('transform', idx);

    if(!isEditing){
      const editable = state.editorMode;
      const paramCount = Array.isArray(t.params) ? t.params.length : 0;
      const paramInfo = paramCount ? `<span style="font-size:10px;opacity:.45;margin-left:4px;">${paramCount} param${paramCount>1?'s':''}</span>` : '';
      const tColorDot = (t.color && t.colorEnabled !== false) ? `<span style="width:10px;height:10px;border-radius:3px;background:${escapeHtml(t.color)};display:inline-block;flex-shrink:0;border:1px solid rgba(255,255,255,.12);"></span>` : '';
      return `<div class="mapCard catItem" data-tidx="${idx}" style="margin-bottom:8px;${editable?'cursor:pointer;':''}" ${editable?'title="Click to edit"':''}>
        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
          ${tColorDot}
          ${trDispLbl ? `<span class="tagChip" style="font-size:12px;pointer-events:none;${t.color?'background:'+escapeHtml(t.color)+';color:#fff;':''}">${trDispLbl}</span>` : ''}
          <strong style="flex:1;">${label}${paramInfo}</strong>
          <code style="font-size:10px;opacity:.5;">${id}</code>${isLikelyAutoId(t) ? '<span class="autoTag" style="font-size:8px;padding:0 4px;">auto</span>' : ''}
        </div>
        ${note ? `<div class="empty" style="margin-top:4px;font-size:11px;">${note}</div>` : ''}
        ${_catTagPillsHtml(t.tags)}
      </div>`;
    }
    const paramsArr = Array.isArray(t.params) ? t.params : [];
    const paramsHtml = paramsArr.map((p, pi)=>`
      <div class="trParamRow" data-pi="${pi}" style="display:flex;gap:4px;align-items:center;margin-bottom:4px;">
        <input class="inp" data-pf="label" value="${escapeHtml(p.label||'')}" placeholder="label" style="flex:2;"/>
        <input class="inp" data-pf="id" value="${escapeHtml(p.id||'')}" placeholder="id (auto)" style="flex:1;font-family:var(--mono);font-size:10px;"/>
        <select class="inp" data-pf="type" style="flex:0 0 70px;font-size:11px;">
          <option value="text"${p.type==='text'?' selected':''}>text</option>
          <option value="number"${p.type==='number'?' selected':''}>number</option>
        </select>
        <input class="inp" data-pf="default" value="${escapeHtml(p.default!==undefined?String(p.default):'')}" placeholder="default" style="flex:1;font-size:11px;"/>
        <button class="btn" data-act="rmParam" data-pi="${pi}" style="padding:2px 6px;font-size:11px;" title="Remove"></button>
      </div>
    `).join('');
    const _isNew = isEditing && __catalogEdit.isNew;
    const tColor = escapeHtml(t.color||'');
    return `<div class="mapCard catItem catEditing" data-tidx="${idx}" style="margin-bottom:10px;border-color:rgba(59,130,246,.5);">
      <div class="kv" style="grid-template-columns: 70px 1fr;">
        <div class="k">Label<span class="req">*</span></div><div class="v"><input class="inp" data-f="label" value="${_isNew ? '' : label}" placeholder="e.g. Trim whitespace"/></div>
        <div class="k">Id <span class="autoTag" data-auto="id">auto</span></div>
        <div class="v" style="display:flex;gap:8px;align-items:center;">
          <input class="inp" data-f="id" value="${_isNew ? '' : id}" placeholder="auto" style="font-family:var(--mono);font-size:11px;flex:1;"/>
          <span style="font-size:10px;opacity:.35;flex-shrink:0;">Abbr</span><span class="autoTag" data-auto="abbr">auto</span>
          <input class="inp" data-f="abbr" value="${_isNew ? '' : abbr}" placeholder="TR" style="width:55px;flex:0 0 auto;text-align:center;font-size:11px;"/>
        </div>
        <div class="k">Emoji</div>
        <div class="v" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
          <input class="inp" data-f="emoji" value="${_isNew ? '' : escapeHtml(t.emoji||'')}" style="width:48px;text-align:center;font-size:16px;flex:0 0 auto;" placeholder="" maxlength="4"/>
          <button class="btn catEmojiToggle" type="button" style="font-size:11px;padding:2px 5px;" title="Pick emoji"></button>
          <div class="catDmWrap" style="display:inline-flex;border:1px solid var(--border);border-radius:6px;overflow:hidden;flex-shrink:0;"><button class="catDmOpt" data-dm="abbr" style="padding:2px 10px;font-size:11px;border:none;cursor:pointer;background:${(t.displayMode==='emoji')?'transparent':'rgba(59,130,246,.25)'};color:var(--fg);transition:all .15s;">Abbr</button><button class="catDmOpt" data-dm="emoji" style="padding:2px 10px;font-size:11px;border:none;border-left:1px solid var(--border);cursor:pointer;background:${(t.displayMode==='emoji')?'rgba(59,130,246,.25)':'transparent'};color:var(--fg);opacity:${t.emoji?'1':'.4'};transition:all .15s;">Emoji</button></div>
        </div>
        <div class="k"></div>
        <div class="v"><div class="catEmojiGrid" style="display:none;flex-wrap:wrap;gap:2px;margin-top:2px;"></div></div>
        <div class="k">Color</div><div class="v"><div data-f="colorSwatches" style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px;"></div><div style="display:flex;align-items:center;gap:6px;"><input type="color" data-f="colorPicker" value="${tColor||'#6b7280'}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${tColor && t.colorEnabled!==false?'':'opacity:.3;'}"/><input class="inp" data-f="color" value="${tColor}" placeholder="optional" style="flex:1;"/><label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" data-f="colorOn" ${(tColor && t.colorEnabled!==false)?'checked':''}/> Apply</label><span class="layoutReset trColorReset" title="Reset color" style="opacity:.3;cursor:pointer;font-size:12px;color:var(--muted);"></span></div></div>
        <div class="k">Note</div><div class="v"><input class="inp" data-f="note" value="${_isNew ? '' : note}" placeholder="optional"/></div>
        ${_catTagRowHtml(_isNew ? [] : t.tags)}
        <div class="k">Params</div><div class="v">
          <div id="trParams_${idx}">${_isNew ? '<span class="empty" style="font-size:11px;">No parameters</span>' : (paramsHtml || '<span class="empty" style="font-size:11px;">No parameters</span>')}</div>
          <button class="btn" data-act="addParam" style="margin-top:4px;font-size:11px;padding:2px 8px;">+ Add param</button>
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap;">
        ${_isNew ? '' : '<button class="btn" data-act="del" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
        <span style="flex:1;"></span>
        <button class="btn" data-act="cancel">Cancel</button>
        <button class="btn btnSave" data-act="save">Save</button>
      </div>
    </div>`;
  }).join('\n');
  body.classList.toggle('catEditActive', __catalogEdit.kind === 'transform' && __catalogEdit.idx >= 0);

  body.querySelectorAll('.catItem').forEach(card=>{
    const idx = Number(card.dataset.tidx);
    const isEditing = catalogIsEditing('transform', idx);
    if(!isEditing){
      card.addEventListener('click', async ()=>{
        if(!state.editorMode) return;
        const itemId = cat[idx]?.id; // capture before guard may shift indices
        if(!await guardCatalogAbandon()) return;
        catalogEditEnd();
        const freshIdx = cat.findIndex(t => t.id === itemId);
        if(freshIdx < 0) { renderTransformsManager(); return; }
        catalogEditBegin('transform', freshIdx, cat[freshIdx]);
        renderTransformsManager();
      });
      return;
    }
    // Save
    card.querySelector('[data-act="save"]')?.addEventListener('click', ()=>{
      const t = cat[idx]; if(!t) return;
      const newLabel = (card.querySelector('[data-f="label"]')?.value||'').trim() || t.label;
      if(!newLabel){ customAlert('Please enter a label.'); card.querySelector('[data-f="label"]')?.focus(); return; }
      let newId = sanitizeManualId(card.querySelector('[data-f="id"]')?.value||'');
      if(!newId) newId = slugifyTransformLabel(newLabel) || t.id;
      const newAbbr = (card.querySelector('[data-f="abbr"]')?.value||'').trim();
      const newNote = (card.querySelector('[data-f="note"]')?.value||'').trim();
      // Read params from form
      const paramRows = card.querySelectorAll('.trParamRow');
      const newParams = [];
      paramRows.forEach(row => {
        let pid = (row.querySelector('[data-pf="id"]')?.value||'').trim();
        const plabel = (row.querySelector('[data-pf="label"]')?.value||'').trim();
        const ptype = row.querySelector('[data-pf="type"]')?.value || 'text';
        const pdef = (row.querySelector('[data-pf="default"]')?.value||'').trim();
        // Auto-generate id from label if empty
        if(!pid && plabel) pid = transliterate(plabel).toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
        if(pid){
          const p = { id: pid, label: plabel || pid, type: ptype };
          if(pdef !== '') p.default = ptype === 'number' ? Number(pdef) : pdef;
          newParams.push(p);
        }
      });
      // For new items, remove placeholder before snapshot so undo doesn't include it
      if(__catalogEdit.isNew) cat.splice(idx, 1);
      recordChange();
      if(__catalogEdit.isNew) cat.splice(idx, 0, t);
      t.label = newLabel; t.abbr = newAbbr; t.note = newNote;
      t._autoId = __editorAutoId; t._autoAbbr = __editorAutoAbbr;
      t.emoji = (card.querySelector('[data-f="emoji"]')?.value||'').trim() || undefined;
      t.displayMode = __editorDisplayMode;
      const newColor = (card.querySelector('[data-f="color"]')?.value||'').trim();
      const newColorOn = card.querySelector('[data-f="colorOn"]')?.checked;
      if(newColor) t.color = newColor; else delete t.color;
      t.colorEnabled = !!newColorOn;
      t.params = newParams.length ? newParams : undefined;
      if(!t.params) delete t.params;
      t.tags = _readCatTags(card);
      if(!t.tags.length) delete t.tags;
      if(newId !== t.id){
        const result = reIdTransformInData(state.data, t.id, newId);
        if(result === t.id) setGlobalStatus('Transform ID conflict \u2014 not changed.');
      }
      catalogEditEnd(); renderTransformsManager(); renderAll();
    });
    // Add param button
    card.querySelector('[data-act="addParam"]')?.addEventListener('click', ()=>{
      const container = card.querySelector(`#trParams_${idx}`);
      if(!container) return;
      const empty = container.querySelector('.empty');
      if(empty) empty.remove();
      const pi = container.querySelectorAll('.trParamRow').length;
      const row = document.createElement('div');
      row.className = 'trParamRow';
      row.dataset.pi = pi;
      row.style.cssText = 'display:flex;gap:4px;align-items:center;margin-bottom:4px;';
      row.innerHTML = `
        <input class="inp" data-pf="label" value="" placeholder="label" style="flex:2;"/>
        <input class="inp" data-pf="id" value="" placeholder="id (auto)" style="flex:1;font-family:var(--mono);font-size:10px;"/>
        <select class="inp" data-pf="type" style="flex:0 0 70px;font-size:11px;">
          <option value="text">text</option>
          <option value="number">number</option>
        </select>
        <input class="inp" data-pf="default" value="" placeholder="default" style="flex:1;font-size:11px;"/>
        <button class="btn" data-act="rmParam" style="padding:2px 6px;font-size:11px;" title="Remove"></button>
      `;
      // Auto-generate id from label whenever id is empty
      const lblInp = row.querySelector('[data-pf="label"]');
      const idInp = row.querySelector('[data-pf="id"]');
      const slugP = (s)=> transliterate(s).trim().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
      if(lblInp && idInp){
        let _lastAuto = idInp.value.trim();
        lblInp.addEventListener('input', ()=>{
          const cur = idInp.value.trim();
          if(!cur || cur === _lastAuto){ const a = slugP(lblInp.value); idInp.value = a; _lastAuto = a; }
        });
        idInp.addEventListener('input', ()=>{
          if(!idInp.value.trim()){ const a = slugP(lblInp.value); idInp.value = a; _lastAuto = a; }
          else _lastAuto = '';
        });
      }
      row.querySelector('[data-act="rmParam"]').addEventListener('click', ()=> row.remove());
      container.appendChild(row);
    });
    // Remove param buttons
    card.querySelectorAll('[data-act="rmParam"]').forEach(btn => {
      btn.addEventListener('click', ()=> btn.closest('.trParamRow')?.remove());
    });
    // Color swatches, picker, reset (same pattern as tags)
    {
      const sw = card.querySelector('[data-f="colorSwatches"]');
      const colorInp = card.querySelector('input[data-f="color"]');
      const colorPick = card.querySelector('input[data-f="colorPicker"]');
      const colorReset = card.querySelector('.trColorReset');
      const _kick = ()=>{ const s = card.querySelector('[data-act="save"]'); if(s && s.__dirtyUpdate) s.__dirtyUpdate(); };
      if(sw){
        const curColor = (colorInp?.value || '').trim();
        TAG_COLOR_PRESETS.forEach(p=>{
          const s = document.createElement('div');
          s.className = 'swatch' + (p.value===curColor ? ' sel' : '');
          s.style.background = p.value;
          s.title = p.name + ' ' + p.value;
          s.addEventListener('click', (e)=>{
            e.stopPropagation();
            if(colorInp){ colorInp.value = p.value; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
            if(colorPick){ colorPick.value = p.value; colorPick.style.opacity = '1'; }
            const colorOn = card.querySelector('[data-f="colorOn"]');
            if(colorOn) colorOn.checked = true;
            sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
            s.classList.add('sel');
            _kick();
          });
          sw.appendChild(s);
        });
      }
      if(colorPick){
        colorPick.addEventListener('input', ()=>{
          if(colorInp){ colorInp.value = colorPick.value; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
          colorPick.style.opacity = '1';
          if(sw) sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
          const colorOn = card.querySelector('[data-f="colorOn"]');
          if(colorOn) colorOn.checked = true;
          _kick();
        });
        colorPick.addEventListener('change', _kick);
      }
      if(colorInp) colorInp.addEventListener('input', ()=>{
        const v = (colorInp.value||'').trim();
        if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
          if(colorPick){ colorPick.value = v; colorPick.style.opacity = '1'; }
          if(sw) sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
          const colorOn = card.querySelector('[data-f="colorOn"]');
          if(colorOn) colorOn.checked = true;
        }
        _kick();
      });
      // Apply checkbox
      const trColorOn = card.querySelector('[data-f="colorOn"]');
      if(trColorOn){
        trColorOn.addEventListener('change', ()=>{
          if(colorPick) colorPick.style.opacity = trColorOn.checked ? '1' : '.3';
          _kick();
        });
      }
      if(colorReset){
        colorReset.addEventListener('click', ()=>{
          if(colorInp){ colorInp.value = ''; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
          if(colorPick){ colorPick.value = '#6b7280'; colorPick.style.opacity = '.3'; }
          if(sw) sw.querySelectorAll('.swatch').forEach(x=>x.classList.remove('sel'));
          const colorOn = card.querySelector('[data-f="colorOn"]');
          if(colorOn) colorOn.checked = false;
          _kick();
        });
      }
    }
    // Cancel
    card.querySelector('[data-act="cancel"]')?.addEventListener('click', ()=>{
      if(__catalogEdit.isNew) _removeCatalogNewEntry();
      catalogEditEnd(); renderTransformsManager();
    });
    // Delete
    card.querySelector('[data-act="del"]')?.addEventListener('click', async ()=>{
      if(!__catalogEdit.isNew && !await customConfirm('Delete transform?')) return;
      if(!__catalogEdit.isNew) recordChange();
      const tid = ensureTransformCatalog()[idx]?.id;
      ensureTransformCatalog().splice(idx,1);
      if(tid && state.data && Array.isArray(state.data.mappings)){
        state.data.mappings.forEach(m=>{ if(m && Array.isArray(m.transforms)) m.transforms = m.transforms.filter(x=> transformRefId(x) !== tid); });
      }
      catalogEditEnd(); renderAll(); renderTransformsManager();
    });
    wireDirtyHighlight(card, card.querySelector('[data-act="save"]'), catalogFormIsDirty, ()=> !!(card.querySelector('[data-f="label"]')?.value||'').trim());
    _wireLabelToId(card, 'transform', cat[idx]);
    _wireCatalogEmoji(card, cat[idx]);
    _wireCatTagSelector(card);
    { const _tb = card.querySelector('.catEmojiToggle'); const _tg = card.querySelector('.catEmojiGrid');
      if(_tb && _tg) _tb.addEventListener('click', e=>{ e.preventDefault(); const v = _tg.style.display!=='none'; _tg.style.display = v?'none':'flex'; _tb.textContent = v?"":""; }); }
  });
}
function openTransforms(){
  ensureTransformCatalog();
  catalogEditEnd();
  renderTransformsManager();
  if(addTransformBtn) addTransformBtn.style.display = state.editorMode ? '' : 'none';
  { const b=document.getElementById('importTransformsBtn'); if(b) b.style.display = state.editorMode ? '' : 'none'; }
  document.getElementById('transformsMask')?.classList.add('active');
  document.getElementById('transformsModal')?.classList.add('active');
}
async function closeTransforms(){
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  document.getElementById('transformsMask')?.classList.remove('active');
  document.getElementById('transformsModal')?.classList.remove('active');
}
function openTransformCreatePrompt(after){
  openTransformCreateModal({ afterCreate: (id)=>{ if(typeof after==='function') after(id); } });
}



// --- Custom Attributes manager modal ---
function renderCustomAttrsManager(){
  const cat = ensureCustomAttributeCatalog();
  normalizeCatalogMultiFlag();
  const body = document.getElementById('customAttrsBody');
  if(!body) return;
  if(!cat.length){
    body.innerHTML = '<div class="empty">' + (state.editorMode ? 'No attributes yet. Click \u201cAdd attribute\u201d.' : 'No attributes defined.') + '</div>';
    return;
  }
  // Build sorted index array by priority (like tags)
  const sortedIdxs = cat.map((_,i)=>i).sort((a,b)=>{
    const pa = typeof cat[a].priority==='number' ? cat[a].priority : 9999;
    const pb = typeof cat[b].priority==='number' ? cat[b].priority : 9999;
    return pa - pb;
  });
  const rows = sortedIdxs.map((idx, sortPos)=>{
    const a = cat[idx];
    const id = escapeHtml(a.id||'');
    const label = escapeHtml(a.label||'');
    const abbr = escapeHtml(a.abbr||'');
    const note = escapeHtml(a.note||'');
    const vals = Array.isArray(a.values) ? a.values : [];
    const isEditing = catalogIsEditing('attr', idx);
    const isFirst = sortPos === 0;
    const isLast = sortPos === sortedIdxs.length - 1;

    if(!isEditing){
      const editable = state.editorMode;
      // Sort values by priority for display
      const sortedVals = [...vals].sort((x,y)=>{
        const px = typeof x.priority==='number' ? x.priority : 9999;
        const py = typeof y.priority==='number' ? y.priority : 9999;
        return px - py;
      });
      const valDots = sortedVals.map(v=>{
        const vColorEnabled = v.color && v.colorEnabled !== false;
        const attrColorEnabled = a.color && a.colorEnabled !== false;
        const c = escapeHtml(vColorEnabled ? v.color : (attrColorEnabled ? a.color : ''));
        const dimmed = v.color && !vColorEnabled ? 'opacity:.4;' : '';
        const vabbr = escapeHtml(v.abbr||'');
        const vDispLbl = escapeHtml(attrValDisplayLabel(v));
        const vlbl = escapeHtml(v.label||v.id);
        return `<span style="display:inline-flex;align-items:center;gap:3px;white-space:nowrap;${dimmed}">${c ? `<span style="width:8px;height:8px;border-radius:3px;background:${c};display:inline-block;flex-shrink:0;border:1px solid rgba(255,255,255,.12);"></span>` : ''}${vDispLbl ? `<b style="font-size:10px;">${vDispLbl}</b> ` : ''}${vlbl}</span>`;
      }).join('<span style="opacity:.3;">, </span>');
      const attrColorDot = (a.color && a.colorEnabled !== false) ? `<span style="width:10px;height:10px;border-radius:4px;background:${escapeHtml(a.color)};display:inline-block;flex-shrink:0;border:1px solid rgba(255,255,255,.15);"></span>` : '';
      const displayBadge = a.displayOnNode ? '<span style="font-size:9px;opacity:.4;margin-left:4px;" title="Displayed on nodes"></span>' : '';
      return `<div class="mapCard catItem" data-aidx="${idx}" data-sort-pos="${sortPos}" ${editable?'draggable="true"':''} style="margin-bottom:10px;${editable?'cursor:pointer;':''}padding:12px 14px;display:flex;align-items:center;gap:10px;" ${editable?'title="Click to edit  Drag to reorder"':''}>
        ${editable?'<span class="catGrip"><svg width="8" height="14" viewBox="0 0 8 14" fill="currentColor"><circle cx="2" cy="2" r="1.2"/><circle cx="6" cy="2" r="1.2"/><circle cx="2" cy="7" r="1.2"/><circle cx="6" cy="7" r="1.2"/><circle cx="2" cy="12" r="1.2"/><circle cx="6" cy="12" r="1.2"/></svg></span>':''}
        ${attrColorDot}
        <div style="flex:1;min-width:0;">
          <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
            ${(a.emoji||abbr) ? `<span class="tagChip" style="font-size:12px;pointer-events:none;">${escapeHtml(attrDisplayLabel(a))}</span>` : ''}
            <strong style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${label}${displayBadge}</strong>
            <span style="font-size:11px;opacity:.5;">${a.multi ? 'multi' : 'single'} \u00b7 ${vals.length} value${vals.length!==1?'s':''}</span>
            <code style="font-size:10px;opacity:.5;flex-shrink:0;">${id}</code>${isLikelyAutoId(a) ? '<span class="autoTag" style="font-size:8px;padding:0 4px;">auto</span>' : ''}
          </div>
          ${vals.length ? `<div class="empty" style="margin-top:4px;font-size:11px;display:flex;flex-wrap:wrap;gap:2px 6px;align-items:center;">${valDots}</div>` : ''}
          ${note ? `<div class="empty" style="margin-top:2px;font-size:11px;">${note}</div>` : ''}
          ${_catTagPillsHtml(a.tags)}
        </div>
        ${editable ? `<div class="catActions"><button class="btn catMoveBtn" data-act="moveUp" data-aidx="${idx}" title="Move up" ${isFirst?'disabled':''}><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="9" x2="6" y2="3"/><polyline points="3.5,5.5 6,3 8.5,5.5"/></svg></button>
        <button class="btn catMoveBtn" data-act="moveDown" data-aidx="${idx}" title="Move down" ${isLast?'disabled':''}><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="3" x2="6" y2="9"/><polyline points="3.5,6.5 6,9 8.5,6.5"/></svg></button></div>` : ''}
      </div>`;
    }

    // Sort values by priority for edit form
    const sortedValIdxs = vals.map((_,i)=>i).sort((a,b)=>{
      const pa = typeof vals[a].priority==='number' ? vals[a].priority : 9999;
      const pb = typeof vals[b].priority==='number' ? vals[b].priority : 9999;
      return pa - pb;
    });
    const valsHtml = sortedValIdxs.map((vi, vSortPos)=>{
      const v = vals[vi];
      const vid = escapeHtml(v.id||'');
      const vlabel = escapeHtml(v.label||'');
      const vnote = escapeHtml(v.note||'');
      const vcolor = escapeHtml(v.color||'');
      const vabbr = escapeHtml(v.abbr||'');
      const vFirst = vSortPos === 0;
      const vLast = vSortPos === sortedValIdxs.length - 1;
      return `<div class="attrValRow" data-vi="${vi}" draggable="true" style="margin-top:4px;padding:7px 10px 7px 32px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.015);position:relative;cursor:grab;">
        <div style="position:absolute;left:4px;top:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:space-between;width:18px;padding:4px 0;">
          <button class="btn catValMoveBtn" data-act="valUp" data-vi="${vi}" title="Move up" ${vFirst?'disabled':''}><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="8" x2="5" y2="2"/><polyline points="3,4 5,2 7,4"/></svg></button>
          <span class="valDragHandle" style="cursor:grab;opacity:.25;line-height:0;user-select:none;" title="Drag to reorder"><svg width="10" height="14" viewBox="0 0 10 14" fill="currentColor"><circle cx="3" cy="2" r="1.3"/><circle cx="7" cy="2" r="1.3"/><circle cx="3" cy="7" r="1.3"/><circle cx="7" cy="7" r="1.3"/><circle cx="3" cy="12" r="1.3"/><circle cx="7" cy="12" r="1.3"/></svg></span>
          <button class="btn catValMoveBtn" data-act="valDown" data-vi="${vi}" title="Move down" ${vLast?'disabled':''}><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="2" x2="5" y2="8"/><polyline points="3,6 5,8 7,6"/></svg></button>
        </div>
        <div style="display:flex;gap:6px;align-items:center;">
          <input class="inp" data-vf="vlabel" data-vi="${vi}" value="${vlabel}" placeholder="Label" style="flex:1 1 100px;"/>
          <input class="inp" data-vf="vid" data-vi="${vi}" data-orig-id="${vid}" value="${vid}" style="font-family:var(--mono);font-size:11px;max-width:90px;flex:0 1 90px;" title="Value ID"/><span class="autoTag" data-auto="vid" data-vi="${vi}">auto</span>
          <button class="btn" data-act="delVal" data-vi="${vi}" style="border-color:rgba(255,154,168,.45);flex-shrink:0;padding:2px 7px;font-size:11px;">\u00d7</button>
        </div>
        <div style="display:flex;gap:6px;align-items:center;margin-top:5px;flex-wrap:wrap;">
          <input class="inp" data-vf="vabbr" data-vi="${vi}" value="${vabbr}" placeholder="Abbr" style="width:45px;flex:0 0 auto;font-size:11px;text-align:center;" title="Abbreviation"/><span class="autoTag" data-auto="vabbr" data-vi="${vi}">auto</span>
          <input class="inp valEmojiInp" data-vf="vemoji" data-vi="${vi}" value="${escapeHtml(v.emoji||'')}" placeholder="" style="width:48px;text-align:center;font-size:14px;flex:0 0 auto;" title="Emoji"/>
          <button class="btn valEmojiBtn" data-vi="${vi}" style="font-size:11px;padding:2px 5px;flex-shrink:0;" title="Pick emoji"></button>
          <button class="btn valDmBtn" data-vi="${vi}" data-vdm="${v.displayMode||'abbr'}" style="font-size:9px;padding:1px 5px;opacity:${v.emoji?'1':'.4'};flex-shrink:0;" title="Toggle display: Abbreviation or Emoji">${(v.displayMode==='emoji'&&v.emoji)?'Emoji':'Abbr'}</button>
          <span style="width:1px;height:14px;background:var(--border);flex-shrink:0;opacity:.5;"></span>
          <input type="color" data-vf="vcolor" data-vi="${vi}" value="${vcolor||'#6b7280'}" style="width:22px;height:18px;padding:0;border:1px solid var(--border);border-radius:3px;cursor:pointer;flex-shrink:0;${vcolor && v.colorEnabled!==false?'':'opacity:.3;'}" title="Value color"/>
          <button class="btn attrValSwatchBtn" data-vi="${vi}" style="font-size:11px;padding:2px 5px;flex-shrink:0;" title="Color presets"></button>
          <label style="font-size:10px;cursor:pointer;display:inline-flex;align-items:center;gap:2px;flex-shrink:0;"><input type="checkbox" data-vf="vcolorOn" data-vi="${vi}" ${(vcolor && v.colorEnabled!==false)?'checked':''} style="margin:0;"/> Apply</label>
          <span class="layoutReset attrValColorReset" data-vi="${vi}" title="Reset color" style="opacity:.3;cursor:pointer;font-size:11px;color:var(--muted);"></span>
          <span style="width:1px;height:14px;background:var(--border);flex-shrink:0;opacity:.5;"></span>
          <input class="inp" data-vf="vnote" data-vi="${vi}" value="${vnote}" placeholder="Note" style="flex:1 1 80px;font-size:11px;"/>
        </div>
        <div class="valEmojiGrid" data-vi="${vi}" style="display:none;flex-wrap:wrap;gap:2px;margin:4px 0 0 0;"></div>
        <div class="attrValSwatchPanel" data-vi="${vi}" style="display:none;margin:4px 0 0 0;padding:4px 0;"></div>
      </div>`;
    }).join('');

    const _isNew = isEditing && __catalogEdit.isNew;
    return `<div class="mapCard catItem catEditing" data-aidx="${idx}" style="margin-bottom:10px;border-color:rgba(59,130,246,.5);">
      <div class="kv" style="grid-template-columns: 70px 1fr;">
        <div class="k">Label<span class="req">*</span></div><div class="v"><input class="inp" data-f="label" value="${_isNew ? '' : label}" placeholder="e.g. Status"/></div>
        <div class="k">Id <span class="autoTag" data-auto="id">auto</span></div>
        <div class="v" style="display:flex;gap:8px;align-items:center;">
          <input class="inp" data-f="id" value="${_isNew ? '' : id}" placeholder="auto" style="font-family:var(--mono);font-size:11px;flex:1;"/>
          <span style="font-size:10px;opacity:.35;flex-shrink:0;">Abbr</span><span class="autoTag" data-auto="abbr">auto</span>
          <input class="inp" data-f="abbr" value="${_isNew ? '' : abbr}" placeholder="TY" style="width:55px;flex:0 0 auto;text-align:center;font-size:11px;"/>
        </div>
        <div class="k">Emoji</div>
        <div class="v" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
          <input class="inp" data-f="emoji" value="${_isNew ? '' : escapeHtml(a.emoji||'')}" style="width:48px;text-align:center;font-size:16px;flex:0 0 auto;" placeholder="" maxlength="4"/>
          <button class="btn catEmojiToggle" type="button" style="font-size:11px;padding:2px 5px;" title="Pick emoji"></button>
          <div class="catDmWrap" style="display:inline-flex;border:1px solid var(--border);border-radius:6px;overflow:hidden;flex-shrink:0;"><button class="catDmOpt" data-dm="abbr" style="padding:2px 10px;font-size:11px;border:none;cursor:pointer;background:${(a.displayMode==='emoji')?'transparent':'rgba(59,130,246,.25)'};color:var(--fg);transition:all .15s;">Abbr</button><button class="catDmOpt" data-dm="emoji" style="padding:2px 10px;font-size:11px;border:none;border-left:1px solid var(--border);cursor:pointer;background:${(a.displayMode==='emoji')?'rgba(59,130,246,.25)':'transparent'};color:var(--fg);opacity:${a.emoji?'1':'.4'};transition:all .15s;">Emoji</button></div>
        </div>
        <div class="k"></div>
        <div class="v"><div class="catEmojiGrid" style="display:none;flex-wrap:wrap;gap:2px;margin-top:2px;"></div></div>
        <div class="k">Note</div><div class="v"><input class="inp" data-f="note" value="${_isNew ? '' : note}" placeholder="optional"/></div>
        <div class="k">Color</div><div class="v" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
          <div style="display:flex;align-items:center;gap:6px;">
          <input type="color" data-f="attrColorPicker" value="${a.color||'#6b7280'}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${a.color && a.colorEnabled!==false?'':'opacity:.3;'}"/>
          <input class="inp" data-f="attrColorHex" value="${escapeHtml(a.color && a.colorEnabled!==false ? a.color : '')}" placeholder="optional" style="flex:1;font-family:var(--mono);font-size:11px;max-width:100px;"/>
          <button class="btn attrSwatchToggle" type="button" style="font-size:11px;padding:2px 5px;" title="Color presets"></button>
          <label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" data-f="attrColorOn" ${(a.color && a.colorEnabled!==false)?'checked':''}/> Apply</label>
          <span class="layoutReset attrColorReset" title="Reset color" style="opacity:.3;cursor:pointer;font-size:12px;color:var(--muted);"></span>
          </div>
          <div data-f="attrColorSwatches" style="display:none;gap:3px;flex-wrap:wrap;flex-basis:100%;"></div>
          <span style="font-size:10px;opacity:.4;">Inherited by values without color</span>
        </div>
        <div class="k">Options</div>
        <div class="v" style="display:flex;flex-wrap:wrap;gap:8px 18px;">
          <label class="toggle" style="padding:6px 10px;display:inline-flex;">
            <input type="checkbox" data-f="multi" ${a.multi ? 'checked' : ''}/>
            Multi-value
          </label>
          <label class="toggle" style="padding:6px 10px;display:inline-flex;">
            <input type="checkbox" data-f="displayOnNode" ${a.displayOnNode ? 'checked' : ''}/>
            Display on node
          </label>
        </div>
        ${_catTagRowHtml(_isNew ? [] : a.tags)}
        <div class="k" style="padding-top:10px;">Values</div>
        <div class="v" style="padding-top:6px;">
          ${valsHtml || '<div class="empty">No values yet.</div>'}
          <div class="inlineValCreator" style="margin-top:6px;display:flex;gap:6px;align-items:center;padding:5px 10px 5px 32px;border:1px dashed var(--border);border-radius:8px;opacity:.6;transition:opacity .15s;">
            <input class="inp" data-act="inlineValLabel" placeholder="Type a value label and press Enter" style="flex:1;font-size:12px;"/>
            <button class="btn" data-act="addVal" style="font-size:10px;padding:2px 8px;flex-shrink:0;">+ Add</button>
          </div>
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap;">
        ${_isNew ? '' : '<button class="btn" data-act="delAttr" style="border-color:rgba(255,154,168,.45);">Delete</button>'}
        <span style="flex:1;"></span>
        <button class="btn" data-act="cancel">Cancel</button>
        <button class="btn btnSave" data-act="save">Save</button>
      </div>
    </div>`;
  }).join('\n');
  body.innerHTML = rows;
  body.classList.toggle('catEditActive', __catalogEdit.kind === 'attr' && __catalogEdit.idx >= 0);

  // Reorder button handlers (must be before click-to-edit so stopPropagation works)
  body.querySelectorAll('.catMoveBtn[data-act="moveUp"], .catMoveBtn[data-act="moveDown"]').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(!state.editorMode) return;
      const aidx = Number(btn.dataset.aidx);
      if(isNaN(aidx)) return; // skip value reorder buttons handled separately
      const dir = btn.dataset.act === 'moveUp' ? -1 : 1;
      const pos = sortedIdxs.indexOf(aidx);
      const swapPos = pos + dir;
      if(swapPos < 0 || swapPos >= sortedIdxs.length) return;
      const otherIdx = sortedIdxs[swapPos];
      recordChange();
      const tmp = cat[aidx].priority;
      cat[aidx].priority = cat[otherIdx].priority;
      cat[otherIdx].priority = tmp;
      renderCustomAttrsManager();
      renderAll();
    });
  });

  // Drag-and-drop reorder (like tags)
  let __attrDragSortPos = null;
  let __attrDragTime = 0;
  body.querySelectorAll('.catItem:not(.catEditing)').forEach(card=>{
    card.addEventListener('dragstart', (e)=>{
      __attrDragSortPos = Number(card.dataset.sortPos);
      __attrDragTime = Date.now();
      card.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    });
    card.addEventListener('dragend', ()=>{
      card.style.opacity = '';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      __attrDragSortPos = null;
    });
    card.addEventListener('dragover', (e)=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      body.querySelectorAll('.catItem').forEach(c => c.classList.remove('dragOver'));
      card.classList.add('dragOver');
    });
    card.addEventListener('dragleave', ()=>{
      card.classList.remove('dragOver');
    });
    card.addEventListener('drop', (e)=>{
      e.preventDefault();
      card.classList.remove('dragOver');
      const fromPos = __attrDragSortPos;
      const toPos = Number(card.dataset.sortPos);
      if(fromPos === null || fromPos === toPos) return;
      const reordered = [...sortedIdxs];
      const [moved] = reordered.splice(fromPos, 1);
      reordered.splice(toPos, 0, moved);
      recordChange();
      reordered.forEach((catIdx, newPos) => { cat[catIdx].priority = newPos + 1; });
      renderCustomAttrsManager();
      renderAll();
    });
  });

  body.querySelectorAll('.catItem').forEach(card=>{
    const aidx = Number(card.dataset.aidx);
    const a = ensureCustomAttributeCatalog()[aidx];
    if(!a) return;
    const isEditing = catalogIsEditing('attr', aidx);

    if(!isEditing){
      card.addEventListener('click', async (e)=>{
        if(!state.editorMode) return;
        if(e.target.closest('.catMoveBtn')) return;
        if(Date.now() - __attrDragTime < 300) return;
        const itemId = a?.id;
        if(!await guardCatalogAbandon()) return;
        catalogEditEnd();
        const freshCat = ensureCustomAttributeCatalog();
        const freshIdx = freshCat.findIndex(x => x.id === itemId);
        if(freshIdx < 0) { renderCustomAttrsManager(); return; }
        catalogEditBegin('attr', freshIdx, freshCat[freshIdx]);
        renderCustomAttrsManager();
      });
      return;
    }

    // ---- Edit mode wiring ----

    // Value reorder buttons (within edit form)
    card.querySelectorAll('[data-act="valUp"], [data-act="valDown"]').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        const vi = Number(btn.dataset.vi);
        if(!a.values || !a.values[vi]) return;
        const vals = a.values;
        // Sort to find neighbors
        const sorted = vals.map((_,i)=>i).sort((x,y)=>{
          const px = typeof vals[x].priority==='number' ? vals[x].priority : 9999;
          const py = typeof vals[y].priority==='number' ? vals[y].priority : 9999;
          return px - py;
        });
        const pos = sorted.indexOf(vi);
        const dir = btn.dataset.act === 'valUp' ? -1 : 1;
        const swapPos = pos + dir;
        if(swapPos < 0 || swapPos >= sorted.length) return;
        const otherVi = sorted[swapPos];
        const tmp = vals[vi].priority;
        vals[vi].priority = vals[otherVi].priority;
        vals[otherVi].priority = tmp;
        renderCustomAttrsManager();
      });
    });

    // Save: read ALL form values and apply in one shot
    card.querySelector('[data-act="save"]')?.addEventListener('click', ()=>{
      const newLabel = (card.querySelector('[data-f="label"]')?.value||'').trim() || a.label;
      if(!newLabel){ customAlert('Please enter a label.'); card.querySelector('[data-f="label"]')?.focus(); return; }
      let newId = sanitizeManualId(card.querySelector('[data-f="id"]')?.value||'');
      if(!newId) newId = idPartFromLabel(newLabel, {lower:true}) || a.id;
      const newAbbr = (card.querySelector('[data-f="abbr"]')?.value||'').trim();
      const newNote = (card.querySelector('[data-f="note"]')?.value||'').trim();
      const newMulti = !!card.querySelector('[data-f="multi"]')?.checked;
      const newDisplayOnNode = !!card.querySelector('[data-f="displayOnNode"]')?.checked;

      // Collect value edits from form + track renames
      const valRenames = []; // [{oldId, newId}]
      const newValues = [];
      card.querySelectorAll('[data-vf="vlabel"]').forEach(inp=>{
        const vi = Number(inp.dataset.vi);
        const vidInp = card.querySelector(`[data-vf="vid"][data-vi="${vi}"]`);
        const vnoteInp = card.querySelector(`[data-vf="vnote"][data-vi="${vi}"]`);
        const vcolorInp = card.querySelector(`[data-vf="vcolor"][data-vi="${vi}"]`);
        const vabbrInp = card.querySelector(`[data-vf="vabbr"][data-vi="${vi}"]`);
        const origId = vidInp?.dataset?.origId || '';
        const curId = sanitizeManualId(vidInp?.value||'') || origId;
        if(origId && curId && origId !== curId) valRenames.push({oldId: origId, newId: curId});
        const vObj = {
          id: curId,
          label: (inp.value||'').trim() || curId,
          note: (vnoteInp?.value||'').trim()
        };
        // Persist auto-link flags from row dataset
        const valRow = inp.closest('.attrValRow');
        if(valRow) {
          vObj._autoId = valRow.dataset.autoId === '1';
          vObj._autoAbbr = valRow.dataset.autoAbbr === '1';
        }
        // Preserve priority from the original value
        const origVal = a.values && a.values[vi];
        if(origVal && typeof origVal.priority === 'number') vObj.priority = origVal.priority;
        // Abbreviation
        const vabbrVal = (vabbrInp?.value||'').trim();
        if(vabbrVal) vObj.abbr = vabbrVal;
        // Emoji and display mode
        const vemojiInp = card.querySelector(`[data-vf="vemoji"][data-vi="${vi}"]`);
        const vemojiVal = (vemojiInp?.value||'').trim();
        if(vemojiVal) vObj.emoji = vemojiVal;
        const vdmBtn = card.querySelector(`.valDmBtn[data-vi="${vi}"]`);
        vObj.displayMode = vdmBtn?.dataset?.vdm || 'abbr';
        // Only store color if the picker was actively used (not the placeholder gray)
        const vcolorVal = vcolorInp?.value || '';
        const vcolorOnCb = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
        const vcolorEnabled = vcolorOnCb ? !!vcolorOnCb.checked : (parseFloat(vcolorInp?.style?.opacity||'1') > 0.5);
        if(vcolorVal && vcolorEnabled){ vObj.color = vcolorVal; vObj.colorEnabled = true; }
        else if(vcolorVal && parseFloat(vcolorInp?.style?.opacity||'1') > 0.5){ vObj.color = vcolorVal; vObj.colorEnabled = false; }
        else { vObj.colorEnabled = false; }
        newValues.push(vObj);
      });

      // Enforce unique value IDs on save
      {
        const seenIds = new Set();
        for(const vObj of newValues){
          if(!vObj.id || seenIds.has(vObj.id)){
            vObj.id = ensureUniqueId(vObj.id || 'val', seenIds);
          }
          seenIds.add(vObj.id);
        }
      }

      // For new items, remove placeholder before snapshot so undo doesn't include it
      if(__catalogEdit.isNew) cat.splice(idx, 1);
      recordChange();
      if(__catalogEdit.isNew) cat.splice(idx, 0, a);
      a.label = newLabel; a.abbr = newAbbr; a.note = newNote; a.multi = newMulti;
      a._autoId = __editorAutoId; a._autoAbbr = __editorAutoAbbr;
      a.emoji = (card.querySelector('[data-f="emoji"]')?.value||'').trim() || undefined;
      a.displayMode = __editorDisplayMode;
      a.displayOnNode = newDisplayOnNode;
      // Attribute-level color
      const attrColorPicker = card.querySelector('[data-f="attrColorPicker"]');
      const attrColorOn = card.querySelector('[data-f="attrColorOn"]');
      if(attrColorOn && attrColorOn.checked && attrColorPicker){
        a.color = attrColorPicker.value; a.colorEnabled = true;
      } else if(attrColorPicker && parseFloat(attrColorPicker.style.opacity||'1') > 0.5){
        a.color = attrColorPicker.value; a.colorEnabled = false;
      } else {
        delete a.color; a.colorEnabled = false;
      }
      a.values = newValues;
      a.tags = _readCatTags(card);
      if(!a.tags.length) delete a.tags;

      // Handle attribute ID rename
      const attrIdForRenames = a.id;
      if(newId !== a.id){
        const result = reIdCustomAttrInData(state.data, a.id, newId);
        if(result === a.id) setGlobalStatus('Attribute ID conflict \u2014 not changed.');
      }

      // Handle value ID renames (cascade to node assignments)
      valRenames.forEach(({oldId, newId: vid})=>{
        reIdCustomAttrValueInData(state.data, a.id, oldId, vid);
      });

      catalogEditEnd(); renderCustomAttrsManager(); renderAll();
    });

    // Cancel
    card.querySelector('[data-act="cancel"]')?.addEventListener('click', ()=>{
      if(__catalogEdit.isNew){
        _removeCatalogNewEntry();
      } else {
        const snap = __catalogEdit.snapshot;
        if(snap && a){
          Object.assign(a, JSON.parse(JSON.stringify(snap)));
        }
      }
      catalogEditEnd(); checkDirtyState(); renderCustomAttrsManager();
    });

    // Delete value
    card.querySelectorAll('[data-act="delVal"]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const vi = Number(btn.dataset.vi);
        if(!a.values) return;
        a.values.splice(vi, 1);
        renderCustomAttrsManager();
      });
    });

    // Inline value creator
    const inlineValInput = card.querySelector('[data-act="inlineValLabel"]');
    const inlineAddBtn = card.querySelector('[data-act="addVal"]');
    const _commitInlineVal = ()=>{
      const lbl = (inlineValInput?.value||'').trim();
      if(!lbl) return;
      if(!Array.isArray(a.values)) a.values = [];
      const taken = new Set(a.values.map(v=>v?.id).filter(Boolean));
      const baseId = idPartFromLabel(lbl, {lower:true}) || 'val';
      const id = ensureUniqueId(baseId, taken);
      const baseAbbr = lbl.replace(/\s+/g,'').slice(0,3).toUpperCase();
      let maxVP = 0;
      a.values.forEach(v=>{ if(v && typeof v.priority==='number' && v.priority > maxVP) maxVP = v.priority; });
      a.values.push({id, label:lbl, abbr:baseAbbr, note:'', priority:maxVP+1, _autoId:true, _autoAbbr:true});
      if(inlineValInput) inlineValInput.value = '';
      renderCustomAttrsManager();
    };
    if(inlineValInput){
      inlineValInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); _commitInlineVal(); } });
      // Focus on the inline input for quick entry
      const creator = card.querySelector('.inlineValCreator');
      if(creator){
        inlineValInput.addEventListener('focus', ()=> creator.style.opacity='1');
        inlineValInput.addEventListener('blur', ()=>{ if(!inlineValInput.value.trim()) creator.style.opacity='.6'; });
      }
    }
    if(inlineAddBtn) inlineAddBtn.addEventListener('click', _commitInlineVal);

    // Value color picker
    card.querySelectorAll('[data-vf="vcolor"]').forEach(inp=>{
      inp.addEventListener('input', ()=>{
        inp.style.opacity = '1';
        const vi = Number(inp.dataset.vi);
        if(a.values && a.values[vi]){ a.values[vi].color = inp.value; a.values[vi].colorEnabled = true; }
        const cb = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
        if(cb) cb.checked = true;
      });
    });

    // Value colorEnabled checkboxes
    const _kick = ()=>{ const s = card.querySelector('[data-act="save"]'); if(s && s.__dirtyUpdate) s.__dirtyUpdate(); };
    card.querySelectorAll('[data-vf="vcolorOn"]').forEach(cb=>{
      cb.addEventListener('change', ()=>{
        const vi = Number(cb.dataset.vi);
        const colorInp = card.querySelector(`[data-vf="vcolor"][data-vi="${vi}"]`);
        if(colorInp) colorInp.style.opacity = cb.checked ? '1' : '.3';
        if(a.values && a.values[vi]) a.values[vi].colorEnabled = cb.checked;
        _kick();
      });
    });

    // Value color pickers  auto-check Apply on change
    card.querySelectorAll('[data-vf="vcolor"]').forEach(colorInp=>{
      colorInp.addEventListener('input', ()=>{
        const vi = colorInp.dataset.vi;
        const cb = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
        if(cb) cb.checked = true;
        colorInp.style.opacity = '1';
        _kick();
      });
      colorInp.addEventListener('change', _kick);
    });

    // Value color swatch toggle buttons
    card.querySelectorAll('.attrValSwatchBtn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const vi = btn.dataset.vi;
        const panel = card.querySelector(`.attrValSwatchPanel[data-vi="${vi}"]`);
        if(!panel) return;
        const visible = panel.style.display !== 'none';
        panel.style.display = visible ? 'none' : 'flex';
        if(!visible && !panel.dataset.built){
          panel.dataset.built = '1';
          panel.style.cssText += 'gap:5px;flex-wrap:wrap;align-items:center;';
          const colorInp = card.querySelector(`[data-vf="vcolor"][data-vi="${vi}"]`);
          TAG_COLOR_PRESETS.forEach(p=>{
            const s = document.createElement('div');
            s.className = 'swatch';
            s.style.cssText = 'width:18px;height:18px;border-radius:6px;flex-shrink:0;cursor:pointer;border:1px solid rgba(255,255,255,.12);box-shadow:0 2px 8px rgba(0,0,0,.2);';
            s.style.background = p.value;
            s.title = p.name;
            s.addEventListener('click', ()=>{
              if(colorInp){ colorInp.value = p.value; colorInp.style.opacity = '1'; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
              const cb2 = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
              if(cb2) cb2.checked = true;
              _kick();
            });
            panel.appendChild(s);
          });
        }
      });
    });

    // Value color reset icons
    card.querySelectorAll('.attrValColorReset').forEach(icon=>{
      icon.addEventListener('click', ()=>{
        const vi = Number(icon.dataset.vi);
        const colorInp = card.querySelector(`[data-vf="vcolor"][data-vi="${vi}"]`);
        if(colorInp){ colorInp.value = '#6b7280'; colorInp.style.opacity = '.3'; colorInp.dispatchEvent(new Event('input',{bubbles:true})); }
        const cb = card.querySelector(`[data-vf="vcolorOn"][data-vi="${vi}"]`);
        if(cb) cb.checked = false;
        if(a.values && a.values[vi]){ delete a.values[vi].color; a.values[vi].colorEnabled = false; }
        _kick();
      });
    });

    // Value row drag-and-drop reordering
    {
      let __valDragVi = null;
      card.querySelectorAll('.attrValRow').forEach(row=>{
        const vi = Number(row.dataset.vi);
        // Prevent drag when interacting with inputs
        row.querySelectorAll('input, select, button').forEach(el=>{
          el.addEventListener('mousedown', ()=>{ row.draggable = false; });
          el.addEventListener('mouseup', ()=>{ row.draggable = true; });
        });
        row.addEventListener('dragstart', (e)=>{
          __valDragVi = vi;
          row.style.opacity = '0.4';
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', '');
        });
        row.addEventListener('dragend', ()=>{
          row.style.opacity = '';
          row.draggable = true;
          card.querySelectorAll('.attrValRow').forEach(r => r.classList.remove('valDragOver'));
          __valDragVi = null;
        });
        row.addEventListener('dragover', (e)=>{
          if(__valDragVi === null || __valDragVi === vi) return;
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          card.querySelectorAll('.attrValRow').forEach(r => r.classList.remove('valDragOver'));
          row.classList.add('valDragOver');
        });
        row.addEventListener('dragleave', ()=>{ row.classList.remove('valDragOver'); });
        row.addEventListener('drop', (e)=>{
          e.preventDefault();
          card.querySelectorAll('.attrValRow').forEach(r => r.classList.remove('valDragOver'));
          if(__valDragVi === null || __valDragVi === vi || !a.values) return;
          // Swap priorities to reorder
          const fromVal = a.values[__valDragVi];
          const toVal = a.values[vi];
          if(fromVal && toVal){
            const tmp = fromVal.priority;
            fromVal.priority = toVal.priority;
            toVal.priority = tmp;
            renderCustomAttrsManager();
          }
          __valDragVi = null;
        });
      });
    }

    // Attribute-level color swatches, picker, checkbox, reset
    {
      const attrColorPicker = card.querySelector('[data-f="attrColorPicker"]');
      const attrColorOn = card.querySelector('[data-f="attrColorOn"]');
      const attrColorHex = card.querySelector('[data-f="attrColorHex"]');
      const attrColorReset = card.querySelector('.attrColorReset');
      const attrSwatchWrap = card.querySelector('[data-f="attrColorSwatches"]');
      if(attrSwatchWrap && attrColorPicker){
        buildColorSwatches(attrSwatchWrap, attrColorPicker, attrColorOn, _kick);
        //  toggle button
        const attrSwatchToggle = card.querySelector('.attrSwatchToggle');
        if(attrSwatchToggle) attrSwatchToggle.addEventListener('click', ()=>{
          const vis = attrSwatchWrap.style.display !== 'none';
          attrSwatchWrap.style.display = vis ? 'none' : 'flex';
        });
        // When picker changes, auto-check Apply
        attrColorPicker.addEventListener('input', ()=>{
          if(attrColorOn) attrColorOn.checked = true;
          attrColorPicker.style.opacity = '1';
          if(attrColorHex) attrColorHex.value = attrColorPicker.value;
          _kick();
        });
        attrColorPicker.addEventListener('change', _kick);
      }
      if(attrColorHex){
        attrColorHex.addEventListener('input', ()=>{
          const v = (attrColorHex.value||'').trim();
          if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
            if(attrColorPicker) attrColorPicker.value = v;
            if(attrColorOn) attrColorOn.checked = true;
            if(attrColorPicker) attrColorPicker.style.opacity = '1';
          }
          _kick();
        });
      }
      if(attrColorOn){
        attrColorOn.addEventListener('change', ()=>{
          if(attrColorPicker) attrColorPicker.style.opacity = attrColorOn.checked ? '1' : '.3';
          _kick();
        });
      }
      if(attrColorReset){
        attrColorReset.addEventListener('click', ()=>{
          if(attrColorPicker){ attrColorPicker.value = '#6b7280'; attrColorPicker.style.opacity = '.3'; attrColorPicker.dispatchEvent(new Event('input',{bubbles:true})); }
          if(attrColorOn) attrColorOn.checked = false;
          if(attrColorHex) attrColorHex.value = '';
          _kick();
        });
      }
    }

    // Value row labelidabbr auto-fill
    card.querySelectorAll('.attrValRow').forEach(row=>{
      const vi = row.dataset.vi;
      const vlabelInp = row.querySelector('[data-vf="vlabel"]');
      const vidInp = row.querySelector('[data-vf="vid"]');
      const vabbrInp = row.querySelector('[data-vf="vabbr"]');
      const vidAutoTag = row.querySelector('[data-auto="vid"]');
      const vabbrAutoTag = row.querySelector('[data-auto="vabbr"]');
      if(!vlabelInp || !vidInp) return;
      const slugV = (raw)=> raw ? idPartFromLabel(raw, {lower:true}) : '';
      const autoAbbrV = (raw)=> raw ? raw.replace(/\s+/g,'').slice(0,3).toUpperCase() : '';
      // Collect sibling value IDs for uniqueness checking
      const siblingValIds = ()=>{
        const ids = new Set();
        card.querySelectorAll('[data-vf="vid"]').forEach(el=>{
          if(el.dataset.vi !== vi) ids.add(el.value.trim());
        });
        return ids;
      };
      // Use actual value for backward compat
      const initIdLocal = vidInp.value.trim();
      const valObj = a.values && a.values[Number(vi)];
      let lastAutoId = (valObj && valObj._autoId) ? initIdLocal : '';
      let lastAutoAbbr = '';
      if(vabbrInp){
        const initAbbrLocal = vabbrInp.value.trim();
        lastAutoAbbr = (valObj && valObj._autoAbbr) ? initAbbrLocal : '';
      }
      row.dataset.autoId = lastAutoId !== '' ? '1' : '0';
      row.dataset.autoAbbr = lastAutoAbbr !== '' ? '1' : '0';
      const refreshAutoTags = ()=>{
        if(vidAutoTag){ const on = lastAutoId !== ''; vidAutoTag.style.display = on ? '' : 'none'; vidAutoTag.classList.toggle('clickable', on); }
        if(vabbrAutoTag){ const on = lastAutoAbbr !== ''; vabbrAutoTag.style.display = on ? '' : 'none'; vabbrAutoTag.classList.toggle('clickable', on); }
      };
      refreshAutoTags();
      if(vidAutoTag){ vidAutoTag.title = 'Click to freeze ID'; vidAutoTag.addEventListener('click', ()=>{
        lastAutoId = '';
        row.dataset.autoId = '0';
        refreshAutoTags();
      }); }
      if(vabbrAutoTag){ vabbrAutoTag.title = 'Click to freeze abbreviation'; vabbrAutoTag.addEventListener('click', ()=>{
        lastAutoAbbr = '';
        row.dataset.autoAbbr = '0';
        refreshAutoTags();
      }); }
      vlabelInp.addEventListener('input', ()=>{
        const raw = vlabelInp.value.trim();
        const cur = vidInp.value.trim();
        if(!cur || cur === lastAutoId){ let ai = slugV(raw)||''; if(ai){ ai = ensureUniqueId(ai, siblingValIds()); vidInp.value = ai; lastAutoId = ai; } }
        if(vabbrInp){
          const ca = vabbrInp.value.trim();
          if(!ca || ca === lastAutoAbbr){ const ab = autoAbbrV(raw); if(ab){ vabbrInp.value = ab; lastAutoAbbr = ab; } }
        }
        row.dataset.autoId = lastAutoId !== '' ? '1' : '0';
        row.dataset.autoAbbr = lastAutoAbbr !== '' ? '1' : '0';
        refreshAutoTags();
      });
      vidInp.addEventListener('input', ()=>{
        if(!vidInp.value.trim()){ let ai = slugV(vlabelInp.value.trim())||''; if(ai){ ai = ensureUniqueId(ai, siblingValIds()); } vidInp.value = ai; lastAutoId = ai; }
        else lastAutoId = '';
        row.dataset.autoId = lastAutoId !== '' ? '1' : '0';
        refreshAutoTags();
      });
      if(vabbrInp){
        vabbrInp.addEventListener('input', ()=>{
          if(!vabbrInp.value.trim()){ const ab = autoAbbrV(vlabelInp.value.trim()); vabbrInp.value = ab; lastAutoAbbr = ab; }
          else lastAutoAbbr = '';
          row.dataset.autoAbbr = lastAutoAbbr !== '' ? '1' : '0';
          refreshAutoTags();
        });
      }
      // Value emoji + display mode toggle
      const vemojiInp = row.querySelector('[data-vf="vemoji"]');
      const vdmBtn = row.querySelector('.valDmBtn');
      if(vemojiInp && vdmBtn){
        vemojiInp.addEventListener('input', ()=>{
          const has = !!vemojiInp.value.trim();
          vdmBtn.style.opacity = has ? '1' : '.4';
          if(has && vdmBtn.dataset.vdm === 'abbr'){ vdmBtn.dataset.vdm = 'emoji'; vdmBtn.textContent = 'Emoji'; }
          if(!has && vdmBtn.dataset.vdm === 'emoji'){ vdmBtn.dataset.vdm = 'abbr'; vdmBtn.textContent = 'Abbr'; }
        });
        vdmBtn.addEventListener('click', (e)=>{
          e.preventDefault();
          if(!vemojiInp.value.trim() && vdmBtn.dataset.vdm === 'abbr') return;
          const next = vdmBtn.dataset.vdm === 'abbr' ? 'emoji' : 'abbr';
          if(next === 'emoji' && !vemojiInp.value.trim()) return;
          vdmBtn.dataset.vdm = next;
          vdmBtn.textContent = next === 'emoji' ? 'Emoji' : 'Abbr';
        });
      }
    });

    // Delete attribute
    card.querySelector('[data-act="delAttr"]')?.addEventListener('click', async ()=>{
      if(!__catalogEdit.isNew && !await customConfirm('Delete attribute? This will remove it from all nodes.')) return;
      if(!__catalogEdit.isNew) recordChange();
      const aid = a.id;
      ensureCustomAttributeCatalog().splice(aidx,1);
      if(aid){
        for(const n of IDX.nodeById.values()){
          if(n && n.customAttributes && typeof n.customAttributes==='object') delete n.customAttributes[aid];
        }
      }
      catalogEditEnd(); renderCustomAttrsManager(); renderAll();
    });
    wireDirtyHighlight(card, card.querySelector('[data-act="save"]'), catalogFormIsDirty, ()=> !!(card.querySelector('[data-f="label"]')?.value||'').trim());
    _wireLabelToId(card, 'attr', a);
    _wireCatalogEmoji(card, a);
    _wireCatTagSelector(card);

    // Emoji picker toggle button (attribute level)
    const _emojiTogBtn = card.querySelector('.catEmojiToggle');
    const _emojiGrid = card.querySelector('.catEmojiGrid');
    if(_emojiTogBtn && _emojiGrid){
      _emojiTogBtn.addEventListener('click', (e)=>{
        e.preventDefault();
        const vis = _emojiGrid.style.display !== 'none';
        _emojiGrid.style.display = vis ? 'none' : 'flex';
        _emojiTogBtn.textContent = vis ? '' : '';
      });
    }

    // Value-level emoji grids ( button toggle)
    card.querySelectorAll('.valEmojiBtn').forEach(btn=>{
      const vi = btn.dataset.vi;
      const grid = card.querySelector(`.valEmojiGrid[data-vi="${vi}"]`);
      const inp = card.querySelector(`.valEmojiInp[data-vi="${vi}"]`);
      if(!grid || !inp) return;
      btn.addEventListener('click', ()=>{
        const vis = grid.style.display !== 'none';
        grid.style.display = vis ? 'none' : 'flex';
        btn.textContent = vis ? '' : '';
        if(!vis && !grid.dataset.built){
          grid.dataset.built = '1';
          grid.innerHTML = CATALOG_EMOJI_PICKS.map(e=>`<button class="catEP valEP" data-emoji="${e}" data-vi="${vi}" style="font-size:14px;padding:2px 4px;border:1px solid transparent;border-radius:5px;background:transparent;cursor:pointer;line-height:1;" title="${e}">${e}</button>`).join('') + '<button class="catEP valEP" data-emoji="" data-vi="${vi}" style="font-size:10px;padding:2px 5px;border:1px solid var(--border);border-radius:5px;background:transparent;cursor:pointer;color:var(--muted);line-height:1;" title="Clear"></button>';
          grid.querySelectorAll('.valEP').forEach(pick=>{
            pick.addEventListener('click', (ev)=>{
              ev.preventDefault();
              inp.value = pick.dataset.emoji;
              inp.dispatchEvent(new Event('input', {bubbles:true}));
              if(!pick.dataset.emoji){ grid.style.display = 'none'; btn.textContent = ''; }
            });
          });
        }
      });
    });
  });
}
function openCustomAttrs(){
  ensureCustomAttributeCatalog();
  normalizeCatalogMultiFlag();
  catalogEditEnd();
  renderCustomAttrsManager();
  if(addCustomAttrBtn) addCustomAttrBtn.style.display = state.editorMode ? '' : 'none';
  { const b=document.getElementById('importAttrsBtn'); if(b) b.style.display = state.editorMode ? '' : 'none'; }
  document.getElementById('customAttrsMask')?.classList.add('active');
  document.getElementById('customAttrsModal')?.classList.add('active');
}
async function closeCustomAttrs(){
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  document.getElementById('customAttrsMask')?.classList.remove('active');
  document.getElementById('customAttrsModal')?.classList.remove('active');
}
// 
// Import fields modal
// 
// Tab/Shift+Tab indentation helper for import textareas
function _wireTabIndent(textarea, refreshFn){
  if(!textarea) return;
  textarea.addEventListener('keydown', (e) => {
    if(e.key !== 'Tab') return;
    e.preventDefault();
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const val = textarea.value;

    if(!e.shiftKey){
      // Insert real tab character (works for both TSV and plain indentation)
      const indent = '\t';
      textarea.value = val.substring(0, start) + indent + val.substring(end);
      textarea.selectionStart = textarea.selectionEnd = start + indent.length;
    } else {
      // Shift+Tab: remove leading indent from current line(s)
      const before = val.substring(0, start);
      const lineStart = before.lastIndexOf('\n') + 1;
      const line = val.substring(lineStart);
      const stripped = line.replace(/^( {1,4}|\t)/, '');
      const removed = line.length - stripped.length;
      if(removed > 0){
        textarea.value = val.substring(0, lineStart) + stripped;
        textarea.selectionStart = textarea.selectionEnd = Math.max(lineStart, start - removed);
      }
    }
    if(refreshFn) refreshFn();
  });
}

let __importColId = null;

function openImportFields(colId){
  if(!state.editorMode){ customAlert('Switch to Editor mode to import fields.'); return; }
  __importColId = colId;
  const col = findColumnById(colId);
  const colLabel = col ? (col.label || col.id) : colId;
  const body = document.getElementById('importFieldsBody');
  const commitBtn = document.getElementById('importFieldsCommit');
  if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }

  body.innerHTML = `
<div style="margin-bottom:10px;">
  <div style="font-size:12px;opacity:.6;margin-bottom:8px;">Target column: <b>${escapeHtml(colLabel)}</b></div>
  <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
    <span style="font-size:11px;opacity:.5;">Insert at:</span>
    <div class="dockSelector" id="importPosSelector" style="flex:0 auto;">
      <button class="dockOpt active" data-ipos="bottom" style="padding:4px 12px;min-width:0;">Bottom</button>
      <button class="dockOpt" data-ipos="top" style="padding:4px 12px;min-width:0;">Top</button>
    </div>
    <span style="font-size:11px;opacity:.5;margin-left:8px;">Nesting parent:</span>
    <select class="inp" id="importParentSel" style="font-size:11px;max-width:220px;"></select>
  </div>
</div>
<textarea id="importFieldsText" style="width:100%;min-height:180px;max-height:40vh;font-family:var(--mono);font-size:12px;line-height:1.5;padding:10px 12px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);color:var(--text);resize:vertical;" placeholder="Paste field names  one per line.&#10;&#10;Plain lines:&#10;  customer_id&#10;  first_name&#10;  Address         indented children become groups&#10;      street&#10;      city&#10;&#10;Tab-separated (paste from Excel / DB tool):&#10;  label&#9;parent&#9;note&#10;  customer_id&#9;&#9;Primary key&#10;  Address&#9;&#9;Group&#10;  street&#9;Address&#9;Street name&#10;  city&#9;Address&#9;City name"></textarea>
<div id="importDetectedMode" style="font-size:10px;opacity:.4;margin-top:4px;"></div>
<div id="importPreview" style="margin-top:12px;"></div>`;

  // Build parent selector (column root + all groups)
  const parentSel = body.querySelector('#importParentSel');
  if(parentSel && col){
    parentSel.innerHTML = `<option value="${escapeHtml(colId)}">${escapeHtml(colLabel)} (root)</option>`;
    const walkGroups = (node, depth) => {
      if(node.type === 'group' && node.id !== colId){
        const indent = '\u00A0\u00A0'.repeat(depth);
        parentSel.innerHTML += `<option value="${escapeHtml(node.id)}">${indent} ${escapeHtml(node.label || node.id)}</option>`;
      }
      (node.children || []).forEach(c => walkGroups(c, depth + 1));
    };
    if(col.schema) walkGroups(col.schema, 0);
  }

  // Position selector
  const posSel = body.querySelector('#importPosSelector');
  if(posSel) posSel.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-ipos]');
    if(!btn) return;
    posSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b === btn));
    _refreshImportPreview();
  });

  // Textarea input handler
  const textarea = body.querySelector('#importFieldsText');
  if(textarea){
    textarea.addEventListener('input', _refreshImportPreview);
    _wireTabIndent(textarea, _refreshImportPreview);
    textarea.focus();
  }

  // File upload handler
  const fInput = document.getElementById('importFieldsFileInput');
  if(fInput){ fInput.value = ''; fInput.onchange = (ev) => {
    const f = ev.target.files?.[0]; if(!f) return;
    const r = new FileReader(); r.onload = (e) => { if(textarea){ textarea.value = e.target.result; _refreshImportPreview(); } };
    r.readAsText(f); fInput.value = '';
  }; }

  document.getElementById('importFieldsMask')?.classList.add('active');
  document.getElementById('importFieldsModal')?.classList.add('active');
}

function closeImportFields(){
  __importColId = null;
  document.getElementById('importFieldsMask')?.classList.remove('active');
  document.getElementById('importFieldsModal')?.classList.remove('active');
}

document.getElementById('importFieldsClose')?.addEventListener('click', closeImportFields);
document.getElementById('importFieldsMask')?.addEventListener('click', closeImportFields);
document.getElementById('importFieldsCommit')?.addEventListener('click', _commitImportFields);
document.getElementById('importFieldsModal')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); closeImportFields(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    const btn = document.getElementById('importFieldsCommit');
    if(btn && !btn.disabled) _commitImportFields();
  }
});

function _parseImportText(text){
  const lines = text.split('\n').filter(l => l.trim());
  if(!lines.length) return { mode:'empty', nodes:[] };

  // Detect mode: if first line has tabs  TSV; otherwise plain
  const firstLine = lines[0];
  const hasTabs = firstLine.includes('\t');

  if(hasTabs) return _parseTSV(lines);
  return _parsePlainLines(lines);
}

function _parsePlainLines(lines){
  // Each line: leading whitespace = nesting level
  // Lines with deeper children = groups, leaf lines = fields
  const items = lines.map(line => {
    const match = line.match(/^(\s*)/);
    const indent = match ? match[1].replace(/\t/g, '    ').length : 0;
    const label = line.trim();
    return { label, indent, children: [] };
  });

  // Normalize indentation to levels
  const indents = [...new Set(items.map(i => i.indent))].sort((a,b) => a - b);
  const indentMap = new Map();
  indents.forEach((v, i) => indentMap.set(v, i));
  items.forEach(item => { item.level = indentMap.get(item.indent); });

  // Build tree
  const root = [];
  const stack = [{ children: root, level: -1 }];

  for(const item of items){
    while(stack.length > 1 && stack[stack.length - 1].level >= item.level){
      stack.pop();
    }
    const parent = stack[stack.length - 1];
    const node = { label: item.label, children: [] };
    parent.children.push(node);
    stack.push({ children: node.children, level: item.level });
  }

  // Determine types: if a node has children  group, else field
  const setTypes = (nodes) => {
    for(const n of nodes){
      if(n.children.length > 0){
        n.type = 'group';
        setTypes(n.children);
      } else {
        n.type = 'field';
        delete n.children;
      }
    }
  };
  setTypes(root);

  return { mode: 'plain', nodes: root };
}

function _parseTSV(lines){
  // First row = headers, rest = data rows
  const headers = lines[0].split('\t').map(h => h.trim().toLowerCase());
  const rows = lines.slice(1).map(l => {
    const cells = l.split('\t');
    const obj = {};
    headers.forEach((h, i) => { obj[h] = (cells[i] || '').trim(); });
    return obj;
  }).filter(r => r[headers[0]]); // skip empty first-column rows

  // Map known headers
  const labelCol = headers.find(h => ['label','name','field','field_name','column','column_name'].includes(h)) || headers[0];
  const idCol = headers.find(h => ['id','field_id','column_id'].includes(h));
  const noteCol = headers.find(h => ['note','notes','description','comment','comments','desc'].includes(h));
  const typeCol = headers.find(h => ['type','data_type','datatype','format'].includes(h));
  const tagCol = headers.find(h => ['tag','tags','status'].includes(h));
  const parentCol = headers.find(h => ['parent','parent_name','group','parent_group','folder'].includes(h));

  const nodes = rows.map(r => {
    const node = { label: r[labelCol] || '', type: 'field', children: [] };
    if(idCol && r[idCol]) node._importId = r[idCol];
    if(noteCol && r[noteCol]) node.note = r[noteCol];
    if(parentCol && r[parentCol]) node._parentLabel = r[parentCol];
    // Store extra columns for preview
    node._extra = {};
    if(typeCol && r[typeCol]) node._extra.type = r[typeCol];
    if(tagCol && r[tagCol]) node._extra.tag = r[tagCol];
    // Unmapped columns
    for(const h of headers){
      if([labelCol, idCol, noteCol, typeCol, tagCol, parentCol].includes(h)) continue;
      if(r[h]) node._extra[h] = r[h];
    }
    return node;
  }).filter(n => n.label);

  // Build tree if parent column present
  if(parentCol){
    const byKey = {};
    nodes.forEach(n => {
      byKey[n.label] = n;
      if(n._importId) byKey[n._importId] = n;
    });
    const root = [];
    nodes.forEach(n => {
      if(n._parentLabel && byKey[n._parentLabel]){
        const par = byKey[n._parentLabel];
        par.children = par.children || [];
        par.children.push(n);
        par.type = 'group';
      } else {
        root.push(n);
      }
      delete n._parentLabel;
    });
    // Clean up childless nodes
    const cleanChildren = (list) => {
      list.forEach(n => {
        if(n.children && n.children.length > 0){
          n.type = 'group';
          cleanChildren(n.children);
        } else {
          n.type = 'field';
          delete n.children;
        }
      });
    };
    cleanChildren(root);
    return { mode: 'tsv', nodes: root, headers, labelCol, idCol, noteCol, typeCol, tagCol, parentCol };
  }

  // No parent column  flat list
  nodes.forEach(n => delete n.children);

  return { mode: 'tsv', nodes, headers, labelCol, idCol, noteCol, typeCol, tagCol, parentCol };
}

function _refreshImportPreview(){
  const body = document.getElementById('importFieldsBody');
  if(!body) return;
  const textarea = body.querySelector('#importFieldsText');
  const previewEl = body.querySelector('#importPreview');
  const modeEl = body.querySelector('#importDetectedMode');
  const commitBtn = document.getElementById('importFieldsCommit');
  if(!textarea || !previewEl) return;

  const text = textarea.value;
  const parsed = _parseImportText(text);

  if(parsed.mode === 'empty'){
    previewEl.innerHTML = '';
    modeEl.textContent = '';
    if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }
    return;
  }

  // Count nodes
  let fieldCount = 0, groupCount = 0;
  const countNodes = (nodes) => {
    for(const n of nodes){
      if(n.type === 'group') { groupCount++; countNodes(n.children || []); }
      else fieldCount++;
    }
  };
  countNodes(parsed.nodes);

  modeEl.textContent = parsed.mode === 'tsv'
    ? `Detected: tab-separated (${parsed.headers.length} columns: ${parsed.headers.join(', ')})${parsed.parentCol ? '  with nesting' : ''}`
    : `Detected: plain lines with indentation`;

  // Build preview tree
  let html = `<div style="font-size:11px;font-weight:600;opacity:.6;margin-bottom:6px;">Preview: ${fieldCount} field${fieldCount!==1?'s':''}, ${groupCount} group${groupCount!==1?'s':''}</div>`;
  html += '<div style="border:1px solid var(--border);border-radius:8px;padding:8px 10px;max-height:240px;overflow-y:auto;font-size:11px;line-height:1.7;">';

  const renderTree = (nodes, depth) => {
    for(const n of nodes){
      const indent = depth * 16;
      const icon = n.type === 'group'
        ? '<span style="opacity:.5;"></span>'
        : '<span style="opacity:.3;"></span>';
      let extras = '';
      if(n.note) extras += ` <span style="opacity:.35;"> ${escapeHtml(n.note.substring(0,40))}</span>`;
      if(n._extra){
        for(const [k,v] of Object.entries(n._extra)){
          if(k === 'tag'){
            extras += ` <span style="opacity:.45;font-size:10px;"> ${escapeHtml(v.substring(0,20))}</span>`;
          } else {
            extras += ` <span style="opacity:.35;font-size:10px;background:rgba(255,255,255,.06);padding:0 4px;border-radius:3px;">${escapeHtml(k)}: ${escapeHtml(v.substring(0,20))}</span>`;
          }
        }
      }
      html += `<div style="padding-left:${indent}px;">${icon} <b>${escapeHtml(n.label)}</b>${extras}</div>`;
      if(n.children) renderTree(n.children, depth + 1);
    }
  };
  renderTree(parsed.nodes, 0);
  html += '</div>';

  // Summarize extra columns that will become attributes
  if(parsed.mode === 'tsv'){
    const extraCols = new Set();
    const collectExtras = (nodes) => { for(const n of nodes){ if(n._extra) for(const k of Object.keys(n._extra)) if(k!=='tag') extraCols.add(k); if(n.children) collectExtras(n.children); }};
    collectExtras(parsed.nodes);
    if(extraCols.size){
      const attrCat = ensureCustomAttributeCatalog();
      const newAttrs = [...extraCols].filter(c => {
        const cl = c.toLowerCase();
        return !attrCat.find(a => (a.id||'').toLowerCase()===cl || (a.label||'').toLowerCase()===cl ||
          (['type','data_type','datatype'].includes(cl) && ['format','type','data_type','datatype'].includes((a.id||'').toLowerCase())));
      });
      const existAttrs = [...extraCols].filter(c => !newAttrs.includes(c));
      let attrSummary = '';
      if(existAttrs.length) attrSummary += `<span style="opacity:.4;">Existing attributes: ${existAttrs.join(', ')}</span>`;
      if(newAttrs.length) attrSummary += `${attrSummary?'  ':''}<span style="color:rgba(59,130,246,.8);">New attributes: ${newAttrs.join(', ')}</span>`;
      if(attrSummary) html += `<div style="font-size:10px;margin-top:6px;">${attrSummary}</div>`;
    }
  }

  previewEl.innerHTML = html;
  if(commitBtn){ commitBtn.disabled = parsed.nodes.length === 0; commitBtn.classList.toggle('btnDirty', parsed.nodes.length > 0); }
}

function _commitImportFields(){
  if(!__importColId) return;
  const col = findColumnById(__importColId);
  if(!col) return;
  const body = document.getElementById('importFieldsBody');
  if(!body) return;
  const textarea = body.querySelector('#importFieldsText');
  if(!textarea) return;

  const parsed = _parseImportText(textarea.value);
  if(!parsed.nodes.length) return;

  const parentSel = body.querySelector('#importParentSel');
  const parentId = parentSel ? parentSel.value : __importColId;
  const posSel = body.querySelector('#importPosSelector');
  const atTop = posSel?.querySelector('.dockOpt.active')?.dataset.ipos === 'top';

  // Find parent node
  const parentLoc = locateNode(col.schema, parentId);
  if(!parentLoc || !parentLoc.node){ customAlert('Parent node not found.'); return; }
  if(parentLoc.node.type === 'field'){ customAlert('Cannot import into a field node. Choose a group or column root.'); return; }
  if(!parentLoc.node.children) parentLoc.node.children = [];

  recordChange();

  const taken = collectNodeIds(col);

  // Convert parsed nodes into real nodes with unique IDs
  const buildNodes = (parsedNodes, parentNodeId) => {
    const result = [];
    for(const pn of parsedNodes){
      const slug = idPartFromLabel(pn.label, {lower:true}) || 'field';
      const base = parentNodeId + '.' + slug;
      const id = ensureUniqueId(base, taken);
      taken.add(id);
      const node = { id, label: pn.label, type: pn.type || 'field', _autoId: true };
      if(pn._importId){
        // User specified an ID  try to use it
        const customBase = parentNodeId + '.' + (idPartFromLabel(pn._importId, {lower:true}) || slug);
        const customId = ensureUniqueId(customBase, taken);
        taken.delete(id);
        taken.add(customId);
        node.id = customId;
        node._autoId = false;
      }
      if(pn.note) node.note = pn.note;
      if(pn.type === 'group'){
        node.children = pn.children ? buildNodes(pn.children, node.id) : [];
      }
      // Handle extra columns: try to assign tags and attributes
      if(pn._extra){
        if(pn._extra.tag){
          const tagIds = pn._extra.tag.split(/[,;]/).map(t => t.trim().toLowerCase()).filter(Boolean);
          const tagCat = state.data.tagCatalog || [];
          const matchedTags = tagIds.map(t => {
            const found = tagCat.find(tc => tc.id === t || (tc.label||'').toLowerCase() === t);
            return found ? found.id : null;
          }).filter(Boolean);
          if(matchedTags.length) node.tags = matchedTags;
        }
        // For type and any other unmapped columns  auto-create/find custom attributes + values
        const attrCat = ensureCustomAttributeCatalog();
        const attrExtras = Object.entries(pn._extra).filter(([k]) => k !== 'tag');
        for(const [colName, rawVal] of attrExtras){
          if(!rawVal) continue;
          const colLower = colName.toLowerCase();
          // Find existing attribute matching this column name
          let attr = attrCat.find(a =>
            (a.id||'').toLowerCase() === colLower ||
            (a.label||'').toLowerCase() === colLower
          );
          // Also check common aliases for 'type' column
          if(!attr && ['type','data_type','datatype'].includes(colLower)){
            attr = attrCat.find(a =>
              ['format','type','data_type','datatype'].includes((a.id||'').toLowerCase()) ||
              ['format','type','data type','data_type','datatype'].includes((a.label||'').toLowerCase())
            );
          }
          // Auto-create attribute if not found
          if(!attr){
            const attrLabel = colName.replace(/_/g,' ');
            const attrId = idPartFromLabel(colName, {lower:true});
            const existingIds = new Set(attrCat.map(a=>a.id));
            const uniqueId = ensureUniqueId(attrId, existingIds);
            attr = { id: uniqueId, label: attrLabel, abbr: attrLabel.substring(0,2).toUpperCase(), _autoId: true, values: [], priority: attrCat.length + 1 };
            attrCat.push(attr);
          }
          if(!attr.values) attr.values = [];
          // Find or create value
          const valStr = rawVal.trim();
          let val = attr.values.find(v =>
            (v.id||'').toLowerCase() === valStr.toLowerCase() ||
            (v.label||'').toLowerCase() === valStr.toLowerCase() ||
            (v.abbr||'').toLowerCase() === valStr.toLowerCase()
          );
          if(!val){
            const valId = idPartFromLabel(valStr, {lower:true});
            const existingValIds = new Set(attr.values.map(v=>v.id));
            const uniqueValId = ensureUniqueId(valId, existingValIds);
            val = { id: uniqueValId, label: valStr, abbr: valStr.substring(0,3).toUpperCase(), _autoId: true, priority: attr.values.length + 1 };
            attr.values.push(val);
          }
          // Assign to node
          if(!node.customAttributes) node.customAttributes = {};
          node.customAttributes[attr.id] = attr.multi ? [val.id] : val.id;
        }
      }
      result.push(node);
    }
    return result;
  };

  const newNodes = buildNodes(parsed.nodes, parentId);

  // Insert into parent
  if(atTop){
    parentLoc.node.children.unshift(...newNodes);
  } else {
    parentLoc.node.children.push(...newNodes);
  }

  closeImportFields();
  renderAll();

  // Select imported nodes
  state.multiSelection.clear();
  const flatIds = [];
  const collectIds = (nodes) => { for(const n of nodes){ flatIds.push(n.id); if(n.children) collectIds(n.children); }};
  collectIds(newNodes);
  for(const id of flatIds) state.multiSelection.add(id);
  state.lockedId = flatIds[0] || null;
  applyHighlight();
  if(flatIds[0]) scrollIntoView(flatIds[0]);
  setGlobalStatus(`Imported ${parsed.nodes.length} node${parsed.nodes.length>1?'s':''} into ${col.label || col.id}.`);
}

// end import fields

// 
// Import toolbar menu handlers
// 
document.getElementById('importFieldsBtn')?.addEventListener('click', ()=>{
  closeAllPopovers();
  const colId = state.selectedColumnId || (state.lockedId && columnOf(state.lockedId));
  if(!colId){ customAlert('Select a column first to import fields into.'); return; }
  if(!state.editorMode){ customAlert('Switch to Editor mode first.'); return; }
  openImportFields(colId);
});
document.getElementById('importColumnsBtn')?.addEventListener('click', ()=>{
  closeAllPopovers();
  if(!state.editorMode){ customAlert('Switch to Editor mode first.'); return; }
  if(!state.data){ customAlert('Load or create a project first.'); return; }
  openImportColumns();
});
document.getElementById('importProjectBtn')?.addEventListener('click', ()=>{
  closeAllPopovers();
  if(!state.editorMode){ customAlert('Switch to Editor mode first.'); return; }
  if(!state.data){ customAlert('Load or create a project first.'); return; }
  document.getElementById('importProjectFileInput')?.click();
});
document.getElementById('importProjectFileInput')?.addEventListener('change', (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      ev.target.value = '';
      openImportProject(data, f.name);
    } catch(err) {
      ev.target.value = '';
      customAlert('Could not parse file: ' + err.message);
    }
  };
  reader.readAsText(f);
});

// 
// Import columns modal
// 
function openImportColumns(){
  const body = document.getElementById('importColumnsBody');
  const commitBtn = document.getElementById('importColumnsCommit');
  if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }

  body.innerHTML = `
<div style="margin-bottom:10px;">
  <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
    <span style="font-size:11px;opacity:.5;">Insert at:</span>
    <div class="dockSelector" id="importColPosSelector" style="flex:0 auto;">
      <button class="dockOpt active" data-ipos="right" style="padding:4px 12px;min-width:0;">Right</button>
      <button class="dockOpt" data-ipos="left" style="padding:4px 12px;min-width:0;">Left</button>
    </div>
  </div>
</div>
<textarea id="importColumnsText" style="width:100%;min-height:200px;max-height:40vh;font-family:var(--mono);font-size:12px;line-height:1.5;padding:10px 12px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);color:var(--text);resize:vertical;" placeholder="Plain text  one column per block, blank lines between:&#10;&#10;Source System&#10;    customer_id&#10;    first_name&#10;    Address&#10;        street&#10;        city&#10;&#10;Target System&#10;    CustomerID&#10;    FullName&#10;&#10;Tab-separated  'column' header groups rows into columns:&#10;&#10;column&#9;label&#9;parent&#9;type&#10;Source&#9;customer_id&#9;&#9;Integer&#10;Source&#9;Address&#9;&#9;&#10;Source&#9;street&#9;Address&#9;String&#10;Target&#9;CustomerID&#9;&#9;Integer"></textarea>
<div id="importColDetectedMode" style="font-size:10px;opacity:.4;margin-top:4px;"></div>
<div id="importColPreview" style="margin-top:12px;"></div>`;

  // Position selector
  const posSel = body.querySelector('#importColPosSelector');
  if(posSel) posSel.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-ipos]');
    if(!btn) return;
    posSel.querySelectorAll('.dockOpt').forEach(b => b.classList.toggle('active', b === btn));
    _refreshImportColPreview();
  });

  const textarea = body.querySelector('#importColumnsText');
  if(textarea){
    textarea.addEventListener('input', _refreshImportColPreview);
    _wireTabIndent(textarea, _refreshImportColPreview);
    textarea.focus();
  }

  // File upload handler
  const fInput = document.getElementById('importColumnsFileInput');
  if(fInput){ fInput.value = ''; fInput.onchange = (ev) => {
    const f = ev.target.files?.[0]; if(!f) return;
    const r = new FileReader(); r.onload = (e) => { if(textarea){ textarea.value = e.target.result; _refreshImportColPreview(); } };
    r.readAsText(f); fInput.value = '';
  }; }

  document.getElementById('importColumnsMask')?.classList.add('active');
  document.getElementById('importColumnsModal')?.classList.add('active');
}

function closeImportColumns(){
  document.getElementById('importColumnsMask')?.classList.remove('active');
  document.getElementById('importColumnsModal')?.classList.remove('active');
}
document.getElementById('importColumnsClose')?.addEventListener('click', closeImportColumns);
document.getElementById('importColumnsMask')?.addEventListener('click', closeImportColumns);
document.getElementById('importColumnsCommit')?.addEventListener('click', _commitImportColumns);
document.getElementById('importColumnsModal')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); closeImportColumns(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    const btn = document.getElementById('importColumnsCommit');
    if(btn && !btn.disabled) _commitImportColumns();
  }
});

function _parseImportColumnsText(text){
  const trimmed = text.trim();
  if(!trimmed) return { mode: 'empty', columns: [] };

  const lines = trimmed.split('\n').filter(l => l.trim());
  if(!lines.length) return { mode: 'empty', columns: [] };

  // Detect TSV: first line contains tab and looks like a header with a 'column' field
  const firstLine = lines[0];
  if(firstLine.includes('\t')){
    const headers = firstLine.split('\t').map(h => h.trim().toLowerCase());
    const colCol = headers.find(h => ['column','column_name','system','source','target','schema','table'].includes(h));
    if(colCol){
      // TSV mode with column grouping
      const labelCol = headers.find(h => ['label','name','field','field_name'].includes(h)) || headers.find(h => h !== colCol) || headers[1];
      const parentCol = headers.find(h => ['parent','parent_name','group','parent_group','folder'].includes(h));
      const noteCol = headers.find(h => ['note','notes','description','comment','comments','desc'].includes(h));
      const idCol = headers.find(h => ['id','field_id','column_id'].includes(h));
      const tagCol = headers.find(h => ['tag','tags','status'].includes(h));
      const typeCol = headers.find(h => ['type','data_type','datatype','format'].includes(h));

      const rows = lines.slice(1).map(l => {
        const cells = l.split('\t');
        const obj = {};
        headers.forEach((h, i) => { obj[h] = (cells[i] || '').trim(); });
        return obj;
      }).filter(r => r[colCol]); // skip rows without column name

      // Group rows by column
      const colMap = new Map(); // colLabel -> [{row}]
      const colOrder = [];
      for(const r of rows){
        const cLabel = r[colCol];
        if(!colMap.has(cLabel)){ colMap.set(cLabel, []); colOrder.push(cLabel); }
        if(r[labelCol || headers[1]]) colMap.get(cLabel).push(r);
      }

      const columns = colOrder.map(cLabel => {
        const cRows = colMap.get(cLabel);
        const nodes = cRows.map(r => {
          const label = r[labelCol] || '';
          const node = { label, type: 'field', children: [] };
          if(idCol && r[idCol]) node._importId = r[idCol];
          if(noteCol && r[noteCol]) node.note = r[noteCol];
          if(parentCol && r[parentCol]) node._parentLabel = r[parentCol];
          // Extra columns
          node._extra = {};
          if(typeCol && r[typeCol]) node._extra.type = r[typeCol];
          if(tagCol && r[tagCol]) node._extra.tag = r[tagCol];
          for(const h of headers){
            if([colCol, labelCol, parentCol, noteCol, idCol, typeCol, tagCol].includes(h)) continue;
            if(r[h]) node._extra[h] = r[h];
          }
          if(!Object.keys(node._extra).length) delete node._extra;
          return node;
        }).filter(n => n.label);

        // Build tree from parent column
        if(parentCol){
          const byKey = {};
          nodes.forEach(n => {
            byKey[n.label] = n;
            if(n._importId) byKey[n._importId] = n;
          });
          const root = [];
          nodes.forEach(n => {
            if(n._parentLabel && byKey[n._parentLabel]){
              const par = byKey[n._parentLabel];
              par.children = par.children || [];
              par.children.push(n);
              par.type = 'group';
            } else {
              root.push(n);
            }
            delete n._parentLabel;
          });
          const cleanChildren = (list) => {
            list.forEach(n => {
              if(n.children && n.children.length > 0){ n.type = 'group'; cleanChildren(n.children); }
              else { n.type = 'field'; delete n.children; }
            });
          };
          cleanChildren(root);
          return { label: cLabel, fields: root, _tsv: true };
        }

        // No parent column  flat list
        nodes.forEach(n => { delete n.children; n.type = 'field'; });
        return { label: cLabel, fields: nodes, _tsv: true };
      });

      return { mode: 'tsv', columns, headers, colCol, labelCol, parentCol, noteCol, idCol, typeCol, tagCol };
    }
  }

  // Plain text mode: blank-line-separated blocks
  const blocks = trimmed.split(/\n\s*\n/).filter(b => b.trim());
  const columns = blocks.map(block => {
    const bLines = block.split('\n').filter(l => l.trim());
    if(!bLines.length) return null;
    const colLabel = bLines[0].trim();
    const fieldLines = bLines.slice(1);
    let fields = [];
    if(fieldLines.length > 0){
      const parsed = _parsePlainLines(fieldLines);
      fields = parsed.nodes;
    }
    return { label: colLabel, fields };
  }).filter(Boolean);

  return { mode: 'plain', columns };
}

function _refreshImportColPreview(){
  const body = document.getElementById('importColumnsBody');
  if(!body) return;
  const textarea = body.querySelector('#importColumnsText');
  const previewEl = body.querySelector('#importColPreview');
  const modeEl = body.querySelector('#importColDetectedMode');
  const commitBtn = document.getElementById('importColumnsCommit');
  if(!textarea || !previewEl) return;

  const parsed = _parseImportColumnsText(textarea.value);
  const columns = parsed.columns || [];

  if(!columns.length){
    previewEl.innerHTML = '';
    modeEl.textContent = '';
    if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }
    return;
  }

  let totalFields = 0, totalGroups = 0;
  const countNodes = (nodes) => { for(const n of nodes){ if(n.type==='group'){ totalGroups++; countNodes(n.children||[]); } else totalFields++; }};
  columns.forEach(c => countNodes(c.fields));

  const modeLabel = parsed.mode === 'tsv'
    ? `Detected: tab-separated (${parsed.headers.length} columns: ${parsed.headers.join(', ')})  `
    : '';
  modeEl.textContent = `${modeLabel}${columns.length} column${columns.length!==1?'s':''}, ${totalFields} field${totalFields!==1?'s':''}, ${totalGroups} group${totalGroups!==1?'s':''}`;

  let html = '<div style="border:1px solid var(--border);border-radius:8px;padding:8px 10px;max-height:240px;overflow-y:auto;font-size:11px;line-height:1.7;">';
  for(const col of columns){
    html += `<div style="font-weight:700;margin-top:4px;"> ${escapeHtml(col.label)}</div>`;
    const renderTree = (nodes, depth) => {
      for(const n of nodes){
        const indent = (depth + 1) * 16;
        const icon = n.type === 'group' ? '<span style="opacity:.5;"></span>' : '<span style="opacity:.3;"></span>';
        let extras = '';
        if(n.note) extras += ` <span style="opacity:.35;"> ${escapeHtml(n.note.substring(0,40))}</span>`;
        if(n._extra){
          for(const [k,v] of Object.entries(n._extra)){
            if(k === 'tag') extras += ` <span style="opacity:.45;font-size:10px;"> ${escapeHtml(v.substring(0,20))}</span>`;
            else extras += ` <span style="opacity:.35;font-size:10px;background:rgba(255,255,255,.06);padding:0 4px;border-radius:3px;">${escapeHtml(k)}: ${escapeHtml(v.substring(0,20))}</span>`;
          }
        }
        html += `<div style="padding-left:${indent}px;">${icon} ${escapeHtml(n.label)}${extras}</div>`;
        if(n.children) renderTree(n.children, depth + 1);
      }
    };
    renderTree(col.fields, 0);
  }
  html += '</div>';

  // Attribute creation summary for TSV
  if(parsed.mode === 'tsv'){
    const extraCols = new Set();
    const collectExtras = (nodes) => { for(const n of nodes){ if(n._extra) for(const k of Object.keys(n._extra)) if(k!=='tag') extraCols.add(k); if(n.children) collectExtras(n.children); }};
    columns.forEach(c => collectExtras(c.fields));
    if(extraCols.size){
      const attrCat = ensureCustomAttributeCatalog();
      const newAttrs = [...extraCols].filter(c => {
        const cl = c.toLowerCase();
        return !attrCat.find(a => (a.id||'').toLowerCase()===cl || (a.label||'').toLowerCase()===cl ||
          (['type','data_type','datatype'].includes(cl) && ['format','type','data_type','datatype'].includes((a.id||'').toLowerCase())));
      });
      const existAttrs = [...extraCols].filter(c => !newAttrs.includes(c));
      let attrSummary = '';
      if(existAttrs.length) attrSummary += `<span style="opacity:.4;">Existing attributes: ${existAttrs.join(', ')}</span>`;
      if(newAttrs.length) attrSummary += `${attrSummary?'  ':''}<span style="color:rgba(59,130,246,.8);">New attributes: ${newAttrs.join(', ')}</span>`;
      if(attrSummary) html += `<div style="font-size:10px;margin-top:6px;">${attrSummary}</div>`;
    }
  }

  previewEl.innerHTML = html;
  if(commitBtn){ commitBtn.disabled = columns.length === 0; commitBtn.classList.toggle('btnDirty', columns.length > 0); }
}

function _commitImportColumns(){
  if(!state.data) return;
  const body = document.getElementById('importColumnsBody');
  if(!body) return;
  const textarea = body.querySelector('#importColumnsText');
  if(!textarea) return;

  const parsed = _parseImportColumnsText(textarea.value);
  const columns = parsed.columns || [];
  if(!columns.length) return;

  const posSel = body.querySelector('#importColPosSelector');
  const atLeft = posSel?.querySelector('.dockOpt.active')?.dataset.ipos === 'left';

  recordChange();

  const cols = state.data.columns || (state.data.columns = []);
  const existingIds = new Set(cols.map(c => c?.id));

  const newCols = [];
  for(const colDef of columns){
    const slug = idPartFromLabel(colDef.label) || 'column';
    const colId = ensureUniqueId(slug, existingIds);
    existingIds.add(colId);

    // Build children with proper IDs
    const takenInCol = new Set([colId]);
    const buildNodes = (parsedNodes, parentId) => {
      const result = [];
      for(const pn of parsedNodes){
        const s = idPartFromLabel(pn.label, {lower:true}) || 'field';
        const base = parentId + '.' + s;
        const id = ensureUniqueId(base, takenInCol);
        takenInCol.add(id);
        const node = { id, label: pn.label, type: pn.type || 'field', _autoId: true };
        if(pn._importId){
          const customId = ensureUniqueId(pn._importId, takenInCol);
          takenInCol.add(customId);
          node.id = customId;
          node._autoId = false;
        }
        if(pn.note) node.note = pn.note;
        if(pn.type === 'group') node.children = pn.children ? buildNodes(pn.children, id) : [];
        // Handle extra columns: tags and auto-create attributes
        if(pn._extra){
          if(pn._extra.tag){
            const tagIds = pn._extra.tag.split(/[,;]/).map(t => t.trim().toLowerCase()).filter(Boolean);
            const tagCat = state.data.tagCatalog || [];
            const matchedTags = tagIds.map(t => {
              const found = tagCat.find(tc => tc.id === t || (tc.label||'').toLowerCase() === t);
              return found ? found.id : null;
            }).filter(Boolean);
            if(matchedTags.length) node.tags = matchedTags;
          }
          const attrCat = ensureCustomAttributeCatalog();
          const attrExtras = Object.entries(pn._extra).filter(([k]) => k !== 'tag');
          for(const [colName, rawVal] of attrExtras){
            if(!rawVal) continue;
            const colLower = colName.toLowerCase();
            let attr = attrCat.find(a =>
              (a.id||'').toLowerCase() === colLower || (a.label||'').toLowerCase() === colLower
            );
            if(!attr && ['type','data_type','datatype'].includes(colLower)){
              attr = attrCat.find(a =>
                ['format','type','data_type','datatype'].includes((a.id||'').toLowerCase()) ||
                ['format','type','data type','data_type','datatype'].includes((a.label||'').toLowerCase())
              );
            }
            if(!attr){
              const attrLabel = colName.replace(/_/g,' ');
              const attrId = idPartFromLabel(colName, {lower:true});
              const eIds = new Set(attrCat.map(a=>a.id));
              const uniqueId = ensureUniqueId(attrId, eIds);
              attr = { id: uniqueId, label: attrLabel, abbr: attrLabel.substring(0,2).toUpperCase(), _autoId: true, values: [], priority: attrCat.length + 1 };
              attrCat.push(attr);
            }
            if(!attr.values) attr.values = [];
            const valStr = rawVal.trim();
            let val = attr.values.find(v =>
              (v.id||'').toLowerCase() === valStr.toLowerCase() ||
              (v.label||'').toLowerCase() === valStr.toLowerCase() ||
              (v.abbr||'').toLowerCase() === valStr.toLowerCase()
            );
            if(!val){
              const valId = idPartFromLabel(valStr, {lower:true});
              const eValIds = new Set(attr.values.map(v=>v.id));
              const uniqueValId = ensureUniqueId(valId, eValIds);
              val = { id: uniqueValId, label: valStr, abbr: valStr.substring(0,3).toUpperCase(), _autoId: true, priority: attr.values.length + 1 };
              attr.values.push(val);
            }
            if(!node.customAttributes) node.customAttributes = {};
            node.customAttributes[attr.id] = attr.multi ? [val.id] : val.id;
          }
        }
        result.push(node);
      }
      return result;
    };

    const children = buildNodes(colDef.fields, colId);

    newCols.push({
      id: colId,
      label: colDef.label,
      note: '',
      _autoId: true,
      schema: { id: colId, label: colDef.label, _autoId: true, type: 'group', children }
    });
  }

  if(atLeft) cols.unshift(...newCols);
  else cols.push(...newCols);

  closeImportColumns();
  renderAll();
  setGlobalStatus(`Imported ${newCols.length} column${newCols.length>1?'s':''}.`);
}

// 
// Import from Dunnode project
// 
let __importProjectData = null;

function openImportProject(data, filename){
  __importProjectData = data;
  const body = document.getElementById('importProjectBody');
  const commitBtn = document.getElementById('importProjectCommit');
  if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }

  const srcCols = data?.columns || [];
  const srcTags = data?.tagCatalog || [];
  const srcAttrs = data?.customAttributeCatalog || [];
  const srcTransforms = data?.transformCatalog || [];
  const srcEdges = data?.mappings || [];
  const projTitle = data?.title || data?.meta?.title || filename || 'Unknown project';

  if(!srcCols.length && !srcTags.length && !srcAttrs.length && !srcTransforms.length){
    customAlert('No columns or catalog items found in this file.');
    return;
  }

  let html = `<div style="font-size:12px;opacity:.6;margin-bottom:12px;">Source: <b>${escapeHtml(projTitle)}</b></div>`;

  // Columns section
  if(srcCols.length){
    html += `<div style="font-size:11px;font-weight:600;opacity:.7;margin-bottom:6px;">Columns <span style="opacity:.5;">(${srcCols.length})</span></div>`;
    html += '<div style="border:1px solid var(--border);border-radius:8px;padding:6px 10px;margin-bottom:12px;max-height:220px;overflow-y:auto;">';
    for(let i = 0; i < srcCols.length; i++){
      const c = srcCols[i];
      const fieldCount = _countSchemaNodes(c.schema, 'field');
      const groupCount = _countSchemaNodes(c.schema, 'group') - 1; // subtract root
      const edgeCount = srcEdges.filter(e => _nodeInColumn(e.from, c) || _nodeInColumn(e.to, c)).length;
      html += `<label style="display:flex;align-items:center;gap:8px;padding:4px 2px;font-size:11px;cursor:pointer;">
        <input type="checkbox" class="importProjCol" data-idx="${i}" checked style="margin:0;">
        <span style="font-weight:600;">${escapeHtml(c.label || c.id)}</span>
        <span style="opacity:.35;font-size:10px;">${fieldCount} field${fieldCount!==1?'s':''}, ${groupCount > 0 ? groupCount + ' group' + (groupCount!==1?'s':'') + ', ' : ''}${edgeCount} mapping${edgeCount!==1?'s':''}</span>
      </label>`;
    }
    html += '</div>';
  }

  // Catalog sections
  const catalogSections = [
    { items: srcTags, name: 'Tags', cls: 'importProjTag' },
    { items: srcAttrs, name: 'Attributes', cls: 'importProjAttr' },
    { items: srcTransforms, name: 'Transforms', cls: 'importProjTf' },
  ];
  for(const sec of catalogSections){
    if(!sec.items.length) continue;
    html += `<div style="font-size:11px;font-weight:600;opacity:.7;margin-bottom:6px;">${sec.name} <span style="opacity:.5;">(${sec.items.length})</span></div>`;
    html += '<div style="border:1px solid var(--border);border-radius:8px;padding:6px 10px;margin-bottom:12px;max-height:140px;overflow-y:auto;">';
    for(let i = 0; i < sec.items.length; i++){
      const item = sec.items[i];
      const emoji = item.emoji ? item.emoji + ' ' : '';
      const colorDot = item.color ? `<span style="width:8px;height:8px;border-radius:2px;background:${escapeHtml(item.color)};display:inline-block;flex-shrink:0;"></span> ` : '';
      html += `<label style="display:flex;align-items:center;gap:6px;padding:3px 2px;font-size:11px;cursor:pointer;">
        <input type="checkbox" class="${sec.cls}" data-idx="${i}" checked style="margin:0;">
        ${colorDot}<span>${emoji}${escapeHtml(item.label || item.id)}</span>
      </label>`;
    }
    html += '</div>';
  }

  // Options
  html += `<div style="display:flex;gap:12px;align-items:center;margin-top:6px;">
    <label style="font-size:11px;opacity:.5;display:flex;align-items:center;gap:4px;cursor:pointer;">
      <input type="checkbox" id="importProjEdges" checked style="margin:0;"> Include mappings between imported columns
    </label>
  </div>`;

  body.innerHTML = html;

  // Update commit button based on selection
  const updateCommit = () => {
    const anyCol = body.querySelectorAll('.importProjCol:checked').length > 0;
    const anyTag = body.querySelectorAll('.importProjTag:checked').length > 0;
    const anyAttr = body.querySelectorAll('.importProjAttr:checked').length > 0;
    const anyTf = body.querySelectorAll('.importProjTf:checked').length > 0;
    if(commitBtn){ const _en = !!(anyCol || anyTag || anyAttr || anyTf); commitBtn.disabled = !_en; commitBtn.classList.toggle('btnDirty', _en); }
  };
  body.addEventListener('change', updateCommit);
  updateCommit();

  document.getElementById('importProjectMask')?.classList.add('active');
  document.getElementById('importProjectModal')?.classList.add('active');
}

function _countSchemaNodes(schema, type){
  let count = 0;
  const walk = (n) => {
    if(!n) return;
    if(n.type === type) count++;
    (n.children || []).forEach(walk);
  };
  walk(schema);
  return count;
}

function _nodeInColumn(nodeId, col){
  if(!nodeId || !col || !col.schema) return false;
  return nodeId === col.id || nodeId.startsWith(col.id + '.');
}

function closeImportProject(){
  __importProjectData = null;
  document.getElementById('importProjectMask')?.classList.remove('active');
  document.getElementById('importProjectModal')?.classList.remove('active');
}
document.getElementById('importProjectClose')?.addEventListener('click', closeImportProject);
document.getElementById('importProjectMask')?.addEventListener('click', closeImportProject);
document.getElementById('importProjectCommit')?.addEventListener('click', _commitImportProject);
document.getElementById('importProjectModal')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); closeImportProject(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    const btn = document.getElementById('importProjectCommit');
    if(btn && !btn.disabled) _commitImportProject();
  }
});

function _commitImportProject(){
  if(!__importProjectData || !state.data) return;
  const body = document.getElementById('importProjectBody');
  if(!body) return;

  const src = __importProjectData;
  const srcCols = src.columns || [];
  const srcTags = src.tagCatalog || [];
  const srcAttrs = src.customAttributeCatalog || [];
  const srcTransforms = src.transformCatalog || [];
  const srcEdges = src.mappings || [];

  // Collect selected items
  const selColIdx = new Set([...body.querySelectorAll('.importProjCol:checked')].map(cb => parseInt(cb.dataset.idx)));
  const selTagIdx = new Set([...body.querySelectorAll('.importProjTag:checked')].map(cb => parseInt(cb.dataset.idx)));
  const selAttrIdx = new Set([...body.querySelectorAll('.importProjAttr:checked')].map(cb => parseInt(cb.dataset.idx)));
  const selTfIdx = new Set([...body.querySelectorAll('.importProjTf:checked')].map(cb => parseInt(cb.dataset.idx)));
  const includeEdges = body.querySelector('#importProjEdges')?.checked ?? true;

  if(selColIdx.size === 0 && selTagIdx.size === 0 && selAttrIdx.size === 0 && selTfIdx.size === 0) return;

  recordChange();

  // Build ID remap for collision avoidance
  const existingColIds = new Set((state.data.columns || []).map(c => c?.id));
  const colIdMap = new Map(); // oldId  newId
  const nodeIdMap = new Map(); // oldNodeId  newNodeId

  // Import columns
  const cols = state.data.columns || (state.data.columns = []);
  const importedColIds = new Set();

  for(const idx of selColIdx){
    const srcCol = srcCols[idx];
    if(!srcCol) continue;

    // Deep clone
    const col = JSON.parse(JSON.stringify(srcCol));

    // Ensure unique column ID
    if(existingColIds.has(col.id)){
      const newColId = ensureUniqueId(col.id, existingColIds);
      const oldId = col.id;
      colIdMap.set(oldId, newColId);
      // Remap all node IDs in schema
      _remapSchemaIds(col.schema, oldId, newColId, nodeIdMap);
      col.id = newColId;
    } else {
      colIdMap.set(col.id, col.id);
    }
    existingColIds.add(col.id);
    importedColIds.add(col.id);
    cols.push(col);
  }

  // Import tags (merge, skip duplicates by id)
  if(selTagIdx.size > 0){
    const tagCat = state.data.tagCatalog || (state.data.tagCatalog = []);
    const existingTagIds = new Set(tagCat.map(t => t.id));
    for(const idx of selTagIdx){
      const tag = srcTags[idx];
      if(!tag || existingTagIds.has(tag.id)) continue;
      tagCat.push(JSON.parse(JSON.stringify(tag)));
      existingTagIds.add(tag.id);
    }
  }

  // Import attributes (merge, skip duplicates by id)
  if(selAttrIdx.size > 0){
    const attrCat = state.data.customAttributeCatalog || (state.data.customAttributeCatalog = []);
    const existingAttrIds = new Set(attrCat.map(a => a.id));
    for(const idx of selAttrIdx){
      const attr = srcAttrs[idx];
      if(!attr || existingAttrIds.has(attr.id)) continue;
      attrCat.push(JSON.parse(JSON.stringify(attr)));
      existingAttrIds.add(attr.id);
    }
  }

  // Import transforms (merge, skip duplicates by id)
  if(selTfIdx.size > 0){
    const tfCat = state.data.transformCatalog || (state.data.transformCatalog = []);
    const existingTfIds = new Set(tfCat.map(t => t.id));
    for(const idx of selTfIdx){
      const tf = srcTransforms[idx];
      if(!tf || existingTfIds.has(tf.id)) continue;
      tfCat.push(JSON.parse(JSON.stringify(tf)));
      existingTfIds.add(tf.id);
    }
  }

  // Import edges between imported columns
  if(includeEdges && importedColIds.size > 0){
    const edges = state.data.mappings || (state.data.mappings = []);
    const existingEdgeKeys = new Set(edges.map(e => e.from + '' + e.to));

    for(const edge of srcEdges){
      const fromColId = edge.from?.split('.')?.[0];
      const toColId = edge.to?.split('.')?.[0];
      // Only import edges where both endpoints are in imported columns
      const mappedFromCol = colIdMap.get(fromColId);
      const mappedToCol = colIdMap.get(toColId);
      if(!mappedFromCol || !mappedToCol) continue;
      if(!importedColIds.has(mappedFromCol) || !importedColIds.has(mappedToCol)) continue;

      const newEdge = JSON.parse(JSON.stringify(edge));
      // Remap node IDs
      newEdge.from = nodeIdMap.get(edge.from) || edge.from;
      newEdge.to = nodeIdMap.get(edge.to) || edge.to;
      const key = newEdge.from + '' + newEdge.to;
      if(!existingEdgeKeys.has(key)){
        edges.push(newEdge);
        existingEdgeKeys.add(key);
      }
    }
  }

  closeImportProject();
  renderAll();

  const parts = [];
  if(selColIdx.size) parts.push(`${selColIdx.size} column${selColIdx.size>1?'s':''}`);
  if(selTagIdx.size) parts.push(`${selTagIdx.size} tag${selTagIdx.size>1?'s':''}`);
  if(selAttrIdx.size) parts.push(`${selAttrIdx.size} attribute${selAttrIdx.size>1?'s':''}`);
  if(selTfIdx.size) parts.push(`${selTfIdx.size} transform${selTfIdx.size>1?'s':''}`);
  setGlobalStatus(`Imported ${parts.join(', ')}.`);
}

function _remapSchemaIds(node, oldPrefix, newPrefix, nodeIdMap){
  if(!node) return;
  const oldId = node.id;
  if(oldId === oldPrefix){
    node.id = newPrefix;
  } else if(oldId.startsWith(oldPrefix + '.')){
    node.id = newPrefix + oldId.substring(oldPrefix.length);
  }
  nodeIdMap.set(oldId, node.id);
  (node.children || []).forEach(c => _remapSchemaIds(c, oldPrefix, newPrefix, nodeIdMap));
}

// end import columns/project

// 
// Import SQL / DDL
// 

function _stripSqlComments(sql){
  // Remove block comments /* ... */
  sql = sql.replace(/\/\*[\s\S]*?\*\//g, '');
  // Remove line comments -- ...
  sql = sql.replace(/--.*/g, '');
  return sql;
}

function _unquoteSqlIdent(s){
  s = s.trim();
  if((s.startsWith('"') && s.endsWith('"')) ||
     (s.startsWith('`') && s.endsWith('`')) ||
     (s.startsWith('[') && s.endsWith(']')))
    return s.slice(1, -1);
  return s;
}

function _parseSqlDDL(sql){
  sql = _stripSqlComments(sql);
  const tables = [];
  // Match CREATE TABLE statements  handle IF NOT EXISTS, schema prefix, various quoting
  const createRe = /CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(?:(?:"[^"]+"|`[^`]+`|\[[^\]]+\]|\w+)\.)?("[^"]+"|`[^`]+`|\[[^\]]+\]|\w+)\s*\(([\s\S]*?)\)\s*(?:ENGINE|WITH|TABLESPACE|;|\n\s*\n|$)/gi;

  let m;
  while((m = createRe.exec(sql)) !== null){
    const tableName = _unquoteSqlIdent(m[1]);
    const body = m[2];
    const table = { name: tableName, columns: [], constraints: [] };

    // Split body by commas, respecting parentheses depth
    const parts = [];
    let depth = 0, current = '';
    for(const ch of body){
      if(ch === '(') depth++;
      else if(ch === ')') depth--;
      if(ch === ',' && depth === 0){
        parts.push(current.trim());
        current = '';
      } else {
        current += ch;
      }
    }
    if(current.trim()) parts.push(current.trim());

    for(const part of parts){
      const upper = part.toUpperCase().trim();
      // Table-level constraints
      if(upper.match(/^(CONSTRAINT\s+\S+\s+)?PRIMARY\s+KEY/i)){
        const colMatch = part.match(/PRIMARY\s+KEY\s*\(([^)]+)\)/i);
        if(colMatch){
          const pkCols = colMatch[1].split(',').map(c => _unquoteSqlIdent(c.trim()));
          table.constraints.push({ type: 'pk', columns: pkCols });
        }
        continue;
      }
      if(upper.match(/^(CONSTRAINT\s+\S+\s+)?UNIQUE/i)){
        const colMatch = part.match(/UNIQUE\s*(?:KEY\s*(?:\S+\s*)?)?\(([^)]+)\)/i);
        if(colMatch){
          const uqCols = colMatch[1].split(',').map(c => _unquoteSqlIdent(c.trim()));
          table.constraints.push({ type: 'unique', columns: uqCols });
        }
        continue;
      }
      if(upper.match(/^(CONSTRAINT\s+\S+\s+)?FOREIGN\s+KEY/i)){
        const fkMatch = part.match(/FOREIGN\s+KEY\s*\(([^)]+)\)\s*REFERENCES\s+(?:(?:"[^"]+"|`[^`]+`|\[[^\]]+\]|\w+)\.)?("[^"]+"|`[^`]+`|\[[^\]]+\]|\w+)\s*\(([^)]+)\)/i);
        if(fkMatch){
          const fkCols = fkMatch[1].split(',').map(c => _unquoteSqlIdent(c.trim()));
          const refTable = _unquoteSqlIdent(fkMatch[2]);
          const refCols = fkMatch[3].split(',').map(c => _unquoteSqlIdent(c.trim()));
          table.constraints.push({ type: 'fk', columns: fkCols, refTable, refCols });
        }
        continue;
      }
      if(upper.match(/^(CONSTRAINT|INDEX|KEY|CHECK)\b/i)) continue;

      // Column definition
      const colRe = /^("[^"]+"|`[^`]+`|\[[^\]]+\]|\w+)\s+(.+)$/s;
      const cm = part.match(colRe);
      if(!cm) continue;
      const colName = _unquoteSqlIdent(cm[1]);
      const rest = cm[2].trim();

      // Parse data type  first word (with optional parens)
      const typeMatch = rest.match(/^(\w+(?:\s+\w+)?)\s*(?:\(([^)]*)\))?/i);
      let dataType = typeMatch ? typeMatch[1].toUpperCase() : '';
      const typeParams = typeMatch ? (typeMatch[2] || '') : '';
      // Normalize compound types
      if(dataType === 'DOUBLE PRECISION') dataType = 'DOUBLE';
      if(dataType.startsWith('CHARACTER VARYING')) dataType = 'VARCHAR';

      const col = { name: colName, dataType, typeParams, tags: [], notNull: false, defaultVal: null };

      const restUpper = rest.toUpperCase();
      if(restUpper.includes('PRIMARY KEY')) col.tags.push('pk');
      if(restUpper.includes('NOT NULL')) col.notNull = true;
      if(restUpper.match(/\bNULL\b/) && !restUpper.includes('NOT NULL')) col.notNull = false;
      if(restUpper.includes('UNIQUE')) col.tags.push('unique');
      if(restUpper.includes('AUTO_INCREMENT') || restUpper.includes('AUTOINCREMENT') || restUpper.match(/\bIDENTITY\b/) || restUpper.match(/\bSERIAL\b/) || restUpper.match(/\bGENERATED\b/)) col.tags.push('auto');
      // Check for REFERENCES (inline FK)
      const inlineRef = rest.match(/REFERENCES\s+(?:(?:"[^"]+"|`[^`]+`|\[[^\]]+\]|\w+)\.)?("[^"]+"|`[^`]+`|\[[^\]]+\]|\w+)\s*(?:\(([^)]+)\))?/i);
      if(inlineRef){
        col.tags.push('fk');
        col.refTable = _unquoteSqlIdent(inlineRef[1]);
        col.refCol = inlineRef[2] ? _unquoteSqlIdent(inlineRef[2]) : '';
      }
      const defMatch = rest.match(/DEFAULT\s+('(?:[^'\\]|\\.)*'|\S+)/i);
      if(defMatch) col.defaultVal = defMatch[1].replace(/^'|'$/g, '');

      table.columns.push(col);
    }

    // Apply table-level constraints back to columns
    for(const con of table.constraints){
      for(const colName of con.columns){
        const col = table.columns.find(c => c.name.toLowerCase() === colName.toLowerCase());
        if(!col) continue;
        if(con.type === 'pk' && !col.tags.includes('pk')) col.tags.push('pk');
        if(con.type === 'unique' && !col.tags.includes('unique')) col.tags.push('unique');
        if(con.type === 'fk'){
          if(!col.tags.includes('fk')) col.tags.push('fk');
          if(!col.refTable) col.refTable = con.refTable;
          if(!col.refCol) col.refCol = (con.refCols && con.refCols[con.columns.indexOf(colName)]) || '';
        }
      }
    }

    tables.push(table);
  }
  return tables;
}

function openImportSql(){
  if(!state.editorMode){ customAlert('Switch to Editor mode first.'); return; }
  const body = document.getElementById('importSqlBody');
  const commitBtn = document.getElementById('importSqlCommit');
  if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }

  body.innerHTML = `
<div style="font-size:12px;opacity:.5;margin-bottom:10px;">Paste SQL <b>CREATE TABLE</b> statements. Each table becomes a column; each SQL column becomes a field. Data types, primary keys, NOT NULL, unique constraints, and foreign keys are auto-detected.</div>
<div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
  <span style="font-size:11px;opacity:.5;">Insert at:</span>
  <div class="dockSelector" id="importSqlPosSelector" style="flex:0 auto;">
    <button class="dockOpt active" data-ipos="right" style="padding:4px 12px;min-width:0;">Right</button>
    <button class="dockOpt" data-ipos="left" style="padding:4px 12px;min-width:0;">Left</button>
  </div>
</div>
<textarea id="importSqlText" style="width:100%;min-height:220px;max-height:40vh;font-family:var(--mono);font-size:12px;line-height:1.5;padding:10px 12px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);color:var(--text);resize:vertical;white-space:pre;" placeholder="CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL REFERENCES customers(customer_id),
    total DECIMAL(10,2),
    status VARCHAR(20) DEFAULT 'pending'
);"></textarea>
<div id="importSqlDetected" style="font-size:10px;opacity:.4;margin-top:4px;"></div>
<div id="importSqlPreview" style="margin-top:12px;"></div>`;

  // Position selector
  body.querySelectorAll('#importSqlPosSelector .dockOpt').forEach(b => {
    b.addEventListener('click', () => {
      body.querySelectorAll('#importSqlPosSelector .dockOpt').forEach(x => x.classList.remove('active'));
      b.classList.add('active');
    });
  });

  const textarea = body.querySelector('#importSqlText');
  if(textarea){
    textarea.addEventListener('input', _refreshImportSqlPreview);
    _wireTabIndent(textarea, _refreshImportSqlPreview);
    textarea.focus();
  }

  // File upload handler
  const fileInput = document.getElementById('importSqlFileInput');
  if(fileInput){
    fileInput.value = '';
    fileInput.onchange = (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        const ta = document.getElementById('importSqlText');
        if(ta){ ta.value = e.target.result; _refreshImportSqlPreview(); }
      };
      reader.readAsText(f);
      fileInput.value = '';
    };
  }

  document.getElementById('importSqlMask')?.classList.add('active');
  document.getElementById('importSqlModal')?.classList.add('active');
}

function closeImportSql(){
  document.getElementById('importSqlMask')?.classList.remove('active');
  document.getElementById('importSqlModal')?.classList.remove('active');
}

function _refreshImportSqlPreview(){
  const textarea = document.getElementById('importSqlText');
  const previewEl = document.getElementById('importSqlPreview');
  const detectedEl = document.getElementById('importSqlDetected');
  const commitBtn = document.getElementById('importSqlCommit');
  if(!textarea || !previewEl) return;

  const tables = _parseSqlDDL(textarea.value);
  if(!tables.length){
    previewEl.innerHTML = '';
    detectedEl.textContent = textarea.value.trim() ? 'No CREATE TABLE statements detected.' : '';
    if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }
    return;
  }

  const totalCols = tables.reduce((s,t) => s + t.columns.length, 0);
  detectedEl.textContent = `Detected: ${tables.length} table${tables.length!==1?'s':''}, ${totalCols} column${totalCols!==1?'s':''}`;

  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:10px;">';
  const existingColLabels = new Set((state.data?.columns||[]).map(c => (c.label||'').toLowerCase()));

  for(const table of tables){
    const dup = existingColLabels.has(table.name.toLowerCase());
    const dupBadge = dup ? ' <span style="color:rgba(239,130,130,.7);font-size:9px;">name exists</span>' : '';
    html += `<div style="border:1px solid var(--border);border-radius:8px;padding:8px 10px;font-size:11px;line-height:1.6;">`;
    html += `<div style="font-weight:700;margin-bottom:4px;"> ${escapeHtml(table.name)}${dupBadge}</div>`;
    for(const col of table.columns){
      const badges = [];
      if(col.tags.includes('pk')) badges.push('<span style="background:rgba(168,85,247,.2);color:rgba(168,85,247,.9);font-size:8px;padding:0 4px;border-radius:3px;">PK</span>');
      if(col.tags.includes('fk')) badges.push('<span style="background:rgba(99,102,241,.2);color:rgba(99,102,241,.9);font-size:8px;padding:0 4px;border-radius:3px;">FK' + escapeHtml(col.refTable||'') + '</span>');
      if(col.notNull) badges.push('<span style="background:rgba(59,130,246,.15);color:rgba(59,130,246,.85);font-size:8px;padding:0 4px;border-radius:3px;">NOT NULL</span>');
      if(col.tags.includes('unique')) badges.push('<span style="background:rgba(6,182,212,.15);color:rgba(6,182,212,.85);font-size:8px;padding:0 4px;border-radius:3px;">UQ</span>');
      if(col.tags.includes('auto')) badges.push('<span style="background:rgba(34,197,94,.15);color:rgba(34,197,94,.85);font-size:8px;padding:0 4px;border-radius:3px;">AUTO</span>');
      const typeStr = col.dataType ? `<span style="opacity:.4;margin-left:3px;">${escapeHtml(col.dataType)}${col.typeParams ? '(' + escapeHtml(col.typeParams) + ')' : ''}</span>` : '';
      html += `<div style="padding:1px 0;">${escapeHtml(col.name)}${typeStr} ${badges.join(' ')}</div>`;
    }
    const fkCount = table.columns.filter(c => c.tags.includes('fk')).length;
    if(fkCount) html += `<div style="opacity:.35;font-size:10px;margin-top:4px;">${fkCount} foreign key${fkCount!==1?'s':''} (mapping import in Phase 5)</div>`;
    html += '</div>';
  }
  html += '</div>';
  previewEl.innerHTML = html;

  if(commitBtn){ commitBtn.disabled = false; commitBtn.classList.add('btnDirty'); }
}

function _commitImportSql(){
  if(!state.data) return;
  const textarea = document.getElementById('importSqlText');
  if(!textarea) return;

  const tables = _parseSqlDDL(textarea.value);
  if(!tables.length) return;

  const body = document.getElementById('importSqlBody');
  const posSel = body?.querySelector('#importSqlPosSelector');
  const atLeft = posSel?.querySelector('.dockOpt.active')?.dataset.ipos === 'left';

  recordChange();

  const cols = state.data.columns || (state.data.columns = []);
  const existingColIds = new Set(cols.map(c => c?.id));
  const attrCat = ensureCustomAttributeCatalog();
  const tagCat = ensureTagCatalog();

  // Ensure "Data Type" attribute exists
  let dataTypeAttr = attrCat.find(a =>
    ['data_type','data-type','datatype','type','format'].includes((a.id||'').toLowerCase()) ||
    ['data type','type','format','data_type','datatype'].includes((a.label||'').toLowerCase())
  );
  if(!dataTypeAttr){
    const eIds = new Set(attrCat.map(a=>a.id));
    dataTypeAttr = { id: ensureUniqueId('data_type', eIds), label: 'Data Type', abbr: 'DT', _autoId: true, values: [], priority: attrCat.length + 1 };
    attrCat.push(dataTypeAttr);
  }
  if(!dataTypeAttr.values) dataTypeAttr.values = [];

  // Ensure standard tags exist
  const ensureTag = (label, emoji, color, note) => {
    let tag = tagCat.find(t => (t.label||'').toLowerCase() === label.toLowerCase());
    if(!tag){
      const eIds = new Set(tagCat.map(t=>t.id));
      tag = {
        id: ensureUniqueId(idPartFromLabel(label, {lower:true}), eIds),
        label, abbr: label.substring(0,2).toUpperCase(), _autoId: true,
        priority: tagCat.length + 1
      };
      if(emoji) tag.emoji = emoji;
      if(color){ tag.color = color; tag.colorEnabled = true; }
      if(note) tag.note = note;
      tagCat.push(tag);
    }
    return tag.id;
  };

  const pkTagId = ensureTag('Primary Key', '', '#a855f7', 'Table primary key');
  const fkTagId = ensureTag('Foreign Key', '', '#6366f1', 'References another table');
  const reqTagId = ensureTag('Required', '', '#3b82f6', 'Non-nullable, must be populated');
  const uniqueTagId = ensureTag('Unique', '', '#06b6d4', 'Unique constraint');

  // Ensure "Nullable" attribute
  let nullableAttr = attrCat.find(a =>
    ['nullable'].includes((a.id||'').toLowerCase()) ||
    ['nullable'].includes((a.label||'').toLowerCase())
  );
  if(!nullableAttr){
    const eIds = new Set(attrCat.map(a=>a.id));
    nullableAttr = {
      id: ensureUniqueId('nullable', eIds), label: 'Nullable', abbr: 'NL', _autoId: true,
      values: [
        { id: 'yes', label: 'Yes', abbr: 'YES', _autoId: true, priority: 1 },
        { id: 'no', label: 'No', abbr: 'NO', _autoId: true, priority: 2 }
      ],
      priority: attrCat.length + 1
    };
    attrCat.push(nullableAttr);
  }

  const ensureDataTypeValue = (dt) => {
    if(!dt) return null;
    let val = dataTypeAttr.values.find(v =>
      (v.id||'').toLowerCase() === dt.toLowerCase() ||
      (v.label||'').toLowerCase() === dt.toLowerCase()
    );
    if(!val){
      const eIds = new Set(dataTypeAttr.values.map(v=>v.id));
      val = { id: ensureUniqueId(idPartFromLabel(dt, {lower:true}) || 'type', eIds), label: dt, abbr: dt.substring(0,3).toUpperCase(), _autoId: true, priority: dataTypeAttr.values.length + 1 };
      dataTypeAttr.values.push(val);
    }
    return val.id;
  };

  const newCols = [];
  for(const table of tables){
    const slug = idPartFromLabel(table.name) || 'table';
    const colId = ensureUniqueId(slug, existingColIds);
    existingColIds.add(colId);

    const takenInCol = new Set([colId]);
    const children = [];

    for(const sqlCol of table.columns){
      const s = idPartFromLabel(sqlCol.name, {lower:true}) || 'field';
      const nodeId = ensureUniqueId(colId + '.' + s, takenInCol);
      takenInCol.add(nodeId);

      const node = { id: nodeId, label: sqlCol.name, type: 'field', _autoId: true };

      // Tags
      const nodeTags = [];
      if(sqlCol.tags.includes('pk')) nodeTags.push(pkTagId);
      if(sqlCol.tags.includes('fk')) nodeTags.push(fkTagId);
      if(sqlCol.notNull) nodeTags.push(reqTagId);
      if(sqlCol.tags.includes('unique')) nodeTags.push(uniqueTagId);
      if(nodeTags.length) node.tags = nodeTags;

      // Custom attributes
      node.customAttributes = {};
      // Data type
      const dtValId = ensureDataTypeValue(sqlCol.dataType);
      if(dtValId) node.customAttributes[dataTypeAttr.id] = dtValId;
      // Nullable
      if(nullableAttr){
        const nullVal = sqlCol.notNull ? 'no' : 'yes';
        const nv = nullableAttr.values.find(v => v.id === nullVal);
        if(nv) node.customAttributes[nullableAttr.id] = nv.id;
      }

      // Note: include FK reference info
      if(sqlCol.refTable){
        node.note = `FK  ${sqlCol.refTable}${sqlCol.refCol ? '.' + sqlCol.refCol : ''}`;
      }
      if(sqlCol.defaultVal !== null && sqlCol.defaultVal !== undefined){
        node.note = (node.note ? node.note + '  ' : '') + `Default: ${sqlCol.defaultVal}`;
      }

      children.push(node);
    }

    newCols.push({
      id: colId,
      label: table.name,
      note: '',
      _autoId: true,
      schema: { id: colId, label: table.name, _autoId: true, type: 'group', children }
    });
  }

  if(atLeft) cols.unshift(...newCols);
  else cols.push(...newCols);

  closeImportSql();
  renderAll();
  const totalFields = tables.reduce((s,t) => s + t.columns.length, 0);
  setGlobalStatus(`Imported ${newCols.length} table${newCols.length>1?'s':''} (${totalFields} field${totalFields!==1?'s':''}) from SQL.`);
}

document.getElementById('importSqlBtn')?.addEventListener('click', ()=>{ closeAllPopovers(); openImportSql(); });
document.getElementById('importSqlClose')?.addEventListener('click', closeImportSql);
document.getElementById('importSqlMask')?.addEventListener('click', closeImportSql);
document.getElementById('importSqlCommit')?.addEventListener('click', _commitImportSql);
document.getElementById('importSqlModal')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); closeImportSql(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    const btn = document.getElementById('importSqlCommit');
    if(btn && !btn.disabled) _commitImportSql();
  }
});

// 
// Import CSV / TSV file (with column mapping)
// 
let __csvFileData = null; // { headers, rows, separator }

function _parseCSVLine(line, sep){
  const fields = [];
  let current = '', inQuotes = false;
  for(let i = 0; i < line.length; i++){
    const ch = line[i];
    if(inQuotes){
      if(ch === '"' && line[i+1] === '"'){ current += '"'; i++; }
      else if(ch === '"') inQuotes = false;
      else current += ch;
    } else {
      if(ch === '"') inQuotes = true;
      else if(ch === sep){ fields.push(current); current = ''; }
      else current += ch;
    }
  }
  fields.push(current);
  return fields;
}

function _parseCSVFile(text){
  // Detect separator: tab, comma, or semicolon
  const firstLine = text.split('\n')[0] || '';
  let sep = ',';
  if(firstLine.includes('\t')) sep = '\t';
  else if((firstLine.match(/;/g)||[]).length > (firstLine.match(/,/g)||[]).length) sep = ';';

  const lines = text.split('\n').map(l => l.replace(/\r$/, '')).filter(l => l.trim());
  if(!lines.length) return null;

  const headers = _parseCSVLine(lines[0], sep);
  const rows = lines.slice(1).map(l => {
    const cells = _parseCSVLine(l, sep);
    const obj = {};
    headers.forEach((h, i) => { obj[h] = (cells[i] || '').trim(); });
    return obj;
  }).filter(r => headers.some(h => r[h])); // skip empty rows

  return { headers, rows, separator: sep === '\t' ? 'tab' : (sep === ';' ? 'semicolon' : 'comma') };
}

const CSV_ROLES = [
  { id:'label', label:'Label (name)', desc:'Field display name' },
  { id:'id', label:'ID', desc:'Custom identifier' },
  { id:'parent', label:'Parent', desc:'Nesting parent (label or ID)' },
  { id:'column', label:'Column', desc:'Group into column' },
  { id:'note', label:'Note', desc:'Description / note' },
  { id:'tag', label:'Tag', desc:'Assign tags (comma-separated)' },
  { id:'skip', label:' Skip ', desc:'Do not import' },
  { id:'attr', label:'Custom attribute', desc:'Create/match attribute' }
];

function openImportCsvFile(){
  if(!state.editorMode){ customAlert('Switch to Editor mode first.'); return; }
  __csvFileData = null;
  const body = document.getElementById('importCsvFileBody');
  const commitBtn = document.getElementById('importCsvFileCommit');
  if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }

  body.innerHTML = `
<div style="font-size:12px;opacity:.5;margin-bottom:12px;">Upload a CSV or TSV file. Map each column to a role (label, parent, note, tag, or custom attribute), then import as fields.</div>
<div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:12px;">
  <label class="btn btnSave" style="font-size:12px;cursor:pointer;padding:6px 16px;"> Choose file
    <input type="file" id="csvFilePickerInput" accept=".csv,.tsv,.txt,.xls" style="display:none;">
  </label>
  <span id="csvFileName" style="font-size:11px;opacity:.4;"></span>
</div>
<div id="csvMappingArea" style="display:none;">
  <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px;flex-wrap:wrap;">
    <span style="font-size:11px;opacity:.5;">Import into:</span>
    <div class="dockSelector" id="csvTargetSelector" style="flex:0 auto;">
      <button class="dockOpt active" data-target="new" style="padding:4px 12px;min-width:0;">New column(s)</button>
      <button class="dockOpt" data-target="existing" style="padding:4px 12px;min-width:0;">Existing column</button>
    </div>
    <select class="inp" id="csvTargetCol" style="font-size:11px;max-width:220px;display:none;"></select>
  </div>
  <div id="csvColumnMap" style="margin-bottom:12px;"></div>
  <div id="csvPreview" style="margin-top:12px;"></div>
</div>`;

  // Wire file picker
  const filePicker = body.querySelector('#csvFilePickerInput');
  if(filePicker){
    filePicker.addEventListener('change', (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if(!f) return;
      document.getElementById('csvFileName').textContent = f.name;
      const reader = new FileReader();
      reader.onload = (e) => {
        __csvFileData = _parseCSVFile(e.target.result);
        if(!__csvFileData || !__csvFileData.rows.length){
          customAlert('Could not parse file or file is empty.');
          return;
        }
        _buildCsvMappingUI();
      };
      reader.readAsText(f);
    });
  }

  // Target selector
  body.querySelectorAll('#csvTargetSelector .dockOpt').forEach(b => {
    b.addEventListener('click', () => {
      body.querySelectorAll('#csvTargetSelector .dockOpt').forEach(x => x.classList.remove('active'));
      b.classList.add('active');
      const colSel = document.getElementById('csvTargetCol');
      if(colSel) colSel.style.display = b.dataset.target === 'existing' ? '' : 'none';
      _refreshCsvPreview();
    });
  });

  document.getElementById('importCsvFileMask')?.classList.add('active');
  document.getElementById('importCsvFileModal')?.classList.add('active');
}

function _buildCsvMappingUI(){
  const data = __csvFileData;
  if(!data) return;

  const mappingArea = document.getElementById('csvMappingArea');
  if(mappingArea) mappingArea.style.display = '';

  // Fill target column dropdown
  const colSel = document.getElementById('csvTargetCol');
  if(colSel){
    const cols = state.data?.columns || [];
    colSel.innerHTML = cols.map(c => `<option value="${escapeHtml(c.id)}">${escapeHtml(c.label || c.id)}</option>`).join('');
  }

  // Auto-detect column roles from header names
  const autoRole = (h) => {
    const hl = h.toLowerCase().replace(/[^a-z0-9]/g, '');
    if(['name','label','fieldname','field','columnname','column_name','field_name'].includes(hl)) return 'label';
    if(['id','fieldid','field_id','columnid'].includes(hl)) return 'id';
    if(['parent','parentfield','parent_field','group','parentgroup'].includes(hl)) return 'parent';
    if(['column','table','tablename','table_name','schema','source','target','system'].includes(hl)) return 'column';
    if(['note','notes','description','desc','comment','comments'].includes(hl)) return 'note';
    if(['tag','tags','category','status'].includes(hl)) return 'tag';
    if(['type','datatype','data_type','format'].includes(hl)) return 'attr';
    return 'attr'; // Default: treat as custom attribute
  };

  // Check if there's exactly one "label"-like column; if not, first column is label
  const roles = data.headers.map(h => autoRole(h));
  if(!roles.includes('label')){
    roles[0] = 'label'; // First column defaults to label
  }

  const mapEl = document.getElementById('csvColumnMap');
  let html = '<div style="font-size:11px;font-weight:600;opacity:.5;margin-bottom:6px;">Column mapping</div>';
  html += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:6px;font-size:11px;">';

  for(let i = 0; i < data.headers.length; i++){
    const h = data.headers[i];
    const sample = data.rows.slice(0,3).map(r => r[h]).filter(Boolean).join(', ');
    html += `<div style="border:1px solid var(--border);border-radius:6px;padding:6px 8px;">
      <div style="font-weight:600;margin-bottom:3px;" title="${escapeHtml(sample)}">${escapeHtml(h)}</div>
      <div style="opacity:.3;font-size:10px;margin-bottom:4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${escapeHtml(sample)}">${escapeHtml(sample.substring(0,40))}</div>
      <select class="inp csvRoleSel" data-col="${i}" style="font-size:11px;width:100%;">
        ${CSV_ROLES.map(r => `<option value="${r.id}"${roles[i]===r.id?' selected':''}>${escapeHtml(r.label)}</option>`).join('')}
      </select>
    </div>`;
  }
  html += '</div>';
  mapEl.innerHTML = html;

  // Wire role selects
  mapEl.querySelectorAll('.csvRoleSel').forEach(sel => {
    sel.addEventListener('change', _refreshCsvPreview);
  });

  _refreshCsvPreview();
}

function _getCsvRoleMap(){
  const selects = document.querySelectorAll('.csvRoleSel');
  const map = {}; // role -> header index
  const attrCols = []; // indices of attr columns
  selects.forEach(sel => {
    const idx = parseInt(sel.dataset.col);
    const role = sel.value;
    if(role === 'attr') attrCols.push(idx);
    else if(role !== 'skip') map[role] = idx;
  });
  return { map, attrCols };
}

function _refreshCsvPreview(){
  const data = __csvFileData;
  if(!data) return;
  const previewEl = document.getElementById('csvPreview');
  const commitBtn = document.getElementById('importCsvFileCommit');
  if(!previewEl) return;

  const { map, attrCols } = _getCsvRoleMap();
  if(map.label === undefined){
    previewEl.innerHTML = '<div style="font-size:11px;opacity:.4;">Assign at least one column as <b>Label</b>.</div>';
    if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }
    return;
  }

  const headers = data.headers;
  const isNewCols = document.querySelector('#csvTargetSelector .dockOpt.active')?.dataset.target === 'new';
  const hasColumnRole = map.column !== undefined;

  // Build preview tree
  const entries = data.rows.map(r => ({
    label: r[headers[map.label]] || '',
    id: map.id !== undefined ? r[headers[map.id]] : '',
    parent: map.parent !== undefined ? r[headers[map.parent]] : '',
    column: map.column !== undefined ? r[headers[map.column]] : '',
    note: map.note !== undefined ? r[headers[map.note]] : '',
    tag: map.tag !== undefined ? r[headers[map.tag]] : '',
    attrs: attrCols.map(i => ({ name: headers[i], value: r[headers[i]] })).filter(a => a.value)
  })).filter(e => e.label);

  // Group by column if column role is set and importing as new columns
  let groups;
  if(isNewCols && hasColumnRole){
    groups = {};
    for(const e of entries){
      const key = e.column || 'Imported';
      if(!groups[key]) groups[key] = [];
      groups[key].push(e);
    }
  } else {
    const label = isNewCols ? 'Imported' : '(existing column)';
    groups = { [label]: entries };
  }

  let html = `<div style="font-size:11px;font-weight:600;opacity:.6;margin-bottom:6px;">Preview: ${entries.length} field${entries.length!==1?'s':''} in ${Object.keys(groups).length} column${Object.keys(groups).length!==1?'s':''}</div>`;
  html += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px;">';

  for(const [grpName, items] of Object.entries(groups)){
    html += `<div style="border:1px solid var(--border);border-radius:8px;padding:8px 10px;font-size:11px;line-height:1.6;max-height:220px;overflow-y:auto;">`;
    html += `<div style="font-weight:700;margin-bottom:4px;"> ${escapeHtml(grpName)}</div>`;
    // Build parent hierarchy
    const byKey = {};
    for(const item of items){
      if(item.label) byKey[item.label.toLowerCase()] = item;
      if(item.id) byKey[item.id.toLowerCase()] = item;
    }
    const getDepth = (item, visited) => {
      if(!item.parent) return 0;
      const parentKey = item.parent.toLowerCase();
      if(visited.has(parentKey)) return 0;
      visited.add(parentKey);
      const p = byKey[parentKey];
      return p ? 1 + getDepth(p, visited) : 0;
    };

    for(const item of items){
      const depth = getDepth(item, new Set());
      const indent = depth * 14;
      const tagBadge = item.tag ? ` <span style="background:rgba(59,130,246,.15);color:rgba(59,130,246,.85);font-size:8px;padding:0 4px;border-radius:3px;"> ${escapeHtml(item.tag.substring(0,20))}</span>` : '';
      const attrBadges = item.attrs.map(a => `<span style="background:rgba(139,92,246,.1);color:rgba(139,92,246,.8);font-size:8px;padding:0 4px;border-radius:3px;">${escapeHtml(a.name)}: ${escapeHtml(a.value.substring(0,15))}</span>`).join(' ');
      html += `<div style="padding:1px 0;padding-left:${indent}px;">${depth?' ':''}${escapeHtml(item.label)} ${tagBadge} ${attrBadges}</div>`;
    }
    html += '</div>';
  }
  html += '</div>';

  // Attribute summary
  if(attrCols.length){
    const attrCat = ensureCustomAttributeCatalog();
    const names = attrCols.map(i => headers[i]);
    const existing = names.filter(n => attrCat.some(a => (a.label||'').toLowerCase() === n.toLowerCase() || (a.id||'').toLowerCase() === n.toLowerCase().replace(/\s/g,'_')));
    const newAttrs = names.filter(n => !existing.includes(n));
    let summ = '';
    if(existing.length) summ += `Existing attributes: ${existing.join('  ')}`;
    if(newAttrs.length) summ += `${summ?'  ':''}New attributes: <b>${newAttrs.join(', ')}</b>`;
    if(summ) html += `<div style="font-size:10px;opacity:.4;margin-top:6px;">${summ}</div>`;
  }

  previewEl.innerHTML = html;
  if(commitBtn){ commitBtn.disabled = false; commitBtn.classList.add('btnDirty'); }
}

function _commitImportCsvFile(){
  const data = __csvFileData;
  if(!data || !state.data) return;

  const { map, attrCols } = _getCsvRoleMap();
  if(map.label === undefined) return;

  const headers = data.headers;
  const isNewCols = document.querySelector('#csvTargetSelector .dockOpt.active')?.dataset.target === 'new';
  const hasColumnRole = map.column !== undefined;
  const targetColId = document.getElementById('csvTargetCol')?.value;

  // Build entries
  const entries = data.rows.map(r => ({
    label: r[headers[map.label]] || '',
    id: map.id !== undefined ? r[headers[map.id]] : '',
    parent: map.parent !== undefined ? r[headers[map.parent]] : '',
    column: map.column !== undefined ? r[headers[map.column]] : '',
    note: map.note !== undefined ? r[headers[map.note]] : '',
    tag: map.tag !== undefined ? r[headers[map.tag]] : '',
    attrs: attrCols.map(i => ({ name: headers[i], value: r[headers[i]] })).filter(a => a.value)
  })).filter(e => e.label);

  if(!entries.length) return;

  recordChange();

  const cols = state.data.columns || (state.data.columns = []);
  const existingColIds = new Set(cols.map(c => c?.id));
  const attrCat = ensureCustomAttributeCatalog();

  // Helper to resolve attributes
  const resolveAttr = (name, val) => {
    const nameLower = name.toLowerCase().replace(/\s/g, '_');
    let attr = attrCat.find(a =>
      (a.id||'').toLowerCase() === nameLower || (a.label||'').toLowerCase() === name.toLowerCase()
    );
    if(!attr && ['type','data_type','datatype'].includes(nameLower)){
      attr = attrCat.find(a =>
        ['format','type','data_type','datatype'].includes((a.id||'').toLowerCase()) ||
        ['format','type','data type'].includes((a.label||'').toLowerCase())
      );
    }
    if(!attr){
      const attrLabel = name;
      const eIds = new Set(attrCat.map(a=>a.id));
      attr = { id: ensureUniqueId(idPartFromLabel(name, {lower:true}), eIds), label: attrLabel, abbr: attrLabel.substring(0,2).toUpperCase(), _autoId: true, values: [], priority: attrCat.length + 1 };
      attrCat.push(attr);
    }
    if(!attr.values) attr.values = [];
    const valStr = val.trim();
    let v = attr.values.find(x =>
      (x.id||'').toLowerCase() === valStr.toLowerCase() ||
      (x.label||'').toLowerCase() === valStr.toLowerCase()
    );
    if(!v){
      const eIds = new Set(attr.values.map(x=>x.id));
      v = { id: ensureUniqueId(idPartFromLabel(valStr, {lower:true}) || 'val', eIds), label: valStr, abbr: valStr.substring(0,3).toUpperCase(), _autoId: true, priority: attr.values.length + 1 };
      attr.values.push(v);
    }
    return { attrId: attr.id, valId: v.id };
  };

  // Group entries by column
  let groups;
  if(isNewCols && hasColumnRole){
    groups = {};
    for(const e of entries){
      const key = e.column || 'Imported';
      if(!groups[key]) groups[key] = [];
      groups[key].push(e);
    }
  } else if(!isNewCols && targetColId){
    groups = { [targetColId]: entries };
  } else {
    groups = { 'Imported': entries };
  }

  let totalCreated = 0;
  const newColCount = isNewCols ? Object.keys(groups).length : 0;

  for(const [grpKey, items] of Object.entries(groups)){
    let targetCol;
    if(!isNewCols && targetColId){
      targetCol = cols.find(c => c.id === targetColId);
    }
    if(!targetCol){
      // Create new column
      const slug = idPartFromLabel(grpKey) || 'column';
      const colId = ensureUniqueId(slug, existingColIds);
      existingColIds.add(colId);
      targetCol = {
        id: colId, label: grpKey, note: '', _autoId: true,
        schema: { id: colId, label: grpKey, _autoId: true, type: 'group', children: [] }
      };
      cols.push(targetCol);
    }

    const schema = targetCol.schema || (targetCol.schema = { id: targetCol.id, label: targetCol.label, type: 'group', children: [] });
    const children = schema.children || (schema.children = []);
    const takenIds = new Set();
    const collectIds = (nodes) => { for(const n of (nodes||[])){ takenIds.add(n.id); if(n.children) collectIds(n.children); } };
    collectIds(children);

    // Build parent lookup
    const byKey = {};
    const nodeMap = {}; // entry index -> node
    for(let i = 0; i < items.length; i++){
      const e = items[i];
      if(e.label) byKey[e.label.toLowerCase()] = i;
      if(e.id) byKey[e.id.toLowerCase()] = i;
    }

    // Create all nodes first
    const nodes = items.map(e => {
      const s = idPartFromLabel(e.label, {lower:true}) || 'field';
      const base = (e.id) ? e.id : (targetCol.id + '.' + s);
      const nodeId = ensureUniqueId(base, takenIds);
      takenIds.add(nodeId);
      const node = { id: nodeId, label: e.label, type: 'field', _autoId: !e.id };
      if(e.note) node.note = e.note;
      // Tags
      if(e.tag){
        const tagCat = ensureTagCatalog();
        const tagIds = e.tag.split(/[,;]/).map(t => t.trim().toLowerCase()).filter(Boolean);
        const matched = tagIds.map(t => {
          const found = tagCat.find(tc => tc.id === t || (tc.label||'').toLowerCase() === t);
          return found ? found.id : null;
        }).filter(Boolean);
        if(matched.length) node.tags = matched;
      }
      // Attributes
      if(e.attrs.length){
        node.customAttributes = {};
        for(const a of e.attrs){
          const { attrId, valId } = resolveAttr(a.name, a.value);
          node.customAttributes[attrId] = valId;
        }
      }
      return node;
    });

    // Build tree from parent references
    const rootNodes = [];
    const nodeChildren = new Map(); // index -> child indices
    for(let i = 0; i < items.length; i++){
      const e = items[i];
      if(e.parent){
        const parentIdx = byKey[e.parent.toLowerCase()];
        if(parentIdx !== undefined && parentIdx !== i){
          if(!nodeChildren.has(parentIdx)) nodeChildren.set(parentIdx, []);
          nodeChildren.get(parentIdx).push(i);
          // Make parent a group
          nodes[parentIdx].type = 'group';
          if(!nodes[parentIdx].children) nodes[parentIdx].children = [];
          continue;
        }
      }
      rootNodes.push(i);
    }
    // Attach children recursively
    const attachChildren = (idx) => {
      const childIdxs = nodeChildren.get(idx) || [];
      for(const ci of childIdxs){
        nodes[idx].children.push(nodes[ci]);
        attachChildren(ci);
      }
    };
    for(const ri of rootNodes) attachChildren(ri);

    // Add root nodes to column
    for(const ri of rootNodes){
      children.push(nodes[ri]);
    }
    totalCreated += items.length;
  }

  closeImportCsvFile();
  renderAll();
  setGlobalStatus(`Imported ${totalCreated} field${totalCreated!==1?'s':''} from CSV/TSV${newColCount > 0 ? ` into ${newColCount} column${newColCount!==1?'s':''}` : ''}.`);
}

function closeImportCsvFile(){
  __csvFileData = null;
  document.getElementById('importCsvFileMask')?.classList.remove('active');
  document.getElementById('importCsvFileModal')?.classList.remove('active');
}

document.getElementById('importCsvFileBtn')?.addEventListener('click', ()=>{ closeAllPopovers(); openImportCsvFile(); });
document.getElementById('importCsvFileClose')?.addEventListener('click', closeImportCsvFile);
document.getElementById('importCsvFileMask')?.addEventListener('click', closeImportCsvFile);
document.getElementById('importCsvFileCommit')?.addEventListener('click', _commitImportCsvFile);
document.getElementById('importCsvFileModal')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); closeImportCsvFile(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    const btn = document.getElementById('importCsvFileCommit');
    if(btn && !btn.disabled) _commitImportCsvFile();
  }
});

// 
// Import mappings (Phase 5)
// 

function _buildFieldLookup(){
  // Build multi-strategy lookup: by exact ID, by label, by column.label, by column/label
  const byId = {};       // id -> nodeId
  const byLabel = {};    // label.toLowerCase() -> [nodeId, ...]  (may be ambiguous)
  const byColLabel = {}; // "colLabel.fieldLabel".toLowerCase() -> nodeId
  const byColId = {};    // "colId.fieldLabel".toLowerCase() -> nodeId

  if(!IDX.fieldIds) return { byId, byLabel, byColLabel, byColId };

  for(const fid of IDX.fieldIds){
    const node = IDX.nodeById.get(fid);
    if(!node) continue;
    byId[fid] = fid;
    const label = (node.label || '').toLowerCase();
    if(label){
      if(!byLabel[label]) byLabel[label] = [];
      byLabel[label].push(fid);
    }
    const colId = IDX.nodeColumnById.get(fid);
    if(colId){
      const col = IDX.columns.find(c => c.id === colId);
      const colLabel = col ? (col.label || col.id) : colId;
      // column.label format
      byColLabel[(colLabel + '.' + (node.label||'')).toLowerCase()] = fid;
      byColLabel[(colLabel + '/' + (node.label||'')).toLowerCase()] = fid;
      // colId.label format
      byColId[(colId + '.' + (node.label||'')).toLowerCase()] = fid;
      byColId[(colId + '/' + (node.label||'')).toLowerCase()] = fid;
      // colId.nodeId short form (last segment of hierarchical ID)
      const shortId = fid.includes('.') ? fid.split('.').pop() : fid;
      if(shortId) byColId[(colId + '.' + shortId).toLowerCase()] = fid;
    }
  }
  return { byId, byLabel, byColLabel, byColId };
}

function _resolveFieldRef(ref, lookup){
  if(!ref) return { id: null, status: 'empty' };
  const trimmed = ref.trim();
  if(!trimmed) return { id: null, status: 'empty' };

  // 1. Exact ID match
  if(lookup.byId[trimmed]) return { id: trimmed, status: 'id' };

  // 2. Column.label or column/label
  const lower = trimmed.toLowerCase();
  if(lookup.byColLabel[lower]) return { id: lookup.byColLabel[lower], status: 'col.label' };
  if(lookup.byColId[lower]) return { id: lookup.byColId[lower], status: 'col.label' };

  // 3. Label match (unambiguous)
  const labelHits = lookup.byLabel[lower];
  if(labelHits && labelHits.length === 1) return { id: labelHits[0], status: 'label' };
  if(labelHits && labelHits.length > 1) return { id: null, status: 'ambiguous', count: labelHits.length };

  // 4. Partial match  try last segment of hierarchical ID
  for(const [fid] of Object.entries(lookup.byId)){
    const lastSeg = fid.includes('.') ? fid.split('.').pop() : fid;
    if(lastSeg.toLowerCase() === lower) {
      // Check if unique
      const allMatches = Object.keys(lookup.byId).filter(id => {
        const seg = id.includes('.') ? id.split('.').pop() : id;
        return seg.toLowerCase() === lower;
      });
      if(allMatches.length === 1) return { id: allMatches[0], status: 'partial' };
      if(allMatches.length > 1) return { id: null, status: 'ambiguous', count: allMatches.length };
    }
  }

  return { id: null, status: 'notfound' };
}

function _parseMappingsImportText(text){
  const lines = text.split('\n').map(l => l.replace(/\r$/, '')).filter(l => l.trim());
  if(!lines.length) return { mode:'empty', items:[] };

  // Detect separator
  const first = lines[0];
  let sep = '\t';
  if(!first.includes('\t')){
    if((first.match(/,/g)||[]).length >= 1) sep = ',';
    else if((first.match(/;/g)||[]).length >= 1) sep = ';';
  }

  // Check if first line is a header row
  const firstCells = sep === ',' ? _parseCSVLine(first, ',') : first.split(sep);
  const headerCandidates = firstCells.map(h => h.trim().toLowerCase());
  const knownHeaders = ['source','target','from','to','fromcolumn','toColumn','from_column','to_column','cardinality','label','note','default','tag','tags','transform','transforms','direction'];
  const isHeader = headerCandidates.filter(h => knownHeaders.includes(h.replace(/[\s_]/g,''))).length >= 2;

  let headers, dataLines;
  if(isHeader){
    headers = firstCells.map(h => h.trim());
    dataLines = lines.slice(1);
  } else {
    // Assume 2-column: source, target
    headers = ['source', 'target'];
    dataLines = lines;
  }

  const hLower = headers.map(h => h.toLowerCase().replace(/[\s_]/g,''));

  // Map header names to roles
  const findCol = (...names) => {
    for(const n of names){
      const idx = hLower.indexOf(n);
      if(idx >= 0) return idx;
    }
    return -1;
  };

  const sourceCol = findCol('source','from');
  const targetCol = findCol('target','to');
  const cardCol = findCol('cardinality');
  const labelCol = findCol('label');
  const noteCol = findCol('note');
  const defaultCol = findCol('default');
  const tagCol = findCol('tag','tags');
  const transformCol = findCol('transform','transforms');
  // fromColumn/toColumn are informational only (from CSV export), not used for resolution

  if(sourceCol < 0 || targetCol < 0){
    // If no headers detected, try positional (first two columns)
    if(!isHeader && firstCells.length >= 2){
      // Already handled above with default headers
    } else {
      return { mode: 'error', error: 'Could not find source and target columns. Use headers: source, target' };
    }
  }

  const items = [];
  for(const line of dataLines){
    const cells = sep === ',' ? _parseCSVLine(line, ',') : line.split(sep);
    const get = (idx) => idx >= 0 && idx < cells.length ? cells[idx].trim() : '';

    const source = get(sourceCol);
    const target = get(targetCol);
    if(!source || !target) continue;

    const item = { source, target };
    if(cardCol >= 0 && get(cardCol)) item.cardinality = get(cardCol);
    if(labelCol >= 0 && get(labelCol)) item.label = get(labelCol);
    if(noteCol >= 0 && get(noteCol)) item.note = get(noteCol);
    if(defaultCol >= 0 && get(defaultCol)) item.default = get(defaultCol);
    if(tagCol >= 0 && get(tagCol)) item.tag = get(tagCol);
    if(transformCol >= 0 && get(transformCol)) item.transform = get(transformCol);

    // Extra columns  custom attributes
    const extras = {};
    for(let i = 0; i < headers.length; i++){
      if([sourceCol, targetCol, cardCol, labelCol, noteCol, defaultCol, tagCol, transformCol].includes(i)) continue;
      if(hLower[i] === 'fromcolumn' || hLower[i] === 'tocolumn') continue;
      const val = get(i);
      if(val) extras[headers[i]] = val;
    }
    if(Object.keys(extras).length) item._extra = extras;

    items.push(item);
  }

  return { mode: sep === '\t' ? 'tsv' : (sep === ',' ? 'csv' : 'text'), items, headers };
}

function openImportMappings(){
  if(!state.editorMode){ customAlert('Switch to Editor mode first.'); return; }
  if(!state.data || !state.data.columns || !state.data.columns.length){
    customAlert('Load or create a project with columns and fields first.');
    return;
  }

  const body = document.getElementById('importMappingsBody');
  const commitBtn = document.getElementById('importMappingsCommit');
  if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }

  const fieldCount = IDX.fieldIds ? IDX.fieldIds.size : 0;
  const colNames = (IDX.columns || []).map(c => c.label || c.id).join(', ');

  body.innerHTML = `
<div style="font-size:12px;opacity:.5;margin-bottom:10px;">Paste or upload a mapping table. Each row creates a mapping between a source and target field. Fields are matched by <b>ID</b>, <b>column.label</b>, or <b>label</b> (if unambiguous).</div>
<div style="font-size:10px;opacity:.3;margin-bottom:10px;">Available: ${fieldCount} fields across columns: ${escapeHtml(colNames)}</div>
<textarea id="importMappingsText" style="width:100%;min-height:200px;max-height:40vh;font-family:var(--mono);font-size:12px;line-height:1.5;padding:10px 12px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);color:var(--text);resize:vertical;white-space:pre;" placeholder="Tab-separated or comma-separated:

source\ttarget\tcardinality\tnote
customers.customer_id\torders.customer_id\t1:N\tFK reference
customers.email\tcontacts.email_address\t1:1\tDirect map
customers.first_name\tcontacts.full_name\t\tConcat with last_name

Or paste the CSV export (from, to columns) for round-tripping.
Fields are matched by exact ID, column.label, or unambiguous label."></textarea>
<div id="importMappingsDetected" style="font-size:10px;opacity:.4;margin-top:4px;"></div>
<div id="importMappingsPreview" style="margin-top:12px;"></div>`;

  const textarea = body.querySelector('#importMappingsText');
  if(textarea){
    textarea.addEventListener('input', _refreshImportMappingsPreview);
    _wireTabIndent(textarea, _refreshImportMappingsPreview);
    textarea.focus();
  }

  // File upload
  const fileInput = document.getElementById('importMappingsFileInput');
  if(fileInput){
    fileInput.value = '';
    fileInput.onchange = (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        const ta = document.getElementById('importMappingsText');
        if(ta){ ta.value = e.target.result; _refreshImportMappingsPreview(); }
      };
      reader.readAsText(f);
      fileInput.value = '';
    };
  }

  document.getElementById('importMappingsMask')?.classList.add('active');
  document.getElementById('importMappingsModal')?.classList.add('active');
}

function closeImportMappings(){
  document.getElementById('importMappingsMask')?.classList.remove('active');
  document.getElementById('importMappingsModal')?.classList.remove('active');
}

function _refreshImportMappingsPreview(){
  const textarea = document.getElementById('importMappingsText');
  const previewEl = document.getElementById('importMappingsPreview');
  const detectedEl = document.getElementById('importMappingsDetected');
  const commitBtn = document.getElementById('importMappingsCommit');
  if(!textarea || !previewEl) return;

  const parsed = _parseMappingsImportText(textarea.value);
  if(parsed.mode === 'empty'){
    previewEl.innerHTML = '';
    detectedEl.textContent = '';
    if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }
    return;
  }
  if(parsed.mode === 'error'){
    previewEl.innerHTML = `<div style="color:rgba(239,130,130,.8);font-size:11px;">${escapeHtml(parsed.error)}</div>`;
    detectedEl.textContent = '';
    if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }
    return;
  }

  const lookup = _buildFieldLookup();
  const existingMappings = new Set((state.data?.mappings||[]).map(m => m.from + '|' + m.to));

  detectedEl.textContent = parsed.headers
    ? `Detected: ${parsed.mode} (${parsed.headers.length} columns: ${parsed.headers.join(', ')})  ${parsed.items.length} row${parsed.items.length!==1?'s':''}`
    : `Detected: ${parsed.items.length} row${parsed.items.length!==1?'s':''}`;

  const statusBadge = (res) => {
    if(res.status === 'id') return '<span style="color:rgba(34,197,94,.7);font-size:8px;">ID</span>';
    if(res.status === 'col.label') return '<span style="color:rgba(34,197,94,.7);font-size:8px;">col.label</span>';
    if(res.status === 'label') return '<span style="color:rgba(59,130,246,.7);font-size:8px;">label</span>';
    if(res.status === 'partial') return '<span style="color:rgba(139,92,246,.7);font-size:8px;">partial</span>';
    if(res.status === 'ambiguous') return `<span style="color:rgba(245,158,11,.8);font-size:8px;">ambiguous (${res.count})</span>`;
    if(res.status === 'notfound') return '<span style="color:rgba(239,130,130,.8);font-size:8px;">not found</span>';
    return '';
  };

  const shortId = (id) => {
    if(!id) return '?';
    const parts = id.split('.');
    if(parts.length <= 2) return id;
    return parts[0] + '.' + parts.slice(-1)[0];
  };

  let resolvedCount = 0, dupCount = 0, errorCount = 0;

  let html = '<div style="border:1px solid var(--border);border-radius:8px;padding:8px 10px;max-height:280px;overflow-y:auto;font-size:11px;line-height:1.8;">';
  html += '<div style="display:grid;grid-template-columns:1fr auto 1fr auto;gap:2px 8px;align-items:center;font-family:var(--mono);font-size:10px;">';
  html += '<div style="font-weight:700;opacity:.5;font-family:var(--sans);">Source</div><div></div><div style="font-weight:700;opacity:.5;font-family:var(--sans);">Target</div><div style="font-weight:700;opacity:.5;font-family:var(--sans);">Status</div>';

  for(const item of parsed.items){
    const srcRes = _resolveFieldRef(item.source, lookup);
    const tgtRes = _resolveFieldRef(item.target, lookup);
    const bothResolved = srcRes.id && tgtRes.id;
    const isDup = bothResolved && existingMappings.has(srcRes.id + '|' + tgtRes.id);

    let rowStatus = '';
    if(isDup){
      rowStatus = '<span style="opacity:.3;font-size:9px;">exists</span>';
      dupCount++;
    } else if(bothResolved){
      rowStatus = '<span style="color:rgba(34,197,94,.7);font-size:9px;">new</span>';
      resolvedCount++;
    } else {
      const issues = [];
      if(!srcRes.id) issues.push('src: ' + srcRes.status);
      if(!tgtRes.id) issues.push('tgt: ' + tgtRes.status);
      rowStatus = `<span style="color:rgba(239,130,130,.7);font-size:9px;">${escapeHtml(issues.join(', '))}</span>`;
      errorCount++;
    }

    const srcDisplay = srcRes.id ? shortId(srcRes.id) : escapeHtml(item.source);
    const tgtDisplay = tgtRes.id ? shortId(tgtRes.id) : escapeHtml(item.target);
    const srcStyle = srcRes.id ? '' : 'color:rgba(239,130,130,.7);';
    const tgtStyle = tgtRes.id ? '' : 'color:rgba(239,130,130,.7);';
    const cardBadge = item.cardinality ? ` <span style="opacity:.35;">${escapeHtml(item.cardinality)}</span>` : '';

    html += `<div style="${srcStyle}" title="${escapeHtml(item.source)}${srcRes.id?'  '+srcRes.id:''}">${escapeHtml(srcDisplay)} ${statusBadge(srcRes)}</div>`;
    html += `<div style="opacity:.3;">${cardBadge}</div>`;
    html += `<div style="${tgtStyle}" title="${escapeHtml(item.target)}${tgtRes.id?'  '+tgtRes.id:''}">${escapeHtml(tgtDisplay)} ${statusBadge(tgtRes)}</div>`;
    html += `<div>${rowStatus}</div>`;
  }
  html += '</div></div>';

  // Summary
  const summParts = [];
  if(resolvedCount) summParts.push(`<span style="color:rgba(34,197,94,.7);">${resolvedCount} new</span>`);
  if(dupCount) summParts.push(`<span style="opacity:.4;">${dupCount} existing</span>`);
  if(errorCount) summParts.push(`<span style="color:rgba(239,130,130,.7);">${errorCount} unresolved</span>`);
  html += `<div style="font-size:10px;margin-top:6px;">${summParts.join('  ')}</div>`;

  if(errorCount){
    html += `<div style="font-size:10px;opacity:.4;margin-top:4px;"> Unresolved fields: try using <b>column.label</b> format (e.g. "customers.email") or the exact node ID.</div>`;
  }

  previewEl.innerHTML = html;
  if(commitBtn){
    commitBtn.disabled = resolvedCount === 0;
    commitBtn.classList.toggle('btnDirty', resolvedCount > 0);
  }
}

function _commitImportMappings(){
  if(!state.data) return;
  const textarea = document.getElementById('importMappingsText');
  if(!textarea) return;

  const parsed = _parseMappingsImportText(textarea.value);
  if(!parsed.items.length) return;

  const lookup = _buildFieldLookup();
  const mappings = state.data.mappings || (state.data.mappings = []);
  const existingSet = new Set(mappings.map(m => m.from + '|' + m.to));

  recordChange();

  const tagCat = ensureTagCatalog();
  const tfCat = ensureTransformCatalog();
  const attrCat = ensureCustomAttributeCatalog();

  let addedCount = 0;

  for(const item of parsed.items){
    const srcRes = _resolveFieldRef(item.source, lookup);
    const tgtRes = _resolveFieldRef(item.target, lookup);
    if(!srcRes.id || !tgtRes.id) continue;

    const key = srcRes.id + '|' + tgtRes.id;
    if(existingSet.has(key)) continue;

    const mapping = {
      from: srcRes.id,
      to: tgtRes.id,
      cardinality: item.cardinality || '',
      transforms: [],
      label: item.label || '',
      note: item.note || '',
      default: item.default || '',
      tags: [],
      customAttributes: {},
      direction: (item.direction && ['forward','both','none'].includes(item.direction)) ? item.direction : 'forward'
    };

    // Resolve tags
    if(item.tag){
      const tagIds = item.tag.split(/[,;]/).map(t => t.trim().toLowerCase()).filter(Boolean);
      const matched = tagIds.map(t => {
        const found = tagCat.find(tc => tc.id === t || (tc.label||'').toLowerCase() === t);
        return found ? found.id : null;
      }).filter(Boolean);
      if(matched.length) mapping.tags = matched;
    }

    // Resolve transforms (comma-separated names/IDs)
    if(item.transform){
      const tfNames = item.transform.split(/[,;]/).map(t => t.trim()).filter(Boolean);
      for(const tn of tfNames){
        const tf = tfCat.find(t => t.id === tn || (t.label||'').toLowerCase() === tn.toLowerCase());
        if(tf) mapping.transforms.push({ ref: tf.id });
      }
    }

    // Resolve extra columns as custom attributes
    if(item._extra){
      for(const [colName, rawVal] of Object.entries(item._extra)){
        if(!rawVal) continue;
        const colLower = colName.toLowerCase().replace(/\s/g, '_');
        let attr = attrCat.find(a =>
          (a.id||'').toLowerCase() === colLower || (a.label||'').toLowerCase() === colName.toLowerCase()
        );
        if(!attr){
          const attrLabel = colName.replace(/_/g,' ');
          const eIds = new Set(attrCat.map(a=>a.id));
          attr = { id: ensureUniqueId(idPartFromLabel(colName, {lower:true}), eIds), label: attrLabel, abbr: attrLabel.substring(0,2).toUpperCase(), _autoId: true, values: [], priority: attrCat.length + 1 };
          attrCat.push(attr);
        }
        if(!attr.values) attr.values = [];
        const valStr = rawVal.trim();
        let val = attr.values.find(v =>
          (v.id||'').toLowerCase() === valStr.toLowerCase() ||
          (v.label||'').toLowerCase() === valStr.toLowerCase()
        );
        if(!val){
          const eIds = new Set(attr.values.map(v=>v.id));
          val = { id: ensureUniqueId(idPartFromLabel(valStr, {lower:true}) || 'val', eIds), label: valStr, abbr: valStr.substring(0,3).toUpperCase(), _autoId: true, priority: attr.values.length + 1 };
          attr.values.push(val);
        }
        mapping.customAttributes[attr.id] = attr.multi ? [val.id] : val.id;
      }
    }

    mappings.push(mapping);
    existingSet.add(key);
    addedCount++;
  }

  closeImportMappings();
  renderAll();
  setGlobalStatus(`Imported ${addedCount} mapping${addedCount!==1?'s':''}.`);
}

document.getElementById('importMappingsBtn')?.addEventListener('click', ()=>{ closeAllPopovers(); openImportMappings(); });
document.getElementById('importMappingsClose')?.addEventListener('click', closeImportMappings);
document.getElementById('importMappingsMask')?.addEventListener('click', closeImportMappings);
document.getElementById('importMappingsCommit')?.addEventListener('click', _commitImportMappings);
document.getElementById('importMappingsModal')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); closeImportMappings(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    const btn = document.getElementById('importMappingsCommit');
    if(btn && !btn.disabled) _commitImportMappings();
  }
});

// 
// Import catalog items (tags, attributes, transforms)
// 
let __importCatalogType = null; // 'tag' | 'attribute' | 'transform'

// 
// Built-in catalog presets
// 
const CATALOG_PRESETS = {
  database: {
    label: ' Database',
    description: 'SQL / relational database modeling',
    tag: [
      { label:'Active', emoji:'', color:'#22c55e', note:'Field is live in production' },
      { label:'Deprecated', emoji:'', color:'#f59e0b', note:'Scheduled for removal' },
      { label:'PII', emoji:'', color:'#ef4444', note:'Personally identifiable information' },
      { label:'Required', emoji:'', color:'#3b82f6', note:'Non-nullable, must be populated' },
      { label:'Primary Key', emoji:'', color:'#a855f7', note:'Table primary key' },
      { label:'Foreign Key', emoji:'', color:'#6366f1', note:'References another table' }
    ],
    attribute: [
      { label:'Data Type', values:'String;Integer;Decimal;Boolean;Date;Timestamp;Text;Blob', note:'SQL column data type' },
      { label:'Length', values:'32;64;128;255;1000;MAX', note:'Column length/size' },
      { label:'Nullable', values:'Yes;No', note:'Whether NULL values are allowed' },
      { label:'Default Value', values:'NULL;0;EMPTY;CURRENT_TIMESTAMP;GETDATE()', note:'Default column value' },
      { label:'Index', values:'None;Primary;Unique;Clustered;Non-clustered', note:'Index type' }
    ],
    transform: [
      { label:'Trim', emoji:'', note:'Remove leading/trailing whitespace' },
      { label:'Uppercase', emoji:'', note:'Convert to upper case' },
      { label:'Lowercase', note:'Convert to lower case' },
      { label:'Cast', emoji:'', note:'Change data type' },
      { label:'Coalesce', note:'First non-null value' },
      { label:'Concatenate', note:'Join multiple fields' },
      { label:'Substring', note:'Extract part of a string' },
      { label:'Replace', note:'Find and replace text' },
      { label:'NullIf', note:'Return NULL if value matches' },
      { label:'Default', note:'Apply default when NULL' },
      { label:'Lookup', emoji:'', note:'Reference/lookup table join' }
    ]
  },
  api: {
    label: ' API / JSON',
    description: 'REST API & JSON schema modeling',
    tag: [
      { label:'Required', emoji:'', color:'#ef4444', note:'Mandatory field' },
      { label:'Optional', emoji:'', color:'#94a3b8', note:'Can be omitted' },
      { label:'Deprecated', emoji:'', color:'#f59e0b', note:'Will be removed in future version' },
      { label:'Read Only', emoji:'', color:'#3b82f6', note:'Output only, not accepted in input' },
      { label:'Write Only', emoji:'', color:'#8b5cf6', note:'Input only, not included in output' }
    ],
    attribute: [
      { label:'Data Type', values:'String;Number;Integer;Boolean;Array;Object;Null', note:'JSON schema type' },
      { label:'Format', values:'email;uri;date;date-time;time;uuid;hostname;ipv4;ipv6;byte;binary', note:'String format specifier' },
      { label:'Constraints', values:'minLength;maxLength;minimum;maximum;pattern;enum;uniqueItems', note:'Validation constraint', type:'multi' },
      { label:'Example', values:'', note:'Example value for documentation' }
    ],
    transform: [
      { label:'Serialize', note:'Convert to JSON/XML string' },
      { label:'Deserialize', note:'Parse from JSON/XML string' },
      { label:'Validate', emoji:'', note:'Apply validation rules' },
      { label:'Map fields', emoji:'', note:'Rename or restructure keys' },
      { label:'Flatten', note:'Flatten nested structure' },
      { label:'Nest', note:'Create nested structure' },
      { label:'Wrap in array', note:'Wrap value in array' },
      { label:'Unwrap array', note:'Extract single value from array' },
      { label:'Filter', note:'Filter array items by condition' },
      { label:'Default', note:'Apply default when missing' }
    ]
  },
  governance: {
    label: ' Data Governance',
    description: 'Data classification, privacy & compliance',
    tag: [
      { label:'PII', emoji:'', color:'#ef4444', note:'Personally identifiable information' },
      { label:'PHI', emoji:'', color:'#f97316', note:'Protected health information' },
      { label:'PCI', emoji:'', color:'#dc2626', note:'Payment card industry data' },
      { label:'GDPR', emoji:'', color:'#6366f1', note:'Subject to GDPR regulation' },
      { label:'Public', emoji:'', color:'#22c55e', note:'Can be shared externally' },
      { label:'Internal', emoji:'', color:'#3b82f6', note:'Internal use only' },
      { label:'Classified', emoji:'', color:'#a855f7', note:'Restricted access' }
    ],
    attribute: [
      { label:'Sensitivity', values:'Public;Internal;Confidential;Restricted', note:'Data classification level' },
      { label:'Retention', values:'30 days;90 days;1 year;3 years;7 years;Indefinite', note:'Data retention period' },
      { label:'Data Domain', values:'Customer;Product;Financial;Operational;HR;Legal', note:'Business data domain' },
      { label:'Data Owner', values:'', note:'Accountable person or team' },
      { label:'Legal Basis', values:'Consent;Contract;Legal obligation;Vital interest;Public interest;Legitimate interest', note:'GDPR processing basis' }
    ],
    transform: [
      { label:'Mask', emoji:'', note:'Mask sensitive characters (e.g. ****)' },
      { label:'Hash', emoji:'#', note:'One-way hash (SHA-256, MD5)' },
      { label:'Encrypt', emoji:'', note:'Reversible encryption' },
      { label:'Redact', emoji:'', note:'Remove sensitive data entirely' },
      { label:'Tokenize', note:'Replace with secure token' },
      { label:'Anonymize', note:'Remove identifying information' },
      { label:'Pseudonymize', note:'Replace with consistent alias' },
      { label:'Truncate', note:'Shorten to reduce specificity' }
    ]
  },
  etl: {
    label: ' ETL / Integration',
    description: 'Extract-Transform-Load pipelines',
    tag: [
      { label:'Source', emoji:'', color:'#3b82f6', note:'Data source system' },
      { label:'Target', emoji:'', color:'#22c55e', note:'Destination system' },
      { label:'Staging', emoji:'', color:'#f59e0b', note:'Intermediate staging area' },
      { label:'Lookup', emoji:'', color:'#8b5cf6', note:'Reference/dimension table' },
      { label:'Derived', emoji:'', color:'#06b6d4', note:'Calculated/computed field' },
      { label:'Reject', emoji:'', color:'#ef4444', note:'Rejected/error records' }
    ],
    attribute: [
      { label:'Load Strategy', values:'Full;Incremental;Delta;CDC;Append;Merge', note:'Data loading method' },
      { label:'Frequency', values:'Realtime;Hourly;Daily;Weekly;Monthly;On-demand', note:'Refresh frequency' },
      { label:'SCD Type', values:'Type 0;Type 1;Type 2;Type 3;Type 6', note:'Slowly changing dimension strategy' },
      { label:'Source System', values:'', note:'Origin system name' },
      { label:'Business Rule', values:'', note:'Applied business rule' }
    ],
    transform: [
      { label:'Trim', emoji:'', note:'Remove whitespace' },
      { label:'Cast', emoji:'', note:'Change data type' },
      { label:'Coalesce', note:'First non-null value' },
      { label:'Default', note:'Apply default when NULL' },
      { label:'Concatenate', note:'Join multiple fields' },
      { label:'Replace', note:'Find and replace text' },
      { label:'Lookup', emoji:'', note:'Reference table lookup' },
      { label:'Pivot', note:'Rows to columns' },
      { label:'Unpivot', note:'Columns to rows' },
      { label:'Aggregate', note:'SUM, COUNT, AVG, MIN, MAX' },
      { label:'Deduplicate', note:'Remove duplicate records' },
      { label:'Filter', note:'Include/exclude rows by condition' },
      { label:'Sort', note:'Order by column(s)' },
      { label:'SCD merge', note:'Slowly changing dimension update' }
    ]
  }
};

// Convert a preset's items for a given type into TSV text for the import textarea
function _presetToTSV(presetKey, type){
  const preset = CATALOG_PRESETS[presetKey];
  if(!preset || !preset[type]) return '';
  const items = preset[type];
  if(!items.length) return '';

  if(type === 'tag'){
    const rows = items.map(t =>
      `${t.label}\t${t.color||''}\t${t.emoji||''}\t${t.note||''}`
    );
    return `label\tcolor\temoji\tnote\n${rows.join('\n')}`;
  }
  if(type === 'transform'){
    const rows = items.map(t =>
      `${t.label}\t${t.emoji||''}\t${t.note||''}`
    );
    return `label\temoji\tnote\n${rows.join('\n')}`;
  }
  if(type === 'attribute'){
    const rows = items.map(a =>
      `${a.label}\t${a.type||'single'}\t${a.values||''}\t${a.note||''}`
    );
    return `label\ttype\tvalues\tnote\n${rows.join('\n')}`;
  }
  return '';
}

const CATALOG_IMPORT_CONFIG = {
  tag: {
    title: 'Import tags',
    catalogKey: 'tagCatalog',
    ensureFn: ()=> ensureTagCatalog(),
    placeholder: `Paste tag names  one per line.

Plain lines:
  Active
  Pending
  Retired

Tab-separated (from spreadsheet):
  label\tcolor\temoji\tnote
  Active\t#22c55e\t\tField is live
  Pending\t#f59e0b\t\tStill being defined
  Retired\t#ef4444\t\tNo longer used`,
    tsvHeaders: ['label','id','color','emoji','note','abbr','priority','metaonly','meta_only','meta','tag','tags'],
    buildItem: (parsed, priority) => {
      const item = { id: '', label: parsed.label, _autoId: true, priority };
      if(parsed.id){ item.id = parsed.id; item._autoId = false; }
      if(parsed.color) item.color = parsed.color;
      if(parsed.emoji) item.emoji = parsed.emoji;
      if(parsed.note) item.note = parsed.note;
      if(parsed.abbr) item.abbr = parsed.abbr;
      const metaVal = (parsed.metaonly || parsed.meta_only || parsed.meta || '').toLowerCase();
      if(metaVal === 'true' || metaVal === '1' || metaVal === 'yes' || metaVal === 'x') item.metaOnly = true;
      if(parsed.tag || parsed.tags) item._importTags = (parsed.tag || parsed.tags);
      return item;
    }
  },
  transform: {
    title: 'Import transforms',
    catalogKey: 'transformCatalog',
    ensureFn: ()=> ensureTransformCatalog(),
    placeholder: `Paste transform names  one per line.

Plain lines:
  Trim whitespace
  Uppercase
  Cast to decimal
  Slugify code

Tab-separated (from spreadsheet):
  label\tcolor\tnote
  Trim whitespace\t#22c55e\tRemove leading/trailing spaces
  Uppercase\t\tConvert to upper case
  Cast to decimal\t#8b5cf6\tParse string to decimal`,
    tsvHeaders: ['label','id','color','emoji','note','abbr','tag','tags'],
    buildItem: (parsed, priority) => {
      const item = { id: '', label: parsed.label, _autoId: true };
      if(parsed.id){ item.id = parsed.id; item._autoId = false; }
      if(parsed.color) item.color = parsed.color;
      if(parsed.emoji) item.emoji = parsed.emoji;
      if(parsed.note) item.note = parsed.note;
      if(parsed.abbr) item.abbr = parsed.abbr;
      if(parsed.tag || parsed.tags) item._importTags = (parsed.tag || parsed.tags);
      return item;
    }
  },
  attribute: {
    title: 'Import attributes',
    catalogKey: 'customAttributeCatalog',
    ensureFn: ()=> ensureCustomAttributeCatalog(),
    placeholder: `Paste attribute names  one per line.
Indent lines under an attribute to create its values.

Plain lines:
  Format
      String
      Integer
      Decimal
      Boolean
  Sensitivity
      Public
      Internal
      Confidential

Tab-separated:
  label\ttype\tvalues\tcolor\tnote
  Format\tsingle\tString;Integer;Decimal;Boolean\t\tData type
  Sensitivity\tsingle\tPublic;Internal;Confidential\t#f59e0b\tData classification`,
    tsvHeaders: ['label','id','type','values','color','emoji','note','abbr','displayonnode','tag','tags'],
    buildItem: (parsed, priority) => {
      const item = { id: '', label: parsed.label, _autoId: true, priority, multi: false, values: [] };
      if(parsed.id){ item.id = parsed.id; item._autoId = false; }
      if(parsed.color) item.color = parsed.color;
      if(parsed.emoji) item.emoji = parsed.emoji;
      if(parsed.note) item.note = parsed.note;
      if(parsed.abbr) item.abbr = parsed.abbr;
      if(parsed.type && parsed.type.toLowerCase() === 'multi') item.multi = true;
      if(parsed.displayonnode && ['true','yes','1','on'].includes(parsed.displayonnode.toLowerCase())) item.displayOnNode = true;
      if(parsed.tag || parsed.tags) item._importTags = (parsed.tag || parsed.tags);
      // Values from TSV
      if(parsed.values){
        const vals = parsed.values.split(';').map(v => v.trim()).filter(Boolean);
        item.values = vals.map((v, i) => ({
          id: '', label: v, _autoId: true, priority: i + 1
        }));
      }
      // Values from plain-line children
      if(parsed._children && parsed._children.length){
        item.values = parsed._children.map((c, i) => ({
          id: '', label: c.label, _autoId: true, priority: i + 1
        }));
      }
      return item;
    }
  }
};

function openImportCatalog(type){
  if(!state.editorMode){ customAlert('Switch to Editor mode first.'); return; }
  __importCatalogType = type;
  const config = CATALOG_IMPORT_CONFIG[type];
  if(!config) return;

  document.getElementById('importCatalogTitle').textContent = config.title;
  const body = document.getElementById('importCatalogBody');
  const commitBtn = document.getElementById('importCatalogCommit');
  if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }

  // Build presets bar
  const presetKeys = Object.keys(CATALOG_PRESETS).filter(k => {
    const p = CATALOG_PRESETS[k];
    return p[type] && p[type].length > 0;
  });
  const presetsHtml = presetKeys.length ? `<div style="margin-bottom:10px;display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
    <span style="font-size:11px;opacity:.5;font-weight:600;">Presets:</span>
    ${presetKeys.map(k => {
      const p = CATALOG_PRESETS[k];
      const count = p[type].length;
      return `<button class="btn presetBtn" data-preset="${escapeHtml(k)}" style="font-size:11px;padding:3px 10px;" title="${escapeHtml(p.description)}  ${count} ${type}${count!==1?'s':''}">${p.label}</button>`;
    }).join('')}
  </div>` : '';

  body.innerHTML = `${presetsHtml}
<textarea id="importCatalogText" style="width:100%;min-height:200px;max-height:40vh;font-family:var(--mono);font-size:12px;line-height:1.5;padding:10px 12px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);color:var(--text);resize:vertical;white-space:pre;" placeholder="${escapeHtml(config.placeholder)}"></textarea>
<div id="importCatalogDetected" style="font-size:10px;opacity:.4;margin-top:4px;"></div>
<div id="importCatalogPreview" style="margin-top:12px;"></div>`;

  // Wire preset buttons
  body.querySelectorAll('.presetBtn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const key = btn.dataset.preset;
      const tsv = _presetToTSV(key, type);
      if(!tsv) return;
      const ta = document.getElementById('importCatalogText');
      if(ta){
        // If textarea already has content, ask before replacing
        if(ta.value.trim()){
          if(!await customConfirm('Replace current content with preset?')) return;
        }
        ta.value = tsv;
        _refreshImportCatalogPreview();
        ta.focus();
      }
      // Highlight active preset button
      body.querySelectorAll('.presetBtn').forEach(b => b.style.outline = 'none');
      btn.style.outline = '2px solid rgba(59,130,246,.5)';
    });
  });

  const textarea = body.querySelector('#importCatalogText');
  if(textarea){
    textarea.addEventListener('input', _refreshImportCatalogPreview);
    _wireTabIndent(textarea, _refreshImportCatalogPreview);
    textarea.focus();
  }

  // File upload handler
  const fileInput = document.getElementById('importCatalogFileInput');
  if(fileInput){
    fileInput.value = '';
    fileInput.onchange = (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        const ta = document.getElementById('importCatalogText');
        if(ta){ ta.value = e.target.result; _refreshImportCatalogPreview(); }
      };
      reader.readAsText(f);
      fileInput.value = '';
    };
  }

  document.getElementById('importCatalogMask')?.classList.add('active');
  document.getElementById('importCatalogModal')?.classList.add('active');
}

function closeImportCatalog(){
  __importCatalogType = null;
  document.getElementById('importCatalogMask')?.classList.remove('active');
  document.getElementById('importCatalogModal')?.classList.remove('active');
}
document.getElementById('importCatalogClose')?.addEventListener('click', closeImportCatalog);
document.getElementById('importCatalogMask')?.addEventListener('click', closeImportCatalog);
document.getElementById('importCatalogCommit')?.addEventListener('click', _commitImportCatalog);
document.getElementById('importCatalogModal')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); closeImportCatalog(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    const btn = document.getElementById('importCatalogCommit');
    if(btn && !btn.disabled) _commitImportCatalog();
  }
});

function _parseCatalogImportText(text, type){
  const lines = text.split('\n').filter(l => l.trim());
  if(!lines.length) return { mode:'empty', items:[] };

  const hasTabs = lines[0].includes('\t');
  if(hasTabs) return _parseCatalogTSV(lines, type);
  return _parseCatalogPlainLines(lines, type);
}

function _parseCatalogPlainLines(lines, type){
  if(type === 'attribute'){
    // Attributes: non-indented = attribute, indented = values
    const items = [];
    let currentAttr = null;
    for(const line of lines){
      const match = line.match(/^(\s*)/);
      const indent = match ? match[1].replace(/\t/g, '    ').length : 0;
      const label = line.trim();
      if(indent === 0){
        currentAttr = { label, _children: [] };
        items.push(currentAttr);
      } else if(currentAttr){
        currentAttr._children.push({ label });
      }
    }
    return { mode:'plain', items };
  }
  // Tags / transforms: each line = one item
  return { mode:'plain', items: lines.map(l => ({ label: l.trim() })) };
}

function _parseCatalogTSV(lines, type){
  const headers = lines[0].split('\t').map(h => h.trim().toLowerCase());
  const rows = lines.slice(1).map(l => {
    const cells = l.split('\t');
    const obj = {};
    headers.forEach((h, i) => { obj[h] = (cells[i] || '').trim(); });
    return obj;
  }).filter(r => {
    const labelCol = headers.find(h => ['label','name','tag','transform','attribute'].includes(h)) || headers[0];
    return r[labelCol];
  });

  const labelCol = headers.find(h => ['label','name','tag','transform','attribute'].includes(h)) || headers[0];
  const items = rows.map(r => {
    const item = { label: r[labelCol] || '' };
    for(const h of headers){
      if(h === labelCol) continue;
      if(r[h]) item[h] = r[h];
    }
    return item;
  });

  return { mode:'tsv', items, headers };
}

function _refreshImportCatalogPreview(){
  const type = __importCatalogType;
  if(!type) return;
  const config = CATALOG_IMPORT_CONFIG[type];
  if(!config) return;

  const textarea = document.getElementById('importCatalogText');
  const previewEl = document.getElementById('importCatalogPreview');
  const detectedEl = document.getElementById('importCatalogDetected');
  const commitBtn = document.getElementById('importCatalogCommit');
  if(!textarea || !previewEl) return;

  const parsed = _parseCatalogImportText(textarea.value, type);
  if(parsed.mode === 'empty'){
    previewEl.innerHTML = '';
    detectedEl.textContent = '';
    if(commitBtn){ commitBtn.disabled = true; commitBtn.classList.remove('btnDirty'); }
    return;
  }

  // Check existing  match by id first, then by label
  const existing = config.ensureFn();
  const existingById = {};
  const existingByLabel = {};
  existing.forEach(t => {
    existingById[t.id] = t;
    if(t.label) existingByLabel[t.label.toLowerCase()] = t;
  });

  const findExisting = (item) => {
    if(item.id && existingById[item.id]) return existingById[item.id];
    return existingByLabel[item.label.toLowerCase()] || null;
  };

  detectedEl.textContent = parsed.mode === 'tsv'
    ? `Detected: tab-separated (${parsed.headers.length} columns: ${parsed.headers.join(', ')})`
    : `Detected: plain lines`;

  let newCount = 0, updateCount = 0;
  let html = `<div style="font-size:11px;font-weight:600;opacity:.6;margin-bottom:6px;">Preview: ${parsed.items.length} ${type}${parsed.items.length!==1?'s':''}</div>`;
  html += '<div style="border:1px solid var(--border);border-radius:8px;padding:8px 10px;max-height:240px;overflow-y:auto;font-size:11px;line-height:1.7;">';

  for(const item of parsed.items){
    const ex = findExisting(item);
    let badge = '';
    if(ex){
      // Check if any properties differ
      const hasChanges = ['color','emoji','note','abbr'].some(k => item[k] && item[k] !== ex[k]) ||
        (item.metaOnly !== undefined && item.metaOnly !== ex.metaOnly) ||
        (item.values && type === 'attribute') ||
        (item._children && type === 'attribute');
      if(hasChanges){
        badge = ' <span style="color:rgba(59,130,246,.8);font-size:9px;">will update</span>';
        updateCount++;
      } else {
        badge = ' <span style="opacity:.3;font-size:9px;">exists  no changes</span>';
      }
    } else {
      badge = ' <span style="color:rgba(34,197,94,.7);font-size:9px;">new</span>';
      newCount++;
    }
    const colorDot = item.color ? `<span style="width:8px;height:8px;border-radius:2px;background:${escapeHtml(item.color)};display:inline-block;"></span> ` : '';
    const emoji = item.emoji ? item.emoji + ' ' : '';
    const idBadge = item.id ? ` <span style="opacity:.25;font-size:9px;">${escapeHtml(item.id)}</span>` : '';
    let extras = '';
    if(item.note) extras += ` <span style="opacity:.35;"> ${escapeHtml(item.note.substring(0,40))}</span>`;

    if(type === 'attribute'){
      const valCount = item._children ? item._children.length : (item.values ? item.values.split(';').filter(Boolean).length : 0);
      const multiLabel = item.type === 'multi' ? ' <span style="opacity:.3;font-size:9px;">multi</span>' : '';
      html += `<div>${colorDot}${emoji}<b>${escapeHtml(item.label)}</b>${idBadge}${multiLabel}${extras}${badge}</div>`;
      if(item._children){
        for(const ch of item._children){
          html += `<div style="padding-left:16px;opacity:.6;"> ${escapeHtml(ch.label)}</div>`;
        }
      } else if(item.values){
        const vals = item.values.split(';').map(v => v.trim()).filter(Boolean);
        for(const v of vals){
          html += `<div style="padding-left:16px;opacity:.6;"> ${escapeHtml(v)}</div>`;
        }
      }
    } else {
      const metaBadge = (type === 'tag' && item.metaOnly) ? ' <span style="font-size:8px;padding:0 4px;border-radius:3px;background:rgba(139,92,246,.15);color:rgba(139,92,246,.85);font-weight:600;">META</span>' : '';
      html += `<div>${colorDot}${emoji}<b>${escapeHtml(item.label)}</b>${idBadge}${metaBadge}${extras}${badge}</div>`;
    }
  }
  html += '</div>';

  // Summary line
  const summParts = [];
  if(newCount) summParts.push(`${newCount} new`);
  if(updateCount) summParts.push(`${updateCount} to update`);
  const unchangedCount = parsed.items.length - newCount - updateCount;
  if(unchangedCount) summParts.push(`${unchangedCount} unchanged`);
  if(summParts.length) html += `<div style="font-size:10px;opacity:.4;margin-top:6px;">${summParts.join('  ')}</div>`;

  previewEl.innerHTML = html;

  // Enable commit if any new OR updatable items
  const actionable = newCount + updateCount;
  if(commitBtn){ commitBtn.disabled = actionable === 0; commitBtn.classList.toggle('btnDirty', actionable > 0); }
}

function _commitImportCatalog(){
  const type = __importCatalogType;
  if(!type) return;
  const config = CATALOG_IMPORT_CONFIG[type];
  if(!config) return;

  const textarea = document.getElementById('importCatalogText');
  if(!textarea) return;

  const parsed = _parseCatalogImportText(textarea.value, type);
  if(!parsed.items.length) return;

  recordChange();

  const catalog = config.ensureFn();
  const existingIds = new Set(catalog.map(t => t.id));

  // Build lookup maps for matching
  const byId = {};
  const byLabel = {};
  catalog.forEach(t => {
    byId[t.id] = t;
    if(t.label) byLabel[t.label.toLowerCase()] = t;
  });

  const findExisting = (item) => {
    if(item.id && byId[item.id]) return byId[item.id];
    return byLabel[item.label.toLowerCase()] || null;
  };

  // Determine next priority
  let maxPriority = 0;
  catalog.forEach(t => { if(typeof t.priority === 'number') maxPriority = Math.max(maxPriority, t.priority); });

  let addedCount = 0, updatedCount = 0;

  // Helper to resolve _importTags
  const resolveImportTags = (raw) => {
    if(!raw) return null;
    const tagCat = ensureTagCatalog();
    const tagIds = raw.split(/[,;]/).map(t => t.trim().toLowerCase()).filter(Boolean);
    const matched = tagIds.map(t => {
      const found = tagCat.find(tc => tc.id === t || (tc.label||'').toLowerCase() === t);
      return found ? found.id : null;
    }).filter(Boolean);
    return matched.length ? matched : null;
  };

  for(const parsed_item of parsed.items){
    const ex = findExisting(parsed_item);

    if(ex){
      // Merge into existing item  only overwrite non-empty imported properties
      let changed = false;
      for(const key of ['color','emoji','note','abbr']){
        if(parsed_item[key] && parsed_item[key] !== ex[key]){
          ex[key] = parsed_item[key];
          changed = true;
        }
      }
      if(parsed_item.color && !ex.colorEnabled){ ex.colorEnabled = true; changed = true; }
      if(parsed_item.metaOnly !== undefined && parsed_item.metaOnly !== ex.metaOnly){
        ex.metaOnly = parsed_item.metaOnly;
        changed = true;
      }
      // Resolve and merge tags
      const importedTags = resolveImportTags(parsed_item.tag || parsed_item.tags);
      if(importedTags){
        const existing_tags = ex.tags || [];
        const merged = [...new Set([...existing_tags, ...importedTags])];
        if(merged.length !== existing_tags.length){ ex.tags = merged; changed = true; }
      }
      // For attributes: merge values (add new, don't remove existing)
      if(type === 'attribute'){
        const newValues = [];
        if(parsed_item.values){
          newValues.push(...parsed_item.values.split(';').map(v => v.trim()).filter(Boolean));
        }
        if(parsed_item._children){
          newValues.push(...parsed_item._children.map(c => c.label));
        }
        if(newValues.length){
          if(!ex.values) ex.values = [];
          const existingValLabels = new Set(ex.values.map(v => (v.label||'').toLowerCase()));
          const existingValIds = new Set(ex.values.map(v => v.id));
          for(const vLabel of newValues){
            if(existingValLabels.has(vLabel.toLowerCase())) continue;
            const vs = idPartFromLabel(vLabel, {lower:true}) || 'val';
            const vid = ensureUniqueId(vs, existingValIds);
            existingValIds.add(vid);
            ex.values.push({ id: vid, label: vLabel, _autoId: true, abbr: vLabel.substring(0,3).toUpperCase(), priority: ex.values.length + 1 });
            changed = true;
          }
        }
        if(parsed_item.type && parsed_item.type.toLowerCase() === 'multi' && !ex.multi){ ex.multi = true; changed = true; }
        if(parsed_item.displayonnode && ['true','yes','1','on'].includes(parsed_item.displayonnode.toLowerCase()) && !ex.displayOnNode){ ex.displayOnNode = true; changed = true; }
      }
      if(changed) updatedCount++;
    } else {
      // New item  create
      maxPriority++;
      const item = config.buildItem(parsed_item, maxPriority);

      // Use custom ID if provided, otherwise generate
      if(item.id && item.id !== '' && !item._autoId){
        // User-supplied ID  ensure unique
        if(existingIds.has(item.id)){
          item.id = ensureUniqueId(item.id, existingIds);
        }
      } else {
        const slug = idPartFromLabel(item.label, {lower:true}) || type;
        item.id = ensureUniqueId(slug, existingIds);
      }
      existingIds.add(item.id);
      byId[item.id] = item;
      byLabel[item.label.toLowerCase()] = item;

      // Generate abbreviation
      if(!item.abbr){
        item.abbr = item.label.substring(0, 2).toUpperCase();
      }

      // For attributes, generate value IDs
      if(item.values && item.values.length){
        const valIds = new Set();
        for(const v of item.values){
          const vs = idPartFromLabel(v.label, {lower:true}) || 'val';
          v.id = ensureUniqueId(vs, valIds);
          valIds.add(v.id);
          if(!v.abbr) v.abbr = v.label.substring(0, 3).toUpperCase();
        }
      }

      // Resolve _importTags to tag IDs
      if(item._importTags){
        const matched = resolveImportTags(item._importTags);
        if(matched) item.tags = matched;
        delete item._importTags;
      }

      catalog.push(item);
      addedCount++;
    }
  }

  closeImportCatalog();

  // Re-render the relevant catalog if open
  if(type === 'tag'){
    if(document.getElementById('tagsModal')?.classList.contains('active')) renderTagsManager();
  } else if(type === 'transform'){
    if(document.getElementById('transformsModal')?.classList.contains('active')) renderTransformsManager();
  } else if(type === 'attribute'){
    if(document.getElementById('customAttrsModal')?.classList.contains('active')) renderCustomAttrsManager();
  }

  renderAll();
  const parts = [];
  if(addedCount) parts.push(`${addedCount} added`);
  if(updatedCount) parts.push(`${updatedCount} updated`);
  setGlobalStatus(`Import ${type}s: ${parts.join(', ')}.`);
}

// Catalog import toolbar & modal button handlers
document.getElementById('importCatTagsBtn')?.addEventListener('click', ()=>{ closeAllPopovers(); openImportCatalog('tag'); });
document.getElementById('importCatAttrsBtn')?.addEventListener('click', ()=>{ closeAllPopovers(); openImportCatalog('attribute'); });
document.getElementById('importCatTfBtn')?.addEventListener('click', ()=>{ closeAllPopovers(); openImportCatalog('transform'); });
document.getElementById('importTagsBtn')?.addEventListener('click', ()=>{ openImportCatalog('tag'); });
document.getElementById('importTransformsBtn')?.addEventListener('click', ()=>{ openImportCatalog('transform'); });
document.getElementById('importAttrsBtn')?.addEventListener('click', ()=>{ openImportCatalog('attribute'); });

// end import catalog

// 
// Preset bundle modal
// 
let __selectedPreset = null;

function openPresetBundle(){
  if(!state.editorMode){ customAlert('Switch to Editor mode first.'); return; }
  __selectedPreset = null;
  const body = document.getElementById('presetBundleBody');
  const applyBtn = document.getElementById('presetBundleApply');
  if(applyBtn){ applyBtn.disabled = true; applyBtn.classList.remove('btnDirty'); }

  let html = '<div style="font-size:12px;opacity:.5;margin-bottom:12px;">Select a domain preset to populate tags, attributes & transforms. Existing items are preserved  only new items are added.</div>';
  html += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">';

  for(const [key, preset] of Object.entries(CATALOG_PRESETS)){
    const tagCount = preset.tag ? preset.tag.length : 0;
    const attrCount = preset.attribute ? preset.attribute.length : 0;
    const tfCount = preset.transform ? preset.transform.length : 0;
    html += `<button class="btn presetCard" data-preset="${escapeHtml(key)}" style="display:flex;flex-direction:column;align-items:flex-start;padding:12px 14px;border:2px solid var(--border);border-radius:10px;text-align:left;cursor:pointer;transition:border-color .15s;">
      <div style="font-size:14px;font-weight:700;margin-bottom:2px;">${preset.label}</div>
      <div style="font-size:11px;opacity:.5;margin-bottom:6px;">${escapeHtml(preset.description)}</div>
      <div style="font-size:10px;opacity:.35;">${tagCount} tags  ${attrCount} attributes  ${tfCount} transforms</div>
    </button>`;
  }
  html += '</div>';
  html += '<div id="presetBundlePreview" style="margin-top:14px;"></div>';

  body.innerHTML = html;

  // Wire card clicks
  body.querySelectorAll('.presetCard').forEach(card => {
    card.addEventListener('click', () => {
      __selectedPreset = card.dataset.preset;
      body.querySelectorAll('.presetCard').forEach(c => { c.style.borderColor = 'var(--border)'; c.style.background = 'transparent'; });
      card.style.borderColor = 'rgba(59,130,246,.6)';
      card.style.background = 'rgba(59,130,246,.05)';
      _renderPresetBundlePreview();
      if(applyBtn){ applyBtn.disabled = false; applyBtn.classList.add('btnDirty'); }
    });
  });

  document.getElementById('presetBundleMask')?.classList.add('active');
  document.getElementById('presetBundleModal')?.classList.add('active');
}

function _renderPresetBundlePreview(){
  const el = document.getElementById('presetBundlePreview');
  if(!el || !__selectedPreset) return;
  const preset = CATALOG_PRESETS[__selectedPreset];
  if(!preset){ el.innerHTML = ''; return; }

  const tagCat = ensureTagCatalog();
  const attrCat = ensureCustomAttributeCatalog();
  const tfCat = ensureTransformCatalog();
  const tagLabels = new Set(tagCat.map(t => (t.label||'').toLowerCase()));
  const attrLabels = new Set(attrCat.map(a => (a.label||'').toLowerCase()));
  const tfLabels = new Set(tfCat.map(t => (t.label||'').toLowerCase()));

  const sections = [
    { title:'Tags', items: preset.tag || [], existing: tagLabels, renderItem: t => {
      const dup = existing => existing.has(t.label.toLowerCase());
      const colorDot = t.color ? `<span style="width:8px;height:8px;border-radius:2px;background:${escapeHtml(t.color)};display:inline-block;margin-right:3px;"></span>` : '';
      const emoji = t.emoji ? t.emoji + ' ' : '';
      const dupBadge = tagLabels.has(t.label.toLowerCase()) ? ' <span style="color:rgba(239,130,130,.7);font-size:9px;">exists</span>' : ' <span style="color:rgba(34,197,94,.7);font-size:9px;">new</span>';
      return `<div style="padding:1px 0;">${colorDot}${emoji}${escapeHtml(t.label)}${dupBadge}</div>`;
    }},
    { title:'Attributes', items: preset.attribute || [], existing: attrLabels, renderItem: a => {
      const dupBadge = attrLabels.has(a.label.toLowerCase()) ? ' <span style="color:rgba(239,130,130,.7);font-size:9px;">exists</span>' : ' <span style="color:rgba(34,197,94,.7);font-size:9px;">new</span>';
      const vals = a.values ? a.values.split(';').filter(Boolean) : [];
      const valStr = vals.length ? ` <span style="opacity:.35;">(${vals.join(', ')})</span>` : '';
      return `<div style="padding:1px 0;">${escapeHtml(a.label)}${valStr}${dupBadge}</div>`;
    }},
    { title:'Transforms', items: preset.transform || [], existing: tfLabels, renderItem: t => {
      const dupBadge = tfLabels.has(t.label.toLowerCase()) ? ' <span style="color:rgba(239,130,130,.7);font-size:9px;">exists</span>' : ' <span style="color:rgba(34,197,94,.7);font-size:9px;">new</span>';
      const emoji = t.emoji ? t.emoji + ' ' : '';
      return `<div style="padding:1px 0;">${emoji}${escapeHtml(t.label)}${dupBadge}</div>`;
    }}
  ];

  let html = '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;border:1px solid var(--border);border-radius:8px;padding:10px 12px;font-size:11px;line-height:1.6;max-height:220px;overflow-y:auto;">';
  for(const sec of sections){
    const newCount = sec.items.filter(i => !sec.existing.has(i.label.toLowerCase())).length;
    html += `<div><div style="font-weight:700;opacity:.6;margin-bottom:4px;">${sec.title} <span style="font-weight:400;opacity:.5;">(${newCount} new)</span></div>`;
    html += sec.items.map(i => sec.renderItem(i)).join('');
    html += '</div>';
  }
  html += '</div>';
  el.innerHTML = html;
}

function closePresetBundle(){
  __selectedPreset = null;
  document.getElementById('presetBundleMask')?.classList.remove('active');
  document.getElementById('presetBundleModal')?.classList.remove('active');
}

function _applyPresetBundle(){
  if(!__selectedPreset) return;
  const preset = CATALOG_PRESETS[__selectedPreset];
  if(!preset) return;

  recordChange();
  let totalAdded = 0;

  // Helper: add items to a catalog, skip duplicates by label
  const addItems = (catalog, items, buildFn) => {
    const existingLabels = new Set(catalog.map(t => (t.label||'').toLowerCase()));
    const existingIds = new Set(catalog.map(t => t.id));
    let maxP = 0;
    catalog.forEach(t => { if(typeof t.priority === 'number') maxP = Math.max(maxP, t.priority); });
    let added = 0;
    for(const raw of items){
      if(existingLabels.has(raw.label.toLowerCase())) continue;
      maxP++;
      const item = buildFn(raw, maxP);
      const slug = idPartFromLabel(item.label, {lower:true}) || 'item';
      item.id = ensureUniqueId(slug, existingIds);
      existingIds.add(item.id);
      existingLabels.add(item.label.toLowerCase());
      if(!item.abbr) item.abbr = item.label.substring(0, 2).toUpperCase();
      // For attributes, generate value IDs
      if(item.values && item.values.length){
        const valIds = new Set();
        for(const v of item.values){
          const vs = idPartFromLabel(v.label, {lower:true}) || 'val';
          v.id = ensureUniqueId(vs, valIds);
          valIds.add(v.id);
          if(!v.abbr) v.abbr = v.label.substring(0, 3).toUpperCase();
        }
      }
      catalog.push(item);
      added++;
    }
    return added;
  };

  // Tags
  if(preset.tag && preset.tag.length){
    const tagCat = ensureTagCatalog();
    totalAdded += addItems(tagCat, preset.tag, (raw, priority) => {
      const item = { id: '', label: raw.label, priority, _autoId: true };
      if(raw.color){ item.color = raw.color; item.colorEnabled = true; }
      if(raw.emoji) item.emoji = raw.emoji;
      if(raw.note) item.note = raw.note;
      return item;
    });
  }

  // Attributes
  if(preset.attribute && preset.attribute.length){
    const attrCat = ensureCustomAttributeCatalog();
    totalAdded += addItems(attrCat, preset.attribute, (raw, priority) => {
      const item = { id: '', label: raw.label, priority, _autoId: true, multi: (raw.type === 'multi'), values: [] };
      if(raw.note) item.note = raw.note;
      if(raw.values){
        const vals = raw.values.split(';').map(v => v.trim()).filter(Boolean);
        item.values = vals.map((v, i) => ({
          id: '', label: v, _autoId: true, priority: i + 1
        }));
      }
      return item;
    });
  }

  // Transforms
  if(preset.transform && preset.transform.length){
    const tfCat = ensureTransformCatalog();
    totalAdded += addItems(tfCat, preset.transform, (raw, priority) => {
      const item = { id: '', label: raw.label, _autoId: true };
      if(raw.emoji) item.emoji = raw.emoji;
      if(raw.note) item.note = raw.note;
      return item;
    });
  }

  const presetLabel = preset.label || __selectedPreset;
  closePresetBundle();

  // Re-render any open catalog modals
  if(document.getElementById('tagsModal')?.classList.contains('active')) renderTagsManager();
  if(document.getElementById('customAttrsModal')?.classList.contains('active')) renderCustomAttrsManager();
  if(document.getElementById('transformsModal')?.classList.contains('active')) renderTransformsManager();

  renderAll();
  setGlobalStatus(`Applied "${presetLabel}" preset  ${totalAdded} new item${totalAdded!==1?'s':''} added.`);
}

document.getElementById('presetBundleBtn')?.addEventListener('click', ()=>{ closeAllPopovers(); openPresetBundle(); });
document.getElementById('presetBundleClose')?.addEventListener('click', closePresetBundle);
document.getElementById('presetBundleMask')?.addEventListener('click', closePresetBundle);
document.getElementById('presetBundleApply')?.addEventListener('click', _applyPresetBundle);
document.getElementById('presetBundleModal')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); closePresetBundle(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    e.preventDefault();
    const btn = document.getElementById('presetBundleApply');
    if(btn && !btn.disabled) _applyPresetBundle();
  }
});
function openTags(){
  ensureTagCatalog();
  catalogEditEnd();
  renderTagsManager();
  if(addTagBtn) addTagBtn.style.display = state.editorMode ? '' : 'none';
  { const b=document.getElementById('importTagsBtn'); if(b) b.style.display = state.editorMode ? '' : 'none'; }
  tagsMask?.classList.add('active');
  tagsModal?.classList.add('active');
}
async function closeTags(){
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  tagsMask?.classList.remove('active');
  tagsModal?.classList.remove('active');
}
if(tagsBtn) tagsBtn.addEventListener('click', openTags);
const transformsBtn = document.getElementById('transformsBtn');
const customAttrsBtn = document.getElementById('customAttrsBtn');
if(transformsBtn) transformsBtn.addEventListener('click', openTransforms);
if(customAttrsBtn) customAttrsBtn.addEventListener('click', openCustomAttrs);
if(closeCustomAttrsBtn) closeCustomAttrsBtn.addEventListener('click', closeCustomAttrs);
if(customAttrsMask) customAttrsMask.addEventListener('click', closeCustomAttrs);
if(addCustomAttrBtn) addCustomAttrBtn.addEventListener('click', async ()=>{
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  const cat = ensureCustomAttributeCatalog();
  normalizeCatalogMultiFlag();
  let maxP = 0;
  cat.forEach(a=>{ if(a && typeof a.priority==='number' && a.priority > maxP) maxP = a.priority; });
  const blank = { id: 'attr_' + Date.now().toString(36), label: '', abbr: '', note: '', multi: false, displayOnNode: false, priority: maxP + 1, values: [] };
  cat.push(blank);
  const idx = cat.length - 1;
  catalogEditBegin('attr', idx, blank, true);
  renderCustomAttrsManager();
});

if(closeTagsBtn) closeTagsBtn.addEventListener('click', closeTags);
const closeTransformsBtn = document.getElementById('closeTransformsBtn');
if(closeTransformsBtn) closeTransformsBtn.addEventListener('click', closeTransforms);
if(tagsMask) tagsMask.addEventListener('click', closeTags);
const transformsMask = document.getElementById('transformsMask');
if(transformsMask) transformsMask.addEventListener('click', closeTransforms);
if(addTagBtn) addTagBtn.addEventListener('click', async ()=>{
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  const cat = ensureTagCatalog();
  const minPri = cat.reduce((m,t)=>Math.min(m, typeof t.priority==='number'?t.priority:0), 0);
  const blank = { id: 'tag_' + Date.now().toString(36), label: '', abbr: '', note: '', color: TAG_COLOR_PRESETS[0].value, priority: minPri - 1 };
  cat.push(blank);
  const idx = cat.length - 1;
  catalogEditBegin('tag', idx, blank, true);
  renderTagsManager();
});
if(addTransformBtn) addTransformBtn.addEventListener('click', async ()=>{
  if(!await guardCatalogAbandon()) return;
  catalogEditEnd();
  const cat = ensureTransformCatalog();
  const blank = { id: 'transform_' + Date.now().toString(36), label: '', abbr: '', note: '' };
  cat.unshift(blank);
  catalogEditBegin('transform', 0, blank, true);
  renderTransformsManager();
});
function closeHelp(){
  helpMask.classList.remove('active');
  helpModal.classList.remove('active');
}
if(helpBtn) helpBtn.addEventListener('click', openHelp);
if(closeHelpBtn) closeHelpBtn.addEventListener('click', closeHelp);
if(helpMask) helpMask.addEventListener('click', closeHelp);



if(expandAllBtn) expandAllBtn.addEventListener("click", () => setAllGroupsCollapsed(false));
if(collapseAllBtn) collapseAllBtn.addEventListener("click", () => setAllGroupsCollapsed(true));

if(clearSelectionBtn) clearSelectionBtn.addEventListener("click", () => {
  if(state.editorMode && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node') {
    cancelEditAndDeselect();
    return;
  }
  state.lockedId = null;
  state.hoverId = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.multiSelection.clear();
  applyHighlight();
});

const clearSelBtn = document.getElementById('clearSelBtn');
if(clearSelBtn) clearSelBtn.addEventListener('click', () => {
  if(clearSelectionBtn) clearSelectionBtn.click();
});

function selectAllNodes(){
  state.multiSelection.clear();
  for(const [nid,el] of IDX.elementById.entries()){
    if(!el.classList.contains('hidden') && IDX.rowById.get(nid)?.offsetParent) state.multiSelection.add(nid);
  }
  state.lockedId = null; state.hoverId = null;
  state.selectedEdgeId = null; state.hoverEdgeId = null;
  applyHighlight();
}
function invertSelection(){
  const cur = new Set(state.multiSelection);
  if(cur.size === 0 && state.lockedId) cur.add(state.lockedId);
  state.multiSelection.clear();
  for(const [nid,el] of IDX.elementById.entries()){
    if(!el.classList.contains('hidden') && IDX.rowById.get(nid)?.offsetParent && !cur.has(nid)) state.multiSelection.add(nid);
  }
  state.lockedId = null; state.hoverId = null;
  state.selectedEdgeId = null; state.hoverEdgeId = null;
  applyHighlight();
}
{ const b = document.getElementById('selectAllBtn'); if(b) b.addEventListener('click', selectAllNodes); }
{ const b = document.getElementById('invertSelectionBtn'); if(b) b.addEventListener('click', invertSelection); }

if(loadExampleBtn) loadExampleBtn.addEventListener("click", async () => {
  const sure = await customConfirm('Load the example project?\n\nAny unsaved changes to the current project will be lost.\nMake sure you\u2019ve saved your work first.');
  if(!sure) { setGlobalStatus('Load example cancelled.'); return; }
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.lockedId = null;
  state.hoverId = null;
  state.multiSelection.clear();
  // Clear any in-flight edit sessions
  __editSnapshot = null;
  __edgeEditSession = null;
  state.data = JSON.parse(JSON.stringify(EXAMPLE_JSON));
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  clearUndoHistory();
  renderAll();
  markClean();
  setGlobalStatus('Loaded example project.');
});
if(newMappingBtn) newMappingBtn.addEventListener('click', startNewMapping);

// Dirty state helpers
function markDirty(){
  state.isDirty = true;
  updateSaveButtonStyle();
}

// Combined function: save undo snapshot AND mark dirty
// Call this BEFORE making the change
function recordChange(){
  pushUndo();
  markDirty();
}

function markClean(){
  try { state.__cleanDataJSON = JSON.stringify(state.data); } catch(e) { state.__cleanDataJSON = null; }
  state.isDirty = false;
  updateSaveButtonStyle();
}

function checkDirtyState(){
  if(!state.__cleanDataJSON){ markDirty(); return; }
  try {
    state.isDirty = (JSON.stringify(state.data) !== state.__cleanDataJSON);
  } catch(e) { state.isDirty = true; }
  updateSaveButtonStyle();
}

function updateSaveButtonStyle(){
  if(!saveProjectBtn) return;
  if(state.isDirty){
    saveProjectBtn.classList.add('dirty');
    saveProjectBtn.title = 'Save project (unsaved changes)';
  } else {
    saveProjectBtn.classList.remove('dirty');
    saveProjectBtn.title = 'Download the current project as JSON';
  }
}

// Undo/Redo system
function deepCloneData(data){
  try {
    return JSON.parse(JSON.stringify(data));
  } catch(e) {
    console.error('Failed to clone data:', e);
    return data;
  }
}

function pushUndo(){
  if(!state.data) return;
  
  // Clone current state before it changes
  const snapshot = {
    data: deepCloneData(state.data),
    selection: {
      lockedId: state.lockedId,
      selectedEdgeId: state.selectedEdgeId,
      selectedColumnId: state.selectedColumnId,
      multiSelection: state.multiSelection.size > 0 ? [...state.multiSelection] : null
    }
  };
  
  // Add to undo stack
  state.undoStack.push(snapshot);
  
  // Limit stack size
  if(state.undoStack.length > state.maxUndoSteps){
    state.undoStack.shift();
  }
  
  // Clear redo stack when new action is taken
  state.redoStack = [];
  
  updateUndoRedoButtons();
}

// Save post-action selection into the most recent undo snapshot.
// Called after an action changes the selection (e.g. multi-move updates IDs).
// This lets redo restore the correct post-action selection even if the user
// manually clears the selection before pressing undo.
function savePostSelection(){
  if(state.undoStack.length === 0) return;
  const top = state.undoStack[state.undoStack.length - 1];
  top.postSelection = {
    lockedId: state.lockedId,
    selectedEdgeId: state.selectedEdgeId,
    selectedColumnId: state.selectedColumnId,
    multiSelection: state.multiSelection.size > 0 ? [...state.multiSelection] : null
  };
}

async function undo(){
  if(state.undoStack.length === 0){
    setViewerStatus('Nothing to undo');
    return;
  }
  // Guard unsaved edits
  if(nodeEditIsDirty()){
    if(!await guardNodeAbandon()) return;
    revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
  }
  if(edgeEditIsDirty()){
    if(!await guardAbandonEdit('mapping', __edgeEditSession?.edgeId || '')) return;
  }
  // Discard any active edit sessions (undo replaces state.data entirely)
  __editSnapshot = null;
  clearEdgeEditSession({clearSelection:false});
  
  // Restore previous state
  const snapshot = state.undoStack.pop();
  
  // Save current state to redo stack.
  // Use postSelection (the selection that existed right after the action) if available,
  // so redo restores the correct selection even if the user cleared it before undoing.
  const redoSelection = snapshot.postSelection || {
    lockedId: state.lockedId,
    selectedEdgeId: state.selectedEdgeId,
    selectedColumnId: state.selectedColumnId,
    multiSelection: state.multiSelection.size > 0 ? [...state.multiSelection] : null
  };
  state.redoStack.push({
    data: deepCloneData(state.data),
    selection: redoSelection
  });
  
  state.data = snapshot.data;
  
  
  // Update UI (full refresh without triggering markDirty)
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  try { validateEditor(); } catch(e) {}
  try { rebuildStructuredList(); } catch(e) {}
  
  // FIRST: Clear selections
  state.lockedId = null;
  state.hoverId = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.multiSelection.clear();
  
  // SECOND: Rebuild indexes (needed to check if items exist)
  buildIndexes(state.data);
  rebuildFieldDatalist();
  
  // THIRD: Try to restore selection from snapshot if item still exists

  const savedSelection = snapshot.selection || {};
  
  // Restore multi-selection if present
  let _pendingMultiSelection = null;
  if(savedSelection.multiSelection && Array.isArray(savedSelection.multiSelection)){
    _pendingMultiSelection = savedSelection.multiSelection;
    for(const nid of savedSelection.multiSelection){
      if(IDX && IDX.nodeById && IDX.nodeById.has(nid)){
        state.multiSelection.add(nid);
      }
    }
  }
  
  if(state.multiSelection.size === 0 && savedSelection.lockedId && IDX && IDX.nodeById && IDX.nodeById.has(savedSelection.lockedId)){
    state.lockedId = savedSelection.lockedId;

  } else if(state.multiSelection.size === 0 && savedSelection.selectedColumnId && IDX && IDX.columns && IDX.columns.some(c => c.id === savedSelection.selectedColumnId)){
    state.selectedColumnId = savedSelection.selectedColumnId;

  } else if(state.multiSelection.size === 0 && savedSelection.selectedEdgeId && IDX && IDX.edges && IDX.edges.some(e => e.id === savedSelection.selectedEdgeId)){
    state.selectedEdgeId = savedSelection.selectedEdgeId;

  }
  
  
  // FOURTH: Render and apply highlighting
  renderColumns();
  applyVisibility();
  
  // Force-restore multiSelection right before applyHighlight  ensures no intermediate
  // code path (renderColumns, applyVisibility, event handlers) can clear it
  if(_pendingMultiSelection && _pendingMultiSelection.length > 0){
    state.multiSelection.clear();
    for(const nid of _pendingMultiSelection){
      if(IDX && IDX.nodeById && IDX.nodeById.has(nid)){
        state.multiSelection.add(nid);
      }
    }
    if(state.multiSelection.size > 0){
      state.lockedId = null;
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
    }
  }
  
  applyHighlight();
  
  // Scroll first selected node into view
  if(state.multiSelection.size > 0){
    const firstId = state.multiSelection.values().next().value;
    if(firstId) try{ scrollIntoView(firstId); }catch(e){}
  } else if(state.lockedId){
    try{ scrollIntoView(state.lockedId); }catch(e){}
  }
  
  // Sync header inputs with restored data
  const __ti = document.getElementById('projectTitle');
  if(__ti && state.data) __ti.value = state.data.title || 'New Project';

  // Restore highlight colors from data
  try { restoreHlColors(); } catch(e){}

  // Reset any active catalog edit and re-render open catalog modals
  catalogEditEnd();
  __filterEditId = null; __filterEditSnapshot = null;
  try { renderTagsManager(); } catch(e){}
  try { renderTransformsManager(); } catch(e){}
  try { renderCustomAttrsManager(); } catch(e){}
  try { renderFiltersManager(); } catch(e){}

  updateUndoRedoButtons();
  checkDirtyState();
  syncBrowserTitle();
  setViewerStatus('Undo');
}

async function redo(){
  if(state.redoStack.length === 0){
    setViewerStatus('Nothing to redo');
    return;
  }
  // Guard unsaved edits
  if(nodeEditIsDirty()){
    if(!await guardNodeAbandon()) return;
    revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
  }
  if(edgeEditIsDirty()){
    if(!await guardAbandonEdit('mapping', __edgeEditSession?.edgeId || '')) return;
  }
  __editSnapshot = null;
  clearEdgeEditSession({clearSelection:false});
  
  // Restore next state
  const snapshot = state.redoStack.pop();
  
  // Save current state to undo stack.
  // Preserve postSelection from the redo snapshot so that if the user undoes again,
  // the redo entry will still know the correct post-action selection.
  state.undoStack.push({
    data: deepCloneData(state.data),
    selection: {
      lockedId: state.lockedId,
      selectedEdgeId: state.selectedEdgeId,
      selectedColumnId: state.selectedColumnId,
      multiSelection: state.multiSelection.size > 0 ? [...state.multiSelection] : null
    },
    postSelection: snapshot.selection  // the redo target selection becomes the postSelection
  });
  
  state.data = snapshot.data;
  
  // Update UI (full refresh without triggering markDirty)
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  try { validateEditor(); } catch(e) {}
  try { rebuildStructuredList(); } catch(e) {}
  
  // FIRST: Clear selections
  state.lockedId = null;
  state.hoverId = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.multiSelection.clear();
  
  // SECOND: Rebuild indexes
  buildIndexes(state.data);
  rebuildFieldDatalist();
  
  // THIRD: Try to restore selection from snapshot if item still exists
  const savedSelection = snapshot.selection || {};
  
  // Restore multi-selection if present
  let _pendingMultiSelection = null;
  if(savedSelection.multiSelection && Array.isArray(savedSelection.multiSelection)){
    _pendingMultiSelection = savedSelection.multiSelection;
    for(const nid of savedSelection.multiSelection){
      if(IDX && IDX.nodeById && IDX.nodeById.has(nid)){
        state.multiSelection.add(nid);
      }
    }
  }
  
  if(state.multiSelection.size === 0 && savedSelection.lockedId && IDX && IDX.nodeById && IDX.nodeById.has(savedSelection.lockedId)){
    state.lockedId = savedSelection.lockedId;
  } else if(state.multiSelection.size === 0 && savedSelection.selectedColumnId && IDX && IDX.columns && IDX.columns.some(c => c.id === savedSelection.selectedColumnId)){
    state.selectedColumnId = savedSelection.selectedColumnId;
  } else if(state.multiSelection.size === 0 && savedSelection.selectedEdgeId && IDX && IDX.edges && IDX.edges.some(e => e.id === savedSelection.selectedEdgeId)){
    state.selectedEdgeId = savedSelection.selectedEdgeId;
  }
  
  // FOURTH: Render and apply highlighting
  renderColumns();
  applyVisibility();
  
  // Force-restore multiSelection right before applyHighlight
  if(_pendingMultiSelection && _pendingMultiSelection.length > 0){
    state.multiSelection.clear();
    for(const nid of _pendingMultiSelection){
      if(IDX && IDX.nodeById && IDX.nodeById.has(nid)){
        state.multiSelection.add(nid);
      }
    }
    if(state.multiSelection.size > 0){
      state.lockedId = null;
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
    }
  }
  
  applyHighlight();
  
  // Scroll first selected node into view
  if(state.multiSelection.size > 0){
    const firstId = state.multiSelection.values().next().value;
    if(firstId) try{ scrollIntoView(firstId); }catch(e){}
  } else if(state.lockedId){
    try{ scrollIntoView(state.lockedId); }catch(e){}
  }
  
  // Sync header inputs with restored data
  const __ti = document.getElementById('projectTitle');
  if(__ti && state.data) __ti.value = state.data.title || 'New Project';

  // Restore highlight colors from data
  try { restoreHlColors(); } catch(e){}

  // Reset any active catalog edit and re-render open catalog modals
  catalogEditEnd();
  __filterEditId = null; __filterEditSnapshot = null;
  try { renderTagsManager(); } catch(e){}
  try { renderTransformsManager(); } catch(e){}
  try { renderCustomAttrsManager(); } catch(e){}
  try { renderFiltersManager(); } catch(e){}

  updateUndoRedoButtons();
  checkDirtyState();
  syncBrowserTitle();
  setViewerStatus('Redo');
}

function clearUndoHistory(){
  state.undoStack = [];
  state.redoStack = [];
  updateUndoRedoButtons();
}

function updateUndoRedoButtons(){
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  if(undoBtn) undoBtn.disabled = state.undoStack.length === 0;
  if(redoBtn) redoBtn.disabled = state.redoStack.length === 0;
}

// New project management buttons
if(saveProjectBtn) saveProjectBtn.addEventListener('click', async ()=>{
  if(!state.data) return;
  state.data._app = { name: 'Dunnode', version: APP_VERSION, schema: 1 };
  delete state.data._appVersion; // migrated into _app object
  state.data._savedAt = new Date().toISOString();
  const filename = transliterate(state.data.title || 'project').replace(/[^a-z0-9_-]/gi, '_').toLowerCase() + '.json';
  downloadText(filename, 'application/json;charset=utf-8', JSON.stringify(state.data,null,2));
  setGlobalStatus('Downloaded ' + filename);
  markClean();
});

if(openProjectBtn) openProjectBtn.addEventListener('click', ()=>{ 
  if(fileInput) fileInput.click(); 
});

if(showAllColumnsBtn) showAllColumnsBtn.addEventListener('click', async ()=>{
  buildColumnsMenu();
  togglePopover(!columnsPopover.classList.contains('active'));
});

if(undoBtn) undoBtn.addEventListener('click', async ()=>{
  undo();
});

if(redoBtn) redoBtn.addEventListener('click', async ()=>{
  redo();
});

if(addColumnLeftBtn) addColumnLeftBtn.addEventListener('click', async ()=>{
  if(!state.data) return;
  togglePopover(false);
  const cols = state.data.columns || (state.data.columns = []);
  const taken = new Set(cols.map(c=>c?.id));
  
  openCreateModal({
    kind: 'column',
    title: 'Add column (far left)',
    placeholder: 'Column title',
    hint: 'ID is generated from the title (no dots) and made unique.',
    taken,
    onCommit: ({label, id, note, color, _autoId})=>{
      recordChange(); // Save BEFORE adding
      const newCol = {
        id,
        label,
        note: (note||''),
        _autoId,
        schema: { id, label, _autoId, type: 'group', children: [] }
      };
      if(color) newCol.color = color;
      cols.unshift(newCol); // Add at beginning
      try{ syncJsonAreaFromObj(); }catch(e){}
      renderAll();
      setViewerStatus('Added column: ' + id);
    }
  });
});

if(addColumnRightBtn) addColumnRightBtn.addEventListener('click', async ()=>{
  if(!state.data) return;
  togglePopover(false);
  const cols = state.data.columns || (state.data.columns = []);
  const taken = new Set(cols.map(c=>c?.id));
  
  openCreateModal({
    kind: 'column',
    title: 'Add column (far right)',
    placeholder: 'Column title',
    hint: 'ID is generated from the title (no dots) and made unique.',
    taken,
    onCommit: ({label, id, note, color, _autoId})=>{
      recordChange(); // Save BEFORE adding
      const newCol = {
        id,
        label,
        note: (note||''),
        _autoId,
        schema: { id, label, _autoId, type: 'group', children: [] }
      };
      if(color) newCol.color = color;
      cols.push(newCol); // Add at end
      try{ syncJsonAreaFromObj(); }catch(e){}
      renderAll();
      setViewerStatus('Added column: ' + id);
    }
  });
});


// Project shortcuts  all use Alt/Option+ prefix for consistency
// On Mac, Option+letter produces special characters (, , ) so we match e.code not e.key
window.addEventListener('keydown', (e) => {
  if(!e.altKey) return;
  if(e.ctrlKey || e.metaKey || e.shiftKey) return;
  if(e.code === 'KeyN'){
    e.preventDefault();
    document.getElementById('newMappingBtn')?.click();
    return;
  }
  if(e.code === 'KeyO'){
    e.preventDefault();
    document.getElementById('openProjectBtn')?.click();
    return;
  }
  if(e.code === 'KeyS'){
    e.preventDefault();
    document.getElementById('saveProjectBtn')?.click();
    return;
  }
  if(e.code === 'KeyE'){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    const toggle = document.getElementById('editorModeToggle');
    if(toggle){ toggle.checked = !toggle.checked; toggle.dispatchEvent(new Event('change')); }
  }
}, true); // capture phase


document.addEventListener("keydown", (e) => {
  // Undo/Redo shortcuts
  if((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey){
    // Don't interfere with text inputs
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    undo();
    return;
  }
  if((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))){
    // Don't interfere with text inputs
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    redo();
    return;
  }
  // Select all visible nodes
  if((e.ctrlKey || e.metaKey) && e.key === 'a' && !e.shiftKey && !e.altKey){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    selectAllNodes();
    return;
  }
  // Invert selection
  if((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'i' || e.key === 'I') && !e.altKey){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    e.preventDefault();
    invertSelection();
    return;
  }
  // Project shortcuts (Alt+N / Alt+O / Alt+S / Alt+E)
  // NOTE: handled in capture-phase window handler above for reliable browser override
  
  // --- Inline rename: let Ctrl+Arrow create shortcuts work from within the input ---
  const _isInlineInput = __inlineRename && e.target && e.target.closest && e.target.closest('.inlineRenameWrap');

  // Ctrl/Cmd + Arrow = quick-create node (works even during inline rename)
  if((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'ArrowRight')){
    if(!_isInlineInput && e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
    if(!state.editorMode) return;
    e.preventDefault();
    const isGroup = e.altKey;
    const type = isGroup ? 'group' : 'field';
    if(e.key === 'ArrowDown') quickCreateNode('below', type);
    else if(e.key === 'ArrowUp') quickCreateNode('above', type);
    else if(e.key === 'ArrowRight') quickCreateNode('child', type);
    return;
  }

  // Ctrl+C: copy selected nodes (editor mode)
  if((e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey && e.code === 'KeyC'){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;
    if(!state.editorMode || (!state.lockedId && state.multiSelection.size === 0)) return;
    e.preventDefault();
    copyNodes();
    return;
  }

  // Ctrl+V: paste nodes (editor mode)
  if((e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey && e.code === 'KeyV'){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;
    if(!state.editorMode || !__nodeClipboard) return;
    e.preventDefault();
    pasteNodes();
    return;
  }

  // Ctrl+D: duplicate selected nodes (editor mode)
  // Always prevent default to avoid browser bookmark dialog
  if((e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey && e.code === 'KeyD'){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;
    e.preventDefault();
    if(!state.editorMode || (!state.lockedId && state.multiSelection.size === 0)) return;
    duplicateNodes();
    return;
  }

  // Ctrl+G: group selected siblings (editor mode)
  // Always prevent default to avoid browser find-next dialog
  if((e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey && e.code === 'KeyG'){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;
    e.preventDefault();
    if(!state.editorMode || (!state.lockedId && state.multiSelection.size === 0)) return;
    groupSelection();
    return;
  }

  // Ctrl+Shift+G: ungroup selected group (editor mode)
  if((e.ctrlKey || e.metaKey) && !e.altKey && e.shiftKey && e.code === 'KeyG'){
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;
    e.preventDefault();
    if(!state.editorMode || (!state.lockedId && state.multiSelection.size === 0)) return;
    ungroupNode();
    return;
  }

  // Don't intercept normal typing in inputs (except inline rename specials handled above)
  if(!_isInlineInput && e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)){
    // Still allow Escape from any input
    if(e.key !== 'Escape') return;
  }
  // If inline rename is active, only allow specific keys through
  if(_isInlineInput && !['Tab','Delete','Enter','Escape'].includes(e.key) && !e.key.startsWith('Arrow')) return;

  // / arrow navigation
  if((e.key === 'ArrowDown' || e.key === 'ArrowUp') && !e.ctrlKey && !e.metaKey && !e.altKey){
    if(_isInlineInput) return; // let cursor move in input
    e.preventDefault();
    const order = getVisibleNodeOrder();
    if(!order.length) return;

    // Find current position
    const currentId = state.lockedId;
    let currentIdx = currentId ? order.findIndex(o => o.nodeId === currentId) : -1;

    // If column header is selected (lockedId = column ID), jump to first node in that column
    if(currentIdx < 0 && state.selectedColumnId){
      const colFirst = order.findIndex(o => o.colId === state.selectedColumnId);
      if(colFirst >= 0){
        // Position so either  or  lands on first node in this column
        const dir = e.key === 'ArrowDown' ? 1 : -1;
        currentIdx = colFirst - dir;
      }
    }

    // If multi-selection active and no lockedId, use the last multi-selected as anchor
    if(currentIdx < 0 && state.multiSelection.size > 0){
      const lastMulti = [...state.multiSelection].pop();
      currentIdx = order.findIndex(o => o.nodeId === lastMulti);
    }

    const dir = e.key === 'ArrowDown' ? 1 : -1;
    let nextIdx = currentIdx + dir;
    if(nextIdx < 0) nextIdx = 0;
    if(nextIdx >= order.length) nextIdx = order.length - 1;
    if(nextIdx === currentIdx && currentIdx >= 0) return;

    const next = order[nextIdx];
    if(!next) return;

    if(e.shiftKey){
      // Shift+Arrow: extend multi-selection
      if(state.multiSelection.size === 0 && currentId){
        state.multiSelection.add(currentId);
      }
      if(!state.multiSelection.has(next.nodeId)){
        state.multiSelection.add(next.nodeId);
      }
      state.lockedId = next.nodeId;
      state.hoverId = null;
      state.selectedColumnId = null;
      state.selectedEdgeId = null;
      applyHighlight();
      scrollIntoView(next.nodeId);
    } else {
      // Plain arrow: single select
      state.multiSelection = new Set();
      state.selectedColumnId = null;
      state.selectedEdgeId = null;
      lockSelection(next.nodeId);
      scrollIntoView(next.nodeId);
    }
    return;
  }

  // Space: toggle collapse/expand on selected group(s)
  if(e.key === ' ' && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey){
    if(_isInlineInput) return;
    if(!state.lockedId && state.multiSelection.size === 0) return;
    e.preventDefault();
    const ids = state.multiSelection.size > 0 ? [...state.multiSelection] : [state.lockedId];
    let toggled = 0;
    for(const nid of ids){
      const node = IDX.nodeById.get(nid);
      if(node && node.type === 'group'){
        toggleCollapse(nid, null, true); // null = toggle, true = skipHighlight (we do it once after)
        toggled++;
      }
    }
    if(toggled){
      applyHighlight();
      scheduleArrowsUpdate();
    }
    return;
  }

  // Alt+/: move node(s) up/down among siblings (editor mode)
  // Alt+/: indent / outdent node(s) (editor mode)
  if(e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey && (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'ArrowRight' || e.key === 'ArrowLeft')){
    if(_isInlineInput) return;
    // Always prevent browser default (Alt+Left/Right = back/forward on Windows/Edge)
    e.preventDefault();
    if(!state.editorMode || (!state.lockedId && state.multiSelection.size === 0)) return;
    if(e.key === 'ArrowDown' || e.key === 'ArrowUp'){
      const dir = e.key === 'ArrowDown' ? 1 : -1;
      if(state.multiSelection.size > 0) bulkMove(dir);
      else moveNode(state.lockedId, columnOf(state.lockedId), dir);
    } else if(e.key === 'ArrowRight'){
      if(state.multiSelection.size > 0) bulkIndent();
      else inlineIndent(state.lockedId, columnOf(state.lockedId));
    } else if(e.key === 'ArrowLeft'){
      if(state.multiSelection.size > 0) bulkOutdent();
      else inlineOutdent(state.lockedId, columnOf(state.lockedId));
    }
    return;
  }

  // Tab / Shift+Tab: also indent / outdent (legacy fallback)
  if(e.key === 'Tab' && !e.ctrlKey && !e.metaKey && !e.altKey){
    if(_isInlineInput){ e.preventDefault(); commitInlineRename(); return; }
    // Always prevent browser default (Tab = focus cycling) when not in a text input
    e.preventDefault();
    if(!state.editorMode || (!state.lockedId && state.multiSelection.size === 0)) return;
    if(state.multiSelection.size > 0){
      if(e.shiftKey) bulkOutdent(); else bulkIndent();
    } else {
      const nid = state.lockedId;
      const cid = columnOf(nid);
      if(!cid) return;
      if(e.shiftKey) inlineOutdent(nid, cid);
      else inlineIndent(nid, cid);
    }
    return;
  }

  // Enter: focus label in details editor (editor mode) or open details panel
  if(e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey){
    if(_isInlineInput) return; // handled by input's own keydown
    if(!state.lockedId) return;
    e.preventDefault();
    // Open details panel if hidden
    const vg = document.getElementById('viewerGrid');
    if(vg && vg.dataset.panel === 'hidden') setTab('right');
    if(state.editorMode){
      // Re-render to show editor, then focus label
      renderAll();
      requestAnimationFrame(() => {
        const ndLabel = document.getElementById('ndLabel');
        if(ndLabel){ ndLabel.focus(); ndLabel.select(); }
      });
    }
    return;
  }

  // Delete / Backspace: delete selected node(s) (editor mode)
  if((e.key === 'Delete' || (e.key === 'Backspace' && !_isInlineInput)) && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey){
    if(_isInlineInput) return; // let backspace work in input
    if(!state.editorMode) return;
    if(!state.lockedId && state.multiSelection.size === 0) return;
    e.preventDefault();
    bulkDelete();
    return;
  }

  if(e.key === "?") { openHelp(); return; }
  if(e.key === "Escape") {
    // If editing a node, Escape should cancel node edits (revert snapshot) before clearing selection.
    if(state.editorMode && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'){
      cancelEditAndDeselect();
      state.search = '';
      if(searchInput) searchInput.value = '';
      updateFilterBadge();
      refreshViewer();
      return;
    }
    // If editing a column, Escape should cancel column edits
    if(state.editorMode && typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='column'){
      cancelEditAndDeselect();
      state.search = '';
      if(searchInput) searchInput.value = '';
      updateFilterBadge();
      refreshViewer();
      return;
    }
    // If editing an edge, Escape should discard draft
    if(state.editorMode && __edgeEditSession){
      clearEdgeEditSession({clearSelection:true});
    }
    // clear selection + search
    state.lockedId = null;
    state.hoverId = null;
    state.search = "";
    state._consolidatedEdgeCache = null;
    searchInput.value = "";
    updateFilterBadge();
    refreshViewer();
  }
});

/* =========================
   File loading & validation utilities
========================= */

function validateEditor(){
  if(!state.data) return { ok:false, errors:['No data loaded'], warnings:[] };
  const result = validateData(state.data);
  renderValidationLog(result);
  if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
  return { ok: result.errors.length === 0, ...result, obj: state.data };
}

// Kept for backward compat  now just syncs jsonArea from state.data
function syncJsonAreaFromObj(){
  if(state.data && jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
}

// Kept for backward compat  now just syncs jsonArea + validates
function rebuildStructuredList(){
  syncJsonAreaFromObj();
  try { validateEditor(); } catch(e) {}
}

// File upload handler (shared by "Open project" button and legacy "Upload" button)
if(fileInput) fileInput.addEventListener('change', async () => {
  const f = fileInput.files && fileInput.files[0];
  if(!f) return;
  try{
    const text = await f.text();
    const sure = await customConfirm('Are you sure you want to load this file? This will override the current view and you will lose unsaved changes.');
    if(!sure) { setGlobalStatus('Upload cancelled.'); return; }
    let obj;
    try { obj = JSON.parse(text); } catch(err){ customAlert('Invalid JSON: '+err.message); setGlobalStatus('Upload failed: invalid JSON'); return; }
    const result = validateData(obj);
    if(result.errors.length === 0){
      state.data = obj;
      if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2);
      clearUndoHistory();
      state.selectedEdgeId = null;
      state.hoverEdgeId = null;
      state.lockedId = null;
      state.hoverId = null;
      state.multiSelection.clear();
      // Clear any in-flight edit sessions
      __editSnapshot = null;
      __edgeEditSession = null;
      renderAll();
      markClean();
      setGlobalStatus('Loaded mapping from file.');
    } else {
      renderValidationLog(result);
      customAlert('The loaded file has validation errors:\n' + result.errors.join('\n'));
      setGlobalStatus('Upload failed: validation errors');
    }
  } catch(e){ console.error(e); customAlert('Failed to read file: '+ e.message); }
  fileInput.value = '';
});

/* Field autocomplete datalist */
function collectFieldsFromData(data){
  const out = [];
  function walk(node){
    if(!node || typeof node !== "object") return;
    if(node.type === "field") out.push({ id: node.id, label: node.label || node.id });
    (node.children || []).forEach(walk);
  }
  (data.columns || []).forEach(c => walk(c.schema));
  out.sort((a,b)=> a.id.localeCompare(b.id));
  return out;
}

function rebuildFieldDatalist(){
  const data = state.data;
  if(data && typeof data==='object'){
    const fields = collectFieldsFromData(data);
    if(fieldDatalist) fieldDatalist.innerHTML = fields.map(f => `<option value="${escapeHtml(f.id)}">${escapeHtml(f.label)}</option>`).join("\n");
  }
}


/* =========================
 Tree utility functions (used by inline editor)
========================= */

function locateNode(root, targetId, parent=null){
  if(!root) return null;
  if(root.id === targetId) return { node: root, parent, idx: null, siblings: null };
  const kids = root.children || [];
  for(let i = 0; i < kids.length; i++){
    const ch = kids[i];
    if(ch && ch.id === targetId) return { node: ch, parent: root, idx: i, siblings: kids };
    const deep = locateNode(ch, targetId, root);
    if(deep) return deep;
  }
  return null;
}

function ensureGroup(node){
  if(!node.children) node.children = [];
  node.type = (node.type !== 'field') ? 'group' : node.type;
  return node;
}

function collectNodeIds(col){
  const ids = new Set();
  (function walk(n){ if(!n || typeof n !== 'object') return; if(n.id) ids.add(n.id); (n.children||[]).forEach(walk); })(col.schema);
  return ids;
}

function collectFieldIdsFromNode(node){
  const out = [];
  (function walk(n){ if(!n) return; if(n.type === 'field') out.push(n.id); (n.children||[]).forEach(walk); })(node);
  return out;
}

/* =========================
 INLINE_EDITOR_RUNTIME (viewer embedded)
========================= */

function findColumnById(colId){
  return (state.data?.columns||[]).find(c=>c && c.id===colId);
}

function removeMappingsReferencingInState(fieldIds){
  const kill = new Set(fieldIds);
  state.data.mappings = (state.data.mappings||[]).filter(m => {
    if(!m || typeof m !== 'object') return false;
    if(kill.has(m.from)) return false;
    if(kill.has(m.to)) return false;
    return true;
  });
}

function removeNodeFromTree(nodes, targetId){
  if(!nodes) return false;
  for(let i = 0; i < nodes.length; i++){
    if(nodes[i] && nodes[i].id === targetId){ nodes.splice(i,1); return true; }
    if(nodes[i] && nodes[i].children && removeNodeFromTree(nodes[i].children, targetId)) return true;
  }
  return false;
}

/* =========================
   Bulk action modals (multi-select)
========================= */
function findNodeInData(nodeId){
  if(!state.data || !state.data.columns) return null;
  for(const col of state.data.columns){
    if(!col.schema) continue;
    const loc = locateNode(col.schema, nodeId);
    if(loc && loc.node) return loc.node;
  }
  return null;
}

function _setupBulkModalHeader(dialog, title, closeFn){
  const hdr = dialog.querySelector('.modalHeader');
  if(hdr) hdr.style.display = '';
  const titleEl = hdr?.querySelector('.title');
  if(titleEl) titleEl.textContent = title;
  const controls = hdr?.querySelector('.controls');
  if(controls){
    controls.innerHTML = '';
    const closeBtn = document.createElement('button');
    closeBtn.className = 'btn';
    closeBtn.textContent = 'Close';
    closeBtn.style.fontSize = '12px';
    closeBtn.addEventListener('click', ()=> closeFn());
    controls.appendChild(closeBtn);
  }
}

// Replace shared mask element to clear stale handlers from previous customConfirm/customAlert
function _freshMask(){
  const old = document.getElementById('customDialogMask');
  const fresh = old.cloneNode(false);
  old.parentNode.replaceChild(fresh, old);
  return fresh;
}

// Show an inline guard overlay inside the dialog (avoids reusing shared customConfirm dialog)
// Global tracked mask handler for bulk modals (prevents stale listener accumulation)
let __bulkModalMaskHandler = null;
function _setBulkMaskGuard(mask, handler){
  if(__bulkModalMaskHandler) mask.removeEventListener('click', __bulkModalMaskHandler);
  __bulkModalMaskHandler = handler;
  mask.addEventListener('click', handler);
}
function _clearBulkMaskGuard(mask){
  if(__bulkModalMaskHandler){ mask.removeEventListener('click', __bulkModalMaskHandler); __bulkModalMaskHandler = null; }
}

function _showInlineGuard(dialog, message, onDiscard){
  if(dialog.querySelector('[data-guard-overlay]')) return; // prevent duplicates
  const overlay = document.createElement('div');
  overlay.dataset.guardOverlay = '1';
  overlay.style.cssText = 'position:absolute;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:10;border-radius:inherit;';
  const box = document.createElement('div');
  box.style.cssText = 'background:var(--bg);border:1px solid var(--border);border-radius:12px;padding:20px 24px;max-width:320px;text-align:center;';
  box.innerHTML = `<div style="font-size:14px;line-height:1.6;margin-bottom:16px;">${escapeHtml(message)}</div>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button class="btn" data-act="keep" style="min-width:80px;">Cancel</button>
      <button class="btn" data-act="discard" style="min-width:80px;background:rgba(59,130,246,.15);border-color:rgba(59,130,246,.4);color:rgba(96,165,250,1);">OK</button>
    </div>`;
  box.querySelector('[data-act="keep"]').addEventListener('click', ()=> overlay.remove());
  box.querySelector('[data-act="discard"]').addEventListener('click', ()=>{ overlay.remove(); onDiscard(); });
  overlay.addEventListener('click', (ev)=>{ if(ev.target===overlay) overlay.remove(); });
  overlay.appendChild(box);
  dialog.appendChild(overlay);
}

// Wrap a close function to be guard-aware: won't close if a guard overlay is active
function _guardedCloseFactory(dialog, dirtyFn, message, rawClose){
  const close = ()=>{
    // Refuse to close while guard overlay is showing
    if(dialog.querySelector('[data-guard-overlay]')) return;
    rawClose();
  };
  const guardedClose = ()=>{
    if(dialog.querySelector('[data-guard-overlay]')) return; // already guarding
    if(dirtyFn()) _showInlineGuard(dialog, message, rawClose);
    else rawClose();
  };
  return { close, guardedClose };
}

function showBulkTagModal(nodeIds){
  const allTags = ensureTagCatalog();
  const tags = allTags.filter(t => !t.metaOnly);
  if(!tags.length){ customAlert('No assignable tags defined. Create tags in the Tags catalog first.'); return; }
  
  // Compute current tag state across all selected nodes
  const tagCounts = new Map();
  for(const nid of nodeIds){
    const node = IDX.nodeById.get(nid);
    if(!node) continue;
    const nTags = normalizeNodeTags(node);
    for(const tid of nTags) tagCounts.set(tid, (tagCounts.get(tid)||0) + 1);
  }

  const mask = _freshMask();
  const dialog = document.getElementById('customDialog');
  dialog.querySelectorAll('[data-guard-overlay]').forEach(el => el.remove());
  const total = nodeIds.length;

  const body = dialog.querySelector('.modalBody');
  body.innerHTML = `
    <div style="font-size:12px;margin-bottom:14px;opacity:.55;line-height:1.5;">Check to add, uncheck to remove. Dash means partially applied.</div>
    <div id="bulkTagList" style="display:flex;flex-direction:column;gap:2px;max-height:340px;overflow-y:auto;padding:2px 0;"></div>
    <div style="margin-top:18px;display:flex;gap:8px;justify-content:flex-end;border-top:1px solid var(--border);padding-top:14px;">
      <button class="btn" id="bulkTagCancel">Cancel</button>
      <button class="btn btnSave" id="bulkTagApply">Save</button>
    </div>`;

  const list = document.getElementById('bulkTagList');
  for(const t of tags){
    const count = tagCounts.get(t.id) || 0;
    const checked = count === total;
    const indeterminate = count > 0 && count < total;
    const color = tagColor(t);
    const row = document.createElement('label');
    row.style.cssText = 'display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;';
    row.addEventListener('mouseenter', ()=>{ row.style.background='rgba(255,255,255,.04)'; });
    row.addEventListener('mouseleave', ()=>{ row.style.background=''; });
    row.innerHTML = `
      <input type="checkbox" data-tag-id="${escapeHtml(t.id)}" ${checked?'checked':''} ${indeterminate?'data-indeterminate="1"':''} style="accent-color:${color};width:16px;height:16px;flex-shrink:0;">
      <span class="tagChip" data-color="1" style="--c:${color};flex-shrink:0;">${escapeHtml(tagDisplayLabel(t)||t.id)}</span>
      <span style="flex:1;font-size:12.5px;font-weight:600;">${escapeHtml(t.label||t.id)}</span>
      <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${count}/${total}</span>`;
    list.appendChild(row);
  }
  list.querySelectorAll('input[data-indeterminate="1"]').forEach(cb=>{ cb.indeterminate = true; });

  mask.classList.add('active');
  dialog.classList.add('active');

  // Dirty tracking
  const applyBtn = document.getElementById('bulkTagApply');
  const initialStates = new Map();
  list.querySelectorAll('input[type=checkbox]').forEach(cb=>{
    initialStates.set(cb.dataset.tagId, cb.checked);
  });
  const checkDirty = ()=>{
    let dirty = false;
    list.querySelectorAll('input[type=checkbox]').forEach(cb=>{
      if(cb.checked !== initialStates.get(cb.dataset.tagId)) dirty = true;
    });
    return dirty;
  };
  if(applyBtn) wireDirtyHighlight(body, applyBtn, checkDirty);

  const rawClose = ()=>{ mask.classList.remove('active'); dialog.classList.remove('active'); _clearBulkMaskGuard(mask); };
  const { close, guardedClose } = _guardedCloseFactory(dialog, checkDirty, 'Abandon unsaved changes?', rawClose);
  _setupBulkModalHeader(dialog, `Set tags on ${total} node${total>1?'s':''}`, guardedClose);
  document.getElementById('bulkTagCancel').addEventListener('click', rawClose);
  _setBulkMaskGuard(mask, (e)=>{ if(e.target===mask){ e.stopImmediatePropagation(); guardedClose(); } });

  document.getElementById('bulkTagApply').addEventListener('click', ()=>{
    pushUndo();
    list.querySelectorAll('input[type=checkbox]').forEach(cb=>{
      const tid = cb.dataset.tagId;
      const shouldHave = cb.checked;
      for(const nid of nodeIds){
        const node = findNodeInData(nid);
        if(!node) continue;
        let nTags = normalizeNodeTags(node);
        if(shouldHave && !nTags.includes(tid)) nTags.push(tid);
        else if(!shouldHave) nTags = nTags.filter(x=>x!==tid);
        node.tags = nTags;
      }
    });
    markDirty();
    renderAll();
    close();
    setGlobalStatus(`Updated tags on ${nodeIds.length} nodes.`);
  });
}

function showBulkAttrModal(nodeIds){
  const attrs = ensureCustomAttributeCatalog();
  if(!attrs.length){ customAlert('No custom attributes defined. Create attributes in the Attributes catalog first.'); return; }

  const mask = _freshMask();
  const dialog = document.getElementById('customDialog');
  dialog.querySelectorAll('[data-guard-overlay]').forEach(el => el.remove());
  const total = nodeIds.length;

  const body = dialog.querySelector('.modalBody');

  body.innerHTML = `
    <div style="font-size:12px;margin-bottom:14px;opacity:.55;line-height:1.5;">Choose an attribute and a value to apply to all selected nodes.</div>
    <div style="margin-bottom:14px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:.5px;opacity:.4;margin-bottom:5px;">Attribute</div>
      <select id="bulkAttrSelect" class="inp" style="width:100%;">
        ${_buildAttrSelectOptions({})}
      </select>
    </div>
    <div style="margin-bottom:14px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:.5px;opacity:.4;margin-bottom:5px;">Value</div>
      <div id="bulkAttrValues" style="display:flex;flex-direction:column;gap:2px;max-height:220px;overflow-y:auto;padding:2px 0;"></div>
    </div>
    <div style="margin-top:18px;display:flex;gap:8px;justify-content:flex-end;border-top:1px solid var(--border);padding-top:14px;">
      <button class="btn" id="bulkAttrCancel">Cancel</button>
      <button class="btn btnSave" id="bulkAttrApply">Save</button>
    </div>`;


  function renderValues(){
    const attrId = document.getElementById('bulkAttrSelect').value;
    const attr = attrs.find(a=>a.id===attrId);
    const isMulti = !!(attr && attr.multi);
    const vals = (attr && attr.values) || [];
    const container = document.getElementById('bulkAttrValues');

    // Compute current value distribution
    const valCounts = new Map();
    let hasAttrCount = 0;
    for(const nid of nodeIds){
      const node = IDX.nodeById.get(nid);
      if(!node) continue;
      const ca = node.customAttributes || {};
      const cur = ca[attrId];
      if(cur !== undefined && cur !== null && cur !== ''){
        hasAttrCount++;
        const curArr = Array.isArray(cur) ? cur : [cur];
        for(const v of curArr) valCounts.set(v, (valCounts.get(v)||0) + 1);
      }
    }

    let html = '';
    if(isMulti){
      // Multi-select: checkboxes
      for(const v of vals){
        const count = valCounts.get(v.id) || 0;
        const checked = count === total;
        const indeterminate = count > 0 && count < total;
        const vc = v.color ? `<span style="width:10px;height:10px;border-radius:3px;background:${v.color};flex-shrink:0;"></span>` : '';
        html += `<label style="display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;" onmouseenter="this.style.background='rgba(255,255,255,.04)'" onmouseleave="this.style.background=''">
          <input type="checkbox" name="bulkAttrVal" value="${escapeHtml(v.id)}" ${checked?'checked':''} ${indeterminate?'data-indeterminate="1"':''} style="width:16px;height:16px;flex-shrink:0;">
          ${vc}
          <span style="flex:1;font-size:12.5px;">${escapeHtml(_catalogItemLabel(v))}</span>
          <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${count}/${total}</span>
        </label>`;
      }
      // Clear all option
      html += `<label style="display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;margin-top:4px;border-top:1px solid var(--border);padding-top:10px;color:rgba(255,120,120,.8);" onmouseenter="this.style.background='rgba(255,120,120,.04)'" onmouseleave="this.style.background=''">
        <input type="checkbox" id="bulkAttrClear" style="width:16px;height:16px;flex-shrink:0;">
        <span style="flex:1;font-size:12px;">Clear all values for this attribute</span>
        <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${hasAttrCount}/${total} set</span>
      </label>`;
    } else {
      // Single-select: radio buttons
      for(const v of vals){
        const count = valCounts.get(v.id) || 0;
        const vc = v.color ? `<span style="width:10px;height:10px;border-radius:3px;background:${v.color};flex-shrink:0;"></span>` : '';
        html += `<label style="display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;" onmouseenter="this.style.background='rgba(255,255,255,.04)'" onmouseleave="this.style.background=''">
          <input type="radio" name="bulkAttrVal" value="${escapeHtml(v.id)}" ${count===total?'checked':''} style="width:16px;height:16px;flex-shrink:0;">
          ${vc}
          <span style="flex:1;font-size:12.5px;">${escapeHtml(_catalogItemLabel(v))}</span>
          <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${count}/${total}</span>
        </label>`;
      }
      // Clear option as a radio
      html += `<label style="display:flex;align-items:center;gap:10px;padding:7px 10px;border-radius:8px;cursor:pointer;transition:background .1s;margin-top:4px;border-top:1px solid var(--border);padding-top:10px;color:rgba(255,120,120,.8);" onmouseenter="this.style.background='rgba(255,120,120,.04)'" onmouseleave="this.style.background=''">
        <input type="radio" name="bulkAttrVal" value="__clear__" id="bulkAttrClear" style="width:16px;height:16px;flex-shrink:0;">
        <span style="flex:1;font-size:12px;">Clear this attribute</span>
        <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${hasAttrCount}/${total} set</span>
      </label>`;
    }

    if(!vals.length) html = '<div style="opacity:.4;font-size:12px;padding:8px;">No values defined for this attribute.</div>';
    container.innerHTML = html;
    container.querySelectorAll('input[data-indeterminate="1"]').forEach(cb=>{ cb.indeterminate = true; });

    // Multi-select clear logic: uncheck all value checkboxes when "Clear all" is checked
    if(isMulti){
      const clearCb = document.getElementById('bulkAttrClear');
      if(clearCb){
        clearCb.addEventListener('change', ()=>{
          if(clearCb.checked){
            container.querySelectorAll('input[name=bulkAttrVal]').forEach(cb=>{ cb.checked = false; });
          }
        });
        container.querySelectorAll('input[name=bulkAttrVal]').forEach(cb=>{
          cb.addEventListener('change', ()=>{ if(cb.checked && clearCb) clearCb.checked = false; });
        });
      }
    }
  }

  renderValues();
  document.getElementById('bulkAttrSelect').addEventListener('change', ()=>{ renderValues(); });

  function _hasSelection(){
    const clearCb = document.getElementById('bulkAttrClear');
    if(clearCb && clearCb.checked) return true;
    const checked = document.querySelectorAll('input[name=bulkAttrVal]:checked');
    return checked.length > 0;
  }

  mask.classList.add('active');
  dialog.classList.add('active');

  const applyBtn = document.getElementById('bulkAttrApply');
  const checkDirty = ()=> _hasSelection();
  if(applyBtn) wireDirtyHighlight(body, applyBtn, checkDirty);

  // For guard: track if user actually changed any value from initial state
  let _attrDirty = false;
  const valuesContainer = document.getElementById('bulkAttrValues');
  if(valuesContainer) valuesContainer.addEventListener('change', ()=>{ _attrDirty = true; });

  const rawClose = ()=>{ mask.classList.remove('active'); dialog.classList.remove('active'); _clearBulkMaskGuard(mask); };
  const { close, guardedClose } = _guardedCloseFactory(dialog, ()=>_attrDirty, 'Abandon unsaved changes?', rawClose);
  document.getElementById('bulkAttrCancel').addEventListener('click', rawClose);
  _setupBulkModalHeader(dialog, `Set attribute on ${total} node${total>1?'s':''}`, guardedClose);
  _setBulkMaskGuard(mask, (e)=>{ if(e.target===mask){ e.stopImmediatePropagation(); guardedClose(); } });

  document.getElementById('bulkAttrApply').addEventListener('click', ()=>{
    const attrId = document.getElementById('bulkAttrSelect').value;
    const attr = attrs.find(a=>a.id===attrId);
    const isMulti = !!(attr && attr.multi);
    const clearCb = document.getElementById('bulkAttrClear');
    const shouldClear = clearCb ? clearCb.checked : false;

    if(isMulti){
      // Gather checked values
      const checkedVals = Array.from(document.querySelectorAll('input[name=bulkAttrVal]:checked')).map(cb=>cb.value);
      if(!shouldClear && !checkedVals.length){ customAlert('Select at least one value, or choose "Clear all values".'); return; }
      pushUndo();
      for(const nid of nodeIds){
        const node = findNodeInData(nid);
        if(!node) continue;
        if(!node.customAttributes) node.customAttributes = {};
        if(shouldClear){
          delete node.customAttributes[attrId];
        } else {
          // Merge: add checked, remove unchecked
          let cur = node.customAttributes[attrId];
          let curArr = Array.isArray(cur) ? [...cur] : (cur ? [cur] : []);
          // For each value in the list, add if checked, remove if unchecked
          const allValIds = (attr.values||[]).map(v=>v.id);
          for(const vid of allValIds){
            if(checkedVals.includes(vid) && !curArr.includes(vid)) curArr.push(vid);
            else if(!checkedVals.includes(vid)) curArr = curArr.filter(x=>x!==vid);
          }
          if(curArr.length) node.customAttributes[attrId] = curArr;
          else delete node.customAttributes[attrId];
        }
      }
    } else {
      // Single-select
      const selectedRadio = document.querySelector('input[name=bulkAttrVal]:checked');
      if(!selectedRadio){ customAlert('Select a value or choose "Clear this attribute".'); return; }
      const isClear = selectedRadio.value === '__clear__';
      pushUndo();
      for(const nid of nodeIds){
        const node = findNodeInData(nid);
        if(!node) continue;
        if(!node.customAttributes) node.customAttributes = {};
        if(isClear) delete node.customAttributes[attrId];
        else node.customAttributes[attrId] = selectedRadio.value;
      }
    }
    markDirty();
    renderAll();
    close();
    setGlobalStatus(`${shouldClear ? 'Cleared' : 'Set'} attribute "${attrId}" on ${nodeIds.length} nodes.`);
  });
}

function showBulkTransformModal(edgeGroups){
  const transforms = ensureTransformCatalog();
  if(!transforms.length){ customAlert('No transforms defined. Create transforms in the Transforms catalog first.'); return; }
  let allEdges = [...(edgeGroups.internal||[]), ...(edgeGroups.outbound||[]), ...(edgeGroups.inbound||[]), ...(edgeGroups.linked||[])];
  // Deduplicate (bidirectional edges may appear in both in/out)
  { const _seen = new Set(); allEdges = allEdges.filter(e => { if(_seen.has(e.id)) return false; _seen.add(e.id); return true; }); }
  if(!allEdges.length){ customAlert('No mappings to modify.'); return; }

  const mask = _freshMask();
  const dialog = document.getElementById('customDialog');
  dialog.querySelectorAll('[data-guard-overlay]').forEach(el => el.remove());
  const body = dialog.querySelector('.modalBody');

  // Build scope definitions
  const scopes = [
    { id: 'all', label: 'All', edges: allEdges },
    { id: 'internal', label: 'Internal', edges: edgeGroups.internal || [] },
    { id: 'inbound', label: 'Inbound', edges: edgeGroups.inbound || [] },
    { id: 'outbound', label: 'Outbound', edges: edgeGroups.outbound || [] },
    { id: 'linked', label: 'Linked', edges: edgeGroups.linked || [] },
  ].filter(s => s.edges.length > 0);

  let _scope = 'all';
  function scopeEdges(){ return scopes.find(s=>s.id===_scope)?.edges || allEdges; }
  function scopeKeys(){ const keys = new Set(); for(const e of scopeEdges()) keys.add(e.from+'|'+e.to); return keys; }

  // Working copy: ALL edges (not scoped)  scope just controls what's displayed/modified
  const workingCopy = new Map();
  for(const edge of allEdges){
    const mapping = (state.data.mappings||[]).find(m=> m && m.from===edge.from && m.to===edge.to);
    const key = edge.from + '|' + edge.to;
    workingCopy.set(key, mapping ? JSON.parse(JSON.stringify(normalizeTransforms(mapping.transforms))) : []);
  }

  // Scope tab bar HTML
  const scopeBarHtml = scopes.length > 1 ? `<div id="bulkTransformScopeBar" style="display:flex;gap:0;margin-bottom:14px;border:1px solid var(--border);border-radius:8px;overflow:hidden;">
    ${scopes.map(s=>`<button class="btn" data-scope="${s.id}" style="flex:1;border:none;border-radius:0;font-size:11px;padding:6px 4px;text-align:center;white-space:nowrap;${s.id==='all'?'background:rgba(255,255,255,.08);':''}">${s.label} (${s.edges.length})</button>`).join('')}
  </div>` : '';

  body.innerHTML = `
    ${scopeBarHtml}
    <div id="bulkTransformSubtitle" style="font-size:12px;margin-bottom:14px;opacity:.55;line-height:1.5;">
      Add, remove, or reorder transforms across ${allEdges.length} mapping${allEdges.length>1?'s':''}.
    </div>
    <div style="margin-bottom:14px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:.5px;opacity:.4;margin-bottom:5px;">Add transform</div>
      <div style="display:flex;gap:6px;align-items:flex-start;">
        <select id="bulkTransformSel" class="inp" style="flex:1;">
          <option value="">Choose\u2026</option>
          ${_buildTransformSelectOptions([], {})}
        </select>
        <button class="btn" id="bulkTransformAddBtn" style="font-size:11px;padding:6px 12px;white-space:nowrap;opacity:.4;pointer-events:none;">+ Add</button>
      </div>
      <div id="bulkTransformParams" style="display:none;margin-top:8px;padding:8px 10px;background:rgba(0,0,0,.12);border-radius:8px;border:1px solid var(--border);"></div>
    </div>
    <div style="border-top:1px solid var(--border);padding-top:10px;margin-bottom:14px;">
      <div style="font-size:10px;text-transform:uppercase;letter-spacing:.5px;opacity:.4;margin-bottom:5px;">Applied transforms</div>
      <div id="bulkTransformCurrent" style="display:flex;flex-direction:column;gap:2px;max-height:240px;overflow-y:auto;padding:2px 0;"></div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;border-top:1px solid var(--border);padding-top:14px;">
      <button class="btn" id="bulkTransformCancel">Cancel</button>
      <button class="btn btnSave" id="bulkTransformSave">Save</button>
    </div>`;

  const sel = document.getElementById('bulkTransformSel');
  const paramsDiv = document.getElementById('bulkTransformParams');
  const addBtn = document.getElementById('bulkTransformAddBtn');
  const currentDiv = document.getElementById('bulkTransformCurrent');
  const saveBtn = document.getElementById('bulkTransformSave');
  const subtitleEl = document.getElementById('bulkTransformSubtitle');

  function makeKey(inst){
    const rid = transformRefId(inst);
    const ps = (inst.params && Object.keys(inst.params).length > 0)
      ? Object.entries(inst.params).sort((a,b)=>a[0].localeCompare(b[0])).map(([k,v])=>`${k}=${v}`).join('|') : '';
    return ps ? `${rid}|${ps}` : rid;
  }

  // Snapshot for dirty detection  serializes working copy + display order
  function _serializeWC(){
    const arr = [];
    for(const [k, v] of workingCopy) arr.push([k, v]);
    return JSON.stringify([arr, _displayOrder]);
  }
  // Snapshot taken after initial rebuildDisplayOrder() below
  let _snapshotStr = null;

  function isDirty(){ return _serializeWC() !== _snapshotStr; }

  function updateDirtyState(){
    const dirty = isDirty();
    if(dirty) saveBtn.classList.add('btnDirty');
    else saveBtn.classList.remove('btnDirty');
    // Enable/disable scope tabs based on dirty state
    const scopeBar = document.getElementById('bulkTransformScopeBar');
    if(scopeBar){
      scopeBar.querySelectorAll('[data-scope]').forEach(b=>{
        if(dirty && b.dataset.scope !== _scope){
          b.style.opacity = '.3'; b.style.pointerEvents = 'none';
        } else {
          b.style.opacity = ''; b.style.pointerEvents = '';
        }
      });
    }
    return dirty;
  }

  // Build display order from scoped edges
  const _displayOrder = [];
  const _instByKey = new Map();
  function rebuildDisplayOrder(){
    _displayOrder.length = 0;
    _instByKey.clear();
    const seen = new Set();
    const keys = scopeKeys();
    for(const [ekey, tArr] of workingCopy){
      if(!keys.has(ekey)) continue;
      for(const inst of tArr){
        const k = makeKey(inst);
        if(!seen.has(k)){ seen.add(k); _displayOrder.push(k); _instByKey.set(k, inst); }
      }
    }
  }
  rebuildDisplayOrder();
  _snapshotStr = _serializeWC();

  function renderCurrentTransforms(){
    const keys = scopeKeys();
    const scopeTotal = keys.size;

    // Count how many scoped mappings have each transform
    const countMap = new Map();
    for(const [ekey, tArr] of workingCopy){
      if(!keys.has(ekey)) continue;
      for(const inst of tArr){
        const k = makeKey(inst);
        countMap.set(k, (countMap.get(k)||0) + 1);
        if(!_instByKey.has(k)) _instByKey.set(k, inst);
      }
    }

    // Filter displayOrder to only keys present in scoped edges
    for(let i = _displayOrder.length - 1; i >= 0; i--){
      if(!countMap.has(_displayOrder[i])) _displayOrder.splice(i, 1);
    }
    // Add any new keys not yet in displayOrder
    for(const k of countMap.keys()){
      if(!_displayOrder.includes(k)) _displayOrder.push(k);
    }

    if(_displayOrder.length === 0){
      currentDiv.innerHTML = '<div style="opacity:.35;font-size:11px;padding:4px;">No transforms applied.</div>';
      return;
    }

    currentDiv.innerHTML = '';
    _displayOrder.forEach((key, idx)=>{
      const inst = _instByKey.get(key);
      if(!inst) return;
      const rid = transformRefId(inst);
      const t = transformById(rid);
      const label = t ? (t.label || t.id) : rid;
      const ps = (inst.params && Object.keys(inst.params).length > 0)
        ? Object.entries(inst.params).sort((a,b)=>a[0].localeCompare(b[0])).map(([k,v])=>`${k}=${v}`).join(', ') : '';
      const paramDisplay = ps ? ` (${ps})` : '';
      const count = countMap.get(key) || 0;
      const isFirst = idx === 0, isLast = idx === _displayOrder.length - 1;

      const row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;gap:6px;padding:5px 8px;border-radius:8px;transition:background .1s;';
      row.innerHTML = `
        <span style="display:flex;flex-direction:column;gap:1px;flex-shrink:0;">
          <button class="btn" data-move="up" style="font-size:8px;padding:0 3px;line-height:1.2;${isFirst?'opacity:.2;pointer-events:none;':''}">&#9650;</button>
          <button class="btn" data-move="down" style="font-size:8px;padding:0 3px;line-height:1.2;${isLast?'opacity:.2;pointer-events:none;':''}">&#9660;</button>
        </span>
        <span style="font-size:12px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(label)}<span style="opacity:.4;font-size:10px;">${escapeHtml(paramDisplay)}</span></span>
        <span style="font-size:10px;opacity:.35;font-family:var(--mono);flex-shrink:0;">${count}/${scopeTotal}</span>
        <button class="btn btnDanger" data-act="rm" style="font-size:10px;padding:2px 6px;">\u2212</button>`;
      row.addEventListener('mouseenter', ()=>{ row.style.background='rgba(255,255,255,.04)'; });
      row.addEventListener('mouseleave', ()=>{ row.style.background=''; });

      row.querySelector('[data-act="rm"]').addEventListener('click', ()=>{
        for(const [ekey, tArr] of workingCopy){
          if(!keys.has(ekey)) continue;
          workingCopy.set(ekey, tArr.filter(x=> makeKey(x) !== key));
        }
        _instByKey.delete(key);
        updateDirtyState();
        renderCurrentTransforms();
      });

      row.querySelectorAll('[data-move]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const dir = btn.dataset.move === 'up' ? -1 : 1;
          const ni = idx + dir;
          if(ni < 0 || ni >= _displayOrder.length) return;
          [_displayOrder[idx], _displayOrder[ni]] = [_displayOrder[ni], _displayOrder[idx]];
          const neighborKey = _displayOrder[idx];
          for(const [ekey, tArr] of workingCopy){
            if(!keys.has(ekey)) continue;
            const ai = tArr.findIndex(x=> makeKey(x) === key);
            const bi = tArr.findIndex(x=> makeKey(x) === neighborKey);
            if(ai >= 0 && bi >= 0 && Math.abs(ai - bi) === 1){
              [tArr[ai], tArr[bi]] = [tArr[bi], tArr[ai]];
            }
          }
          updateDirtyState();
          renderCurrentTransforms();
        });
      });

      currentDiv.appendChild(row);
    });
  }

  // Scope bar handler
  const scopeBar = document.getElementById('bulkTransformScopeBar');
  if(scopeBar){
    scopeBar.addEventListener('click', (ev)=>{
      const btn = ev.target.closest('[data-scope]');
      if(!btn) return;
      if(isDirty()) return; // blocked while dirty (tabs are visually disabled)
      _scope = btn.dataset.scope;
      scopeBar.querySelectorAll('[data-scope]').forEach(b=>{
        b.style.background = b.dataset.scope === _scope ? 'rgba(255,255,255,.08)' : '';
      });
      const se = scopeEdges();
      subtitleEl.textContent = `Add, remove, or reorder transforms across ${se.length} mapping${se.length>1?'s':''}.`;
      rebuildDisplayOrder();
      renderCurrentTransforms();
    });
  }

  sel.addEventListener('change', ()=>{
    const tid = sel.value;
    const t = transforms.find(x=>x.id===tid);
    if(!t){ paramsDiv.style.display = 'none'; addBtn.style.opacity='.4'; addBtn.style.pointerEvents='none'; return; }
    addBtn.style.opacity = '1'; addBtn.style.pointerEvents = 'auto';
    if(t.params && t.params.length > 0){
      paramsDiv.style.display = '';
      paramsDiv.innerHTML = t.params.map((p,pi)=>`
        <div style="display:flex;align-items:center;gap:8px;margin:4px 0;">
          <label for="btParam${pi}" style="font-size:11px;opacity:.6;flex:0 0 100px;">${escapeHtml(p.label||p.id)}</label>
          <input class="inp" id="btParam${pi}" name="btParam${pi}" type="${p.type==='number'?'number':'text'}" data-param-id="${escapeHtml(p.id)}" value="${escapeHtml(p.default!=null?String(p.default):'')}" style="flex:1;font-size:11px;padding:5px 8px;">
        </div>`).join('');
    } else { paramsDiv.style.display = 'none'; paramsDiv.innerHTML = ''; }
  });

  addBtn.addEventListener('click', ()=>{
    const tid = sel.value;
    const t = transforms.find(x=>x.id===tid);
    if(!t) return;
    const inst = { ref: tid };
    if(t.params && t.params.length > 0){
      inst.params = {};
      paramsDiv.querySelectorAll('[data-param-id]').forEach(inp=>{
        const val = inp.type==='number' ? (inp.value!=='' ? Number(inp.value) : '') : inp.value;
        if(val !== '') inst.params[inp.dataset.paramId] = val;
      });
    }
    const keys = scopeKeys();
    for(const [ekey, tArr] of workingCopy){
      if(!keys.has(ekey)) continue;
      tArr.push(JSON.parse(JSON.stringify(inst)));
    }
    const addKey = makeKey(inst);
    if(!_instByKey.has(addKey)){ _instByKey.set(addKey, inst); _displayOrder.push(addKey); }
    updateDirtyState();
    sel.value = ''; paramsDiv.style.display = 'none';
    addBtn.style.opacity='.4'; addBtn.style.pointerEvents='none';
    renderCurrentTransforms();
  });

  renderCurrentTransforms();

  mask.classList.add('active');
  dialog.classList.add('active');

  const rawClose = ()=>{ mask.classList.remove('active'); dialog.classList.remove('active'); _clearBulkMaskGuard(mask); };
  const { close, guardedClose } = _guardedCloseFactory(dialog, isDirty, 'Abandon unsaved changes?', rawClose);
  _setupBulkModalHeader(dialog, `Transforms (${allEdges.length} mapping${allEdges.length>1?'s':''})`, guardedClose);
  document.getElementById('bulkTransformCancel').addEventListener('click', rawClose);

  saveBtn.addEventListener('click', ()=>{
    if(!isDirty()){ close(); return; }
    pushUndo();
    for(const edge of allEdges){
      const key = edge.from + '|' + edge.to;
      const mapping = (state.data.mappings||[]).find(m=> m && m.from===edge.from && m.to===edge.to);
      if(mapping) mapping.transforms = workingCopy.get(key) || [];
    }
    markDirty();
    close();
    renderAll();
    applyHighlight();
    setGlobalStatus(`Updated transforms on ${allEdges.length} mapping${allEdges.length>1?'s':''}.`);
  });

  _setBulkMaskGuard(mask, (e)=>{ if(e.target===mask){ e.stopImmediatePropagation(); guardedClose(); } });
}

function showBulkMapModal(nodeIds){
  // Only fields can be mapped  filter to fields only
  const fieldIds = nodeIds.filter(nid => {
    const n = IDX.nodeById.get(nid);
    return n && n.type === 'field';
  });
  if(!fieldIds.length){ customAlert('No fields in selection. Only fields can be mapped (not groups).'); return; }

  const mask = _freshMask();
  const dialog = document.getElementById('customDialog');
  dialog.querySelectorAll('[data-guard-overlay]').forEach(el => el.remove());

  const body = dialog.querySelector('.modalBody');

  body.innerHTML = `
    <div style="font-size:12px;margin-bottom:14px;opacity:.55;line-height:1.5;">Search for a target field. A mapping will be created from each selected field to the chosen target.</div>
    <input type="text" id="bulkMapSearch" class="inp" placeholder="Search fields by name or ID" style="width:100%;margin-bottom:10px;">
    <div id="bulkMapResults" style="display:flex;flex-direction:column;gap:2px;max-height:340px;overflow-y:auto;padding:2px 0;"></div>
    <div style="margin-top:18px;display:flex;gap:8px;justify-content:flex-end;border-top:1px solid var(--border);padding-top:14px;">
      <button class="btn" id="bulkMapCancel">Cancel</button>
    </div>`;

  const searchInput = document.getElementById('bulkMapSearch');
  const resultsEl = document.getElementById('bulkMapResults');
  const sourceSet = new Set(fieldIds);

  function renderResults(term){
    const t = (term||'').toLowerCase().trim();
    const matches = [];
    for(const fid of IDX.fieldIds){
      if(sourceSet.has(fid)) continue;
      const node = IDX.nodeById.get(fid);
      if(!node) continue;
      const label = (node.label||'').toLowerCase();
      const id = (fid||'').toLowerCase();
      if(t && !label.includes(t) && !id.includes(t)) continue;
      matches.push({ id: fid, node });
      if(matches.length >= 50) break;
    }
    resultsEl.innerHTML = matches.map(m=>{
      const col = columnOf(m.id);
      const colIdx = IDX.columnIndex.get(col);
      const colObj = colIdx !== undefined ? IDX.columns[colIdx] : null;
      const colLabel = colObj ? (colObj.label||colObj.id) : '';
      return `<div style="cursor:pointer;padding:7px 10px;border-radius:8px;font-size:12.5px;display:flex;align-items:center;gap:8px;transition:background .1s;" data-target-id="${escapeHtml(m.id)}" onmouseenter="this.style.background='rgba(255,255,255,.06)'" onmouseleave="this.style.background=''">
        <span style="opacity:.35;font-size:10px;flex-shrink:0;"></span>
        <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:600;">${escapeHtml(m.node.label||m.id)}</span>
        <span style="opacity:.3;font-size:10px;font-family:var(--mono);flex-shrink:0;">${escapeHtml(colLabel)}</span>
      </div>`;
    }).join('') || '<div style="opacity:.4;font-size:12px;padding:10px;text-align:center;">No matching fields.</div>';

    resultsEl.querySelectorAll('[data-target-id]').forEach(el=>{
      el.addEventListener('click', ()=>{
        const targetId = el.dataset.targetId;
        pushUndo();
        let created = 0;
        for(const fid of fieldIds){
          const exists = (state.data.mappings||[]).some(m=> m && m.from===fid && m.to===targetId);
          if(!exists){
            state.data.mappings = state.data.mappings || [];
            state.data.mappings.push({ from: fid, to: targetId, cardinality:'', transforms:[], label:'', note:'', default:'' });
            created++;
          }
        }
        markDirty();
        renderAll();
        close();
        // Lock selection on target to show all new arrows as visual confirmation
        state.multiSelection.clear();
        state.lockedId = targetId;
        state.hoverId = null;
        state.selectedColumnId = null;
        state.selectedEdgeId = null;
        applyHighlight();
        scrollIntoView(targetId);
        setGlobalStatus(`Created ${created} mapping${created===1?'':'s'}  ${el.querySelector('span:nth-child(2)')?.textContent || targetId}`);
      });
    });
  }

  renderResults('');
  searchInput.addEventListener('input', ()=> renderResults(searchInput.value));

  mask.classList.add('active');
  dialog.classList.add('active');
  setTimeout(()=> searchInput.focus(), 50);

  const close = ()=>{ mask.classList.remove('active'); dialog.classList.remove('active'); _clearBulkMaskGuard(mask); };
  _setupBulkModalHeader(dialog, `Map ${fieldIds.length} field${fieldIds.length>1?'s':''} to`, close);
  document.getElementById('bulkMapCancel').addEventListener('click', close);
  _setBulkMaskGuard(mask, (e)=>{ if(e.target===mask){ e.stopImmediatePropagation(); close(); } });
}

function ensureMapping(fromId, toId, direction){
  if(!state.data) return;
  state.data.mappings = state.data.mappings || [];
  for(const m of state.data.mappings){
    if(!m || typeof m!=='object') continue;
    if(m.from===fromId && m.to===toId) return; // Already exists, no change
  }
  recordChange(); // Save BEFORE creating mapping
  state.data.mappings.push({ from: fromId, to: toId, cardinality:'', transforms: [], label:'', note:'', default:'', tags:[], customAttributes:{}, direction: direction || 'forward' });
}

// Determine mapping direction from modifier keys: Alt+Shift = both, Alt+Shift+Ctrl = none
function _dirFromModifiers(e){
  if(e && e.altKey && e.shiftKey && e.ctrlKey) return 'none';
  if(e && e.altKey && e.shiftKey) return 'both';
  return 'forward';
}
// Store last pointer event modifiers for drop handlers that don't have direct event access
let __lastDragModifiers = null;


// removed legacy addColumnAtVisibleIndex + hover zones
function addColumnAtVisibleIndex(insertIndex){
  if(!state.data){ return; }
  const cols = state.data.columns || (state.data.columns = []);
  let pos = 0;
  if(typeof insertIndex==='number' && insertIndex>=0){
    const visibleIds = (IDX.columns||[]).filter(c=>!state.hiddenColumns.has(c.id)).map(c=>c.id);
    if(visibleIds.length){
      if(insertIndex<=0){
        const firstId = visibleIds[0];
        const p = cols.findIndex(c=>c && c.id===firstId);
        pos = p>=0 ? p : 0;
      } else {
        const beforeId = visibleIds[Math.min(insertIndex-1, visibleIds.length-1)];
        const p = cols.findIndex(c=>c && c.id===beforeId);
        pos = p>=0 ? p+1 : cols.length;
      }
    } else {
      pos = cols.length;
    }
  } else {
    pos = cols.length;
  }
  const taken = new Set(cols.map(c=>c.id));
  openCreateModal({
    kind: 'column',
    title: 'Add column',
    placeholder: 'Column title',
    hint: 'ID is generated from the title (no dots) and made unique.',
    taken,
    onCommit: ({label, id, note, color, _autoId})=>{
      if(cols.some(c=>c.id===id)) return;
      recordChange(); // Save BEFORE add
      const newCol = { id, label, note: (note||''), _autoId, schema: { id, label, _autoId, type:'group', children: [] } };
      if(color) newCol.color = color;
      cols.splice(Math.max(0, Math.min(pos, cols.length)), 0, newCol);
      state.hiddenColumns.delete(id);
      renderAll();
      state.selectedColumnId = id; state.lockedId = id; state.hoverId=null; state.selectedEdgeId=null;
      applyHighlight();
      setGlobalStatus('Added column '+id);
    }
  });
}

// ---- Column header actions (select + delete) ----
function collectFieldIdsOfColumn(col){
  const out=[];
  (function walk(n){
    if(!n || typeof n!=='object') return;
    if(n.type==='field') out.push(n.id);
    (n.children||[]).forEach(walk);
  })(col.schema);
  return out;
}

async function deleteColumnById(colId){
  if(!state.data) return;
  const cols = state.data.columns || [];
  if(cols.length<=0){
    customAlert('No columns to delete.');
    return;
  }
  const col = cols.find(c=>c && c.id===colId);
  if(!col) return;
  const colLabel = col.label || col.id;
  // Count contents
  let fieldCount = 0, groupCount = 0;
  (function walk(n){ if(!n) return; if(n.type==='field') fieldCount++; else if(n.type==='group') groupCount++; (n.children||[]).forEach(walk); })(col.schema);
  const killFields = collectFieldIdsOfColumn(col);
  const killSet = new Set(killFields);
  const mapCount = (state.data.mappings||[]).filter(m => m && (killSet.has(m.from) || killSet.has(m.to))).length;
  const contentParts = [];
  if(fieldCount) contentParts.push(fieldCount + ' field' + (fieldCount>1?'s':''));
  if(groupCount) contentParts.push(groupCount + ' group' + (groupCount>1?'s':''));
  const contentInfo = contentParts.length ? `\n\nContains ${contentParts.join(' and ')}.` : '';
  const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
  if(!await customConfirm(`Delete column "${colLabel}" (${colId})?${contentInfo}${mapInfo}`)) return;
  recordChange(); // Save BEFORE delete
  removeMappingsReferencingInState(killFields);
  state.data.columns = cols.filter(c=>c && c.id!==colId);
  state.hiddenColumns.delete(colId);
  if(state.selectedColumnId===colId) state.selectedColumnId = null;
  if(state.lockedId===colId) state.lockedId = null;
  renderAll();
  buildColumnsMenu();
  setGlobalStatus('Deleted column '+colId);
}


function addColumnLeftOf(colId){
  // Insert a new column immediately to the left of the given visible column id
  const visible = IDX.columns.filter(c=> !state.hiddenColumns.has(c.id)).map(c=>c.id);
  const idx = Math.max(0, visible.indexOf(colId));
  addColumnAtVisibleIndex(idx);
}
function addColumnRightOf(colId){
  const visible = IDX.columns.filter(c=> !state.hiddenColumns.has(c.id)).map(c=>c.id);
  const idx = visible.indexOf(colId);
  const ins = (idx<0) ? visible.length : idx+1;
  addColumnAtVisibleIndex(ins);
}
function moveColumn(colId, dir){
  if(!state.data) return;
  const cols = state.data.columns || [];
  const i = cols.findIndex(c=>c && c.id===colId);
  if(i<0) return;
  const j = i + (dir<0?-1:1);
  if(j<0 || j>=cols.length) return;
  const tmp = cols[i]; cols[i] = cols[j]; cols[j] = tmp;
  renderAll();
  // keep selection stable
  state.selectedColumnId = colId; state.lockedId = colId; state.hoverId=null; state.selectedEdgeId=null;
  applyHighlight();
}
function customPrompt(message, defaultValue){
  return new Promise((resolve) => {
    _ensureDialogBody();
    const mask = document.getElementById('customDialogMask');
    const dialog = document.getElementById('customDialog');
    const messageEl = document.getElementById('customDialogMessage');
    const buttonsEl = document.getElementById('customDialogButtons');
    
    messageEl.textContent = message;
    buttonsEl.innerHTML = '';
    const hdr = dialog.querySelector('.modalHeader');
    if(hdr) hdr.style.display = 'none';
    
    const inputEl = document.createElement('input');
    inputEl.className = 'inp';
    inputEl.type = 'text';
    inputEl.value = defaultValue || '';
    inputEl.style.cssText = 'width:100%;margin-bottom:16px;';
    messageEl.after(inputEl);
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.minWidth = '80px';
    cancelBtn.addEventListener('click', () => { cleanup(); resolve(null); });
    
    const okBtn = document.createElement('button');
    okBtn.className = 'btn';
    okBtn.textContent = 'OK';
    okBtn.style.cssText = 'min-width:80px;background:rgba(59,130,246,0.15);border-color:rgba(59,130,246,0.4);color:rgba(96,165,250,1);';
    okBtn.addEventListener('click', () => { cleanup(); resolve(inputEl.value); });
    
    buttonsEl.appendChild(cancelBtn);
    buttonsEl.appendChild(okBtn);
    
    mask.classList.add('active');
    dialog.classList.add('active');
    setTimeout(()=>{ inputEl.focus(); inputEl.select(); }, 50);
    
    const cleanup = ()=>{
      inputEl.remove();
      mask.classList.remove('active');
      dialog.classList.remove('active');
      document.removeEventListener('keydown', onKey);
    };
    const onKey = (e) => {
      if(e.key === 'Escape'){ e.preventDefault(); e.stopPropagation(); cleanup(); resolve(null); }
      if(e.key === 'Enter'){ e.preventDefault(); e.stopPropagation(); cleanup(); resolve(inputEl.value); }
    };
    document.addEventListener('keydown', onKey);
    mask.addEventListener('click', () => { cleanup(); resolve(null); }, {once: true});
  });
}

function renameColumnFromViewer(colId){
  const col = findColumnById(colId);
  if(!col) return;
  customPrompt('New label for column '+colId+':', col.label || col.id).then(v => {
    if(v===null) return;
    const oldId = col.id;
    const newId = renameColumnInData(state.data, oldId, v);
    state.selectedColumnId = newId; state.lockedId = newId; state.hoverId=null; state.selectedEdgeId=null;
    renderAll();
    applyHighlight();
  });
}
function openColumnMenu(anchorEl, colId, pos){
  const cols = state.data?.columns || [];
  const i = cols.findIndex(c=>c && c.id===colId);
  const canMoveLeft = i>0;
  const canMoveRight = i>=0 && i<cols.length-1;
  openCtxMenu([
    { label:'Edit column',        icon:ICONS.edit,   onClick: ()=> selectColumn(colId) },
    { type:'label', text:'Add child' },
    { label:'Field on top',       icon:ICONS.addFieldUp,   onClick: ()=> addChildNode(colId, colId, true,  true) },
    { label:'Field at bottom',    icon:ICONS.addFieldDown, onClick: ()=> addChildNode(colId, colId, true,  false) },
    { label:'Group on top',       icon:ICONS.addGroupUp,   onClick: ()=> addChildNode(colId, colId, false, true) },
    { label:'Group at bottom',    icon:ICONS.addGroupDown, onClick: ()=> addChildNode(colId, colId, false, false) },
    { type:'sep' },
    { label:'Import fields',    icon:ICONS.importFields, onClick: ()=> openImportFields(colId) },
    { type:'label', text:'Arrange' },
    { label:'Move column left',   icon:ICONS.moveLeft,   disabled:!canMoveLeft,  onClick: ()=> moveColumn(colId, -1) },
    { label:'Move column right',  icon:ICONS.moveRight,  disabled:!canMoveRight, onClick: ()=> moveColumn(colId, +1) },
    { type:'sep' },
    { label:'Insert column left', icon:ICONS.insertColLeft,  onClick: ()=> addColumnLeftOf(colId) },
    { label:'Insert column right',icon:ICONS.insertColRight, onClick: ()=> addColumnRightOf(colId) },
    { type:'sep' },
    { label:'Hide column',      icon:ICONS.hide, onClick: ()=> {
        state.hiddenColumns.add(colId); 
        state.selectedEdgeId = null;
        state.hoverEdgeId = null;
        state.lockedId = null;
        state.hoverId = null;
        renderAll();
      } },
    { type:'sep' },
    { label:'Delete',      icon:ICONS.trash, danger:true, onClick: ()=> deleteColumnById(colId) },
  ], anchorEl, pos);
  __ctxMenuColId = colId;
}function selectColumn(colId){
  if(state.editorMode && state.selectedEdgeId){ clearEdgeEditSession({clearSelection:true}); }
  // Revert any pending node edit session
  let didRevert = false;
  if(state.editorMode && __editSnapshot && __editSnapshot.data && __editSnapshot.kind==='node'){
    revertEditSnapshot();
    __editSnapshot = null;
    didRevert = true;
    checkDirtyState();
  }
state.selectedColumnId = colId;
  state.lockedId = colId;
  state.hoverId = null;
  state.selectedEdgeId = null;
  state.multiSelection.clear();
  if(didRevert) renderAll();
  updateColumnHeaderSelectionStyles();
 applyHighlight();
  scrollIntoView(colId);
}

function attachColumnHeaderActions(){
  const panels = Array.from(columnsRow.querySelectorAll('.panel'));
  for(const panel of panels){
    const colId = panel.dataset.columnId;
    const header = panel.querySelector('.panelHeader');
    if(!header) continue;

    header.classList.add('clickable');

    // Remove any legacy header actions when switching modes
    const existing = header.querySelector('.colActions');
    if(existing) existing.remove();

    // Add actions (different for editor vs viewer mode)
    const actions = document.createElement('div');
    actions.className='colActions';
    actions.style.display='flex';
    actions.style.gap='6px';
    actions.style.alignItems='center';

    if(state.editorMode){
      // Editor mode: hide button + menu button
      const btnHide = document.createElement('button');
      btnHide.className='miniBtn';
      btnHide.title='Hide column';
      btnHide.innerHTML=ICONS.hide;
      btnHide.style.opacity = '0.7'; btnHide.style.display='inline-flex'; btnHide.style.alignItems='center'; btnHide.style.justifyContent='center';
      actions.appendChild(btnHide);
      btnHide.addEventListener('click', async (e)=>{
        e.stopPropagation();
        if(nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        closeCtxMenu();
        state.hiddenColumns.add(colId);
        state.selectedEdgeId = null;
        state.hoverEdgeId = null;
        state.lockedId = null;
        state.hoverId = null;
        renderAll();
      });

      const btnMenu = document.createElement('button');
      btnMenu.className='miniBtn';
      btnMenu.title='Column actions';
      btnMenu.textContent='';
      actions.appendChild(btnMenu);
      
      btnMenu.addEventListener('click', async (e)=>{ 
        e.stopPropagation(); 
        
        // Menu is still open (capture handler skips miniBtn)  toggle it closed
        if(__ctxMenuEl && __ctxMenuColId === colId){
          closeCtxMenu();
          return;
        }
        
        // Close any other open menu first
        closeCtxMenu();
        
        // Guard unsaved node/edge edits before switching to this column
        if(nodeEditIsDirty() && __editSnapshot?.id !== colId){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        if(edgeEditIsDirty()){
          if(!await guardAbandonEdit('mapping', __edgeEditSession?.edgeId || '')) return;
        }
        
        // Select column if not already selected
        const savedRect = btnMenu.getBoundingClientRect();
        if(state.selectedColumnId !== colId || state.lockedId !== colId){
          selectColumn(colId);
        }
        // After potential re-render, find the new menu button in the rebuilt DOM
        const newPanel = columnsRow.querySelector(`.panel[data-column-id="${colId}"]`);
        const allBtns = newPanel ? Array.from(newPanel.querySelectorAll('.colActions .miniBtn')) : [];
        const newBtn = allBtns[1] || allBtns[0]; // second button is menu button
        const anchor = (newBtn && newBtn.getBoundingClientRect().width > 0) ? newBtn : {
          getBoundingClientRect(){ return savedRect; },
          closest(){ return null; },
          contains(){ return false; }
        };
        openColumnMenu(anchor, colId);
      });
    } else {
      // Viewer mode: hide column button
      const btnHide = document.createElement('button');
      btnHide.className='miniBtn';
      btnHide.title='Hide column';
      btnHide.innerHTML=ICONS.hide;
      btnHide.style.opacity = '0.7'; btnHide.style.display='inline-flex'; btnHide.style.alignItems='center'; btnHide.style.justifyContent='center';
      actions.appendChild(btnHide);
      
      btnHide.addEventListener('click', (e)=>{
        e.stopPropagation();
        state.hiddenColumns.add(colId);
        state.selectedEdgeId = null;
        state.hoverEdgeId = null;
        state.lockedId = null;
        state.hoverId = null;
        renderAll();
      });
    }
    
    header.appendChild(actions);

    // Bind header click once (viewer + editor)
    if(header.dataset.colClickBound !== '1'){
      header.dataset.colClickBound = '1';
      header.addEventListener('click', async (e)=>{
        if(state.selectedColumnId===colId && state.lockedId===colId){
          state.selectedColumnId = null;
          state.selectedEdgeId = null;
          state.lockedId = null;
          state.hoverId = null;
          __editSnapshot = null;
          updateColumnHeaderSelectionStyles();
          renderAll();
          applyHighlight();
          return;
        }
        if(state.editorMode && nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        if(state.editorMode && edgeEditIsDirty()){
          const eid = __edgeEditSession?.edgeId || '';
          if(!await guardAbandonEdit('mapping', eid)) return;
        }
        selectColumn(colId);
      });
    }

    // Column header hover preview
    if(header.dataset.colHoverBound !== '1'){
      header.dataset.colHoverBound = '1';
      header.addEventListener('mouseenter', ()=>{
        // Don't preview if something is locked/selected/editing
        if(state.lockedId || state.selectedColumnId || state.selectedEdgeId || state.multiSelection.size > 0) return;
        if(__editSnapshot || __edgeEditSession) return;
        renderColumnHoverPreview(colId);
      });
      header.addEventListener('mouseleave', ()=>{
        if(state.lockedId || state.selectedColumnId || state.selectedEdgeId || state.multiSelection.size > 0) return;
        if(__editSnapshot || __edgeEditSession) return;
        applyHighlight(); // restores default project view
      });
    }
  }
}

function renderColumnHoverPreview(colId){
  const col = findColumnById(colId);
  if(!col) return;
  const fieldCount = (IDX.nodeFieldDescendants.get(colId) || []).length;
  const groupCount = (() => {
    let c = 0;
    const walk = (n) => { if(n.type==='group') c++; (n.children||[]).forEach(walk); };
    if(col.schema) walk(col.schema);
    return c > 0 ? c - 1 : 0;
  })();
  const colEdges = (IDX.edges||[]).filter(e =>
    (columnOf(e.from) === colId || columnOf(e.to) === colId)
  );
  detailsMeta.textContent = 'hover';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtHero">
        <div class="dtName">${escapeHtml(col.label||col.id)}</div>
        <span class="dtType column">Column</span>
      </div>
      <div class="dtRow">
        <span class="dtRowK">ID</span>
        <span class="dtRowV"><span class="dtId">${escapeHtml(colId)}${isLikelyAutoId(col) ? '<span class="autoTag">auto</span>' : ''}</span></span>
      </div>
      ${col.note ? `<div class="dtNote">${escapeHtml(col.note)}</div>` : ''}
      ${col.color ? `<div class="dtRow">
        <span class="dtRowK">Color</span>
        <span class="dtRowV"><span class="dtColorSwatch" style="background:${escapeHtml(col.color)};"></span> <span style="font-family:var(--mono);font-size:11px;opacity:.55;">${escapeHtml(col.color)}</span></span>
      </div>` : ''}
      <div class="dtStatRow">
        <span class="dtStatChip"><span class="dtStatN">${fieldCount}</span><span class="dtStatL">field${fieldCount!==1?'s':''}</span></span>
        <span class="dtStatChip"><span class="dtStatN">${groupCount}</span><span class="dtStatL">group${groupCount!==1?'s':''}</span></span>
        <span class="dtStatChip"><span class="dtStatN">${colEdges.length}</span><span class="dtStatL">mapping${colEdges.length!==1?'s':''}</span></span>
      </div>
    </div>
  `;
}

function renderSelectedColumnViewer(){
  if(!state.selectedColumnId) return false;
  if(state.editorMode) return false; // editor mode uses renderSelectedColumnEditor
  const colId = state.selectedColumnId;
  if(state.lockedId !== colId) return false;
  const col = findColumnById(colId);
  if(!col) return false;

  const fieldCount = (IDX.nodeFieldDescendants.get(colId) || []).length;
  const groupCount = (() => {
    let c = 0;
    const walk = (n) => { if(n.type==='group') c++; (n.children||[]).forEach(walk); };
    if(col.schema) walk(col.schema);
    return c > 0 ? c - 1 : 0; // exclude root
  })();
  // Count mappings with at least one endpoint in this column
  const colEdges = (IDX.edges||[]).filter(e =>
    (columnOf(e.from) === colId || columnOf(e.to) === colId)
  );

  detailsMeta.textContent = 'column';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtHero">
        <div class="dtName">${escapeHtml(col.label||col.id)}</div>
        <span class="dtType column">Column</span>
      </div>
      <div class="dtRow">
        <span class="dtRowK">ID</span>
        <span class="dtRowV"><span class="dtId">${escapeHtml(colId)}${isLikelyAutoId(col) ? '<span class="autoTag">auto</span>' : ''}</span></span>
      </div>
      ${col.note ? `<div class="dtNote">${escapeHtml(col.note)}</div>` : ''}
      ${col.color ? `<div class="dtRow">
        <span class="dtRowK">Color</span>
        <span class="dtRowV"><span class="dtColorSwatch" style="background:${escapeHtml(col.color)};"></span> <span style="font-family:var(--mono);font-size:11px;opacity:.55;">${escapeHtml(col.color)}</span> <span style="font-size:10px;opacity:.35;">applied</span></span>
      </div>` : ''}
      <div class="dtStatRow">
        <span class="dtStatChip"><span class="dtStatN">${fieldCount}</span><span class="dtStatL">field${fieldCount!==1?'s':''}</span></span>
        <span class="dtStatChip"><span class="dtStatN">${groupCount}</span><span class="dtStatL">group${groupCount!==1?'s':''}</span></span>
        <span class="dtStatChip"><span class="dtStatN">${colEdges.length}</span><span class="dtStatL">mapping${colEdges.length!==1?'s':''}</span></span>
      </div>
    </div>
  `;
  updateColumnHeaderSelectionStyles();
  return true;
}

function renderSelectedColumnEditor(){
  if(!state.editorMode || !state.selectedColumnId) return false;
  const colId = state.selectedColumnId;
  if(state.lockedId !== colId) return false;
  const col = findColumnById(colId);
  if(!col) return false;

  const fieldCount = (IDX.nodeFieldDescendants.get(colId) || []).length;
  beginEditSnapshot('column', colId);
 detailsMeta.textContent = 'column';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtEditorHead">
        <span class="dtType column">Column</span>
        <span class="dtEditorLabel">Editor</span>
      </div>
      <div class="kv" style="grid-template-columns: 80px 1fr;">
        <div class="k">Label<span class="req">*</span></div><div class="v"><input class="inp" id="colLabel" value="${escapeHtml(col.label||col.id)}"/></div>
        <div class="k">ID <span class="autoTag" id="colIdAuto">auto</span></div><div class="v" style="display:flex;align-items:center;gap:0;"><input class="inp" id="colId" value="${escapeHtml(col.id)}" style="font-family:var(--mono);font-size:11px;flex:1;"/></div>
        <div class="k">Note</div><div class="v"><input class="inp" id="colNote" value="${escapeHtml(col.note||'')}" placeholder="optional"/></div>
        <div class="k">Color</div><div class="v" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
          <div id="colColorSwatches" style="display:flex;gap:3px;flex-wrap:wrap;"></div>
          <div style="display:flex;align-items:center;gap:6px;flex-basis:100%;">
          <input type="color" id="colColor" value="${escapeHtml(col.color||col._pendingColor||'#3b82f6')}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${col.color?'':'opacity:.3;'}"/>
          <input class="inp" id="colColorHex" value="${escapeHtml(col.color||'')}" placeholder="optional" style="flex:1;font-family:var(--mono);font-size:11px;max-width:100px;"/>
          <label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" id="colColorOn" ${col.color?'checked':''}/> Apply</label>
          </div>
          <div style="font-size:10px;opacity:.35;flex-basis:100%;">Colors header &amp; child nodes without own color</div>
        </div>
        <div class="k">Fields</div><div class="v"><span class="dtStatChip" style="padding:2px 7px;"><span class="dtStatN" style="font-size:12px;">${fieldCount}</span></span></div>
      </div>
      <div class="dtActions">
        <button class="btn" id="colDelete" style="border-color: rgba(255,154,168,.45);">Delete</button>
        <span class="spacer"></span>
        <button class="btn" id="colCancel">Cancel</button>
        <button class="btn btnSave" id="colSave">Save</button>
      </div>
      <div class="dtHint">Changing the column ID will rewrite all descendant node IDs and mappings.</div>
    </div>
  `;

  document.getElementById('colSave')?.addEventListener('click', async ()=>{
  const newLabel = (document.getElementById('colLabel')?.value || '').trim() || col.label || col.id;
  const newId = sanitizeManualId(document.getElementById('colId')?.value || '') || col.id;
  const newNote = (document.getElementById('colNote')?.value || '');
  const oldId = col.id;
  recordChange(); // Save BEFORE changes

  // Update label and note (independent of ID)
  col.label = newLabel;
  col.note = newNote;

  // Update column color
  const colColorOn = document.getElementById('colColorOn')?.checked;
  const colColorVal = document.getElementById('colColor')?.value || '';
  if(colColorOn && colColorVal){ col.color = colColorVal; }
  else { delete col.color; if(colColorVal && colColorVal !== '#3b82f6') col._pendingColor = colColorVal; else delete col._pendingColor; }

  // Persist auto-ID state
  col._autoId = __editorAutoId;

  // Update ID if changed
  let finalColId = oldId;
  if(newId !== oldId){
    const result = reIdColumnInData(state.data, oldId, newId);
    if(result === oldId){
      setGlobalStatus('Column ID conflict  ID not changed (duplicate).');
    } else {
      finalColId = result;
    }
  }

  __editSnapshot = null;
  // Stay on the column after save (use finalColId in case ID was changed)
  state.selectedColumnId = finalColId;
  state.lockedId = finalColId;
  state.selectedEdgeId = null;
  state.hoverId = null;
  state.__hoverCooldownUntil = Date.now() + 400;
  renderAll();
  setGlobalStatus('Saved column.');
});

  document.getElementById('colCancel')?.addEventListener('click', ()=>{
    const stayColId = state.selectedColumnId;
    revertEditSnapshot();
    __editSnapshot = null;
    state.selectedColumnId = stayColId; // stay on column
    state.lockedId = stayColId;
    state.selectedEdgeId = null;
    state.hoverId = null;
    state.__hoverCooldownUntil = Date.now() + 400;
    checkDirtyState();
    renderAll();
    setGlobalStatus('Cancelled changes.');
  });
 document.getElementById('colDelete')?.addEventListener('click', ()=> deleteColumnById(colId));
  // Column color swatches, hex input, and checkbox
  {
    const _colColorPicker = document.getElementById('colColor');
    const _colColorOn = document.getElementById('colColorOn');
    const _colColorHex = document.getElementById('colColorHex');
    const _colSwatchWrap = document.getElementById('colColorSwatches');
    const _kick = ()=>{ const s = document.getElementById('colSave'); if(s && s.__dirtyUpdate) s.__dirtyUpdate(); };
    if(_colSwatchWrap && _colColorPicker){
      buildColorSwatches(_colSwatchWrap, _colColorPicker, _colColorOn, _kick);
      _colColorPicker.addEventListener('input', ()=>{
        if(_colColorOn) _colColorOn.checked = true;
        _colColorPicker.style.opacity = '1';
        if(_colColorHex) _colColorHex.value = _colColorPicker.value;
        _kick();
      });
      _colColorPicker.addEventListener('change', _kick);
    }
    if(_colColorHex){
      _colColorHex.addEventListener('input', ()=>{
        const v = (_colColorHex.value||'').trim();
        if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
          if(_colColorPicker) _colColorPicker.value = v;
          if(_colColorOn) _colColorOn.checked = true;
          if(_colColorPicker) _colColorPicker.style.opacity = '1';
        }
        _kick();
      });
    }
    if(_colColorOn){
      _colColorOn.addEventListener('change', ()=>{
        if(_colColorPicker) _colColorPicker.style.opacity = _colColorOn.checked ? '1' : '.3';
        _kick();
      });
    }
  }
  wireDirtyHighlight(detailsBody, document.getElementById('colSave'), nodeEditIsDirty, ()=> !!(document.getElementById('colLabel')?.value||'').trim());
  // Column labelid auto-fill
  {
    const _colLabelInp = document.getElementById('colLabel');
    const _colIdInp = document.getElementById('colId');
    const _colIdAutoTag = document.getElementById('colIdAuto');
    if(_colLabelInp && _colIdInp){
      const _slugCol = (raw)=> idPartFromLabel(raw, {lower:true});
      const initLabel = _colLabelInp.value.trim();
      const initIdAuto = _slugCol(initLabel) || '';
      let _lastAutoId = col._autoId ? initIdAuto : '';
      __editorAutoId = _lastAutoId !== '';
      const _refreshTag = ()=>{ if(_colIdAutoTag) _colIdAutoTag.style.display = _lastAutoId !== '' ? '' : 'none'; };
      _refreshTag();
      _colLabelInp.addEventListener('input', ()=>{
        const cur = _colIdInp.value.trim();
        if(!cur || cur === _lastAutoId){ const ai = _slugCol(_colLabelInp.value.trim())||''; _colIdInp.value = ai; _lastAutoId = ai; }
        __editorAutoId = _lastAutoId !== '';
        _refreshTag();
      });
      _colIdInp.addEventListener('input', ()=>{
        if(!_colIdInp.value.trim()){ const ai = _slugCol(_colLabelInp.value.trim())||''; _colIdInp.value = ai; _lastAutoId = ai; }
        else _lastAutoId = '';
        __editorAutoId = _lastAutoId !== '';
        _refreshTag();
      });
    }
  }
  return true;
}




function renderSelectedNodeEditor(nodeId){
  if(!state.editorMode) return false;
  if(!nodeId) return false;
  // avoid column editor overlap
  if(state.selectedColumnId && nodeId===state.selectedColumnId) return false;
  const node = IDX.nodeById.get(nodeId);
  if(!node || (node.type!=='field' && node.type!=='group')) return false;
  const __isLocked = (state.lockedId === nodeId);
  // Only show editor for locked (clicked) selections; hover falls through to viewer preview
  if(!__isLocked) return false;

  // Start snapshot for cancel
  beginEditSnapshot('node', nodeId);
  normalizeNodeTags(node);
  normalizeCustomAttributes(node);
  normalizeNodeNote(node);

  const isFieldNode = node.type==='field';

  // Build a summary like normal details does
  const selectedFields = new Set((IDX.nodeFieldDescendants.get(nodeId) || (IDX.fieldIds.has(nodeId) ? [nodeId] : [])));
  const inbound = [];
  const outbound = [];
  const linked = [];
  const candidates = node.type==='field' ? (IDX.edgesByField.get(nodeId) || []) : IDX.edges;
  const seen = new Set();
  for(const e of candidates){
    if(!e || seen.has(e.id)) continue;
    if(node.type!=='field'){
      if(!(selectedFields.has(e.from) || selectedFields.has(e.to))) continue;
    }
    seen.add(e.id);
    const dir = e.direction || 'forward';
    if(dir === 'none'){
      if(selectedFields.has(e.from) || selectedFields.has(e.to)) linked.push(e);
    } else if(dir === 'both'){
      if(selectedFields.has(e.from) && !selectedFields.has(e.to)){ outbound.push(e); inbound.push(e); }
      else if(selectedFields.has(e.to) && !selectedFields.has(e.from)){ inbound.push(e); outbound.push(e); }
    } else {
      if(selectedFields.has(e.from) && !selectedFields.has(e.to)) outbound.push(e);
      if(selectedFields.has(e.to) && !selectedFields.has(e.from)) inbound.push(e);
    }
  }
  inbound.sort(compareEdgesSimple);
  outbound.sort(compareEdgesSimple);
  linked.sort(compareEdgesSimple);
  const summaryParts2 = [`Inbound: ${inbound.length}`, `Outbound: ${outbound.length}`];
  if(linked.length) summaryParts2.push(`Linked: ${linked.length}`);
  const summary = summaryParts2.join('  ');
  function ioItem(edge, dir){
    const jump = dir === 'linked' ? (selectedFields.has(edge.from) ? edge.to : edge.from) : (dir==='out') ? edge.to : edge.from;
    const jumpNode = IDX.nodeById.get(jump);
    const jumpLabel = jumpNode?.label ?? jump;
    const side = columnOf(jump) ?? 'node';
    const title = escapeHtml(edgeTooltip(edge));
    const eDir = edge.direction || 'forward';
    const arrowSym = eDir === 'none' ? '' : eDir === 'both' ? '' : '';
    // Perspective-aware route
    let dFrom = edge.from, dTo = edge.to;
    if(eDir === 'both' || eDir === 'none'){
      if(dir === 'out' && !selectedFields.has(edge.from) && selectedFields.has(edge.to)){ dFrom = edge.to; dTo = edge.from; }
      else if(dir === 'in' && selectedFields.has(edge.from) && !selectedFields.has(edge.to)){ dFrom = edge.to; dTo = edge.from; }
      else if(dir === 'linked' && !selectedFields.has(edge.from) && selectedFields.has(edge.to)){ dFrom = edge.to; dTo = edge.from; }
    }
    const route = `${dFrom} ${arrowSym} ${dTo}`;
    const prefix = dir === 'linked' ? '' : (dir==='out') ? 'out' : 'in';
    const dirBadge = eDir === 'both' ? '<span class="pill" style="opacity:.6;" title="Bidirectional"></span>' : eDir === 'none' ? '<span class="pill" style="opacity:.6;" title="Linked"></span>' : '';
    return `
      <li class="item" data-jump-id="${escapeHtml(jump)}" data-edge="${escapeHtml(edge.id)}" title="${title}">
        <span class="pill">${escapeHtml(side)}</span>
        <span class="pill">${escapeHtml(prefix)}</span>
        ${dirBadge}
        <span class="itemActions" aria-hidden="true"><button class="miniBtn" data-act="editMap" title="Edit mapping"></button><button class="miniBtn" data-act="goTo" title="Go to mapped node"></button><button class="miniBtn danger" data-act="delMap" title="Delete mapping"></button></span>
 <span class=\"itemBreak\"></span>
        <span class="txt">${escapeHtml(jumpLabel)}</span>
        ${badgeHtml(edge)}
        ${edge.label ? `<span class="tag" title="Label" style="font-weight:600;font-size:10px;opacity:.85;">${escapeHtml(edge.label)}</span>` : ''}
        <span class="route">${escapeHtml(route)}</span>${(edge.note && String(edge.note).trim()) ? `<span class="mapNote">${escapeHtml(short(edge.note, 120))}</span>` : ``}
      </li>
    `;
  }


  detailsMeta.textContent = 'node';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtEditorHead">
        <span class="dtType${node.type==='group'?' group':''}">${escapeHtml(node.type)}</span>
        <span class="dtEditorLabel">Editor</span>
      </div>
      <div class="kv" style="grid-template-columns: 80px 1fr;">
        <div class="k">Label<span class="req">*</span></div><div class="v"><input class="inp" id="ndLabel" value="${escapeHtml(node.label||'')}" placeholder="${escapeHtml(node.id)}"/></div>
        <div class="k">ID <span class="autoTag" id="ndIdAuto">auto</span></div><div class="v" style="display:flex;align-items:center;gap:0;"><span style="font-family:var(--mono);font-size:11px;opacity:.55;white-space:nowrap;">${escapeHtml(idPathPrefix(node.id))}</span><input class="inp" id="ndId" value="${escapeHtml(localIdSegment(node.id))}" style="font-family:var(--mono);font-size:11px;flex:1 1 auto;min-width:80px;"/></div>
        <div class="k">Summary</div><div class="v"><div class="dtStatRow" style="padding:0;"><span class="dtStatChip" style="padding:2px 7px;"><span class="dtStatN" style="font-size:11px;">${inbound.length}</span><span class="dtStatL">in</span></span><span class="dtStatChip" style="padding:2px 7px;"><span class="dtStatN" style="font-size:11px;">${outbound.length}</span><span class="dtStatL">out</span></span>${linked.length ? `<span class="dtStatChip" style="padding:2px 7px;"><span class="dtStatN" style="font-size:11px;">${linked.length}</span><span class="dtStatL">linked</span></span>` : ''}</div></div>
        <div class="k">Note</div><div class="v"><input class="inp" id="ndNote" value="${escapeHtml(node.note||'')}" placeholder="optional"/></div>
        <div class="k">Color</div><div class="v" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
          <div id="ndColorSwatches" style="display:flex;gap:3px;flex-wrap:wrap;"></div>
          <div style="display:flex;align-items:center;gap:6px;flex-basis:100%;">
          <input type="color" id="ndColor" value="${escapeHtml(node.color||node._pendingColor||'#3b82f6')}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${node.color?'':'opacity:.3;'}"/>
          <input class="inp" id="ndColorHex" value="${escapeHtml(node.color||'')}" placeholder="optional" style="flex:1;font-family:var(--mono);font-size:11px;max-width:100px;"/>
          <label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" id="ndColorOn" ${node.color?'checked':''}/> Apply</label>
          </div>
        </div>

        <div class="k">Tags</div>
        <div class="v">
          <div id="ndTagChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
          <div id="ndAttrInlineControls" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <select class="inp" id="ndTagSel" style="max-width:280px;flex:0 0 auto;"><option value="">Add tag</option></select>
            <button class="btn" id="ndTagNew" type="button">Tags</button>
          </div>
        </div>

        <div class="k">Custom</div>
        <div class="v">
          <div id="ndAttrChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <select class="inp" id="ndAttrSel" style="max-width:240px;flex:0 0 auto;"><option value="">Attribute</option></select>
            <select class="inp" id="ndAttrValSel" style="max-width:240px;flex:0 0 auto;"><option value="">Value</option></select>
                        <button class="btn" id="ndAttrCatalog" type="button">Attributes</button>
          </div>
          <div class="dtHint" style="padding:4px 0;">Choose an attribute and a value. Use Attributes to manage attributes/values.</div>
          <div id="multiValsWrap" class="multiVals hidden"></div>
        </div>
      </div>

      <div class="dtActions">
        <button class="btn" id="ndDelete" style="border-color:rgba(255,154,168,.45);">Delete</button>
        <span class="spacer"></span>
        <button class="btn" id="ndCancel">Cancel</button>
        <button class="btn btnSave" id="ndSave">Save</button>
      </div>
    </div>
    ${(!isFieldNode && node.children && node.children.length) ? `
    <div class="box detailSection collapsed">
      <h3 class="detailSectionHead"><span>Children</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${node.children.length}</span></h3>
      <div class="detailSectionBody" style="padding-top:8px;">
        ${node.children.map(ch => miniNodeCard(ch.id)).join('')}
      </div>
    </div>
    ` : ''}
    <div class="box detailSection${isFieldNode ? '' : ' collapsed'}">
      <h3 class="detailSectionHead"><span>Inbound mappings</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${inbound.length}</span></h3>
      <div class="detailSectionBody">
      ${inbound.length ? `<ul class="list">${inbound.map(e => ioItem(e,'in')).join('')}</ul>` : '<div class="empty">No inbound mappings for this selection.</div>'}
      ${isFieldNode ? `
      <div style="border-top:1px solid rgba(255,255,255,.10); padding-top:10px;">
        <div class="kv" style="grid-template-columns: 110px 1fr;">
          <div class="k">Add inbound mapping</div>
          <div class="v"><input class="inp" id="ndAddFrom" list="fieldDatalist" placeholder="source field id"/></div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
          <button class="btn" id="ndAddInboundMap">Add inbound mapping</button>
        </div>
      </div>
      ` : ''}
      </div>
    </div>

    <div class="box detailSection${isFieldNode ? '' : ' collapsed'}">
      <h3 class="detailSectionHead"><span>Outbound mappings</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${outbound.length}</span></h3>
      <div class="detailSectionBody">
      ${outbound.length ? `<ul class="list">${outbound.map(e => ioItem(e,'out')).join('')}</ul>` : '<div class="empty">No outbound mappings for this selection.</div>'}
      ${isFieldNode ? `
      <div style="border-top:1px solid rgba(255,255,255,.10); padding-top:10px;">
        <div class="kv" style="grid-template-columns: 110px 1fr;">
          <div class="k">Add outbound mapping</div>
          <div class="v"><input class="inp" id="ndAddTo" list="fieldDatalist" placeholder="target field id"/></div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
          <button class="btn" id="ndAddMap">Add outbound mapping</button>
        </div>
      </div>
      ` : ''}
      </div>
    </div>

    ${linked.length ? `<div class="box detailSection collapsed">
      <h3 class="detailSectionHead"><span>Linked (directionless)</span><span style="font-family:var(--mono);font-size:11px;opacity:.9;">${linked.length}</span></h3>
      <div class="detailSectionBody">
      <ul class="list">${linked.map(e => ioItem(e,'linked')).join('')}</ul>
      </div>
    </div>` : ''}
  `;

  // Wire collapsible section toggles
  detailsBody.querySelectorAll('.detailSectionHead').forEach(h => {
    h.addEventListener('click', () => {
      h.closest('.detailSection').classList.toggle('collapsed');
    });
  });

  // Wire children jump links



  // Select an edge when clicking a mapping row (v11 behavior)
  detailsBody.querySelectorAll('[data-edge]').forEach(li=>{
    // Action buttons inside the mapping row (do not steal the row click).
    li.querySelectorAll('button[data-act]').forEach(btn=>{
      btn.addEventListener('click', async (ev)=>{
        ev.stopPropagation();
        const act = btn.dataset.act;
        const eid = li.dataset.edge;
        const jump = li.dataset.jumpId;
        // Guard unsaved node edits before navigation
        if(nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        if(act==='editMap'){ selectEdge(eid); return; }
        if(act==='goTo' && jump){
          lockSelection(jump);
          scrollIntoView(jump);
          return;
        }
        if(act==='delMap'){
          deleteMappingByEdgeId(eid);
          return;
        }
      });
    });

    li.addEventListener('click', async ()=>{
      const eid = li.dataset.edge;
      // Guard unsaved node edits before switching to edge
      if(nodeEditIsDirty()){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      state.selectedEdgeId = eid;
      // force rerender details to show selected edge context
      renderAll();
      applyHighlight();
    });
  });

  if(isFieldNode){
    document.getElementById('ndAddMap')?.addEventListener('click', async ()=>{
      const toId = (document.getElementById('ndAddTo')?.value || '').trim();
      if(!toId) return;
      if(!IDX.fieldIds.has(toId)) { customAlert('Unknown target field: '+toId); return; }
      if(toId===nodeId) return;
      // Guard unsaved node edits before adding mapping
      if(nodeEditIsDirty()){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      if(typeof ensureMapping==='function') ensureMapping(nodeId, toId);
      else { state.data.mappings = state.data.mappings || []; state.data.mappings.push({from: nodeId, to: toId}); }
      renderAll();
      const edge = IDX.edges.find(e=>e.from===nodeId && e.to===toId);
      if(edge) state.selectedEdgeId=edge.id;
      state.lockedId=nodeId;
      applyHighlight();
      scheduleArrowsUpdate();
    });

    document.getElementById('ndAddInboundMap')?.addEventListener('click', async ()=>{
      const fromId = (document.getElementById('ndAddFrom')?.value || '').trim();
      if(!fromId) return;
      if(!IDX.fieldIds.has(fromId)) { customAlert('Unknown source field: '+fromId); return; }
      if(fromId===nodeId) return;
      // Guard unsaved node edits before adding mapping
      if(nodeEditIsDirty()){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      if(typeof ensureMapping==='function') ensureMapping(fromId, nodeId);
      else { state.data.mappings = state.data.mappings || []; state.data.mappings.push({from: fromId, to: nodeId}); }
      renderAll();
      const edge = IDX.edges.find(e=>e.from===fromId && e.to===nodeId);
      if(edge) state.selectedEdgeId=edge.id;
      state.lockedId=nodeId;
      applyHighlight();
      scheduleArrowsUpdate();
    });
  }

  // Jump interactions (like normal details)
  detailsBody.querySelectorAll('[data-jump-id]').forEach(li=>{
    li.addEventListener('click', async ()=>{
      if(li.dataset.edge) return;
      const id = li.dataset.jumpId;
      if(nodeEditIsDirty() && __editSnapshot?.id !== id){
        if(!await guardNodeAbandon()) return;
        revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
      }
      lockSelection(id);
      scrollIntoView(id);
    });
  });

  // Tags wiring
  const ndTagChips = document.getElementById('ndTagChips');
  const ndTagSel = document.getElementById('ndTagSel');
  const ndTagNew = document.getElementById('ndTagNew');
  
    function rebuildValOptions(aid){
    // rebuild the single-select value dropdown from catalog values
    const selId = aid || (ndAttrSel ? ndAttrSel.value : '');
    const def = customAttrById(selId);
    const vals = (def && Array.isArray(def.values)) ? def.values : [];
    if(!ndAttrValSel) return;
    ndAttrValSel.innerHTML = '';
    const opt0 = document.createElement('option');
    opt0.value=''; opt0.textContent='(choose value)';
    ndAttrValSel.appendChild(opt0);
    vals.forEach(v=>{
      const vid = v && v.id ? String(v.id) : '';
      if(!vid) return;
      const o = document.createElement('option');
      o.value = vid;
      o.textContent = _catalogItemLabel(v);
      ndAttrValSel.appendChild(o);
    });
  }

function renderMultiVals(aid){
    // Keep the attribute selector focused on this attribute while interacting with multi values.
    if(state) state.nodeEditorAttrFocus = aid || state.nodeEditorAttrFocus || '';

    const a = customAttrById(aid);
    const vals = (a && Array.isArray(a.values)) ? a.values : [];
    const isMulti = customAttrIsMulti(aid);

    const multiValsWrap = document.getElementById('multiValsWrap');
    if(!multiValsWrap) return;
    multiValsWrap.innerHTML = '';

    const inline = document.getElementById('ndAttrInlineControls');
    inline?.classList.toggle('hidden', isMulti);
    multiValsWrap.classList.toggle('hidden', !isMulti);
    if(!isMulti) return;

    const curRaw = (node.customAttributes||{})[aid];
    const cur = Array.isArray(curRaw) ? curRaw.map(String) : (curRaw ? [String(curRaw)] : []);

    // checkboxes
    vals.forEach(v=>{
      const lab = (v && (v.label||v.id)) ? (v.label||v.id) : '';
      const vid = v && v.id ? String(v.id) : '';
      if(!vid) return;
      const lbl = document.createElement('label');
      const cb = document.createElement('input');
      cb.type='checkbox';
      cb.checked = cur.includes(vid);
      cb.addEventListener('change', ()=>{
        node.customAttributes = node.customAttributes || {};
        let arr = Array.isArray(node.customAttributes[aid]) ? node.customAttributes[aid].map(String) : (node.customAttributes[aid] ? [String(node.customAttributes[aid])] : []);
        if(cb.checked){ if(!arr.includes(vid)) arr.push(vid); }
        else { arr = arr.filter(x=>x!==vid); }
        if(arr.length===0) delete node.customAttributes[aid];
        else if(arr.length===1) node.customAttributes[aid] = arr[0];
        else node.customAttributes[aid] = arr;
        renderAttrChips();
        renderAll();
      });
      lbl.appendChild(cb);
      lbl.appendChild(document.createTextNode(' '+lab));
      multiValsWrap.appendChild(lbl);
    });

    // actions under the list
    const actions = document.createElement('div');
    actions.className = 'multiValsActions';

    const btnAll = document.createElement('button');
    btnAll.type='button'; btnAll.className='linkBtn'; btnAll.textContent='Select all';
    const btnNone = document.createElement('button');
    btnNone.type='button'; btnNone.className='linkBtn'; btnNone.textContent='Clear all';
    const btnAddOpt = document.createElement('button');
    btnAddOpt.type='button'; btnAddOpt.className='linkBtn'; btnAddOpt.textContent='Add new option';

    actions.appendChild(btnAll);
    actions.appendChild(btnNone);
    actions.appendChild(btnAddOpt);
    multiValsWrap.appendChild(actions);

    // Move the main Attributes catalog button (big button) below the multi-select actions row.
    // This avoids having two buttons and keeps the control close to multi-select operations.
    const catBtn = document.getElementById('ndAttrCatalog');
    if(catBtn){
      catBtn.textContent = 'Attributes';
      const catRow = document.createElement('div');
      catRow.className = 'multiValsActions';
      catRow.appendChild(catBtn);
      multiValsWrap.appendChild(catRow);
    }


    btnAll.addEventListener('click', async ()=>{
      node.customAttributes = node.customAttributes || {};
      const allIds = vals.map(v=>v && v.id ? String(v.id) : '').filter(Boolean);
      if(allIds.length===0) return;
      node.customAttributes[aid] = allIds.length===1 ? allIds[0] : allIds;
      renderMultiVals(aid);
      renderAttrChips();
      renderAll();
    });
    btnNone.addEventListener('click', async ()=>{
      node.customAttributes = node.customAttributes || {};
      delete node.customAttributes[aid];
      renderMultiVals(aid);
      renderAttrChips();
      renderAll();
    });
    btnAddOpt.addEventListener('click', async ()=>{
      if(!a) return;
      if(!Array.isArray(a.values)) a.values = [];
      const taken = new Set((a.values||[]).map(v=>v && v.id).filter(Boolean));
      openCreateModal({
        kind:'customAttrValue',
        title:`Add value to ${a.label||a.id}`,
        placeholder:'Value label',
        hint:'ID is generated from the value label and made unique.',
        taken,
        onCommit: ({label,id,note,color,abbr,emoji,displayMode,_autoId,_autoAbbr})=>{
          let maxVP = 0;
          a.values.forEach(v=>{ if(v && typeof v.priority==='number' && v.priority > maxVP) maxVP = v.priority; });
          const vObj = {id, label, note: (note||''), priority: maxVP + 1, _autoId, _autoAbbr};
          if(abbr) vObj.abbr = abbr;
          if(emoji) vObj.emoji = emoji;
          if(displayMode) vObj.displayMode = displayMode;
          if(color) { vObj.color = color; vObj.colorEnabled = true; }
          a.values.push(vObj);
          node.customAttributes = node.customAttributes || {};
          const cur = node.customAttributes[aid];
          if(cur===undefined) node.customAttributes[aid] = id;
          else if(Array.isArray(cur)){ if(!cur.map(String).includes(String(id))) cur.push(id); }
          else { if(String(cur)!==String(id)) node.customAttributes[aid] = [cur, id]; }
          renderMultiVals(aid);
          renderAttrChips();
          renderAll();
        }
      });
    });
  }

function rebuildTagOptions(){
    const cat = ensureTagCatalog();
    ndTagSel.innerHTML = '<option value="">Add tag</option>' + _buildTagSelectOptions(normalizeNodeTags(node), {includeNew: true});
  }
  function renderTagChips(){
    ndTagChips.innerHTML='';
    const arr = sortTagIdsByPriority(normalizeNodeTags(node));
    if(!arr.length){ ndTagChips.innerHTML='<span class="empty">No tags.</span>'; return; }
    arr.forEach(tid=>{
      const td = tagById(tid) || {id:tid,label:tid,abbr:''};
      const chip=document.createElement('span');
      chip.className='tagChip';
      chip.style.setProperty('--c', tagColor(td));
      chip.setAttribute('data-color','1');
      chip.textContent = tagDisplayLabel(td) || tid;
      chip.title = (td.label||td.id) + (td.note?('  '+td.note):'');
      const x=document.createElement('span');
      x.textContent=' '; x.style.cursor='pointer'; x.style.opacity='.85';
      x.addEventListener('click',(e)=>{ e.stopPropagation(); node.tags = (node.tags||[]).filter(v=>v!==tid); renderTagChips(); renderAll(); });
      chip.appendChild(x);
      ndTagChips.appendChild(chip);
    });
  }
  ndTagSel.addEventListener('change', ()=>{
    const v=(ndTagSel.value||'').trim();
    if(!v) return;
    if(v==='__new__'){
      ndTagSel.value='';
      openTagCreateModal({attachNodeId: nodeId, afterCreate: null});
      return;
    }
    node.tags = node.tags || [];
    if(!node.tags.includes(v)) node.tags.push(v);
    ndTagSel.value='';
    renderTagChips();
  });
  ndTagNew.addEventListener('click', async ()=>{
    openTags();
  });
  rebuildTagOptions();
  renderTagChips();

  // Color toggle
  {
    const ndColorOn = document.getElementById('ndColorOn');
    const ndColor = document.getElementById('ndColor');
    const ndColorHex = document.getElementById('ndColorHex');
    const ndSaveBtn = document.getElementById('ndSave');
    if(ndColorOn && ndColor){
      const triggerDirty = ()=>{ if(ndSaveBtn && ndSaveBtn.__dirtyUpdate) ndSaveBtn.__dirtyUpdate(); };
      // Build preset swatches
      buildColorSwatches(document.getElementById('ndColorSwatches'), ndColor, ndColorOn, triggerDirty);
      ndColorOn.addEventListener('change', ()=>{
        ndColor.style.opacity = ndColorOn.checked ? '1' : '.3';
        triggerDirty();
      });
      ndColor.addEventListener('input', ()=>{
        if(ndColorOn) ndColorOn.checked = true;
        ndColor.style.opacity = '1';
        if(ndColorHex) ndColorHex.value = ndColor.value;
        triggerDirty();
      });
      ndColor.addEventListener('change', triggerDirty);
      if(ndColorHex){
        ndColorHex.addEventListener('input', ()=>{
          const v = (ndColorHex.value||'').trim();
          if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
            ndColor.value = v;
            if(ndColorOn) ndColorOn.checked = true;
            ndColor.style.opacity = '1';
          }
          triggerDirty();
        });
      }
    }
  }

  // Attributes wiring
  const ndAttrChips = document.getElementById('ndAttrChips');
  const ndAttrSel = document.getElementById('ndAttrSel');
  const ndAttrValSel = document.getElementById('ndAttrValSel');
  const ndAttrCatalog = document.getElementById('ndAttrCatalog');

  function rebuildAttrOptions(){
    const cat = ensureCustomAttributeCatalog();
    // Preserve current attribute selection (especially for multi-select workflows).
    const keep = (state && typeof state.nodeEditorAttrFocus==='string' && state.nodeEditorAttrFocus) ? state.nodeEditorAttrFocus : (ndAttrSel.value||'');
    ndAttrSel.innerHTML = '<option value="">Attribute</option>' + _buildAttrSelectOptions({includeNew: true});
    // Restore selection if still present.
    if(keep){
      ndAttrSel.value = keep;
      if(ndAttrSel.value !== keep){
        // option no longer exists; clear
        ndAttrSel.value = '';
      }
    }
  }
  function rebuildValOptions(aid){
    if(!aid){ ndAttrValSel.innerHTML = '<option value="">Value</option>'; return; }
    const a = customAttrById(aid);
    const vals = (a && Array.isArray(a.values)) ? a.values : [];
    ndAttrValSel.innerHTML = '<option value="">Value</option>' + vals.map(v=>{
      return `<option value="${escapeHtml(v.id)}">${escapeHtml(_catalogItemLabel(v))}</option>`;
    }).join('\n') + '<option value="__new__">+ New value</option>';
  }
  function renderAttrChips(){
    ndAttrChips.innerHTML='';
    const ca = normalizeCustomAttributes(node);
    const keys = Object.keys(ca||{});
    if(!keys.length){ ndAttrChips.innerHTML='<span class="empty">No custom attributes.</span>'; return; }
    keys.sort().forEach(aid=>{
      const raw = ca[aid];
      const a = customAttrById(aid) || {id:aid,label:aid,abbr:''};
      const vals = Array.isArray(raw) ? raw : [raw];
      vals.forEach(vid=>{
        const v = customValueById(aid, vid) || {id:vid,label:vid};
        const chip=document.createElement('span');
        chip.className='tagChip';
        chip.textContent = (customAttrAbbr(a)||aid) + ': ' + (v.label||v.id);
        chip.title = (a.label||a.id) + ' = ' + (v.label||v.id);
        const x=document.createElement('span');
        x.textContent=' '; x.style.cursor='pointer'; x.style.opacity='.85';
        x.addEventListener('click',(e)=>{
          e.stopPropagation();
          const cur = node.customAttributes[aid];
          if(Array.isArray(cur)){
            const next = cur.filter(z=>String(z) !== String(vid));
            if(next.length===0) delete node.customAttributes[aid];
            else if(next.length===1) node.customAttributes[aid] = next[0];
            else node.customAttributes[aid] = next;
          } else {
            delete node.customAttributes[aid];
          }
          renderAttrChips();
          renderAll();
        });
        chip.appendChild(x);
        ndAttrChips.appendChild(chip);
      });
    });
  }

  ndAttrSel.addEventListener('change', ()=>{
    // Remember selected attribute to keep focus stable during multi-select edits.
    state.nodeEditorAttrFocus = ndAttrSel.value || '';

    const aid = ndAttrSel.value;
    if(aid==='__new__'){
      const cat = ensureCustomAttributeCatalog();
      normalizeCatalogMultiFlag();
      const taken = new Set((cat||[]).map(a=>a && a.id).filter(Boolean));
      ndAttrSel.value='';
      openCreateModal({
        kind:'customAttr',
        title:'Add custom attribute',
        placeholder:'Attribute label',
        hint:'ID is generated from the attribute label and made unique.',
        taken,
        onCommit: ({label,id,abbr,note,color,multi,_autoId,_autoAbbr})=>{
          const entry = { id, label, abbr: (abbr||'').trim() || (label||'').replace(/\s+/g,'').slice(0,2).toUpperCase(), note: (note||''), multi:!!multi, values:[], _autoId, _autoAbbr};
          if(color) { entry.color = color; entry.colorEnabled = true; }
          cat.push(entry);
          rebuildAttrOptions();
          ndAttrSel.value = id;
          rebuildValOptions(id);
  if(state) state.nodeEditorAttrFocus = id;
          const inline = document.getElementById('ndAttrInlineControls');
          inline?.classList.remove('hidden');
          ndAttrValSel.classList.remove('hidden');
          renderMultiVals(id);
          renderAll();
        }
      });
      return;
    }
    rebuildValOptions(aid);
    const isM = customAttrIsMulti(aid);
    const inline = document.getElementById('ndAttrInlineControls');
    inline?.classList.toggle('hidden', isM);
    ndAttrValSel.classList.toggle('hidden', isM);
    renderMultiVals(aid);
    const cur = (node.customAttributes||{})[aid];
    if(!isM){ ndAttrValSel.value = cur ? String(cur) : ''; }
  });

  ndAttrCatalog.addEventListener('click', openCustomAttrs);

  rebuildAttrOptions();
  // initialize values UI
  rebuildValOptions(ndAttrSel.value);
  ndAttrValSel.classList.toggle('hidden', customAttrIsMulti(ndAttrSel.value));
  renderMultiVals(ndAttrSel.value);

  ndAttrValSel.addEventListener('change', ()=>{
    const aid = (ndAttrSel.value||'').trim();
    const vid = (ndAttrValSel.value||'').trim();
    if(!aid || aid==='__new__') return;
    const isM = customAttrIsMulti(aid);
    if(isM) return;
    if(!vid) return;

    if(vid==='__new__'){
      ndAttrValSel.value = '';
      const a = customAttrById(aid);
      if(!a){  return; }
      if(!Array.isArray(a.values)) a.values=[];
      const taken = new Set(a.values.map(v=>v && v.id).filter(Boolean));
      openCreateModal({
        kind:'customAttrValue',
        title:`Add value to ${a.label||a.id}`,
        placeholder:'Value label',
        hint:'ID is generated from the value label and made unique.',
        taken,
        onCommit: ({label,id,note,color,abbr,emoji,displayMode,_autoId,_autoAbbr})=>{
          let maxVP = 0;
          a.values.forEach(v=>{ if(v && typeof v.priority==='number' && v.priority > maxVP) maxVP = v.priority; });
          const vObj = {id, label, note: (note||''), priority: maxVP + 1, _autoId, _autoAbbr};
          if(abbr) vObj.abbr = abbr;
          if(emoji) vObj.emoji = emoji;
          if(displayMode) vObj.displayMode = displayMode;
          if(color) { vObj.color = color; vObj.colorEnabled = true; }
          a.values.push(vObj);
          rebuildValOptions(aid);
          node.customAttributes = node.customAttributes || {};
          node.customAttributes[aid] = id;
          // Single-select UX (new value): reset selectors after commit.
          if(state) state.nodeEditorAttrFocus = '';
          try{ ndAttrSel.value = ''; ndAttrValSel.value = ''; }catch(e){}
          try{ rebuildValOptions(''); }catch(e){}
          renderAttrChips();
          renderAll();
        }
      });
      return;
    }

    node.customAttributes = node.customAttributes || {};
    node.customAttributes[aid] = vid;
    // Single-select UX: after choosing a value, reset the Attribute/Value selectors.
    if(state) state.nodeEditorAttrFocus = '';
    try{ ndAttrSel.value = ''; ndAttrValSel.value = ''; }catch(e){}
    try{ rebuildValOptions(''); }catch(e){}
    renderAttrChips();
    renderAll();
  });

  

  rebuildAttrOptions();
  rebuildValOptions(ndAttrSel.value);
  renderAttrChips();

  // Save / Cancel
  document.getElementById('ndSave').addEventListener('click', async ()=>{
    const newLabel = (document.getElementById('ndLabel')?.value || '').trim() || node.label || localIdSegment(node.id);
    const newLocalSeg = sanitizeManualId(document.getElementById('ndId')?.value || '') || localIdSegment(node.id);
    const oldId = node.id;
    const prefix = idPathPrefix(oldId);
    const newId = prefix + newLocalSeg;
    recordChange();

    // Update label (independent of ID)
    node.label = newLabel;
    node.note = (document.getElementById('ndNote')?.value || '');

    // Update color  always remember the picker value
    const colorOn = document.getElementById('ndColorOn')?.checked;
    const pickerVal = document.getElementById('ndColor')?.value || '';
    if(colorOn){
      node.color = pickerVal;
      delete node._pendingColor;
    } else {
      delete node.color;
      // Remember the picked color so it survives save/reload
      if(pickerVal && pickerVal !== '#3b82f6') node._pendingColor = pickerVal;
      else delete node._pendingColor;
    }

    // Persist auto-ID state
    node._autoId = __editorAutoId;

    // Update ID if changed
    let finalId = oldId;
    if(newId !== oldId){
      const colId = columnOf(oldId) || oldId;
      const result = reIdNodeInData(state.data, oldId, newId, colId);
      if(result === oldId){
        setGlobalStatus('Node ID conflict  ID not changed (duplicate).');
      } else {
        finalId = result;
      }
    }

    __editSnapshot = null;
    // Stay on the node after save (use finalId in case ID was changed)
    state.lockedId = finalId; state.hoverId = null; state.selectedEdgeId = null; state.selectedColumnId = null;
    state.__hoverCooldownUntil = Date.now() + 400; // suppress hover for 400ms after save
    renderAll();
    setGlobalStatus('Node saved.');
  });
  document.getElementById('ndCancel').addEventListener('click', async ()=>{
    const stayId = state.lockedId; // remember which node we're on
    revertEditSnapshot();
    __editSnapshot = null;
    state.lockedId = stayId; // stay selected
    state.hoverId = null;
    state.__hoverCooldownUntil = Date.now() + 400;
    checkDirtyState();
    renderAll();
    setGlobalStatus('Cancelled changes.');
  });

  const ndDelBtn = document.getElementById('ndDelete');
  if(ndDelBtn){
    const colId = columnOf(nodeId);
    const hasParent = !!IDX.parentById.get(nodeId);
    if(!hasParent){
      ndDelBtn.disabled = true;
      ndDelBtn.title = 'Cannot delete root node';
    }
    ndDelBtn.addEventListener('click', ()=>{
      if(!hasParent) return;
      // Clear snapshot before delete so we don't revert afterward
      __editSnapshot = null;
      deleteNodeInline(nodeId, colId);
    });
  }

  wireDirtyHighlight(detailsBody, document.getElementById('ndSave'), nodeEditIsDirty, ()=> !!(document.getElementById('ndLabel')?.value||'').trim());
  // Node labelid auto-fill (local segment)
  {
    const _ndLabelInp = document.getElementById('ndLabel');
    const _ndIdInp = document.getElementById('ndId');
    const _ndIdAutoTag = document.getElementById('ndIdAuto');
    if(_ndLabelInp && _ndIdInp){
      const _slugNd = (raw)=> idPartFromLabel(raw, {lower:true});
      // Initialize auto tracker: use the actual local ID segment (handles mixed-case legacy nodes)
      const initIdLocal = _ndIdInp.value.trim();
      let _lastAutoId = node._autoId ? initIdLocal : '';
      __editorAutoId = _lastAutoId !== '';
      const _refreshTag = ()=>{
        if(!_ndIdAutoTag) return;
        const on = _lastAutoId !== '';
        _ndIdAutoTag.style.display = on ? '' : 'none';
        _ndIdAutoTag.classList.toggle('clickable', on);
      };
      _refreshTag();
      if(_ndIdAutoTag){
        _ndIdAutoTag.title = 'Click to freeze ID';
        _ndIdAutoTag.addEventListener('click', ()=>{
          _lastAutoId = '';
          __editorAutoId = false;
          _refreshTag();
        });
      }
      _ndLabelInp.addEventListener('input', ()=>{
        const cur = _ndIdInp.value.trim();
        if(!cur || cur === _lastAutoId){ const ai = _slugNd(_ndLabelInp.value.trim())||''; if(ai){ _ndIdInp.value = ai; _lastAutoId = ai; } }
        __editorAutoId = _lastAutoId !== '';
        _refreshTag();
      });
      _ndIdInp.addEventListener('input', ()=>{
        if(!_ndIdInp.value.trim()){ const ai = _slugNd(_ndLabelInp.value.trim())||''; _ndIdInp.value = ai; _lastAutoId = ai; }
        else _lastAutoId = '';
        __editorAutoId = _lastAutoId !== '';
        _refreshTag();
      });
    }
  }
  return true;
}

function addBelowNode(nodeId, colId, isFieldNew){
  if(!state.editorMode) return;
  if(!IDX.parentById.get(nodeId)) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || loc.idx===null || !loc.siblings) return;
  const taken = collectNodeIds(col);
  const parentId = (loc.parent.id===colId ? colId : loc.parent.id);
  openCreateModal({
    kind: 'node',
    title: `Insert ${isFieldNew?'field':'group'} below`,
    placeholder: isFieldNew ? 'Field label' : 'Group label',

    hint: 'ID is generated from the label under the same parent and made unique.',
    colId,
    parentId,
    taken,
    onCommit: ({label, id, note, tags, customAttributes, _autoId})=>{
      const newNode = { id, label, _autoId, type: isFieldNew?'field':'group' }; if(note) newNode.note = note;
      if(tags && tags.length) newNode.tags = tags;
      if(customAttributes) newNode.customAttributes = customAttributes;
      if(!isFieldNew) newNode.children=[];
      loc.siblings.splice(loc.idx+1, 0, newNode);
      recordChange(); // Node added
      renderAll();
      lockSelection(id);
    }
  });
}

function addAboveNode(nodeId, colId, isFieldNew){
  if(!state.editorMode) return;
  if(!IDX.parentById.get(nodeId)) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || loc.idx===null || !loc.siblings) return;
  const taken = collectNodeIds(col);
  const parentId = (loc.parent.id===colId ? colId : loc.parent.id);
  openCreateModal({
    kind: 'node',
    title: `Insert ${isFieldNew?'field':'group'} above`,
    placeholder: isFieldNew ? 'Field label' : 'Group label',

    hint: 'ID is generated from the label under the same parent and made unique.',
    colId,
    parentId,
    taken,
    onCommit: ({label, id, note, tags, customAttributes, _autoId})=>{
      const newNode = { id, label, _autoId, type: isFieldNew?'field':'group' }; if(note) newNode.note = note;
      if(tags && tags.length) newNode.tags = tags;
      if(customAttributes) newNode.customAttributes = customAttributes;
      if(!isFieldNew) newNode.children=[];
      loc.siblings.splice(loc.idx, 0, newNode);
      recordChange(); // Node added
      renderAll();
      lockSelection(id);
    }
  });
}

function duplicateNode(nodeId, colId, withMappings){
  if(!state.editorMode) return;
  if(!IDX.parentById.get(nodeId)) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || loc.idx===null || !loc.siblings) return;
  const taken = collectNodeIds(col);

  // Deep clone the node
  const clone = JSON.parse(JSON.stringify(loc.node));

  // Build oldnew ID map while rewriting IDs
  const idMap = new Map();
  function rewriteIds(n, parentPrefix){
    const oldId = n.id;
    const localSeg = n.id.includes('.') ? n.id.split('.').pop() : n.id;
    let candidate = parentPrefix ? parentPrefix + '.' + localSeg : localSeg;
    let suffix = 1;
    while(taken.has(candidate)){
      candidate = (parentPrefix ? parentPrefix + '.' : '') + localSeg + '_copy' + (suffix > 1 ? suffix : '');
      suffix++;
    }
    taken.add(candidate);
    n.id = candidate;
    n.label = (n.label || localSeg) + (suffix > 1 || candidate.includes('_copy') ? '' : '');
    idMap.set(oldId, candidate);
    if(Array.isArray(n.children)){
      for(const ch of n.children) rewriteIds(ch, candidate);
    }
  }

  const parentId = loc.parent.id === colId ? colId : loc.parent.id;
  rewriteIds(clone, parentId === colId ? colId : parentId);

  // Append a visual indicator to the top-level label
  if(clone.label && !clone.label.endsWith(' (copy)')) clone.label += ' (copy)';

  loc.siblings.splice(loc.idx + 1, 0, clone);

  // Copy mappings if requested
  if(withMappings && state.data.mappings){
    const newMappings = [];
    for(const m of state.data.mappings){
      if(!m || typeof m !== 'object') continue;
      const fromMapped = idMap.get(m.from);
      const toMapped = idMap.get(m.to);
      // Clone mapping if either endpoint was in the duplicated subtree
      if(fromMapped || toMapped){
        const mc = JSON.parse(JSON.stringify(m));
        if(fromMapped) mc.from = fromMapped;
        if(toMapped) mc.to = toMapped;
        newMappings.push(mc);
      }
    }
    state.data.mappings.push(...newMappings);
  }

  recordChange();
  renderAll();
  lockSelection(clone.id);
}

function moveNode(nodeId, colId, dir){
  if(!state.editorMode) return;
  if(!IDX.parentById.get(nodeId)) return; // cannot move root
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || !loc.siblings || loc.idx===null) return;
  const i = loc.idx;
  const j = i + dir;
  if(j < 0 || j >= loc.siblings.length) return;
  recordChange(); // Save BEFORE move
  const tmp = loc.siblings[i];
  loc.siblings[i] = loc.siblings[j];
  loc.siblings[j] = tmp;
  renderAll();
  // keep the moved node selected
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.lockedId = nodeId;
  state.hoverId = null;
  applyHighlight();
  scrollIntoView(nodeId);
}

function inlineIndent(nodeId, colId){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || !loc.siblings || loc.idx===null) return;
  if(loc.idx<=0) return;
  const prev = loc.siblings[loc.idx-1];
  if(!prev || prev.type==='field') return;
  recordChange(); // Save BEFORE indent
  ensureGroup(prev);
  const node = loc.siblings.splice(loc.idx,1)[0];
  if(!prev.children) prev.children=[];
  prev.children.push(node);
  // re-id to reflect new parent path
  { const moved=node; const taken=collectNodeIds(col); const base=(prev.id===col.id?col.id:prev.id)+'.'+localIdSegment(moved.id); const idMap={}; const old=moved.id; const newid=ensureUniqueId(base, taken); buildSubtreeIdMap(moved, old, newid, idMap); replaceIdsInMappings(state.data, idMap); }
  renderAll();
  lockSelection(node.id);
}

function inlineOutdent(nodeId, colId){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent) return;
  const parentLoc = locateNode(col.schema, loc.parent.id);
  if(!parentLoc || !parentLoc.parent || !parentLoc.siblings || parentLoc.idx===null) return;
  const idx = (loc.parent.children||[]).findIndex(n=>n && n.id===nodeId);
  if(idx<0) return;
  recordChange(); // Save BEFORE outdent
  const node = loc.parent.children.splice(idx,1)[0];
  parentLoc.siblings.splice(parentLoc.idx+1, 0, node);
  // re-id to reflect new parent path (grandparent)
  { const moved=node; const newPar = parentLoc.parent ? parentLoc.parent.id : col.schema.id; const taken=collectNodeIds(col); const base=(newPar===col.id?col.id:newPar)+'.'+localIdSegment(moved.id); const idMap={}; const old=moved.id; const newid=ensureUniqueId(base, taken); buildSubtreeIdMap(moved, old, newid, idMap); replaceIdsInMappings(state.data, idMap); }
  renderAll();
  lockSelection(node.id);
}

async function deleteNodeInline(nodeId, colId){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.parent || !loc.siblings || loc.idx===null) return;
  const nodeType = loc.node.type === 'field' ? 'field' : 'group';
  const nodeLabel = loc.node.label || localIdSegment(nodeId);
  const fieldsToRemove = collectFieldIdsFromNode(loc.node);
  // Count descendants for groups
  let childInfo = '';
  if(nodeType === 'group'){
    let fieldCount = 0, groupCount = 0;
    (function walk(n){ if(!n) return; if(n.type==='field') fieldCount++; else if(n.type==='group') groupCount++; (n.children||[]).forEach(walk); })(loc.node);
    // Don't count the group itself
    groupCount = Math.max(0, groupCount - 1);
    const parts = [];
    if(fieldCount) parts.push(fieldCount + ' field' + (fieldCount>1?'s':''));
    if(groupCount) parts.push(groupCount + ' sub-group' + (groupCount>1?'s':''));
    if(parts.length) childInfo = `\n\nThis will also delete ${parts.join(' and ')} inside it.`;
  }
  // Count affected mappings
  const kill = new Set(fieldsToRemove);
  const mapCount = (state.data.mappings||[]).filter(m => m && (kill.has(m.from) || kill.has(m.to))).length;
  const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
  if(!await customConfirm(`Delete ${nodeType} "${nodeLabel}" (${nodeId})?${childInfo}${mapInfo}`)) return;
  recordChange(); // Save BEFORE deletion
  removeMappingsReferencingInState(fieldsToRemove);
  loc.siblings.splice(loc.idx,1);
  // Clear selection after delete
  state.lockedId = null;
  state.hoverId = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  renderAll();
}

//  Bulk editing helpers 

// Returns info about selected siblings, or null if selection is not all siblings in one parent
function getSelectedSiblingGroup(){
  if(!state.editorMode || !state.data) return null;
  const ids = state.multiSelection.size > 0
    ? [...state.multiSelection]
    : (state.lockedId ? [state.lockedId] : []);
  if(!ids.length) return null;
  // All must be in the same column
  const cid = columnOf(ids[0]);
  if(!cid) return null;
  const col = findColumnById(cid);
  if(!col) return null;
  // All must share the same parent
  const locs = ids.map(id => {
    if(columnOf(id) !== cid) return null;
    return locateNode(col.schema, id);
  });
  if(locs.some(l => !l || !l.parent || !l.siblings)) return null;
  const parentId = locs[0].parent.id;
  if(!locs.every(l => l.parent.id === parentId)) return null;
  const siblings = locs[0].siblings;
  const indices = locs.map(l => l.idx).sort((a,b) => a - b);
  return { ids, cid, col, siblings, parent: locs[0].parent, indices, locs };
}

function areContiguous(sortedIndices){
  for(let i = 1; i < sortedIndices.length; i++){
    if(sortedIndices[i] !== sortedIndices[i-1] + 1) return false;
  }
  return true;
}

// Bulk move: contiguous siblings up or down
function bulkMove(dir){
  const sg = getSelectedSiblingGroup();
  if(!sg) return;
  const { indices, siblings, ids } = sg;
  if(!areContiguous(indices)) return;
  const first = indices[0];
  const last = indices[indices.length - 1];
  if(dir === -1 && first <= 0) return;
  if(dir === 1 && last >= siblings.length - 1) return;
  recordChange();
  if(dir === -1){
    // Move block up: swap first element with the one above
    const removed = siblings.splice(first - 1, 1)[0];
    siblings.splice(last, 0, removed);
  } else {
    // Move block down: swap last element with the one below
    const removed = siblings.splice(last + 1, 1)[0];
    siblings.splice(first, 0, removed);
  }
  renderAll();
  // Keep selection
  for(const id of ids){ state.multiSelection.add(id); }
  if(ids.length === 1) state.lockedId = ids[0];
  applyHighlight();
  scrollIntoView(ids[0]);
}

// Bulk indent: move siblings into the nearest group sibling above them
function bulkIndent(){
  const sg = getSelectedSiblingGroup();
  if(!sg) return;
  const { indices, siblings, col, ids } = sg;
  const first = indices[0];
  if(first <= 0) return;
  // Find nearest group above the selection
  let targetIdx = -1;
  for(let i = first - 1; i >= 0; i--){
    if(siblings[i] && siblings[i].type !== 'field'){
      targetIdx = i;
      break;
    }
  }
  if(targetIdx < 0) return;
  const target = siblings[targetIdx];
  ensureGroup(target);
  if(!target.children) target.children = [];
  recordChange();
  // Extract nodes in order (splice from end to preserve indices)
  const nodes = [];
  for(let i = indices.length - 1; i >= 0; i--){
    nodes.unshift(siblings.splice(indices[i], 1)[0]);
  }
  // Append to target's children
  const taken = collectNodeIds(col);
  const newIds = [];
  for(const node of nodes){
    target.children.push(node);
    // Re-ID to reflect new parent path
    const base = (target.id === col.id ? col.id : target.id) + '.' + localIdSegment(node.id);
    const idMap = {};
    const oldId = node.id;
    const newId = ensureUniqueId(base, taken);
    buildSubtreeIdMap(node, oldId, newId, idMap);
    replaceIdsInMappings(state.data, idMap);
    taken.add(newId);
    newIds.push(node.id);
  }
  renderAll();
  // Restore selection with new IDs
  state.multiSelection.clear();
  for(const id of newIds) state.multiSelection.add(id);
  if(newIds.length === 1) state.lockedId = newIds[0];
  else state.lockedId = newIds[0];
  applyHighlight();
  scrollIntoView(newIds[0]);
}

// Bulk outdent: move siblings up to grandparent level
function bulkOutdent(){
  const sg = getSelectedSiblingGroup();
  if(!sg) return;
  const { indices, siblings, col, parent, ids } = sg;
  // Parent must itself have a parent (can't outdent from root-level)
  const parentLoc = locateNode(col.schema, parent.id);
  if(!parentLoc || !parentLoc.parent || !parentLoc.siblings || parentLoc.idx === null) return;
  recordChange();
  // Extract nodes in order (splice from end to preserve indices)
  const nodes = [];
  for(let i = indices.length - 1; i >= 0; i--){
    nodes.unshift(siblings.splice(indices[i], 1)[0]);
  }
  // Insert after parent in grandparent's children
  const insertIdx = parentLoc.idx + 1;
  const taken = collectNodeIds(col);
  const newIds = [];
  for(let i = 0; i < nodes.length; i++){
    const node = nodes[i];
    parentLoc.siblings.splice(insertIdx + i, 0, node);
    // Re-ID to reflect new parent path (grandparent)
    const newPar = parentLoc.parent ? parentLoc.parent.id : col.schema.id;
    const base = (newPar === col.id ? col.id : newPar) + '.' + localIdSegment(node.id);
    const idMap = {};
    const oldId = node.id;
    const newId = ensureUniqueId(base, taken);
    buildSubtreeIdMap(node, oldId, newId, idMap);
    replaceIdsInMappings(state.data, idMap);
    taken.add(newId);
    newIds.push(node.id);
  }
  renderAll();
  state.multiSelection.clear();
  for(const id of newIds) state.multiSelection.add(id);
  if(newIds.length === 1) state.lockedId = newIds[0];
  else state.lockedId = newIds[0];
  applyHighlight();
  scrollIntoView(newIds[0]);
}

// Bulk delete: any selection, any arrangement
async function bulkDelete(){
  if(!state.editorMode) return;
  const ids = state.multiSelection.size > 0
    ? [...state.multiSelection]
    : (state.lockedId ? [state.lockedId] : []);
  if(!ids.length) return;
  // Collect all field IDs (for mapping removal)
  const allFieldIds = new Set();
  let childFieldCount = 0, childGroupCount = 0;
  for(const nid of ids){
    const node = IDX.nodeById.get(nid);
    if(node){
      for(const f of collectFieldIdsFromNode(node)) allFieldIds.add(f);
      if(node.type === 'group'){
        (function walk(n){ if(!n) return; (n.children||[]).forEach(ch => { if(ch.type==='field') childFieldCount++; else if(ch.type==='group') childGroupCount++; walk(ch); }); })(node);
      }
    }
  }
  const childParts = [];
  if(childFieldCount) childParts.push(childFieldCount + ' child field' + (childFieldCount>1?'s':''));
  if(childGroupCount) childParts.push(childGroupCount + ' child group' + (childGroupCount>1?'s':''));
  const childInfo = childParts.length ? `\nThis includes ${childParts.join(' and ')} inside selected groups.` : '';
  const mapCount = (state.data.mappings||[]).filter(m => m && (allFieldIds.has(m.from) || allFieldIds.has(m.to))).length;
  const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
  const msg = ids.length === 1
    ? `Delete "${IDX.nodeById.get(ids[0])?.label || ids[0]}"?${childInfo}${mapInfo}`
    : `Delete ${ids.length} selected node${ids.length>1?'s':''}?${childInfo}${mapInfo}\n\nThis action can be undone with Ctrl+Z.`;
  if(!await customConfirm(msg)) return;
  recordChange();
  removeMappingsReferencingInState(allFieldIds);
  for(const nid of ids){
    const cid = columnOf(nid);
    if(!cid) continue;
    const colData = findColumnById(cid);
    if(!colData || !colData.schema) continue;
    const loc = locateNode(colData.schema, nid);
    if(loc && loc.siblings && loc.idx !== null) loc.siblings.splice(loc.idx, 1);
  }
  state.multiSelection.clear();
  state.lockedId = null;
  state.hoverId = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  renderAll();
  setGlobalStatus(`Deleted ${ids.length} node${ids.length>1?'s':''}.`);
}

// Deep clone a node subtree (new IDs)
function deepCloneNode(node, taken, parentId){
  const base = parentId + '.' + localIdSegment(node.id);
  const newId = ensureUniqueId(base, taken);
  taken.add(newId);
  const clone = { ...node, id: newId };
  if(node.children){
    clone.children = node.children.map(ch => deepCloneNode(ch, taken, newId));
  }
  return clone;
}

// Duplicate selection as siblings below
function duplicateNodes(){
  const sg = getSelectedSiblingGroup();
  if(!sg) return;
  const { indices, siblings, col, parent, ids } = sg;
  recordChange();
  const taken = collectNodeIds(col);
  const newIds = [];
  const lastIdx = indices[indices.length - 1];
  const nodesToClone = indices.map(i => siblings[i]);
  for(let i = 0; i < nodesToClone.length; i++){
    const clone = deepCloneNode(nodesToClone[i], taken, parent.id);
    siblings.splice(lastIdx + 1 + i, 0, clone);
    newIds.push(clone.id);
    // Duplicate mappings for cloned fields
    const oldFields = new Set();
    (function walk(n){ if(n.type==='field') oldFields.add(n.id); (n.children||[]).forEach(walk); })(nodesToClone[i]);
    const newFields = new Map();
    (function walk(orig, cloned){ if(orig.type==='field') newFields.set(orig.id, cloned.id); const oc = orig.children||[], cc = cloned.children||[]; for(let j=0;j<oc.length;j++) walk(oc[j],cc[j]); })(nodesToClone[i], clone);
    const newMappings = [];
    for(const m of (state.data.mappings||[])){
      if(!m) continue;
      if(newFields.has(m.from)){
        newMappings.push({ ...m, from: newFields.get(m.from) });
      }
      if(newFields.has(m.to)){
        newMappings.push({ ...m, to: newFields.get(m.to) });
      }
    }
    if(newMappings.length) state.data.mappings.push(...newMappings);
  }
  renderAll();
  state.multiSelection.clear();
  for(const id of newIds) state.multiSelection.add(id);
  state.lockedId = newIds[0];
  applyHighlight();
  scrollIntoView(newIds[0]);
  setGlobalStatus(`Duplicated ${newIds.length} node${newIds.length>1?'s':''}.`);
}

// Group selection: wrap selected siblings in a new group
async function groupSelection(){
  const sg = getSelectedSiblingGroup();
  if(!sg) return;
  const { indices, siblings, col, parent } = sg;
  if(!areContiguous(indices)){
    customAlert('Please select contiguous siblings to group them.');
    return;
  }
  const label = await customPrompt('Group name:', 'New Group');
  if(label === null) return; // cancelled
  const groupLabel = label || 'New Group';
  recordChange();
  const taken = collectNodeIds(col);
  const groupId = ensureUniqueId(parent.id + '.' + (transliterate(groupLabel).toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'') || 'group'), taken);
  // Extract nodes
  const nodes = siblings.splice(indices[0], indices.length);
  const newGroup = { id: groupId, label: groupLabel, type: 'group', children: [] };
  siblings.splice(indices[0], 0, newGroup);
  taken.add(groupId);
  // Re-parent nodes into the new group
  for(const node of nodes){
    newGroup.children.push(node);
    const base = groupId + '.' + localIdSegment(node.id);
    const idMap = {};
    const oldId = node.id;
    const newId = ensureUniqueId(base, taken);
    buildSubtreeIdMap(node, oldId, newId, idMap);
    replaceIdsInMappings(state.data, idMap);
    taken.add(newId);
  }
  renderAll();
  state.multiSelection.clear();
  state.lockedId = groupId;
  applyHighlight();
  scrollIntoView(groupId);
  setGlobalStatus(`Grouped ${nodes.length} node${nodes.length>1?'s':''} into "${groupLabel}".`);
}

// Ungroup: dissolve a group, moving its children to the parent level
function ungroupNode(){
  if(!state.editorMode) return;
  const ids = state.multiSelection.size > 0
    ? [...state.multiSelection]
    : (state.lockedId ? [state.lockedId] : []);
  if(!ids.length) return;
  // Filter to only group nodes with children
  const groups = ids.filter(nid => {
    const node = IDX.nodeById.get(nid);
    return node && node.type === 'group' && node.children && node.children.length;
  });
  if(!groups.length){
    customAlert('Select a group with children to ungroup.');
    return;
  }
  recordChange();
  const allNewIds = [];
  // Process in reverse order to preserve indices
  for(const nid of groups.reverse()){
    const cid = columnOf(nid);
    if(!cid) continue;
    const col = findColumnById(cid);
    if(!col) continue;
    const loc = locateNode(col.schema, nid);
    if(!loc || !loc.parent || !loc.siblings || loc.idx === null) continue;
    const children = [...loc.node.children];
    const taken = collectNodeIds(col);
    loc.siblings.splice(loc.idx, 1);
    for(let i = 0; i < children.length; i++){
      const node = children[i];
      loc.siblings.splice(loc.idx + i, 0, node);
      const newPar = loc.parent ? loc.parent.id : col.schema.id;
      const base = (newPar === col.id ? col.id : newPar) + '.' + localIdSegment(node.id);
      const idMap = {};
      const oldId = node.id;
      const newId = ensureUniqueId(base, taken);
      buildSubtreeIdMap(node, oldId, newId, idMap);
      replaceIdsInMappings(state.data, idMap);
      taken.add(newId);
      allNewIds.push(node.id);
    }
    removeMappingsReferencingInState(new Set([nid]));
  }
  renderAll();
  state.multiSelection.clear();
  for(const id of allNewIds) state.multiSelection.add(id);
  state.lockedId = allNewIds[0] || null;
  applyHighlight();
  if(allNewIds[0]) scrollIntoView(allNewIds[0]);
  setGlobalStatus(`Ungrouped ${groups.length} group${groups.length>1?'s':''}  ${allNewIds.length} node${allNewIds.length>1?'s':''} moved to parent.`);
}

//  Clipboard (copy/paste) 
let __nodeClipboard = null; // { nodes: [deep cloned subtrees], fromColId }

function copyNodes(){
  const ids = state.multiSelection.size > 0
    ? [...state.multiSelection]
    : (state.lockedId ? [state.lockedId] : []);
  if(!ids.length) return;
  // Deep clone each node subtree (preserve original IDs for mapping lookup)
  const trees = [];
  for(const nid of ids){
    const cid = columnOf(nid);
    if(!cid) continue;
    const col = findColumnById(cid);
    if(!col) continue;
    const loc = locateNode(col.schema, nid);
    if(!loc || !loc.node) continue;
    trees.push(JSON.parse(JSON.stringify(loc.node)));
  }
  if(!trees.length) return;
  __nodeClipboard = { nodes: trees, fromColId: columnOf(ids[0]) };
  setGlobalStatus(`Copied ${trees.length} node${trees.length>1?'s':''} to clipboard.`);
}

function pasteNodes(){
  if(!state.editorMode || !__nodeClipboard || !__nodeClipboard.nodes.length) return;
  // Determine paste target: selected node's parent (as sibling below) or column root
  let targetSiblings, targetParentId, col, insertIdx;
  if(state.lockedId){
    const cid = columnOf(state.lockedId);
    if(!cid) return;
    col = findColumnById(cid);
    if(!col) return;
    const loc = locateNode(col.schema, state.lockedId);
    if(loc && loc.parent && loc.siblings){
      targetSiblings = loc.siblings;
      targetParentId = loc.parent.id;
      insertIdx = loc.idx + 1;
    } else {
      targetSiblings = col.schema.children || (col.schema.children = []);
      targetParentId = col.schema.id;
      insertIdx = targetSiblings.length;
    }
  } else {
    // No selection: paste at end of first visible column
    const visCol = IDX.columns.find(c => !state.hiddenColumns.has(c.id));
    if(!visCol) return;
    col = findColumnById(visCol.id);
    if(!col) return;
    targetSiblings = col.schema.children || (col.schema.children = []);
    targetParentId = col.schema.id;
    insertIdx = targetSiblings.length;
  }
  recordChange();
  const taken = collectNodeIds(col);
  const newIds = [];
  // Also collect mappings that reference the original clipboard nodes' fields
  const origFieldMap = new Map(); // origFieldId -> newFieldId
  for(let i = 0; i < __nodeClipboard.nodes.length; i++){
    const origNode = __nodeClipboard.nodes[i];
    const clone = deepCloneNode(origNode, taken, targetParentId);
    targetSiblings.splice(insertIdx + i, 0, clone);
    newIds.push(clone.id);
    // Build mapping of original field IDs to new field IDs
    (function buildMap(orig, cloned){
      if(orig.type === 'field') origFieldMap.set(orig.id, cloned.id);
      const oc = orig.children || [], cc = cloned.children || [];
      for(let j = 0; j < oc.length; j++) buildMap(oc[j], cc[j]);
    })(origNode, clone);
  }
  // Duplicate mappings from original fields
  const newMappings = [];
  for(const m of (state.data.mappings || [])){
    if(!m) continue;
    const hasFrom = origFieldMap.has(m.from);
    const hasTo = origFieldMap.has(m.to);
    if(hasFrom || hasTo){
      newMappings.push({
        ...m,
        from: hasFrom ? origFieldMap.get(m.from) : m.from,
        to: hasTo ? origFieldMap.get(m.to) : m.to
      });
    }
  }
  if(newMappings.length) state.data.mappings.push(...newMappings);
  renderAll();
  state.multiSelection.clear();
  for(const id of newIds) state.multiSelection.add(id);
  state.lockedId = newIds[0];
  applyHighlight();
  scrollIntoView(newIds[0]);
  setGlobalStatus(`Pasted ${newIds.length} node${newIds.length>1?'s':''}${newMappings.length ? ' with ' + newMappings.length + ' mapping' + (newMappings.length>1?'s':'') : ''}.`);
}function addChildNode(nodeId, colId, isFieldNew, atTop=false){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.node) return;
  if(loc.node.type==='field') return;
  if(!loc.node.children) loc.node.children=[];
  const taken = collectNodeIds(col);
  openCreateModal({
    kind: 'node',
    title: `Add ${isFieldNew?'field':'group'} (${atTop?'top':'bottom'})`,
    placeholder: isFieldNew ? 'Field label' : 'Group label',

    hint: 'ID is generated from the label under the selected parent and made unique.',
    colId,
    parentId: nodeId===colId ? colId : nodeId,
    taken,
    onCommit: ({label, id, note, tags, customAttributes, _autoId})=>{
      recordChange(); // Save BEFORE adding
      const newNode = { id, label, _autoId, type: isFieldNew?'field':'group' }; if(note) newNode.note = note;
      if(tags && tags.length) newNode.tags = tags;
      if(customAttributes) newNode.customAttributes = customAttributes;
      if(!isFieldNew) newNode.children=[];
      if(atTop) loc.node.children.unshift(newNode);
      else loc.node.children.push(newNode);
      renderAll();
      lockSelection(id);
    }
  });
}


// --- Visible node ordering (for keyboard navigation) ---
function getVisibleNodeOrder(){
  const order = [];
  const panels = columnsRow.querySelectorAll('.panel:not(.hiddenCol)');
  panels.forEach(panel => {
    const colId = panel.dataset.columnId;
    if(!colId) return;
    panel.querySelectorAll('.row[data-node-id]').forEach(row => {
      if(!row.offsetParent) return;
      order.push({ nodeId: row.dataset.nodeId, colId });
    });
  });
  return order;
}

// --- Inline rename system (for keyboard quick-create) ---
let __inlineRename = null; // { nodeId, colId, isNew, blurTimer }

function startInlineRename(nodeId){
  if(__inlineRename) commitInlineRename();
  const row = IDX.rowById.get(nodeId);
  if(!row) return;
  const label = row.querySelector('.label');
  if(!label) return;
  const textSpan = label.querySelector('.text');
  if(!textSpan) return;
  const colId = row.dataset.columnId;
  const node = IDX.nodeById.get(nodeId);
  if(!node) return;

  __inlineRename = { nodeId, colId, isNew: true, blurTimer: null };

  textSpan.style.display = 'none';
  const wrap = document.createElement('div');
  wrap.className = 'inlineRenameWrap';
  const input = document.createElement('input');
  input.type = 'text';
  input.value = '';
  input.placeholder = node.type === 'group' ? 'Group label' : 'Field label';
  wrap.appendChild(input);
  label.appendChild(wrap);

  requestAnimationFrame(() => input.focus());

  input.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.altKey){
      e.preventDefault();
      e.stopPropagation();
      commitInlineRename();
      return;
    }
    if(e.key === 'Escape'){
      e.preventDefault();
      e.stopPropagation();
      cancelInlineRename();
      return;
    }
    // Let Ctrl+/ etc. bubble to main handler which commits first
  });

  input.addEventListener('blur', () => {
    if(!__inlineRename || __inlineRename.nodeId !== nodeId) return;
    // Save the current value so it's available even after DOM rebuild
    __inlineRename._savedValue = input.value;
    __inlineRename.blurTimer = setTimeout(() => {
      if(__inlineRename && __inlineRename.nodeId === nodeId) commitInlineRename();
    }, 150);
  });
}

function commitInlineRename(defaultLabel){
  if(!__inlineRename) return;
  if(__inlineRename.blurTimer) { clearTimeout(__inlineRename.blurTimer); __inlineRename.blurTimer = null; }
  const { nodeId, colId } = __inlineRename;
  const node = IDX.nodeById.get(nodeId);
  const col = findColumnById(colId);
  if(!node || !col) { __inlineRename = null; return; }

  const row = IDX.rowById.get(nodeId);
  const input = row?.querySelector('.inlineRenameWrap input');
  let label = (input?.value ?? __inlineRename?._savedValue ?? '').trim();

  if(!label){
    const base = defaultLabel || (node.type === 'group' ? 'New Group' : 'New Field');
    // Make label unique if needed
    const existingLabels = new Set();
    (function walk(n){ if(!n) return; if(n.id !== nodeId && n.label) existingLabels.add(n.label); (n.children||[]).forEach(walk); })(col.schema);
    label = base;
    if(existingLabels.has(label)){
      let i = 2;
      while(existingLabels.has(base + ' ' + i)) i++;
      label = base + ' ' + i;
    }
  }

  node.label = label;

  // Regenerate ID from label
  const parentId = IDX.parentById.get(nodeId) || colId;
  const taken = collectNodeIds(col);
  taken.delete(nodeId);
  const slug = transliterate(label).replace(/[^a-z0-9_]/gi, '_').replace(/__+/g,'_').replace(/^_|_$/g,'').toLowerCase();
  const baseId = (parentId === colId ? colId : parentId) + '.' + (slug || 'node');
  const newId = ensureUniqueId(baseId, taken);

  if(newId !== nodeId){
    const idMap = {};
    buildSubtreeIdMap(node, nodeId, newId, idMap);
    replaceIdsInMappings(state.data, idMap);
  }
  node._autoId = true;

  // Clear edit snapshot so beginEditSnapshot doesn't auto-revert our changes
  __editSnapshot = null;
  __inlineRename = null;

  // Set selection directly (bypass lockSelection to avoid snapshot cascade)
  state.selectedColumnId = null;
  state.lockedId = node.id;
  state.hoverId = null;
  state._lastClickedNodeId = node.id;

  renderAll();
  // Clear any snapshot created during renderAll's applyHighlight
  __editSnapshot = null;
  applyHighlight();
  __editSnapshot = null;
  scrollIntoView(node.id);
}

function cancelInlineRename(){
  if(!__inlineRename) return;
  if(__inlineRename.blurTimer) { clearTimeout(__inlineRename.blurTimer); __inlineRename.blurTimer = null; }
  const wasNew = __inlineRename.isNew;
  __editSnapshot = null; // Don't auto-revert on next selection
  __inlineRename = null;
  if(wasNew){
    undo();
  } else {
    renderAll();
  }
}

// --- Quick-create node via keyboard ---
function quickCreateNode(position, type){
  // position: 'below' | 'above' | 'child'
  // type: 'field' | 'group'
  if(!state.editorMode) return;

  // If inline rename is active, commit it first (saves label, renames ID)
  if(__inlineRename){
    commitInlineRename();
  }

  const rawId = state.lockedId;
  const colId = state.selectedColumnId;

  // Determine if lockedId is a node or a column
  const isNodeId = rawId && columnOf(rawId);  // node IDs have a "." prefix
  const nodeId = isNodeId ? rawId : null;
  const effectiveColId = colId || (!isNodeId && rawId ? rawId : null);

  // Determine target column and insertion point
  let col, loc, parentId, siblings, insertIdx;

  if(nodeId){
    const c = columnOf(nodeId);
    col = findColumnById(c);
    if(!col) return;

    if(position === 'child'){
      // Add inside the selected node (must be a group)
      const node = IDX.nodeById.get(nodeId);
      if(!node || node.type !== 'group') return;
      if(!node.children) node.children = [];
      parentId = nodeId;
      siblings = node.children;
      insertIdx = siblings.length; // append at bottom
      // Expand the group if collapsed
      toggleCollapse(nodeId, false, true);
    } else {
      loc = locateNode(col.schema, nodeId);
      if(!loc || !loc.parent || !loc.siblings || loc.idx === null) return;
      parentId = loc.parent.id === col.id ? col.id : loc.parent.id;
      siblings = loc.siblings;
      insertIdx = position === 'below' ? loc.idx + 1 : loc.idx;
    }
  } else if(effectiveColId){
    col = findColumnById(effectiveColId);
    if(!col || !col.schema) return;
    if(!col.schema.children) col.schema.children = [];
    parentId = effectiveColId;
    siblings = col.schema.children;
    // above  top, below/child  bottom
    insertIdx = position === 'above' ? 0 : siblings.length;
  } else {
    return;
  }

  // Generate temporary ID
  const taken = collectNodeIds(col);
  const tempBase = (parentId === col.id ? col.id : parentId) + '.' + (type === 'group' ? 'new_group' : 'new_field');
  const tempId = ensureUniqueId(tempBase, taken);

  // Record undo snapshot BEFORE creation
  recordChange();

  const newNode = { id: tempId, label: '', _autoId: true, type };
  if(type === 'group') newNode.children = [];

  siblings.splice(insertIdx, 0, newNode);

  // IMPORTANT: We bypass lockSelection entirely to avoid its snapshot-revert
  // cascade which triggers deferred renderAll() microtasks that destroy the
  // inline rename input. Instead we set selection state directly.
  __editSnapshot = null;
  state.selectedColumnId = null;
  state.selectedEdgeId = null;
  state.hoverEdgeId = null;
  state.hoverId = null;
  if(state.multiSelection instanceof Set) state.multiSelection.clear();
  else state.multiSelection = new Set();
  state._consolidatedEdgeCache = null;
  state.lockedId = tempId;
  state._lastClickedNodeId = tempId;

  renderAll();

  // After renderAll, beginEditSnapshot may have been called and created a snapshot.
  // Clear it so no deferred re-render can fire when we start inline rename.
  __editSnapshot = null;

  // Re-apply highlight with the correct lockedId (renderAll's applyHighlight
  // already ran but may have used stale state; this ensures correct visuals)
  applyHighlight();

  // Final safety: clear any snapshot that applyHighlightupdateDetails may have created
  __editSnapshot = null;

  startInlineRename(tempId);
  scrollIntoView(tempId);
}

// --- Convert field  group ---
function convertNodeType(nodeId, colId){
  if(!state.editorMode) return;
  const col = findColumnById(colId);
  if(!col) return;
  const loc = locateNode(col.schema, nodeId);
  if(!loc || !loc.node) return;
  const node = loc.node;

  if(node.type === 'field'){
    // Field  Group
    recordChange();
    node.type = 'group';
    if(!node.children) node.children = [];
    renderAll();
    lockSelection(nodeId);
    setViewerStatus(`Converted "${node.label || nodeId}" to group`);
  } else if(node.type === 'group'){
    // Group  Field: only if no children
    if(node.children && node.children.length > 0){
      customAlert('Remove all children before converting this group to a field.');
      return;
    }
    recordChange();
    node.type = 'field';
    delete node.children;
    renderAll();
    lockSelection(nodeId);
    setViewerStatus(`Converted "${node.label || nodeId}" to field`);
  }
}


// --- Context menu (vertical, viewport-anchored; avoids clipping) ---
let __ctxMenuEl = null;
let __ctxOwnerEl = null;
let __ctxMenuColId = null;

let __ctxCleanup = null;
function closeCtxMenu(){
  if(__ctxCleanup){ try{ __ctxCleanup(); }catch{} __ctxCleanup=null; }
  if(__ctxMenuEl){ __ctxMenuEl.remove(); __ctxMenuEl=null; }
  if(__ctxOwnerEl){ try{ __ctxOwnerEl.classList.remove('menuOpen'); }catch{} __ctxOwnerEl=null; }
  __ctxMenuColId = null;
}
function openCtxMenu(items, anchorEl, pos){
  closeCtxMenu();
  // Keep the originating row/header in an active-hover state while the context menu is open
  try{
    if(__ctxOwnerEl) __ctxOwnerEl.classList.remove('menuOpen');
    __ctxOwnerEl = anchorEl?.closest('.row') || anchorEl?.closest('.panelHeader') || null;
    if(__ctxOwnerEl) __ctxOwnerEl.classList.add('menuOpen');
  }catch{}

  const menu = document.createElement('div');
  menu.className = 'ctxMenu';
  items.forEach(it=>{
    if(!it) return;
    if(it.type==='sep'){
      const sep=document.createElement('div'); sep.className='ctxSep';
      menu.appendChild(sep); return;
    }
    if(it.type==='label'){
      const lbl=document.createElement('div'); lbl.className='ctxLabel';
      lbl.textContent = it.text||'';
      menu.appendChild(lbl); return;
    }
    const btn=document.createElement('button');
    btn.type='button';
    btn.className = 'ctxItem' + (it.danger ? ' danger' : '');
    btn.disabled = !!it.disabled;
    const kbdHtml = it.kbd ? `<span class="kbd">${escapeHtml(platformKbd(it.kbd))}</span>` : '';
    btn.innerHTML = `<span class="ico">${it.icon||''}</span><span class="lbl">${escapeHtml(it.label||'')}</span>${kbdHtml}`;
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(btn.disabled) return;
      closeCtxMenu();
      try{ it.onClick && it.onClick(); }catch(err){ console.error(err); }
    });
    menu.appendChild(btn);
  });
  document.body.appendChild(menu);

  // position near anchor or at explicit coordinates, clamp to viewport, flip if needed
  const pad = 8;
  const gap = 6;
  let x, y;
  if(pos){
    x = pos.x;
    y = pos.y;
  } else {
    const r = anchorEl.getBoundingClientRect();
    x = r.left;
    y = r.bottom + gap;
  }
  const mr = menu.getBoundingClientRect();
  if(x + mr.width > window.innerWidth - pad) x = window.innerWidth - pad - mr.width;
  if(x < pad) x = pad;
  if(y + mr.height > window.innerHeight - pad){
    y = (pos ? pos.y : anchorEl.getBoundingClientRect().top) - gap - mr.height;
  }
  if(y < pad) y = pad;
  menu.style.left = `${Math.round(x)}px`;
  menu.style.top  = `${Math.round(y)}px`;

  const onDocClick = (e)=>{
    if(menu.contains(e.target)) return;
    // Let miniBtn handlers deal with their own toggle logic
    if(e.target.closest && e.target.closest('.miniBtn')) return;
    closeCtxMenu();
  };
  const onKey = (e)=>{ if(e.key==='Escape') closeCtxMenu(); };
  const onAnyScroll = ()=> closeCtxMenu();

  document.addEventListener('click', onDocClick, true);
  document.addEventListener('keydown', onKey, true);
  window.addEventListener('resize', onAnyScroll, true);
  // Delay scroll listener to avoid false triggers from layout changes that precede menu open
  let _scrollTimer = setTimeout(()=>{
    window.addEventListener('scroll', onAnyScroll, true);
    _scrollTimer = null;
  }, 80);

  __ctxMenuEl = menu;
  __ctxCleanup = ()=>{
    document.removeEventListener('click', onDocClick, true);
    document.removeEventListener('keydown', onKey, true);
    window.removeEventListener('scroll', onAnyScroll, true);
    window.removeEventListener('resize', onAnyScroll, true);
    if(_scrollTimer) clearTimeout(_scrollTimer);
  };
}

function addRowActions(){
  if(!state.editorMode) return;

  // one-time global closer for mini menus (legacy; keep harmless)
  if(!document.__msMenuClose){
    document.__msMenuClose = true;
    document.addEventListener('click', async ()=>{
      document.querySelectorAll('.miniMenu.active').forEach(m=>m.classList.remove('active'));
    });
  }

  for(const [nodeId,row] of IDX.rowById.entries()){
    if(row.querySelector('.rowActions')) continue;
    const node = IDX.nodeById.get(nodeId);
    const colId = row.dataset.columnId;
    const hasParent = !!IDX.parentById.get(nodeId);

    function lockCurrent(e){
      if(e) e.stopPropagation();
      // Toggle: if already locked on this node, unlock it
      if(state.lockedId===nodeId){
        state.lockedId = null;
        state.hoverId = null;
        applyHighlight();
      } else {
        state.selectedColumnId = null;
        state.selectedEdgeId = null;
        state.lockedId = nodeId;
        state.hoverId = null;
        applyHighlight();
      }
    }

    // Compute sibling position
    let loc=null;
    if(hasParent){
      const col = findColumnById(colId);
      if(col) loc = locateNode(col.schema, nodeId);
    }
    const canMoveUp = !!(loc && loc.siblings && loc.idx!==null && loc.idx>0);
    const canMoveDown = !!(loc && loc.siblings && loc.idx!==null && loc.idx < loc.siblings.length-1);

    // Indent into previous sibling group
    const canIndent = !!(loc && loc.siblings && loc.idx!==null && loc.idx>0 && loc.siblings[loc.idx-1] && loc.siblings[loc.idx-1].type==='group');

    // Outdent to parent (requires grandparent)
    let canOutdent = false;
    if(loc && loc.parent){
      const col = findColumnById(colId);
      const parentLoc = col ? locateNode(col.schema, loc.parent.id) : null;
      canOutdent = !!(parentLoc && parentLoc.parent && parentLoc.siblings && parentLoc.idx!==null);
    }

    const actions=document.createElement('div');
    actions.className='rowActions';
    actions.style.position='relative';

    // For groups: add "+" menu for Add child (unchanged options; icon changed)
    if(node && node.type==='group'){
      const addChildItems = [
        {label:'Field on top', icon:ICONS.addFieldUp, onClick: ()=> addChildNode(nodeId, colId, true, true)},
        {label:'Field at bottom', icon:ICONS.addFieldDown, onClick: ()=> addChildNode(nodeId, colId, true, false)},
        {type:'sep'},
        {label:'Group on top', icon:ICONS.addGroupUp, onClick: ()=> addChildNode(nodeId, colId, false, true)},
        {label:'Group at bottom', icon:ICONS.addGroupDown, onClick: ()=> addChildNode(nodeId, colId, false, false)},
      ];
      const btnPlus=document.createElement('button');
      btnPlus.className='miniBtn';
      btnPlus.title='Add child';
      btnPlus.textContent='\u21B3';
      btnPlus.addEventListener('click', async (e)=>{ 
        e.stopPropagation();
        const row = btnPlus.closest('.row') || btnPlus.closest('.panelHeader');
        if(__ctxMenuEl && __ctxOwnerEl === row){
          closeCtxMenu();
          return;
        }
        closeCtxMenu();
        if(state.lockedId !== nodeId){
          if(nodeEditIsDirty()){
            if(!await guardNodeAbandon()) return;
            revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
          }
          state.selectedColumnId = null;
          state.selectedEdgeId = null;
          state.lockedId = nodeId;
          state.hoverId = null;
          applyHighlight();
        }
        openCtxMenu(addChildItems, btnPlus);
      });
      actions.appendChild(btnPlus);
    }

    // Build  menu for both fields and groups
    const menuItems = [];
    menuItems.push({ label: node.type==='field' ? 'Edit field' : 'Edit group', icon:ICONS.edit, onClick: ()=>{
      // Focus on this node without toggling selection
      state.selectedEdgeId = null; state.hoverEdgeId = null; state.selectedColumnId = null;
      if(state.multiSelection.size > 0){ state.multiSelection.clear(); }
      state.lockedId = nodeId; state.hoverId = null;
      applyHighlight();
      scrollIntoView(nodeId);
    }});
    // Add child items (groups only)
    if(node && node.type==='group'){
      menuItems.push({ type:'label', text:'Add child' });
      menuItems.push({ label:'Field on top', icon:ICONS.addFieldUp, onClick: ()=> addChildNode(nodeId, colId, true, true) });
      menuItems.push({ label:'Field at bottom', icon:ICONS.addFieldDown, onClick: ()=> addChildNode(nodeId, colId, true, false) });
      menuItems.push({ label:'Group on top', icon:ICONS.addGroupUp, onClick: ()=> addChildNode(nodeId, colId, false, true) });
      menuItems.push({ label:'Group at bottom', icon:ICONS.addGroupDown, onClick: ()=> addChildNode(nodeId, colId, false, false) });
    }
    // Insert siblings
    if(hasParent){
      menuItems.push({ type:'label', text:'Insert' });
      menuItems.push({ label:'Field above', icon:ICONS.addFieldUp, onClick: ()=> addAboveNode(nodeId, colId, true) });
      menuItems.push({ label:'Field below', icon:ICONS.addFieldDown, onClick: ()=> addBelowNode(nodeId, colId, true) });
      menuItems.push({ label:'Group above', icon:ICONS.addGroupUp, onClick: ()=> addAboveNode(nodeId, colId, false) });
      menuItems.push({ label:'Group below', icon:ICONS.addGroupDown, onClick: ()=> addBelowNode(nodeId, colId, false) });
    }
    // Move
    menuItems.push({ type:'label', text:'Arrange' });
    menuItems.push({ label:'Move up', icon:ICONS.moveUp, disabled:!canMoveUp, onClick: ()=> moveNode(nodeId, colId, -1), kbd:'Alt+' });
    menuItems.push({ label:'Move down', icon:ICONS.moveDown, disabled:!canMoveDown, onClick: ()=> moveNode(nodeId, colId, +1), kbd:'Alt+' });
    if(hasParent) menuItems.push({ type:'sep' });
    // Indent/Outdent
    menuItems.push({ label:'Indent', icon:ICONS.indent, disabled:!canIndent, onClick: ()=> inlineIndent(nodeId, colId), kbd:'Alt+' });
    menuItems.push({ label:'Outdent', icon:ICONS.outdent, disabled:!canOutdent, onClick: ()=> inlineOutdent(nodeId, colId), kbd:'Alt+' });
    if(hasParent) menuItems.push({ type:'sep' });
    // Clipboard & Duplicate
    menuItems.push({ label:'Copy', icon:ICONS.copy, onClick: ()=> copyNodes(), kbd:'Ctrl+C' });
    menuItems.push({ label:'Paste', icon:ICONS.paste, disabled:!__nodeClipboard, onClick: ()=> pasteNodes(), kbd:'Ctrl+V' });
    menuItems.push({ label:'Duplicate', icon:ICONS.duplicate, disabled:!hasParent, onClick: ()=> duplicateNode(nodeId, colId, false), kbd:'Ctrl+D' });
    menuItems.push({ label:'Duplicate+', icon:ICONS.duplicatePlus, disabled:!hasParent, onClick: ()=> duplicateNode(nodeId, colId, true) });
    menuItems.push({ type:'sep' });
    // Group / Ungroup
    menuItems.push({ label:'Group selection', icon:ICONS.groupWrap, disabled:!(state.multiSelection.size > 1 || state.lockedId), onClick: ()=> groupSelection(), kbd:'Ctrl+G' });
    if(node.type === 'group' && node.children && node.children.length > 0){
      menuItems.push({ label:'Ungroup', icon:ICONS.ungroupDissolve, onClick: ()=> ungroupNode(), kbd:'Ctrl+Shift+G' });
    }
    menuItems.push({ type:'sep' });
    // Convert type
    if(node.type === 'field'){
      menuItems.push({ label:'Convert to group', icon:ICONS.convert, onClick: ()=> convertNodeType(nodeId, colId) });
    } else if(node.type === 'group'){
      const canConvert = !(node.children && node.children.length > 0);
      menuItems.push({ label:'Convert to field', icon:ICONS.convert, disabled:!canConvert, onClick: ()=> convertNodeType(nodeId, colId) });
    }
    menuItems.push({ type:'sep' });
    // Delete
    menuItems.push({ label: 'Delete', icon:ICONS.trash, danger:true, disabled:!hasParent, onClick: ()=> bulkDelete(), kbd:'Delete' });

    const btnMenu=document.createElement('button');
    btnMenu.className='miniBtn';
    btnMenu.title='Actions';
    btnMenu.textContent='';
    btnMenu.addEventListener('click', async (e)=>{ 
      e.stopPropagation();
      const row = btnMenu.closest('.row') || btnMenu.closest('.panelHeader');
      if(__ctxMenuEl && __ctxOwnerEl === row){
        closeCtxMenu();
        return;
      }
      closeCtxMenu();
      if(state.lockedId !== nodeId){
        if(nodeEditIsDirty()){
          if(!await guardNodeAbandon()) return;
          revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
        }
        state.selectedColumnId = null;
        state.selectedEdgeId = null;
        state.lockedId = nodeId;
        state.hoverId = null;
        applyHighlight();
      }
      openCtxMenu(menuItems, btnMenu);
    });
    btnMenu.__menuItems = menuItems;
    actions.appendChild(btnMenu);

    row.appendChild(actions);

    // Drag & drop mapping creation (fields only)  unchanged
    if(!window.__ENHANCED_DND && node && node.type==='field'){
      row.draggable = true;
      row.addEventListener('dragstart', (e)=>{
        if(!state.editorMode) return;
        try{ e.dataTransfer.setData('text/plain', nodeId); e.dataTransfer.effectAllowed='copy'; }catch{}
      });
    }

    if(!window.__ENHANCED_DND) row.addEventListener('dragover', (e)=>{
      if(!state.editorMode) return;
      const src = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
      if(!src) return;
      const srcNode = IDX.nodeById.get(src);
      if(!(srcNode && srcNode.type==='field' && node && node.type==='field')) return;
      if(row.dataset.columnId === (IDX.rowById.get(src)?.dataset.columnId)) return;
      e.preventDefault();
      row.classList.add('dropTarget');
    });
    if(!window.__ENHANCED_DND) row.addEventListener('dragleave', ()=> row.classList.remove('dropTarget'));
    if(!window.__ENHANCED_DND) row.addEventListener('drop', (e)=>{
      if(!state.editorMode) return;
      const src = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
      if(!src) return;
      const srcNode = IDX.nodeById.get(src);
      if(!(srcNode && srcNode.type==='field' && node && node.type==='field')) return;
      if(row.dataset.columnId === (IDX.rowById.get(src)?.dataset.columnId)) return;
      e.preventDefault();
      const _dropDir = _dirFromModifiers(e);
      ensureMapping(src, nodeId, _dropDir);
      renderAll();
      const edge = IDX.edges.find(e=>e.from===src && e.to===nodeId);
      if(edge) state.selectedEdgeId = edge.id;
      state.lockedId = nodeId;
      applyHighlight();
      scheduleArrowsUpdate();
    });
  }
}


function setEditorMode(on){
  state.editorMode = !!on;
  // Preserve column selection across mode toggle, just clear edit sessions
  state.hoverEdgeId = null;
  // Clear edit sessions (already guarded before reaching here)
  __editSnapshot = null;
  __edgeEditSession = null;
  if(typeof updateColumnHeaderSelectionStyles==='function') updateColumnHeaderSelectionStyles();

  document.body.classList.toggle('editorMode', state.editorMode);
  const editorModeBtn = document.getElementById('editorModeBtn');
  if(editorModeBtn) editorModeBtn.classList.toggle('active', state.editorMode);
  if(!state.editorMode){
    if(editorOverlay) editorOverlay.innerHTML='';
  }
  
  // Show/hide editor-only buttons
  const vcHistoryGroup = document.getElementById('vcHistoryGroup');
  if(vcHistoryGroup) vcHistoryGroup.style.display = state.editorMode ? '' : 'none';
  const addTagBtn = document.getElementById('addTagBtn');
  const addTransformBtn = document.getElementById('addTransformBtn');
  const addCustomAttrBtn = document.getElementById('addCustomAttrBtn');
  if(addTagBtn) addTagBtn.style.display = state.editorMode ? '' : 'none';
  { const b=document.getElementById('importTagsBtn'); if(b) b.style.display = state.editorMode ? '' : 'none'; }
  if(addTransformBtn) addTransformBtn.style.display = state.editorMode ? '' : 'none';
  { const b=document.getElementById('importTransformsBtn'); if(b) b.style.display = state.editorMode ? '' : 'none'; }
  if(addCustomAttrBtn) addCustomAttrBtn.style.display = state.editorMode ? '' : 'none';
  { const b=document.getElementById('importAttrsBtn'); if(b) b.style.display = state.editorMode ? '' : 'none'; }
  const addFilterBtn2 = document.getElementById('addFilterBtn');
  if(addFilterBtn2) addFilterBtn2.style.display = state.editorMode ? '' : 'none';
  
  // Re-render catalogs for read-only vs edit mode
  if(typeof renderTagsManager==='function') renderTagsManager();
  if(typeof renderTransformsManager==='function') renderTransformsManager();
  if(typeof renderCustomAttrsManager==='function') renderCustomAttrsManager();
  if(typeof renderFiltersManager==='function') renderFiltersManager();
  if(typeof buildColumnsMenu==='function') buildColumnsMenu();
  
  renderAll();
  
  addRowActions();
  attachColumnHeaderActions();
  setGlobalStatus(state.editorMode ? 'Editor mode: ON' : 'Editor mode: OFF');
}

function attachSvgEdgeInteractions(){
  if(!edgesLayer) return;
  if(edgesLayer.__edgeSelectBound) return;
  edgesLayer.__edgeSelectBound = true;

  // Click selects an edge in both Viewer & Editor
  edgesLayer.addEventListener('click', (e)=>{
    const path = e.target?.closest?.('path.edge');
    if(!path) return;
    const eid = path.dataset?.edgeId; if(!eid) return;

    // Cache consolidated metadata from the SVG path BEFORE selectEdge/renderAll
    // destroys it. drawArrows() stores collapsed-group consolidation info on path
    // elements, which is lost when the SVG is cleared and arrows redrawn via RAF.
    state._consolidatedEdgeCache = null;
    if(path.__consolidated){
      state._consolidatedEdgeCache = {
        edgeId: eid,
        consolidated: path.__consolidated,
        isBidirectional: path.__isBidirectional,
        fromId: path.__fromId,
        toId: path.__toId
      };
    }

    selectEdge(eid);
  });

  // Hover previews an edge when nothing is locked/selected
  edgesLayer.addEventListener('mouseover', (e)=>{
    const path = e.target?.closest?.('path.edge');
    if(!path) return;
    if(state.panMode) return;
    if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
    const eid = path.dataset?.edgeId; if(!eid) return;
    state.hoverEdgeId = eid; applyHighlight();
  });
  edgesLayer.addEventListener('mouseout', (e)=>{
    const path = e.target?.closest?.('path.edge');
    if(!path) return;
    if(state.panMode) return;
    if(state.lockedId || state.selectedEdgeId || state.multiSelection.size > 0) return;
    state.hoverEdgeId = null; applyHighlight();
  });
}

function renderSelectedEdgeEditor(){
  if(!state.editorMode) return false;
  const edgeId = state.selectedEdgeId || state.hoverEdgeId;
  if(!edgeId) return false;
  
  // Find the edge object first
  const edge = IDX.edges.find(e => e.id === edgeId);
  if(!edge) return false;
  
  // Check the SVG path element for consolidated metadata (set during drawing)
  const pathEl = Array.from(edgesLayer.querySelectorAll('path.edge')).find(p => p.dataset.edgeId === edgeId);
  
  // Use path metadata if available (handles collapsed groups), otherwise check cache
  // (cached by SVG click handler before renderAll destroys paths), then edge metadata
  const cache = (state._consolidatedEdgeCache && state._consolidatedEdgeCache.edgeId === edgeId) ? state._consolidatedEdgeCache : null;
  const consolidated = pathEl?.__consolidated || cache?.consolidated || edge.__consolidated;
  const isBidirectional = pathEl?.__isBidirectional || cache?.isBidirectional || edge.__isBidirectional;
  const fromId = pathEl?.__fromId || cache?.fromId || edge.__fromId || edge.from;
  const toId = pathEl?.__toId || cache?.toId || edge.__toId || edge.to;
  
  // Check if this edge IS the representative of a consolidated arrow
  const isRepresentative = consolidated && consolidated.length > 1 && consolidated[0].id === edgeId;
  
  // Check if user explicitly wants to view individual mapping (clicked Edit button)
  const forceIndividual = state._showIndividualMapping;
  
  
  if(isRepresentative && !forceIndividual){
    // Check if this is collapsed groups or bidirectional fields
    const isCollapsedGroups = fromId !== edge.from || toId !== edge.to;
    
    if(isCollapsedGroups){
      // Collapsed groups - show all consolidated mappings with click-to-edit
      detailsMeta.textContent = `consolidated  ${consolidated.length} mappings`;
      
      const edges = consolidated;
      const mappings = state.data.mappings || [];
      
      // Build HTML for all mappings as clickable boxes
      const htmlParts = edges.map(edgeItem => {
        // Find the rule for this edge
        let rule = null;
        for(const m of mappings){
          if(!m || typeof m!=='object') continue;
          if(m.from !== edgeItem.from) continue;
          const tos = Array.isArray(m.to) ? m.to : [m.to];
          if(tos.includes(edgeItem.to)) { rule = m; break; }
        }
        
        const tLabels = (rule?.transforms && rule.transforms.length)
          ? rule.transforms.map(formatTransformRef).join('  ')
          : '';
        
        return `
          <div class="box clickable" data-edge-id="${edgeItem.id}">
            <div class="dtEditorHead">
              <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
              <span class="dtEditorLabel">click to edit</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.from)}</code></span></div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.to)}</code></span></div>
            ${rule?.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(rule.cardinality)}</span></div>` : ''}
            ${rule?.label ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Label</span><span class="dtRowV" style="font-weight:600;">${escapeHtml(rule.label)}</span></div>` : ''}
            ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
            ${(rule?.default!=='' && rule?.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(rule.default))}</span></div>` : ''}
            ${edgeTagAttrRowsHtml(rule)}
            ${rule?.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(rule.note)}</div>` : ''}
          </div>
        `;
      });
      
      // Join with dividers
      detailsBody.innerHTML = htmlParts.join('<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 24px 0;"></div>');
      
      // Attach click handlers to edit mappings
      detailsBody.querySelectorAll('.box.clickable').forEach(box => {
        box.addEventListener('click', () => {
          const clickedEdgeId = box.dataset.edgeId;
          
          // Find the edge to get from/to fields
          const clickedEdge = consolidated.find(e => e.id === clickedEdgeId);
          if(clickedEdge){
            // Expand both groups that contain the from/to fields
            const fromParent = findCollapsedParent(clickedEdge.from);
            const toParent = findCollapsedParent(clickedEdge.to);
            if(fromParent) toggleCollapse(fromParent, false);
            if(toParent) toggleCollapse(toParent, false);
          }
          
          state._showIndividualMapping = true;
          try{ clearEdgeEditSession({clearSelection:false}); }catch(e){}
          try{ if(typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'){ revertEditSnapshot(); } }catch(e){}
          __editSnapshot = null;
          state.selectedColumnId = null;
          state.lockedId = null;
          state.hoverId = null;
          state.selectedEdgeId = clickedEdgeId;
          state.hoverEdgeId = null;
          // Update highlights, details, and arrows
          applyHighlight(); // includes updateDetails + scheduleArrowsUpdate
        });
      });
      
      return true;
    } else if(isBidirectional){
      // Bidirectional field mappings - show both in standard format with click-to-edit
      const isHoverOnly = !state.selectedEdgeId && state.hoverEdgeId;
      detailsMeta.textContent = isHoverOnly ? 'bidirectional  hover' : 'bidirectional  2 mappings';
      
      const edges = consolidated;
      const mappings = state.data.mappings || [];
      
      // Build HTML for both mappings using standard box styling
      const htmlParts = edges.map(edgeItem => {
        // Find the rule for this edge
        let rule = null;
        for(const m of mappings){
          if(!m || typeof m!=='object') continue;
          if(m.from !== edgeItem.from) continue;
          const tos = Array.isArray(m.to) ? m.to : [m.to];
          if(tos.includes(edgeItem.to)) { rule = m; break; }
        }
        
        const tLabels = (rule?.transforms && rule.transforms.length)
          ? rule.transforms.map(formatTransformRef).join('  ')
          : '';
        
        return `
          <div class="box clickable" data-edge-id="${edgeItem.id}">
            <div class="dtEditorHead">
              <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
              <span class="dtEditorLabel">click to edit</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.from)}</code></span></div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.to)}</code></span></div>
            ${rule?.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(rule.cardinality)}</span></div>` : ''}
            ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
            ${(rule?.default!=='' && rule?.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(rule.default))}</span></div>` : ''}
            ${edgeTagAttrRowsHtml(rule)}
            ${rule?.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(rule.note)}</div>` : ''}
          </div>
        `;
      });
      
      // Join with a visual divider
      detailsBody.innerHTML = htmlParts.join('<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 24px 0;"></div>');
      
      // Attach click handlers to edit mappings
      detailsBody.querySelectorAll('.box.clickable').forEach(box => {
        box.addEventListener('click', () => {
          const clickedEdgeId = box.dataset.edgeId;
          state._showIndividualMapping = true;
          // Manually select edge without calling renderAll()
          try{ clearEdgeEditSession({clearSelection:false}); }catch(e){}
          try{ if(typeof __editSnapshot==='object' && __editSnapshot && __editSnapshot.kind==='node'){ revertEditSnapshot(); } }catch(e){}
          __editSnapshot = null;
          state.selectedColumnId = null;
          state.lockedId = null;
          state.hoverId = null;
          state.selectedEdgeId = clickedEdgeId;
          state.hoverEdgeId = null;
          // Update highlights, details, and arrows
          applyHighlight(); // includes updateDetails + scheduleArrowsUpdate
        });
      });
      
      return true;
    }
  }
  
  // Edge already found at the top, continue with regular edge editing
  const mappings = state.data.mappings || [];
  let rule = null;
  for(const m of mappings){
    if(!m || typeof m!=='object') continue;
    if(m.from !== edge.from) continue;
    const tos = Array.isArray(m.to) ? m.to : (typeof m.to==='string' ? [m.to] : []);
    if(tos.includes(edge.to)) { rule = m; break; }
  }
  if(!rule) return false;

  // Start/reuse edit session; draft holds unsaved edits.
  // Only create edit session for selected edges, not hovered ones
  if(state.selectedEdgeId && (!__edgeEditSession || __edgeEditSession.edgeId !== state.selectedEdgeId)){
    // Normalize: fill defaults so draft comparison doesn't flag empty-vs-undefined as dirty
    const snap = deepClone(rule);
    if(snap.cardinality === undefined) snap.cardinality = '';
    if(snap.default === undefined) snap.default = '';
    if(snap.note === undefined) snap.note = '';
    if(snap.label === undefined) snap.label = '';
    if(snap.labelHidden === undefined) snap.labelHidden = false;
    if(!Array.isArray(snap.transforms)) snap.transforms = normalizeTransforms(snap.transforms);
    if(!Array.isArray(snap.tags)) snap.tags = [];
    if(!snap.customAttributes || typeof snap.customAttributes !== 'object') snap.customAttributes = {};
    if(!snap.color) delete snap.color;
    if(!snap.direction) snap.direction = 'forward';
    __edgeEditSession = { edgeId: state.selectedEdgeId, from: edge.from, to: edge.to, ruleRef: snap, draft: deepClone(snap) };
  }
  
  // For hover, use the actual rule; for selected, use draft
  const draft = (state.selectedEdgeId && __edgeEditSession) ? __edgeEditSession.draft : rule;
  const isHoverOnly = !state.selectedEdgeId && state.hoverEdgeId;

  const card = (draft.cardinality||'');
  const defv = (draft.default!==undefined && draft.default!==null) ? String(draft.default) : '';
  const note = (draft.note||'');
  const edgeLabel = (draft.label||'');

  detailsMeta.textContent = isHoverOnly ? 'mapping (hover)' : 'mapping';
  detailsBody.innerHTML = `
    <div class="box">
      <div class="${isHoverOnly ? 'dtEditorHead' : 'dtEditorHead'}">
        <span class="dtType mapping">Mapping</span>
        <span class="dtEditorLabel">${isHoverOnly ? 'Preview' : 'Editor'}</span>
      </div>
      <div class="kv" style="grid-template-columns: 80px 1fr;">
        <div class="k">From</div><div class="v"><code>${escapeHtml(edge.from)}</code></div>
        <div class="k">To</div><div class="v"><code>${escapeHtml(edge.to)}</code></div>
        <div class="k">Direction</div><div class="v" style="display:flex;align-items:center;gap:2px;">
          <button class="btn edDirBtn ${(draft.direction||'forward')==='forward'?'active':''}" data-dir="forward" title="Forward (source  target)" style="font-size:13px;min-width:36px;padding:2px 8px;" ${isHoverOnly ? 'disabled' : ''}></button>
          <button class="btn edDirBtn ${(draft.direction||'forward')==='both'?'active':''}" data-dir="both" title="Bidirectional (both ways)" style="font-size:13px;min-width:36px;padding:2px 8px;" ${isHoverOnly ? 'disabled' : ''}></button>
          <button class="btn edDirBtn ${(draft.direction||'forward')==='none'?'active':''}" data-dir="none" title="Directionless (linked)" style="font-size:13px;min-width:36px;padding:2px 8px;" ${isHoverOnly ? 'disabled' : ''}></button>
          <span class="edDirLabel" style="font-size:10px;opacity:.3;margin-left:8px;">${{'forward':'source  target','both':'bidirectional','none':'linked / directionless'}[draft.direction||'forward']}</span>
        </div>
        <div class="k">Label</div><div class="v" style="display:flex;align-items:center;gap:6px;"><input class="inp" id="edLabel" value="${escapeHtml(edgeLabel)}" placeholder="shown on mapping line" style="flex:1;" ${isHoverOnly ? 'disabled' : ''}/><label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:3px;white-space:nowrap;" title="Show label on mapping line"><input type="checkbox" id="edLabelShow" ${!(draft.labelHidden) ? 'checked' : ''} ${isHoverOnly ? 'disabled' : ''}/> Show</label></div>
        <div class="k">Card.</div><div class="v" style="display:flex;align-items:center;gap:0;"><input class="inp" id="edCardL" value="${escapeHtml((card.split(':')[0]||'').trim())}" placeholder="1" style="width:44px;text-align:center;border-radius:8px 0 0 8px;border-right:none;" ${isHoverOnly ? 'disabled' : ''}/><span style="font-size:13px;font-weight:700;opacity:.45;padding:0 1px;user-select:none;flex-shrink:0;">:</span><input class="inp" id="edCardR" value="${escapeHtml((card.split(':')[1]||'').trim())}" placeholder="1" style="width:44px;text-align:center;border-radius:0 8px 8px 0;border-left:none;" ${isHoverOnly ? 'disabled' : ''}/><span style="font-size:10px;opacity:.3;margin-left:8px;white-space:nowrap;">source : target</span></div>
        <div class="k">Default</div><div class="v"><input class="inp" id="edDef" value="${escapeHtml(defv)}" placeholder="optional" ${isHoverOnly ? 'disabled' : ''}/></div>
        <div class="k">Transforms</div>
        <div class="v">
          <div id="edTrChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
          ${!isHoverOnly ? `<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <select class="inp" id="edTrSel" style="max-width:280px;flex:0 0 auto;">
              <option value="">Add transform</option>
            </select>
            <button class="btn" id="edTrNew" type="button">Transforms</button>
          </div>
          <div class="dtHint" style="padding:4px 0;">Edits are saved only when you click <b>Save</b>.</div>` : '<div class="dtHint" style="padding:4px 0;opacity:0.7;">Click the arrow to edit this mapping</div>'}
        </div>
        <div class="k">Note</div><div class="v"><input class="inp" id="edNote" value="${escapeHtml(note)}" placeholder="optional" ${isHoverOnly ? 'disabled' : ''}/></div>
        <div class="k">Color</div><div class="v" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
          <div id="edColorSwatches" style="display:flex;gap:3px;flex-wrap:wrap;"></div>
          <div style="display:flex;align-items:center;gap:6px;">
          <input type="color" id="edColor" value="${escapeHtml((draft||rule).color||(draft||rule)._pendingColor||'#3b82f6')}" style="width:28px;height:22px;padding:0;border:1px solid var(--border);border-radius:4px;cursor:pointer;${(draft||rule).color?'':'opacity:.3;'}" ${isHoverOnly ? 'disabled' : ''}/>
          <input class="inp" id="edColorHex" value="${escapeHtml((draft||rule).color||'')}" placeholder="optional" style="flex:1;font-family:var(--mono);font-size:11px;max-width:100px;" ${isHoverOnly ? 'disabled' : ''}/>
          <label style="font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" id="edColorOn" ${(draft||rule).color?'checked':''} ${isHoverOnly ? 'disabled' : ''}/> Apply</label>
          </div>
        </div>
        <div class="k">Tags</div>
        <div class="v">
          <div id="edTagChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
          ${!isHoverOnly ? `<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <select class="inp" id="edTagSel" style="max-width:280px;flex:0 0 auto;"><option value="">Add tag</option></select>
            <button class="btn" id="edTagMgr" type="button">Tags</button>
          </div>` : ''}
        </div>
        <div class="k">Custom</div>
        <div class="v">
          <div id="edAttrChips" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center;"></div>
          ${!isHoverOnly ? `<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <select class="inp" id="edAttrSel" style="max-width:240px;flex:0 0 auto;"><option value="">Attribute</option></select>
            <select class="inp" id="edAttrValSel" style="max-width:240px;flex:0 0 auto;"><option value="">Value</option></select>
            <button class="btn" id="edAttrCatalog" type="button">Attributes</button>
          </div>
          <div class="dtHint" style="padding:4px 0;">Choose an attribute and a value. Use "Attributes" to manage attributes/values.</div>` : ''}
        </div>
      </div>
      ${!isHoverOnly ? `<div class="dtActions">
        <button class="btn" id="edDel" style="border-color: rgba(255,154,168,.45);">Delete</button>
        <span class="spacer"></span>
        <button class="btn" id="edCancel">Cancel</button>
        <button class="btn btnSave" id="edSave">Save</button>
      </div>` : ''}
    </div>
  `;

  const edCardL = document.getElementById('edCardL');
  const edCardR = document.getElementById('edCardR');
  const edDef  = document.getElementById('edDef');
  const edNote = document.getElementById('edNote');
  const edLabel = document.getElementById('edLabel');
  const edTrChips = document.getElementById('edTrChips');
  const edTrSel = document.getElementById('edTrSel');
  const edTrNew = document.getElementById('edTrNew');
  const edTagChips = document.getElementById('edTagChips');
  const edTagSel = document.getElementById('edTagSel');
  const edTagMgr = document.getElementById('edTagMgr');
  const edAttrChips = document.getElementById('edAttrChips');
  const edAttrSel = document.getElementById('edAttrSel');
  const edAttrValSel = document.getElementById('edAttrValSel');
  const edAttrCatalog = document.getElementById('edAttrCatalog');

  function syncDraftFromInputs(){
    const cl = (edCardL?.value||'').trim();
    const cr = (edCardR?.value||'').trim();
    draft.cardinality = (cl || cr) ? (cl + ':' + cr) : '';
    draft.default = edDef?.value;
    draft.note = (edNote?.value||'').trim();
    draft.label = (edLabel?.value||'').trim();
    draft.labelHidden = !(document.getElementById('edLabelShow')?.checked);
    const colorOn = document.getElementById('edColorOn')?.checked;
    if(colorOn) draft.color = document.getElementById('edColor')?.value || '';
    else delete draft.color;
    // direction is synced via button click, not input
  }

  function rebuildEdgeTransformOptions(){
    const cat = ensureTransformCatalog();
    if(!edTrSel) return;
    edTrSel.innerHTML = '<option value="">Add transform</option>' + _buildTransformSelectOptions([], {includeNew: true});
  }


  function triggerEdgeDirty(){
    const _sb = document.getElementById('edSave');
    if(_sb && _sb.__dirtyUpdate) _sb.__dirtyUpdate();
  }

  function renderEdgeTransformChips(){
    if(!edTrChips) return;
    edTrChips.innerHTML = '';
    const arr = Array.isArray(draft.transforms) ? draft.transforms : [];
    if(!arr.length){
      const sp=document.createElement('span');
      sp.className='empty';
      sp.textContent='No transforms.';
      edTrChips.appendChild(sp);
      return;
    }
    let dragIdx = null;
    arr.forEach((inst, i)=>{
      const rid = transformRefId(inst);
      const td = transformById(rid) || {id:rid,label:rid,abbr:''};
      const catParams = Array.isArray(td.params) ? td.params : [];
      const instParams = (typeof inst === 'object' && inst.params) ? inst.params : {};
      const chip = document.createElement('span');
      chip.className='tagChip';
      chip.style.cursor='grab';
      chip.draggable = true;
      chip.dataset.trIdx = i;

      // Build tooltip
      let tipParts = [(td.label||td.id||rid)];
      if(td.note) tipParts.push(td.note);
      if(catParams.length){
        tipParts.push('Params: ' + catParams.map(p => `${p.label||p.id}=${instParams[p.id]!==undefined ? instParams[p.id] : (p.default||'')}`).join(', '));
      }
      tipParts.push('Drag to reorder');
      if(!isHoverOnly) tipParts.push('Click to edit params');
      chip.title = tipParts.join('\n');

      // Number badge
      const num = document.createElement('span');
      num.textContent = (i+1) + ' ';
      num.style.opacity = '.45';
      num.style.fontSize = '9px';
      chip.appendChild(num);

      const lbl = document.createElement('span');
      lbl.textContent = formatTransformAbbr(inst);
      chip.appendChild(lbl);

      // Click to edit params (if catalog defines params and not hover-only)
      if(!isHoverOnly && catParams.length > 0){
        chip.style.cursor = 'pointer';
        chip.addEventListener('click', (e)=>{
          if(e.target.closest('[data-act="rm"]')) return; // don't trigger on  click
          showTransformParamsEditor(i, inst, td, catParams);
        });
      }

      if(!isHoverOnly){
        const x=document.createElement('span');
        x.textContent=' ';
        x.dataset.act = 'rm';
        x.style.opacity='.85';
        x.style.cursor='pointer';
        x.addEventListener('click', (e)=>{
          e.stopPropagation();
          draft.transforms.splice(i, 1); // remove by index
          renderEdgeTransformChips();
          triggerEdgeDirty();
        });
        chip.appendChild(x);
      }

      // DnD
      chip.addEventListener('dragstart', (e)=>{
        dragIdx = i;
        chip.style.opacity = '0.4';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', '');
      });
      chip.addEventListener('dragend', ()=>{
        chip.style.opacity = '';
        edTrChips.querySelectorAll('.tagChip').forEach(c=>c.style.borderColor='');
        dragIdx = null;
      });
      chip.addEventListener('dragover', (e)=>{
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        edTrChips.querySelectorAll('.tagChip').forEach(c=>c.style.borderColor='');
        chip.style.borderColor = 'rgba(59,130,246,.7)';
      });
      chip.addEventListener('dragleave', ()=>{
        chip.style.borderColor = '';
      });
      chip.addEventListener('drop', (e)=>{
        e.preventDefault();
        chip.style.borderColor = '';
        if(dragIdx === null || dragIdx === i) return;
        const moved = draft.transforms.splice(dragIdx, 1)[0];
        draft.transforms.splice(i, 0, moved);
        renderEdgeTransformChips();
        triggerEdgeDirty();
      });

      edTrChips.appendChild(chip);
    });
  }

  // Inline params editor: shows below chips when a parameterized chip is clicked
  function showTransformParamsEditor(idx, inst, catDef, catParams){
    let paramsDiv = document.getElementById('edTrParamsEditor');
    if(paramsDiv) paramsDiv.remove();
    paramsDiv = document.createElement('div');
    paramsDiv.id = 'edTrParamsEditor';
    paramsDiv.style.cssText = 'margin-top:8px;padding:10px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,.03);';
    const title = document.createElement('div');
    title.style.cssText = 'font-size:11px;font-weight:700;margin-bottom:8px;opacity:.7;';
    title.textContent = `Parameters: ${catDef.label||catDef.id}`;
    paramsDiv.appendChild(title);

    const instParams = (typeof inst === 'object' && inst.params) ? { ...inst.params } : {};

    catParams.forEach(p => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;gap:8px;margin-bottom:6px;';
      const label = document.createElement('label');
      label.style.cssText = 'font-size:12px;min-width:80px;';
      label.textContent = p.label || p.id;
      row.appendChild(label);

      const input = document.createElement('input');
      input.className = 'inp';
      input.type = p.type === 'number' ? 'number' : 'text';
      input.value = instParams[p.id] !== undefined ? instParams[p.id] : (p.default || '');
      input.placeholder = p.default !== undefined ? String(p.default) : '';
      input.style.cssText = 'flex:1;';
      input.dataset.paramId = p.id;
      row.appendChild(input);
      paramsDiv.appendChild(row);
    });

    const btnRow = document.createElement('div');
    btnRow.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;margin-top:8px;';
    const applyBtn = document.createElement('button');
    applyBtn.className = 'btn';
    applyBtn.textContent = 'Apply';
    applyBtn.addEventListener('click', ()=>{
      if(!inst.params) inst.params = {};
      paramsDiv.querySelectorAll('input[data-param-id]').forEach(inp => {
        const pid = inp.dataset.paramId;
        const pDef = catParams.find(cp => cp.id === pid);
        const val = inp.value.trim();
        if(pDef && pDef.type === 'number' && val !== ''){
          inst.params[pid] = Number(val);
        } else if(val !== ''){
          inst.params[pid] = val;
        } else {
          delete inst.params[pid];
        }
      });
      paramsDiv.remove();
      renderEdgeTransformChips();
      triggerEdgeDirty();
    });
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.addEventListener('click', ()=> {
      paramsDiv.remove();
      triggerEdgeDirty();
    });
    btnRow.appendChild(cancelBtn);
    btnRow.appendChild(applyBtn);
    paramsDiv.appendChild(btnRow);

    edTrChips.parentElement.insertBefore(paramsDiv, edTrChips.nextSibling);
  }

  // Only set up interactive elements when actually selected (not just hovering)
  if(!isHoverOnly){
    [edCardL, edCardR, edDef, edNote].forEach(el=>{
      el?.addEventListener('change', syncDraftFromInputs);
      el?.addEventListener('blur', syncDraftFromInputs);
    });

    edTrSel?.addEventListener('change', ()=>{
      const v = (edTrSel.value||'').trim();
      if(!v) return;
      if(v==='__new__'){
        edTrSel.value='';
        openTransformCreateModal({afterCreate: (createdId)=>{
          rebuildEdgeTransformOptions();
          if(createdId){
            draft.transforms = Array.isArray(draft.transforms) ? draft.transforms : [];
            const td = transformById(createdId);
            const inst = { ref: createdId };
            // Initialize params from catalog defaults
            if(td && Array.isArray(td.params) && td.params.length){
              inst.params = {};
              td.params.forEach(p => { if(p.default !== undefined) inst.params[p.id] = p.default; });
            }
            draft.transforms.push(inst);
          }
          renderEdgeTransformChips();
          triggerEdgeDirty();
        }});
        return;
      }
      draft.transforms = Array.isArray(draft.transforms) ? draft.transforms : [];
      const td = transformById(v);
      const inst = { ref: v };
      // Initialize params from catalog defaults
      if(td && Array.isArray(td.params) && td.params.length){
        inst.params = {};
        td.params.forEach(p => { if(p.default !== undefined) inst.params[p.id] = p.default; });
      }
      draft.transforms.push(inst); // allow duplicates
      edTrSel.value='';
      renderEdgeTransformChips();
    });

    edTrNew?.addEventListener('click', async ()=>{
      openTransforms();
    });

    rebuildEdgeTransformOptions();
    renderEdgeTransformChips();

    // Edge color checkbox toggle
    {
      const edColorOn = document.getElementById('edColorOn');
      const edColor = document.getElementById('edColor');
      const edColorHex = document.getElementById('edColorHex');
      const _edKick = ()=>{ syncDraftFromInputs(); triggerEdgeDirty(); };
      if(edColorOn && edColor){
        // Build preset swatches
        if(!isHoverOnly) buildColorSwatches(document.getElementById('edColorSwatches'), edColor, edColorOn, _edKick);
        edColorOn.addEventListener('change', ()=>{
          edColor.style.opacity = edColorOn.checked ? '1' : '.3';
          _edKick();
        });
        edColor.addEventListener('input', ()=>{
          if(edColorOn) edColorOn.checked = true;
          edColor.style.opacity = '1';
          if(edColorHex) edColorHex.value = edColor.value;
          _edKick();
        });
        edColor.addEventListener('change', _edKick);
        if(edColorHex){
          edColorHex.addEventListener('input', ()=>{
            const v = (edColorHex.value||'').trim();
            if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
              edColor.value = v;
              if(edColorOn) edColorOn.checked = true;
              edColor.style.opacity = '1';
            }
            _edKick();
          });
        }
      }
    }

    // Label show/hide toggle
    {
      const edLabelShow = document.getElementById('edLabelShow');
      if(edLabelShow && !isHoverOnly){
        edLabelShow.addEventListener('change', ()=>{ syncDraftFromInputs(); triggerEdgeDirty(); });
      }
    }

    //  Direction toggle 
    if(!isHoverOnly){
      detailsBody.querySelectorAll('.edDirBtn').forEach(btn => {
        btn.addEventListener('click', ()=>{
          draft.direction = btn.dataset.dir;
          detailsBody.querySelectorAll('.edDirBtn').forEach(b => b.classList.toggle('active', b.dataset.dir === draft.direction));
          const lbl = detailsBody.querySelector('.edDirLabel');
          if(lbl) lbl.textContent = {forward:'source  target', both:'bidirectional', none:'linked / directionless'}[draft.direction] || '';
          triggerEdgeDirty();
        });
      });
    }

    //  Edge Tags 
    function rebuildEdgeTagOptions(){
      if(!edTagSel) return;
      edTagSel.innerHTML = '<option value="">Add tag</option>' + _buildTagSelectOptions(Array.isArray(draft.tags) ? draft.tags : [], {includeNew: true});
    }
    function renderEdgeTagChips(){
      if(!edTagChips) return;
      edTagChips.innerHTML='';
      const arr = sortTagIdsByPriority(Array.isArray(draft.tags) ? draft.tags : []);
      if(!arr.length){ edTagChips.innerHTML='<span class="empty">No tags.</span>'; return; }
      arr.forEach(tid=>{
        const td = tagById(tid) || {id:tid,label:tid,abbr:''};
        const chip=document.createElement('span');
        chip.className='tagChip';
        chip.style.setProperty('--c', tagColor(td));
        chip.setAttribute('data-color','1');
        chip.textContent = tagDisplayLabel(td) || tid;
        chip.title = (td.label||td.id) + (td.note?('  '+td.note):'');
        if(!isHoverOnly){
          const x=document.createElement('span');
          x.textContent=' '; x.style.cursor='pointer'; x.style.opacity='.85';
          x.addEventListener('click',(e)=>{ e.stopPropagation(); draft.tags = (draft.tags||[]).filter(v=>v!==tid); renderEdgeTagChips(); triggerEdgeDirty(); });
          chip.appendChild(x);
        }
        edTagChips.appendChild(chip);
      });
    }
    if(edTagSel && !isHoverOnly){
      edTagSel.addEventListener('change', ()=>{
        const v=(edTagSel.value||'').trim();
        if(!v) return;
        if(v==='__new__'){
          edTagSel.value='';
          openTagCreateModal({afterCreate: ()=>{ rebuildEdgeTagOptions(); }});
          return;
        }
        draft.tags = draft.tags || [];
        if(!draft.tags.includes(v)) draft.tags.push(v);
        edTagSel.value='';
        renderEdgeTagChips();
        triggerEdgeDirty();
      });
    }
    if(edTagMgr) edTagMgr.addEventListener('click', ()=> openTags());
    rebuildEdgeTagOptions();
    renderEdgeTagChips();

    //  Edge Custom Attributes 
    function rebuildEdgeAttrOptions(){
      const cat = ensureCustomAttributeCatalog();
      if(!edAttrSel) return;
      edAttrSel.innerHTML = '<option value="">Attribute</option>' + _buildAttrSelectOptions({includeNew: true});
    }
    function rebuildEdgeValOptions(aid){
      if(!edAttrValSel) return;
      if(!aid){ edAttrValSel.innerHTML = '<option value="">Value</option>'; return; }
      const a = customAttrById(aid);
      const vals = (a && Array.isArray(a.values)) ? a.values : [];
      edAttrValSel.innerHTML = '<option value="">Value</option>' + vals.map(v=>{
        return `<option value="${escapeHtml(v.id)}">${escapeHtml(_catalogItemLabel(v))}</option>`;
      }).join('\n') + '<option value="__new__">+ New value</option>';
    }
    function renderEdgeAttrChips(){
      if(!edAttrChips) return;
      edAttrChips.innerHTML='';
      const ca = draft.customAttributes || {};
      const keys = Object.keys(ca);
      if(!keys.length){ edAttrChips.innerHTML='<span class="empty">No custom attributes.</span>'; return; }
      keys.sort().forEach(aid=>{
        const raw = ca[aid];
        const a = customAttrById(aid) || {id:aid,label:aid,abbr:''};
        const vals = Array.isArray(raw) ? raw : [raw];
        vals.forEach(vid=>{
          const v = customValueById(aid, vid) || {id:vid,label:vid};
          const chip=document.createElement('span');
          chip.className='tagChip';
          chip.textContent = (customAttrAbbr(a)||aid) + ': ' + (v.label||v.id);
          chip.title = (a.label||a.id) + ' = ' + (v.label||v.id);
          if(!isHoverOnly){
            const x=document.createElement('span');
            x.textContent=' '; x.style.cursor='pointer'; x.style.opacity='.85';
            x.addEventListener('click',(e)=>{
              e.stopPropagation();
              const cur = draft.customAttributes[aid];
              if(Array.isArray(cur)){
                const next = cur.filter(z=>String(z) !== String(vid));
                if(next.length===0) delete draft.customAttributes[aid];
                else if(next.length===1) draft.customAttributes[aid] = next[0];
                else draft.customAttributes[aid] = next;
              } else {
                delete draft.customAttributes[aid];
              }
              renderEdgeAttrChips();
              triggerEdgeDirty();
            });
            chip.appendChild(x);
          }
          edAttrChips.appendChild(chip);
        });
      });
    }
    if(edAttrSel && !isHoverOnly){
      edAttrSel.addEventListener('change', ()=>{
        const aid = (edAttrSel.value||'').trim();
        if(!aid) return;
        if(aid==='__new__'){
          const cat = ensureCustomAttributeCatalog();
          normalizeCatalogMultiFlag();
          const taken = new Set((cat||[]).map(a=>a && a.id).filter(Boolean));
          edAttrSel.value='';
          openCreateModal({
            kind:'customAttr',
            title:'Add custom attribute',
            placeholder:'Attribute label',
            hint:'ID is generated from the attribute label and made unique.',
            taken,
            onCommit: ({label,id,abbr,note,color,multi,_autoId,_autoAbbr})=>{
              const entry = { id, label, abbr: (abbr||'').trim() || (label||'').replace(/\s+/g,'').slice(0,2).toUpperCase(), note: (note||''), multi:!!multi, values:[], _autoId, _autoAbbr};
              if(color) { entry.color = color; entry.colorEnabled = true; }
              cat.push(entry);
              rebuildEdgeAttrOptions();
              edAttrSel.value = id;
              rebuildEdgeValOptions(id);
            }
          });
          return;
        }
        rebuildEdgeValOptions(aid);
      });
    }
    if(edAttrValSel && !isHoverOnly){
      edAttrValSel.addEventListener('change', ()=>{
        const aid = (edAttrSel?.value||'').trim();
        const vid = (edAttrValSel.value||'').trim();
        if(!aid || !vid) return;
        if(vid==='__new__'){
          const a = customAttrById(aid);
          const vals = (a && Array.isArray(a.values)) ? a.values : [];
          const taken = new Set(vals.map(v=>v.id));
          edAttrValSel.value='';
          openCreateModal({
            kind:'customAttrVal',
            title:'Add value for ' + (a?.label||aid),
            placeholder:'Value label',
            hint:'ID is generated from the value label.',
            taken,
            onCommit: ({label,id,abbr,note,color,_autoId,_autoAbbr})=>{
              const entry = { id, label, abbr: (abbr||'').trim() || (label||'').replace(/\s+/g,'').slice(0,2).toUpperCase(), note: (note||''), _autoId, _autoAbbr};
              if(color) { entry.color = color; entry.colorEnabled = true; }
              if(!a.values) a.values = [];
              a.values.push(entry);
              rebuildEdgeValOptions(aid);
              edAttrValSel.value = id;
              // auto-assign the new value
              draft.customAttributes = draft.customAttributes || {};
              const isMulti = customAttrIsMulti(aid);
              if(isMulti){
                const cur = draft.customAttributes[aid];
                const arr = Array.isArray(cur) ? [...cur] : (cur ? [cur] : []);
                if(!arr.map(String).includes(String(id))) arr.push(id);
                draft.customAttributes[aid] = arr;
              } else {
                draft.customAttributes[aid] = id;
              }
              edAttrValSel.value='';
              renderEdgeAttrChips();
              triggerEdgeDirty();
            }
          });
          return;
        }
        draft.customAttributes = draft.customAttributes || {};
        const isMulti = customAttrIsMulti(aid);
        if(isMulti){
          const cur = draft.customAttributes[aid];
          const arr = Array.isArray(cur) ? [...cur] : (cur ? [cur] : []);
          if(!arr.map(String).includes(String(vid))) arr.push(vid);
          draft.customAttributes[aid] = arr;
        } else {
          draft.customAttributes[aid] = vid;
        }
        edAttrValSel.value='';
        renderEdgeAttrChips();
        triggerEdgeDirty();
      });
    }
    if(edAttrCatalog) edAttrCatalog.addEventListener('click', openCustomAttrs);
    rebuildEdgeAttrOptions();
    renderEdgeAttrChips();

    const saveBtn = document.getElementById('edSave');
    const cancelBtn = document.getElementById('edCancel');
    const delBtn = document.getElementById('edDel');

  if(saveBtn) saveBtn.addEventListener('click', async ()=>{
    syncDraftFromInputs();
    recordChange(); // Save BEFORE modifying
    rule.cardinality = (draft.cardinality||'').trim();
    rule.default = (draft.default!==undefined && draft.default!==null) ? draft.default : '';
    rule.note = (draft.note||'').trim();
    rule.label = (draft.label||'').trim();
    rule.labelHidden = !!draft.labelHidden;
    rule.transforms = Array.isArray(draft.transforms) ? draft.transforms.map(t => typeof t === 'object' ? {...t, params: t.params ? {...t.params} : undefined} : t) : [];
    rule.tags = Array.isArray(draft.tags) ? [...draft.tags] : [];
    rule.customAttributes = draft.customAttributes ? JSON.parse(JSON.stringify(draft.customAttributes)) : {};
    rule.direction = draft.direction || 'forward';
    // Save color  always remember the picker value
    const __saveColorOn = document.getElementById('edColorOn')?.checked;
    const __savePickerVal = document.getElementById('edColor')?.value || '';
    if(__saveColorOn){
      rule.color = __savePickerVal;
      delete rule._pendingColor;
    } else {
      delete rule.color;
      if(__savePickerVal && __savePickerVal !== '#3b82f6') rule._pendingColor = __savePickerVal;
      else delete rule._pendingColor;
    }
    if('transform' in rule) delete rule.transform;

    const stayEdgeId = state.selectedEdgeId;
    clearEdgeEditSession({clearSelection:false});
    state.selectedEdgeId = stayEdgeId; // stay on edge
    state._showIndividualMapping = true; // keep showing individual editor (not consolidated picker)
    state.hoverEdgeId = null;
    renderAll(); // includes applyHighlight + scheduleArrowsUpdate
    setGlobalStatus('Mapping saved.');
  });

  if(cancelBtn) cancelBtn.addEventListener('click', async ()=>{
    const stayEdgeId = state.selectedEdgeId;
    clearEdgeEditSession({clearSelection:false});
    state.selectedEdgeId = stayEdgeId; // stay on edge
    state._showIndividualMapping = true; // keep showing individual editor (not consolidated picker)
    state.hoverEdgeId = null;
    renderAll(); // includes applyHighlight + scheduleArrowsUpdate
    setGlobalStatus('Mapping edit cancelled.');
  });

  if(delBtn) delBtn.addEventListener('click', async ()=>{
    const fromLabel = IDX.nodeById.get(edge.from)?.label || edge.from;
    const toLabel = IDX.nodeById.get(edge.to)?.label || edge.to;
    if(!await customConfirm(`Delete mapping "${fromLabel}  ${toLabel}"?`)) return;
    recordChange(); // Save BEFORE delete
    const tos = Array.isArray(rule.to) ? rule.to.slice() : (typeof rule.to==='string' ? [rule.to] : []);
    const kept = tos.filter(t=>t!==edge.to);
    if(kept.length===0){
      const idx = mappings.indexOf(rule);
      if(idx>=0) mappings.splice(idx,1);
    } else {
      rule.to = kept.length===1 ? kept[0] : kept;
    }
    clearEdgeEditSession({clearSelection:true});
    renderAll(); // includes applyHighlight + scheduleArrowsUpdate
    setGlobalStatus('Mapping deleted.');
  });
  wireDirtyHighlight(detailsBody, saveBtn, ()=>{
    if(!__edgeEditSession || !__edgeEditSession.ruleRef || !__edgeEditSession.draft) return false;
    // Sync DOM values into draft before comparing
    const _cl = (edCardL?.value||'').trim();
    const _cr = (edCardR?.value||'').trim();
    __edgeEditSession.draft.cardinality = (_cl || _cr) ? (_cl + ':' + _cr) : '';
    __edgeEditSession.draft.default = edDef?.value;
    __edgeEditSession.draft.note = (edNote?.value||'').trim();
    __edgeEditSession.draft.label = (edLabel?.value||'').trim();
    const __edColorOn = document.getElementById('edColorOn')?.checked;
    if(__edColorOn) __edgeEditSession.draft.color = document.getElementById('edColor')?.value || '';
    else delete __edgeEditSession.draft.color;
    if(JSON.stringify(__edgeEditSession.ruleRef) !== JSON.stringify(__edgeEditSession.draft)) return true;
    // Detect picker change OR checkbox toggle independently of Apply state
    const origColor = __edgeEditSession.ruleRef.color || '';
    const origPickerVal = origColor || __edgeEditSession.ruleRef._pendingColor || '#3b82f6';
    const curPickerVal = document.getElementById('edColor')?.value || '#3b82f6';
    if(__edColorOn !== !!origColor) return true;       // checkbox toggled
    if(curPickerVal !== origPickerVal) return true;     // picker value changed
    return false;
  });
  } // end if(!isHoverOnly)
  
  // For hover, still show transform chips (read-only)
  if(isHoverOnly){
    renderEdgeTransformChips();
  }

  // Clear the force individual flag at the END after showing the editor
  if(state._showIndividualMapping){
    delete state._showIndividualMapping;
  }

  return true;
}


const __renderColumns_base = renderColumns;
renderColumns = function(){
  __renderColumns_base();
  /* attachSvgEdgeInteractions disabled */
  if(state.editorMode){
    
    addRowActions();
    attachColumnHeaderActions();
  }
};

const __updateDetails_base = updateDetails;
updateDetails = function(nodeId, selectedFieldsSet){
  // Edge editor only for selected (locked) edges, not hover
  if(state.selectedEdgeId && renderSelectedEdgeEditor()) return;
  if(renderSelectedColumnEditor()) return;
  if(renderSelectedColumnViewer()) return;
  if(renderSelectedNodeEditor(nodeId)) return;
  // If column is selected but we got here, don't show root node  skip
  if(state.selectedColumnId && state.lockedId === state.selectedColumnId && nodeId === state.selectedColumnId) return;
  __updateDetails_base(nodeId, selectedFieldsSet);
};

columnsScroller.addEventListener('scroll', ()=>{ if(state.editorMode){/* no-op while editing */} }, {passive:true});
window.addEventListener('resize', ()=>{ if(state.editorMode){/* no-op while editing */} }, {passive:true});

if(editorModeToggle) editorModeToggle.addEventListener('change', async ()=>{
  const wantOn = editorModeToggle.checked;
  const _syncBtn = ()=>{ const b=document.getElementById('editorModeBtn'); if(b) b.classList.toggle('active', editorModeToggle.checked); };
  // Guard: if turning off editor mode with unsaved changes, prompt
  if(!wantOn){
    if(nodeEditIsDirty()){
      if(!await guardNodeAbandon()){
        editorModeToggle.checked = true; _syncBtn(); // revert checkbox + button
        return;
      }
      revertEditSnapshot(); __editSnapshot = null; checkDirtyState();
    }
    if(edgeEditIsDirty()){
      if(!await guardAbandonEdit('mapping', __edgeEditSession?.edgeId || '')){
        editorModeToggle.checked = true; _syncBtn();
        return;
      }
    }
  }
  setEditorMode(wantOn);
});

// Wire the visible button to the hidden checkbox
const editorModeBtn = document.getElementById('editorModeBtn');
if(editorModeBtn) editorModeBtn.addEventListener('click', ()=>{
  if(editorModeToggle){ editorModeToggle.checked = !editorModeToggle.checked; editorModeToggle.dispatchEvent(new Event('change')); }
});

/* =========================
   Rendering pipeline
========================= */
function refreshViewer(){
  if(!state.data) return;
  applyVisibility();
  // Clear selection if selected node(s) became hidden (filter mode = hide)
  if(state.filterMode === 'hide' && (hasActiveFilters() || state.onlyMapped || state.search)){
    let cleared = false;
    if(state.lockedId){
      const el = IDX.elementById.get(state.lockedId);
      if(el && el.classList.contains('hidden')){ state.lockedId = null; state.hoverId = null; cleared = true; }
    }
    if(state.multiSelection.size){
      const before = state.multiSelection.size;
      for(const id of [...state.multiSelection]){
        const el = IDX.elementById.get(id);
        if(!el || el.classList.contains('hidden')) state.multiSelection.delete(id);
      }
      if(state.multiSelection.size !== before) cleared = true;
    }
    if(cleared){
      state.selectedEdgeId = null;
      state._consolidatedEdgeCache = null;
    }
  }
  applyHighlight();
  refreshEdgeColorScheme();
  scheduleArrowsUpdate();
  if(!__applyingView) _clearActiveViewIfDrifted();
}



function renderSelectedEdgeViewer(edgeId){
  if(!edgeId) return false;
  
  // Find the edge object first - check real edges, then virtual edges
  let edge = IDX.edges.find(e => e.id === edgeId);
  let isVirtual = false;
  if(!edge && edgeId.startsWith('virtual:')){
    const virtualEdges = findChainsThoughHiddenColumns();
    edge = virtualEdges.find(x => x.id === edgeId);
    isVirtual = true;
  }
  if(!edge) return false;
  
  // Virtual/indirect edge: show chain info in details panel
  if(isVirtual && edge.chain){
    const selected = (state.selectedEdgeId === edgeId);
    detailsMeta.textContent = selected ? 'indirect link  selected' : 'indirect link  hover';
    
    // Gather hidden column names
    const hiddenCols = [];
    for(const chainEdge of edge.chain){
      const fromCol = columnOf(chainEdge.from);
      const toCol = columnOf(chainEdge.to);
      if(fromCol && state.hiddenColumns.has(fromCol)){
        const ci = IDX.columnIndex.get(fromCol);
        const col = (ci !== undefined) ? IDX.columns[ci] : null;
        const name = col ? (col.label || col.id) : fromCol;
        if(!hiddenCols.includes(name)) hiddenCols.push(name);
      }
      if(toCol && state.hiddenColumns.has(toCol)){
        const ci = IDX.columnIndex.get(toCol);
        const col = (ci !== undefined) ? IDX.columns[ci] : null;
        const name = col ? (col.label || col.id) : toCol;
        if(!hiddenCols.includes(name)) hiddenCols.push(name);
      }
    }
    
    function colLabel(colId){
      const i = IDX.columnIndex.get(colId);
      return (i!==undefined && IDX.columns[i]) ? (IDX.columns[i].label||colId) : colId;
    }
    
    // Build chain steps display
    const chainSteps = edge.chain.map(ce => {
      const fromNode = IDX.nodeById.get(ce.from);
      const toNode = IDX.nodeById.get(ce.to);
      const fromLabel = fromNode ? (fromNode.label || ce.from) : ce.from;
      const toLabel = toNode ? (toNode.label || ce.to) : ce.to;
      const fromCol = columnOf(ce.from) || '';
      const toCol = columnOf(ce.to) || '';
      const fromHidden = state.hiddenColumns.has(fromCol);
      const toHidden = state.hiddenColumns.has(toCol);
      return `<div style="display:flex;align-items:center;gap:6px;padding:4px 0;">
        <code style="opacity:${fromHidden ? '0.5' : '1'}">${escapeHtml(fromLabel)}</code>
        <span style="color:var(--muted);"></span>
        <code style="opacity:${toHidden ? '0.5' : '1'}">${escapeHtml(toLabel)}</code>
        ${fromHidden||toHidden ? '<span class="pill" style="font-size:10px;opacity:.7;">hidden</span>' : ''}
      </div>`;
    }).join('');
    
    detailsBody.innerHTML = `
      <div class="box" style="border-color: rgba(59,130,246,.35);">
        <div class="dtEditorHead">
          <span class="dtType" style="font-size:8px;padding:2px 6px;">Indirect link</span>
          <span class="dtEditorLabel">${edge.chain.length} steps</span>
        </div>
        <div class="dtHint" style="padding:2px 0 8px;">Passes through ${hiddenCols.length} hidden column${hiddenCols.length>1?'s':''}: <b style="color:var(--text);opacity:1;">${escapeHtml(hiddenCols.join(', '))}</b></div>
        <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edge.from)}</code></span></div>
        <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edge.to)}</code></span></div>
        <div style="margin-top:10px;padding-top:8px;border-top:1px solid var(--border);">
          <div style="font-size:11px;color:var(--muted);margin-bottom:4px;text-transform:uppercase;letter-spacing:.4px;font-weight:700;">Full chain</div>
          ${chainSteps}
        </div>
      </div>
      <button class="btn" id="revealChainBtn" style="margin-top:10px;width:100%;">Reveal hidden columns & select first edge</button>
    `;
    
    // Wire up reveal button
    const revealBtn = document.getElementById('revealChainBtn');
    if(revealBtn){
      revealBtn.addEventListener('click', ()=>{
        // Unhide all columns in the chain
        for(const chainEdge of edge.chain){
          const fromCol = columnOf(chainEdge.from);
          const toCol = columnOf(chainEdge.to);
          if(fromCol && state.hiddenColumns.has(fromCol)) state.hiddenColumns.delete(fromCol);
          if(toCol && state.hiddenColumns.has(toCol)) state.hiddenColumns.delete(toCol);
        }
        renderAll();
        applyHighlight();
        scheduleArrowsUpdate();
        if(edge.chain.length > 0){
          setTimeout(() => selectEdge(edge.chain[0].id), 100);
        }
      });
    }
    
    return true;
  }
  
  // Check the SVG path element for consolidated metadata (set during drawing)
  const pathEl = Array.from(edgesLayer.querySelectorAll('path.edge')).find(p => p.dataset.edgeId === edgeId);
  
  
  // Use path metadata if available (handles collapsed groups), otherwise use edge metadata
  const consolidated = pathEl?.__consolidated || edge.__consolidated;
  const isBidirectional = pathEl?.__isBidirectional || edge.__isBidirectional;
  const fromId = pathEl?.__fromId || edge.__fromId || edge.from;
  const toId = pathEl?.__toId || edge.__toId || edge.to;
  
  
  // Check if this edge IS the representative of a consolidated arrow
  const isRepresentative = consolidated && consolidated.length > 1 && consolidated[0].id === edgeId;
  
  
  // Check if user explicitly wants to view individual mapping (clicked VIEW button)
  const forceIndividual = state._showIndividualMapping;
  
  
  if(isRepresentative && !forceIndividual){
    // Check if this is collapsed groups or bidirectional fields
    const isCollapsedGroups = fromId !== edge.from || toId !== edge.to;
    
    if(isCollapsedGroups){
      // Collapsed groups - show all consolidated mappings
      detailsMeta.textContent = `consolidated  ${consolidated.length} mappings`;
      
      const edges = consolidated;
      
      // Helper functions
      function colLabel(colId){
        const i = IDX.columnIndex.get(colId);
        return (i!==undefined && IDX.columns[i]) ? (IDX.columns[i].label||colId) : colId;
      }
      function miniFieldBox(fieldId, title){
        const node = IDX.nodeById.get(fieldId);
        if(!node) return '';
        const colId = columnOf(fieldId)||'';
        const inout = (IDX.edgesByField.get(fieldId)||[]);
        let inbound=0,outbound=0; inout.forEach(e=>{ if(e.to===fieldId) inbound++; if(e.from===fieldId) outbound++; });
        const label = node.label||fieldId;
        return `
          <div class="box clickable" data-jump-id="${escapeHtml(fieldId)}" style="cursor:pointer;">
            <div class="dtHero" style="padding-bottom:6px;">
              <div class="dtName" style="font-size:14px;">${escapeHtml(label)}</div>
              <span class="dtType" style="font-size:8px;padding:2px 6px;">${escapeHtml(title)}</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;">
              <span class="dtRowK" style="min-width:28px;">ID</span>
              <span class="dtRowV"><span class="dtId">${escapeHtml(fieldId)}${isLikelyAutoId(node) ? '<span class="autoTag" style="font-size:7px;padding:0 3px;">auto</span>' : ''}</span></span>
            </div>
            <div class="dtStatRow" style="padding:3px 0;">
              <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${inbound}</span><span class="dtStatL">in</span></span>
              <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${outbound}</span><span class="dtStatL">out</span></span>
            </div>
          </div>`;
      }
      
      // Build HTML for all mappings
      const htmlParts = edges.map(edgeItem => {
        const tLabels = (edgeItem.transforms && edgeItem.transforms.length)
          ? edgeItem.transforms.map(formatTransformRef).join('  ')
          : '';
        const srcBox = miniFieldBox(edgeItem.from, 'Source field');
        const tgtBox = miniFieldBox(edgeItem.to, 'Target field');
        
        return `
          <div class="box clickable" data-mapping-from="${escapeHtml(edgeItem.from)}" data-mapping-to="${escapeHtml(edgeItem.to)}">
            <div class="dtEditorHead">
              <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
              <span class="dtEditorLabel">click to expand</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.from)}</code></span></div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.to)}</code></span></div>
            ${edgeItem.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(edgeItem.cardinality)}</span></div>` : ''}
            ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
            ${(edgeItem.default!=='' && edgeItem.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(edgeItem.default))}</span></div>` : ''}
            ${edgeItem.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(edgeItem.note)}</div>` : ''}
          </div>
          ${srcBox}
          ${tgtBox}
        `;
      });
      
      // Join with dividers
      detailsBody.innerHTML = htmlParts.join('<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 24px 0;"></div>');
      
      // Attach click handlers for mapping boxes
      detailsBody.querySelectorAll('.box.clickable[data-mapping-from]').forEach(box => {
        box.addEventListener('click', () => {
          const fromId = box.getAttribute('data-mapping-from');
          const toId = box.getAttribute('data-mapping-to');
          
          // Find the edge ID for this mapping
          const mappingEdge = edges.find(e => e.from === fromId && e.to === toId);
          
          if(mappingEdge){
            // Expand both groups
            const fromParent = findCollapsedParent(fromId);
            const toParent = findCollapsedParent(toId);
            if(fromParent) toggleCollapse(fromParent, false);
            if(toParent) toggleCollapse(toParent, false);
            
            // Manually set selection
            state.lockedId = null;
            state.hoverId = null;
            state.selectedEdgeId = mappingEdge.id;
            state.hoverEdgeId = null;
            
            // Update highlights and redraw arrows
            applyHighlight();
            scheduleArrowsUpdate();
            // Use setTimeout to wait for arrows to redraw before updating details
            setTimeout(() => updateDetails(null, null), 50);
          }
        });
      });
      
      // Attach click handlers for field boxes
      detailsBody.querySelectorAll('[data-jump-id]').forEach(el=>{
        el.addEventListener('click', async ()=>{
          const id = el.getAttribute('data-jump-id');
          if(id){ 
            // Find which mapping this field belongs to and expand the other end too
            for(const edgeItem of edges){
              if(edgeItem.from === id || edgeItem.to === id){
                // Expand both ends of this mapping
                const fromParent = findCollapsedParent(edgeItem.from);
                const toParent = findCollapsedParent(edgeItem.to);
                if(fromParent) toggleCollapse(fromParent, false);
                if(toParent) toggleCollapse(toParent, false);
                break;
              }
            }
            lockSelection(id); 
            scrollIntoView(id); 
          }
        });
      });
      
      return true;
    } else if(isBidirectional){
      // Bidirectional field mappings - show both in standard format
      const selected = (state.selectedEdgeId === edgeId);
      detailsMeta.textContent = selected ? 'bidirectional  2 mappings' : 'bidirectional  hover';
      
      const edges = consolidated;
      
      // Helper functions (from regular edge viewer)
      function colLabel(colId){
        const i = IDX.columnIndex.get(colId);
        return (i!==undefined && IDX.columns[i]) ? (IDX.columns[i].label||colId) : colId;
      }
      function miniFieldBox(fieldId, title){
        const node = IDX.nodeById.get(fieldId);
        if(!node) return '';
        const colId = columnOf(fieldId)||'';
        const inout = (IDX.edgesByField.get(fieldId)||[]);
        let inbound=0,outbound=0; inout.forEach(e=>{ if(e.to===fieldId) inbound++; if(e.from===fieldId) outbound++; });
        const label = node.label||fieldId;
        return `
          <div class="box clickable" data-jump-id="${escapeHtml(fieldId)}" style="cursor:pointer;">
            <div class="dtHero" style="padding-bottom:6px;">
              <div class="dtName" style="font-size:14px;">${escapeHtml(label)}</div>
              <span class="dtType" style="font-size:8px;padding:2px 6px;">${escapeHtml(title)}</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;">
              <span class="dtRowK" style="min-width:28px;">ID</span>
              <span class="dtRowV"><span class="dtId">${escapeHtml(fieldId)}${isLikelyAutoId(node) ? '<span class="autoTag" style="font-size:7px;padding:0 3px;">auto</span>' : ''}</span></span>
            </div>
            <div class="dtStatRow" style="padding:3px 0;">
              <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${inbound}</span><span class="dtStatL">in</span></span>
              <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${outbound}</span><span class="dtStatL">out</span></span>
            </div>
          </div>`;
      }
      
      // Build HTML for both mappings
      const htmlParts = edges.map(edgeItem => {
        const tLabels = (edgeItem.transforms && edgeItem.transforms.length)
          ? edgeItem.transforms.map(formatTransformRef).join('  ')
          : '';
        const srcBox = miniFieldBox(edgeItem.from, 'Source field');
        const tgtBox = miniFieldBox(edgeItem.to, 'Target field');
        
        return `
          <div class="box">
            <div class="dtEditorHead">
              <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
              <span class="dtEditorLabel">View</span>
            </div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">From</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.from)}</code></span></div>
            <div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">To</span><span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edgeItem.to)}</code></span></div>
            ${edgeItem.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(edgeItem.cardinality)}</span></div>` : ''}
            ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
            ${(edgeItem.default!=='' && edgeItem.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(edgeItem.default))}</span></div>` : ''}
            ${edgeItem.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(edgeItem.note)}</div>` : ''}
          </div>
          ${srcBox}
          ${tgtBox}
        `;
      });
      
      // Join with a visual divider
      detailsBody.innerHTML = htmlParts.join('<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 24px 0;"></div>');
      
      // Attach click handlers for field boxes
      detailsBody.querySelectorAll('[data-jump-id]').forEach(el=>{
        el.addEventListener('click', async ()=>{
          const id = el.getAttribute('data-jump-id');
          if(id){ lockSelection(id); scrollIntoView(id); }
        });
      });
      
      return true;
    }
  }
  
  // Edge already found at the top, no need to lookup again
  const selected = (state.selectedEdgeId===edgeId);
  detailsMeta.textContent = selected ? 'mapping  selected' : 'mapping  hover';
  const tLabels = (edge.transforms && edge.transforms.length)
    ? edge.transforms.map(formatTransformRef).join('  ')
    : '';
  
  // Clear the force individual flag after showing the details
  if(state._showIndividualMapping){
    delete state._showIndividualMapping;
  }
  function colLabel(colId){
    const i = IDX.columnIndex.get(colId);
    return (i!==undefined && IDX.columns[i]) ? (IDX.columns[i].label||colId) : colId;
  }
  function renderAttrChips(node){
    if(!node || !node.customAttributes) return '';
    const keys = Object.keys(node.customAttributes||{});
    if(!keys.length) return '';
    return keys.sort().map(aid=>{
      const raw = node.customAttributes[aid];
      const a = customAttrById(aid)||{id:aid,label:aid};
      const vals = Array.isArray(raw) ? raw : [raw];
      const valueTags = vals.map(vid=>{
        const v = customValueById(aid, vid)||{id:vid,label:vid};
        return `<span class="dtAttrVal">${escapeHtml(_catalogItemLabel(v))}</span>`;
      }).join('');
      return `<div class="dtAttrGroup"><span class="dtAttrLabel">${escapeHtml(a.label||a.id)}</span>${valueTags}</div>`;
    }).join('');
  }
  function renderTagChips(node){
    if(!node) return '';
    const ids = sortTagIdsByPriority(normalizeNodeTags(node));
    if(!ids.length) return '';
    const chips = ids.slice(0,5).map(tid=>{
      const td = tagById(tid)||{id:tid,label:tid,abbr:tid.slice(0,1).toUpperCase(),color:'#3b82f6'};
      return `<span class="tagChip" data-color="1" style="--c:${tagColor(td)};">${escapeHtml(tagDisplayLabel(td)||td.id)}</span>`;
    }).join(' ');
    return chips;
  }
  function miniFieldBox(fieldId, title){
    const node = IDX.nodeById.get(fieldId);
    if(!node) return '';
    const colId = columnOf(fieldId)||'';
    const inout = (IDX.edgesByField.get(fieldId)||[]);
    let inbound=0,outbound=0; inout.forEach(e=>{ if(e.to===fieldId) inbound++; if(e.from===fieldId) outbound++; });
    const label = node.label||fieldId;
    const note = (node.note||'').trim();
    const tags = renderTagChips(node);
    const attrs = renderAttrChips(node);
    return `
      <div class="box clickable" data-jump-id="${escapeHtml(fieldId)}" style="cursor:pointer;">
        <div class="dtHero" style="padding-bottom:6px;">
          <div class="dtName" style="font-size:14px;">${escapeHtml(label)}</div>
          <span class="dtType" style="font-size:8px;padding:2px 6px;">${escapeHtml(title)}</span>
        </div>
        <div class="dtRow" style="padding:3px 2px;">
          <span class="dtRowK" style="min-width:28px;">ID</span>
          <span class="dtRowV"><span class="dtId">${escapeHtml(fieldId)}${isLikelyAutoId(node) ? '<span class="autoTag" style="font-size:7px;padding:0 3px;">auto</span>' : ''}</span></span>
        </div>
        <div class="dtRow" style="padding:3px 2px;">
          <span class="dtRowK" style="min-width:28px;">Col</span>
          <span class="dtRowV">${escapeHtml(colLabel(colId))}${colLabel(colId) !== colId ? ` <span style="font-family:var(--mono);font-size:10px;opacity:.35;">  ${escapeHtml(colId)}</span>` : ''}</span>
        </div>
        <div class="dtStatRow" style="padding:3px 0;">
          <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${inbound}</span><span class="dtStatL">in</span></span>
          <span class="dtStatChip" style="padding:2px 6px;"><span class="dtStatN" style="font-size:11px;">${outbound}</span><span class="dtStatL">out</span></span>
        </div>
        ${note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(note)}</div>` : ''}
        ${attrs ? `<div style="padding:1px 0;">${attrs}</div>` : ''}
        ${tags ? `<div class="dtChipWrap" style="padding:2px 0;">${tags}</div>` : ''}
      </div>`;
  }
  const srcBox = miniFieldBox(edge.from, 'Source field');
  const tgtBox = miniFieldBox(edge.to, 'Target field');
  detailsBody.innerHTML = `
    <div class="box">
      <div class="dtHero" style="padding-bottom:6px;">
        <div style="font-size:10px;opacity:.35;">View</div>
        <span class="dtType mapping" style="font-size:8px;padding:2px 6px;">Mapping</span>
      </div>
      <div class="dtRow" style="padding:3px 2px;">
        <span class="dtRowK">From</span>
        <span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edge.from)}</code></span>
      </div>
      <div class="dtRow" style="padding:3px 2px;">
        <span class="dtRowK">To</span>
        <span class="dtRowV"><code style="font-size:11px;">${escapeHtml(edge.to)}</code></span>
      </div>
      ${(edge.direction && edge.direction !== 'forward') ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Direction</span><span class="dtRowV">${edge.direction === 'both' ? ' Bidirectional' : ' Linked (directionless)'}</span></div>` : ''}
      ${edge.cardinality ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Card.</span><span class="dtRowV">${escapeHtml(edge.cardinality)}</span></div>` : ''}
      ${tLabels ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Transforms</span><span class="dtRowV" style="font-size:11.5px;">${escapeHtml(tLabels)}</span></div>` : ''}
      ${(edge.default!=='' && edge.default!==undefined) ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Default</span><span class="dtRowV">${escapeHtml(String(edge.default))}</span></div>` : ''}
      ${edge.note ? `<div class="dtNote" style="font-size:11px;padding:4px 8px;">${escapeHtml(edge.note)}</div>` : ''}
      ${edge.color ? `<div class="dtRow" style="padding:3px 2px;"><span class="dtRowK">Color</span><span class="dtRowV"><span class="dtColorSwatch" style="background:${escapeHtml(edge.color)};"></span> <span style="font-family:var(--mono);font-size:11px;opacity:.55;">${escapeHtml(edge.color)}</span></span></div>` : ''}
    </div>
    ${srcBox}
    ${tgtBox}
  `;
  // clicking a field box jumps to that node
  detailsBody.querySelectorAll('[data-jump-id]').forEach(el=>{
    el.addEventListener('click', async ()=>{
      const id = el.getAttribute('data-jump-id');
      if(id){ lockSelection(id); scrollIntoView(id); }
    });
  });
  return true;
}

function renderAll(){
  // Save collapse state before rebuild
  const collapsedIds = new Set();
  if(IDX && IDX.elementById){
    for(const [id, el] of IDX.elementById.entries()){
      if(el.classList.contains('group') && el.classList.contains('collapsed')){
        collapsedIds.add(id);
      }
    }
  }

  // Save column scroll positions before DOM rebuild
  const scrollPositions = new Map();
  if(IDX && IDX.columns){
    for(const col of IDX.columns){
      const panel = IDX.panelByColumnId?.get(col.id);
      if(panel){
        const tree = panel.querySelector('.tree');
        if(tree && tree.scrollTop > 0) scrollPositions.set(col.id, tree.scrollTop);
      }
    }
  }
  // Also save outer scroller position
  const outerScrollLeft = columnsScroller.scrollLeft;
  const outerScrollTop = columnsScroller.scrollTop;

  // rebuild indexes + render columns
  buildIndexes(state.data);
  // Mark bidirectional/consolidated edges
  markConsolidatedEdges();
  // keep mapping target dropdowns in sync with latest schema
  rebuildFieldDatalist();
  renderColumns();

  // Restore collapse state
  for(const id of collapsedIds){
    const el = IDX.elementById.get(id);
    if(el && el.classList.contains('group')){
      el.classList.add('collapsed');
      const children = el.querySelector(':scope > .children');
      if(children) children.style.display = 'none';
    }
  }

  applyVisibility();
  applyHighlight();

  // Restore column scroll positions after DOM rebuild
  for(const [colId, scrollTop] of scrollPositions){
    const panel = IDX.panelByColumnId?.get(colId);
    if(panel){
      const tree = panel.querySelector('.tree');
      if(tree) tree.scrollTop = scrollTop;
    }
  }
  // Restore outer scroller position
  columnsScroller.scrollLeft = outerScrollLeft;
  columnsScroller.scrollTop = outerScrollTop;

  // Restore highlight colors from project data
  if(typeof restoreHlColors === 'function') restoreHlColors();

  // Refresh mapping color scheme (must run after buildIndexes so edges exist)
  refreshEdgeColorScheme();
  rebuildEdgeSchemeOptions();
  
  // Sync project title
  const titleInput = document.getElementById('projectTitle');
  if(titleInput && state.data) {
    titleInput.value = state.data.title || 'New Project';
  }
  syncBrowserTitle();

  // quick meta in status
  setViewerStatus(`Loaded: ${IDX.columns.length} columns  ${IDX.fieldIds.size} fields  ${IDX.edges.length} mappings`);

  // Refresh filter chips (catalogs may have changed)
  renderActiveFilterChips();
  if(!__applyingView) _clearActiveViewIfDrifted();
}

/* =========================
   Docs content
========================= */
function buildDocs(){
  const docs = `
<div style="text-align:center;padding:18px 0 20px;margin-bottom:16px;border-bottom:1px solid var(--border);">
<div style="font-size:20px;font-weight:800;letter-spacing:1.2px;text-transform:uppercase;">Dunnode</div>
<div style="font-size:12px;font-weight:600;opacity:.5;letter-spacing:.4px;margin-top:2px;">Done. Now.</div>
<div style="font-size:11.5px;opacity:.45;margin-top:6px;">A lightweight mapping studio for complex flows.</div>
</div>
<h2>Overview</h2>
<p>Dunnode is a single-file, zero-dependency tool for visualizing, editing, and documenting field-level data mappings across multiple systems. It runs entirely in the browser &mdash; nothing is uploaded or stored on a server.</p>
<p>Key capabilities: multi-column schema trees, bezier arrow visualization, inline editing with drag-and-drop, tag/transform/attribute catalogs, undo/redo, project save/load, CSV and HTML export.</p>

<h2>Getting started</h2>
<ol>
  <li>Visit <b>dunnode.com</b> in any modern browser, or download the HTML file to run it locally.</li>
  <li>Click <b>Load example</b> to explore the sample project, or <b>New mapping</b> to start from scratch.</li>
  <li>To load your own data, click <b>Open</b> and select a <code>.json</code> file.</li>
  <li>Use <b>Save project</b> to download your work as JSON (the file includes all columns, mappings, catalogs, and metadata).</li>
</ol>

<h2>Viewer</h2>
<p>The viewer displays each system as a column of collapsible tree nodes. Mappings appear as highlighted connections between fields.</p>
<ul>
  <li><b>Hover</b> a field or group to preview all connected mappings across the entire chain.</li>
  <li><b>Click</b> a field or group to lock the selection &mdash; you can then scroll and inspect distant matches.</li>
  <li><b>Ctrl/Cmd+click</b> to add or remove nodes from a multi-selection. Works across columns. The details panel shows a combined summary with bulk action buttons in editor mode.</li>
  <li><b>Shift+click</b> to select a range of visible nodes within the same column (from last clicked to current click).</li>
  <li><b>Alt+click</b> for chain select: if the clicked node is connected to the current selection, adds it plus the path between them; otherwise adds its full chain. <b>Alt+Shift</b>=upstream only, <b>Alt+Ctrl/Cmd</b>=downstream only.</li>
  <li><b>Drag on empty space</b> to draw a selection rectangle &mdash; all intersecting nodes are selected. Hold <b>Alt</b> while dragging for a freeform lasso shape. Hold Shift to add to existing selection, Ctrl/Cmd to subtract.</li>
  <li><b>Click a mapping line</b> to select a specific mapping and view/edit its properties.</li>
  <li><b>Esc</b> (or the <b></b> toolbar button) clears selection and search.</li>
  <li><b>Collapse/expand groups</b> by clicking the &#9656;/&#9662; toggle on any group node.</li>
</ul>

<h3>Search &amp; filter</h3>
<ul>
  <li><b>Search</b> ( toolbar) filters nodes across all columns matching label or id text. Matching groups auto-expand. Search is always ANDed with active filters.</li>
  <li><b>Only mapped</b> hides fields that have no inbound or outbound mappings.</li>
  <li><b>Columns&hellip;</b> lets you show, hide, and drag-reorder columns. In editor mode, also includes <b>+ Add left</b> / <b>+ Add right</b> buttons to create new columns.</li>
</ul>

<h3>Filters</h3>
<p>Rule-based filters apply visual highlights to matching nodes. Open the <b>Filters</b> catalog from the  toolbar group to create and manage filters.</p>
<ul>
  <li><b>Conditions</b>: each filter has one or more conditions (e.g. "tag has Active", "label contains mission", "has outbound mapping"). Conditions can be combined with AND/OR.</li>
  <li><b>Groups</b>: nest conditions inside <code>( )</code> groups for complex logic like "(tag=Active AND has mapping) OR (label contains legacy)".</li>
  <li><b>Priority</b>: filters are evaluated in priority order. Higher-priority filter styles override lower ones. Drag-reorder or use / buttons in the catalog.</li>
  <li><b>Highlight styles</b>: each filter can set background tint, left border stripe, arrow color, frame outline, bold text, and an emoji prefix. Each channel has an enable/disable checkbox.</li>
  <li><b>Color palette</b> (): click the palette button in the filter editor to reveal preset swatches. Click a swatch to apply it to all enabled channels; drag it onto a specific color picker to set just that one.</li>
  <li><b>Activation</b>: toggle individual filters with the checkbox in the catalog. Active filters appear as chips in the filter bar.</li>
</ul>

<h3>Display modes</h3>
<p>The display mode selector in the filter bar has three options:</p>
<ul>
  <li><b>Hide</b> (default): non-matching nodes are hidden entirely.</li>
  <li><b>Dim</b>: non-matching nodes stay visible but dimmed (reduced opacity).</li>
  <li><b>Highlight</b>: all nodes remain visible at full opacity. Only the highlight styles (background, border, bold, etc.) are applied to matches.</li>
</ul>
<p>The <b>AND / OR</b> selector controls whether nodes must match ALL active filters (AND) or ANY (OR). Note: search text is always ANDed with filter results regardless of this setting.</p>

<h3>Mappings &amp; highlighting</h3>
<p>By default, arrows draw only for the current selection. The highlight follows the <b>entire chain</b> of connected mappings, not just immediate neighbors.</p>
<ul>
  <li><b>Mapping visibility</b> (Graph menu): a 3-way selector  <b>Selected</b> shows mapping lines only for hovered/selected nodes (default), <b>All</b> draws every mapping line at once (best for small graphs), <b>Off</b> hides all mapping lines.</li>
  <li><b>Mapping scope</b> (Graph menu): two independent toggles control which mapping types are drawn. <b>Same-column</b> controls mappings between nodes within the same column. <b>Distant</b> controls mappings that cross non-adjacent columns. Adjacent-column mappings are always shown when arrows are on. Uncheck either to reduce clutter.</li>
  <li><b>Color mappings by</b> (Graph menu): automatic arrow coloring by a shared property  cardinality, first transform, source/target tag, or source/target custom attribute. A legend appears in the Graph popover. Hover any scheme button to preview its legend without switching.</li>
  <li><b>Color priority (mappings)</b>: Selection/hover highlight  Filter color  Color-by scheme  Per-mapping manual color  default. The scheme overrides individual mapping colors, so "Color mappings by" gives a consistent palette when active. See the <b>Colors</b> section below for full details on each layer.</li>
  <li><b>Dim mode</b> (Selection menu): choose how unselected nodes and mappings appear  <b>All</b> dims everything, <b>Parents</b> keeps parent groups visible, <b>Off</b> disables dimming entirely. Colored mappings (scheme, filter, or manual) properly dim alongside nodes.</li>
  <li><b>Dim unselected</b> (Selection menu): <b>All</b> dims everything except directly connected fields. <b>Parents</b> also keeps ancestor groups visible with a subtle highlight. <b>Off</b> disables dimming. Collapsed groups always stay highlighted regardless of mode.</li>
  <li><b>Highlight mode</b> (Selection menu): choose between <b>Chain</b> (follow full mapping chain across all columns, default), <b>Direct</b> (show only immediate/adjacent mappings), and <b>Selected</b> (highlight only the selected node(s), no connected fields). Applies to both single and multi-selections.</li>
  <li><b>Highlight colors</b> (Selection  Highlight colors): customize the Selected / Hovered and Connected highlight colors with a picker and preset swatches. Includes a live preview tester with interactive Source  Target nodes. Per-row  reset to defaults. Colors are saved as <code>_highlightColors</code> in the project JSON and travel with the file. Changes are undoable (Ctrl+Z). Editable only in Editor mode; read-only in Viewer mode. Save / Cancel / Delete workflow with unsaved-changes guard.</li>
</ul>
<p>Tip: for large graphs, keep arrow mode on <b>Selected</b> and use hover/click to explore connections contextually. Disable <b>Same-column</b> and <b>Distant</b> arrows to focus on adjacent mappings only.</p>

<h3>Details pane</h3>
<p>The details panel shows contextual information. It can be docked <b>left, right, bottom</b>, used as a <b>floating</b> window (drag to reposition, resize from corner), or <b>hidden</b>. Press <b>D</b> to toggle visibility. Use the mode buttons in the panel header or drag the float panel to a screen edge to dock.</p>
<ul>
  <li><b>No selection</b>: project metadata summary (title, author, description, etc.).</li>
  <li><b>Field/group selected</b>: node label, ID, tags, custom attributes, note, and inbound/outbound mapping lists. Groups additionally show a <b>Children</b> section with rich detail cards (type, summary, tags, attributes) for each child node.</li>
  <li><b>Mapping selected</b>: mapping details including from/to, label (shown on mapping line), cardinality, transforms, default, tags, custom attributes, and note.</li>
  <li><b>Column selected</b>: column header properties.</li>
  <li>Inbound, Outbound, and Children sections are <b>collapsible</b> (click the  caret). Groups default to collapsed sections; fields default to expanded.</li>
</ul>

<h3>Layout controls</h3>
<ul>
  <li><b>Column width</b> and <b>Column gap</b> sliders adjust the visual layout.</li>
  <li><b>Wrap columns</b>: stacks columns vertically instead of side-by-side (useful for screenshots or narrow screens).</li>
  <li><b>Bright mode</b>: toggles between dark and light themes.</li>
  <li><b>Zoom / density</b>: scales the entire viewer (50&ndash;150%). Use the slider in the Layout popover to fit more on screen or zoom in for detail.</li>
  <li><b>Display tags / Display attributes</b>: toggles tag and attribute pills on tree nodes.</li>
  <li><b>Node color mode</b>: controls which color inheritance levels are active for node background tints. Four modes:
    <ul>
      <li><b>All</b> (default): full inheritance chain &mdash; node &rarr; group &rarr; column.</li>
      <li><b>Groups</b>: column + group colors only. Field-level color overrides are suppressed (groups still override their parent).</li>
      <li><b>Column</b>: only column colors are applied. All group and field colors are suppressed.</li>
      <li><b>Off</b>: no background tinting at all. Column headers still show their color.</li>
    </ul>
  </li>
  <li><b>Pan mode</b>: press <b>P</b> or click the <b>&#x229e;</b> toolbar button to enter pan mode &mdash; drag anywhere to scroll the viewer. Press P, Esc, or click &#x229e; again to exit.</li>
  <li><b>Clear selection</b>: press <b>Esc</b> or click the <b>&#x2298;</b> toolbar button to deselect the current node, mapping, or column.</li>
</ul>

<h2>Editor mode</h2>
<p>Toggle <b>Editor mode</b> in the toolbar to edit the model directly in the viewer. All changes are tracked by undo/redo (<b>Ctrl+Z</b> / <b>Ctrl+Y</b>, or <b>Cmd</b> on Mac).</p>

<h3>Columns</h3>
<ul>
  <li><b>Add columns</b>: open <b>Columns&hellip;</b> and use the <b>+ Add left</b> / <b>+ Add right</b> buttons (editor mode), or hover between column headers to reveal a &ldquo;+&rdquo; insertion zone.</li>
  <li><b>Rename columns</b>: click the column header label (in editor mode) to edit it.</li>
  <li><b>Column context menu</b>: click the &#x2AF6; button on a column header to access rename, delete, move, add, and <b>import fields</b> options.</li>
  <li><b>Column notes</b>: editable in the details pane when a column is selected.</li>
  <li><b>Column colors</b>: optional per-column color with swatch picker, hex input, and Apply checkbox. When applied, the column header name is tinted and a colored bottom border appears. The color acts as the final fallback in the node color inheritance chain &mdash; all descendant nodes without their own applied color (or an ancestor group color) inherit the column color as a subtle background tint.</li>
  <li><b>Import fields</b>: open from the column context menu ( &rarr; <b>Import fields&hellip;</b>), the Import toolbar menu, or the command palette. Paste field names &mdash; one per line &mdash; and they&rsquo;re created instantly. Two modes are auto-detected:
    <ul>
      <li><b>Plain lines</b>: each line becomes a field. Indented lines nest under their parent (which auto-promotes to a group).</li>
      <li><b>Tab-separated</b>: paste from a spreadsheet or database tool. The first row is treated as headers; recognized columns include <em>label, id, note, type, tag</em>. Unrecognized columns are shown in the preview for reference.</li>
    </ul>
    Choose the <b>insertion position</b> (top/bottom) and <b>nesting parent</b> (column root or any existing group). A live preview shows exactly what will be created before you commit. Press <b>Ctrl+Enter</b> to import.</li>
  <li><b>Import columns</b>: open from the Import toolbar menu or command palette. Supports two formats: <b>Plain text</b> &mdash; column definitions separated by blank lines, first line of each block = column name, indented lines = fields with automatic nesting. <b>Tab-separated</b> &mdash; a <code>column</code> header groups rows into columns; supports <code>parent</code>, <code>note</code>, <code>type</code>, <code>tag</code>, and extra columns (auto-created as custom attributes). Choose right or left insertion position. A live preview shows the column and field tree before committing.</li>
  <li><b>Import from project</b>: open from the Import toolbar menu or command palette. Browse to another Dunnode <code>.json</code> file and cherry-pick which columns, tags, attributes, and transforms to merge into the current project. Mappings between imported columns are preserved. Column IDs are automatically de-duplicated if they conflict with existing ones.</li>
  <li><b>Import SQL/DDL</b>: open from the Import toolbar menu or command palette. Paste or upload SQL <code>CREATE TABLE</code> statements. The parser extracts:
    <ul style="margin:4px 0 2px;">
      <li>Each table &rarr; a new column</li>
      <li>Each SQL column &rarr; a field with data type assigned as a custom attribute</li>
      <li><b>PRIMARY KEY</b> &rarr;  Primary Key tag</li>
      <li><b>NOT NULL</b> &rarr;  Required tag + Nullable: No attribute</li>
      <li><b>UNIQUE</b> &rarr; Unique tag</li>
      <li><b>FOREIGN KEY  REFERENCES</b> &rarr;  Foreign Key tag + reference noted in field note</li>
      <li><b>DEFAULT</b> value &rarr; noted in field note</li>
      <li><b>AUTO_INCREMENT / SERIAL / IDENTITY</b> &rarr; detected</li>
    </ul>
    Supports MySQL, PostgreSQL, SQL Server, and Oracle syntax including quoted identifiers (<code>&quot;name&quot;</code>, <code>&#x60;name&#x60;</code>, <code>[name]</code>), schema prefixes, inline and table-level constraints, and <code>IF NOT EXISTS</code>. Tags and attributes are auto-created if they don&rsquo;t exist. Choose right or left insertion position.</li>
  <li><b>Import CSV/TSV file</b>: open from the Import toolbar menu or command palette. Upload a <code>.csv</code>, <code>.tsv</code>, or <code>.txt</code> file. An interactive column mapping UI shows each file column with a sample and a role dropdown:
    <ul style="margin:4px 0 2px;">
      <li><b>Label</b> &mdash; field display name (required, auto-detected from common header names)</li>
      <li><b>ID</b> &mdash; custom identifier override</li>
      <li><b>Parent</b> &mdash; nesting hierarchy (matches by label or ID)</li>
      <li><b>Column</b> &mdash; group fields into separate columns (one per unique value)</li>
      <li><b>Note</b> &mdash; field description</li>
      <li><b>Tag</b> &mdash; comma/semicolon-separated tag names</li>
      <li><b>Custom attribute</b> &mdash; auto-creates or matches an attribute and assigns values</li>
      <li><b>Skip</b> &mdash; ignore column</li>
    </ul>
    Supports comma, tab, and semicolon separators with RFC-compliant quoted field parsing. Import into new columns or an existing column. Live preview shows the resulting tree with nesting, tag badges, and attribute pills.</li>
  <li><b>Import mappings</b>: open from the Import toolbar menu or command palette. Paste or upload a CSV/TSV file with mapping definitions. Required columns:
    <ul style="margin:4px 0 2px;">
      <li><b>source</b> (or <b>from</b>) &mdash; source field reference</li>
      <li><b>target</b> (or <b>to</b>) &mdash; target field reference</li>
    </ul>
    Optional columns: <b>cardinality</b>, <b>label</b>, <b>note</b>, <b>default</b>, <b>tag</b> (comma-separated), <b>transform</b> (comma-separated). Extra columns become custom attributes.
    <br/><br/>
    Field resolution uses multiple strategies in order: <b>exact ID</b> match, <b>column.label</b> path (e.g. &ldquo;customers.email&rdquo;), unambiguous <b>label</b> match, or <b>partial ID</b> match (last segment). The preview shows resolution status badges for each field. Compatible with the CSV export format for round-tripping &mdash; paste an exported <code>mappings.csv</code> to re-import mappings into a modified project.</li>
</ul>

<h3>Nodes (fields &amp; groups)</h3>
<ul>
  <li><b>Add nodes</b>: hover a row to reveal action buttons &mdash; &#x21B3; (add child inside group), &#x2AFA; (context menu with insert, move, indent, copy/paste, duplicate, group/ungroup, delete).</li>
  <li><b>Context menu</b>: click the  button on any node or <b>right-click</b> a node for insert above/below, move, indent/outdent, copy/paste, duplicate (without mappings), duplicate+ (with mappings), group selection, ungroup, convert type (field  group), and delete.</li>
  <li><b>Convert to field/group</b>: available in the context menu. Fields can be converted to empty groups. Groups can be converted to fields only when they have no children.</li>
  <li><b>Edit node properties</b>: click a field to select it, then edit label, ID, note, color, tags, custom attributes, and mappings in the details pane.</li>
  <li><b>Drag-and-drop nodes</b>: drag a field or group to reorder, move between groups, or move to another column. Hold modifier keys during drag for different operations:
    <ul>
      <li><b>No modifier</b> &mdash; <em>Move</em>: relocates the node (removes from source).</li>
      <li><b>Alt / Option</b> &mdash; <em>Map</em>: creates a mapping between the dragged field and the drop target.</li>
      <li><b>Alt + Shift</b> &mdash; <em>Map </em>: creates a <em>bidirectional</em> mapping (single edge, both directions).</li>
      <li><b>Alt + Shift + Ctrl / Cmd</b> &mdash; <em>Map </em>: creates a <em>directionless</em> (linked) mapping with no implied flow.</li>
      <li><b>Ctrl / Cmd</b> &mdash; <em>Copy</em>: duplicates the node to the drop location (original stays).</li>
      <li><b>Ctrl / Cmd + Alt / Option</b> &mdash; <em>Copy+</em>: duplicates the node and copies all its mappings to the new copy.</li>
    </ul>
  </li>
  <li><b>Node IDs</b>: hierarchical path structure. The path prefix is auto-calculated from the parent hierarchy; the local segment is editable.</li>
  <li><b>Node colors</b>: optional per-node color shown as a subtle background tint. Use the preset swatches, color picker, or hex input in the editor. Check <b>Apply</b> to activate; uncheck to stage a color without applying it.</li>
  <li><b>Column colors</b>: optional per-column color with swatch picker, hex input, and Apply checkbox that tints the column header and acts as the final fallback in the inheritance chain for all descendant nodes.</li>
  <li><b>Attribute value colors</b>: each value can have a color with an Apply checkbox. If a value's color is not applied, it inherits from the attribute-level color. For &ldquo;Color mappings by&rdquo;, disabled value colors fall back to the default palette.</li>
  <li><b>Color priority (node background)</b>: multiple systems can color a node. From highest to lowest priority: <b>Selection/hover highlight</b> &rarr; <b>Filter highlight</b> &rarr; <b>Node color</b> (applied) &rarr; <b>Nearest ancestor group color</b> (applied) &rarr; <b>Column color</b> &rarr; none. Selection and filter highlights completely override the inheritance chain. Within the inheritance chain, groups with color applied cascade to all descendants until a child overrides with its own applied color.</li>
  <li><b>Color priority (mappings)</b>: multiple systems can color an arrow. From highest to lowest priority:
    <ol style="margin:4px 0 2px 18px;font-size:12px;line-height:1.7;">
      <li><b>Selection/hover highlight</b> &mdash; when a mapping is part of the active selection or hover chain, the highlight color (blue for connected, gold for selected) always wins. This is why "Color mappings by" is most useful in <b>All</b> arrow mode, where drawn arrows aren&rsquo;t highlighted.</li>
      <li><b>Filter mapping color</b> &mdash; if a filter has <b>mapping color</b> enabled in its highlight style, arrows matching the filter get that color. Evaluated per-arrow: both endpoints must match the filter.</li>
      <li><b>Color-by scheme</b> &mdash; when "Color mappings by" is active in the Graph menu (Cardinality, Transform, Source/Target tag, or custom attribute), all arrows are colored by the chosen property using a consistent palette. Custom colors defined on tags or attribute values take priority over the auto-palette when the value&rsquo;s color is enabled (Apply checked).</li>
      <li><b>Manual per-mapping color</b> &mdash; individual color set on the mapping itself via the editor. This is the lowest priority, meaning "Color mappings by" overrides it when active. To see manual colors, set the scheme to <b>Off</b>.</li>
      <li><b>Default</b> &mdash; no coloring; the arrow uses the standard line color (light gray in dark mode, dark gray in bright mode).</li>
    </ol>
    <p style="margin:4px 0 0;font-size:12px;opacity:.7;">When a selection is active and <b>Dim mode</b> is not Off, unrelated arrows dim to the background regardless of their color  filter, scheme, and manual colors all respect dimming.</p>
  </li>
  <li><b>Color priority (attribute pills)</b>: <b>Value color</b> (Apply checked) &rarr; <b>Attribute color</b> (Apply checked) &rarr; none (default chip style).</li>
</ul>

<h3>Mappings</h3>
<ul>
  <li><b>Create by drag</b>: hold <b>Alt / Option</b> and drag a field onto a field in another column. Alternatively, drag without modifiers between columns to create a mapping when the drop indicator shows the link icon.</li>
  <li><b>Create from details pane</b>: when a field is selected, use "Add outbound" or "Add inbound".</li>
  <li><b>Edit mapping properties</b>: click an arrow to select the mapping, then edit cardinality, transforms, default value, color, and note.</li>
  <li><b>Mapping direction</b>: each mapping has a direction  <b>Forward</b> (, default), <b>Bidirectional</b> (), or <b>Directionless</b> (). Set via the 3-way toggle in the mapping editor, or by using modifier keys during drag creation:
    <ul>
      <li><b>Alt+Drag</b>  Forward mapping ()</li>
      <li><b>Alt+Shift+Drag</b>  Bidirectional mapping ()  symmetric relationship, same logic both ways</li>
      <li><b>Alt+Shift+Ctrl/Cmd+Drag</b>  Directionless link ()  association without implied flow</li>
    </ul>
  </li>
  <li><b>Two separate forwards vs bidirectional</b>: two forward mappings AB and BA are consolidated into a single line with opposing arrows meeting at the center (). A single bidirectional mapping () has arrowheads at both endpoints  visually and semantically distinct.</li>
  <li><b>Delete mappings</b>: select a mapping and click the delete button in the details pane.</li>
</ul>

<h3>Multi-select &amp; bulk actions</h3>
<p>Select multiple nodes to perform bulk operations. The details panel shows a combined summary with action buttons.</p>
<ul>
  <li><b>Ctrl/Cmd+click</b>: toggle individual nodes in/out of the multi-selection. Works across columns.</li>
  <li><b>Shift+click</b>: select a range of visible nodes within the same column (from last clicked node to current).</li>
  <li><b>Alt+click</b>: chain select. If the clicked node is connected to the current selection, adds it and all nodes on the shortest path back to the selection. If it&rsquo;s already selected or not connected, adds its entire mapping chain instead.</li>
  <li><b>Alt+Shift+click</b>: upstream chain select &mdash; follows mappings backwards to find all sources that map <em>to</em> the clicked node.</li>
  <li><b>Alt+Ctrl/Cmd+click</b>: downstream chain select &mdash; follows mappings forwards to find all targets the clicked node maps <em>to</em>.</li>
  <li><b>Marquee &amp; lasso select</b>: drag on empty viewer background to draw a selection rectangle. Hold Alt while dragging for a freeform lasso shape instead. All nodes inside the shape are selected. Hold Shift to add, Ctrl/Cmd to subtract. Modifiers combine: Alt+Shift = freeform add, Alt+Ctrl = freeform subtract.</li>
  <li><b>Bulk delete</b>: remove all selected nodes and their mappings. Supports undo.</li>
  <li><b>Bulk set tags</b>: add or remove tags across all selected nodes. The dialog shows each tag&rsquo;s current state (checked, unchecked, or indeterminate for partial application).</li>
  <li><b>Bulk set attribute</b>: set a custom attribute value on all selected nodes, or remove an attribute entirely.</li>
  <li><b>Bulk map to&hellip;</b>: search for a target field and create mappings from all selected fields to that target in one click.</li>
  <li><b>Multi-select drag-and-drop</b>: when multiple nodes are selected, dragging any selected node performs the operation on all selected nodes simultaneously. The drag ghost shows a &times;N count badge. Same modifier keys apply:
    <ul>
      <li><b>No modifier (Move)</b>: moves all selected root nodes to the drop position, maintaining their original relative order.</li>
      <li><b>Alt / Option (Map)</b>: maps all selected fields to the drop target field. The selection then switches to the target.</li>
      <li><b>Ctrl / Cmd (Copy)</b>: duplicates all selected root nodes to the drop position.</li>
      <li><b>Ctrl / Cmd + Alt / Option (Copy+)</b>: duplicates all selected root nodes and their mappings.</li>
    </ul>
  </li>
  <li><b>Deduplication</b>: when a group and some of its children are both selected, only the group is processed &mdash; children travel implicitly with their parent, avoiding duplicates.</li>
  <li><b>Drop target validation</b>: you cannot drop onto or inside any selected node during Move. You cannot Map to any selected field. Invalid targets show a &ldquo;not allowed&rdquo; cursor.</li>
  <li><b>Multi bin delete</b>: drag the multi-selection to the &ldquo; Delete&rdquo; zone during a Move drag to bulk-delete all selected root nodes (with confirmation).</li>
</ul>

<h3>Save / Cancel behavior</h3>
<p>Catalog editors (tags, transforms, attributes, filters) and node/column/mapping editors use a click-to-edit pattern:</p>
<ul>
  <li>Click an item to enter edit mode. Only one item is editable at a time &mdash; other items are greyed out.</li>
  <li><b>Save</b>: commits all changes as a single undo entry. The button turns <span style="color:#f59e0b;font-weight:700;">yellow</span> when there are pending unsaved changes.</li>
  <li><b>Cancel</b>: reverts to the state before editing &mdash; no undo entry is created, no confirmation prompt.</li>
  <li><b>Delete</b>: prompts for confirmation, then removes the item with cascading cleanup.</li>
  <li><b>Abandon guard</b>: navigating away from unsaved edits (clicking another node, switching modes, closing a catalog, undo/redo) prompts "Abandon unsaved changes?" The prompt only appears when actual changes are detected vs. the snapshot. Manually reverting all changes back to original values clears the dirty state.</li>
</ul>

<h2>Catalogs</h2>
<p>Five catalogs are managed via modal panels (accessible from the CATALOGS toolbar group). All catalog editors share a unified editing pattern:</p>
<ul>
  <li><b>Inline creation</b>: clicking <b>Add</b> inserts a blank editor card at the top of the list. No popup  edit in place. When creating a node, selecting "+ New tag", "+ New attribute", or "+ New value" opens a nested create modal  the node form is saved and restored automatically after committing or cancelling.</li>
  <li><b>Auto-ID &amp; abbreviation</b>: as you type a label, the ID and abbreviation auto-generate in real time. A blue <b>auto</b> badge indicates the field is linked to the label. Edit the field to override (badge disappears); clear it to re-link (badge reappears).</li>
  <li><b>Required fields</b>: Label is required in all editors  marked with a red <b style="color:rgba(239,130,130,.7);">*</b>. The Save button stays disabled until a label is entered.</li>
  <li><b>Save / Cancel / Delete</b>: the Save button is disabled until changes are detected and all required fields are filled. New items have no Delete button. Cancel on a new item discards it (with a confirmation prompt if dirty).</li>
  <li><b>Click to edit</b>: click any existing item to open its inline editor. A dirty guard prompts before abandoning unsaved changes.</li>
</ul>

<h3>Tags</h3>
<p>Tags are colored labels attached to nodes (fields and groups), mappings, and other catalog items (tags, attributes, transforms). They appear as small pills in the viewer and catalog lists, and indicate status, ownership, category, or workflow stage. Tags marked <b>Meta only</b> act as category headers &mdash; they are hidden from node/mapping selectors and group their child tags, attributes, and transforms into labeled optgroup sections in all selector dropdowns.</p>
<ul>
  <li>Each tag has: <b>id</b>, <b>label</b>, <b>abbreviation</b>, <b>emoji</b> (optional, with picker palette), <b>display mode</b> (Abbr or Emoji  controls what appears in pills), <b>color</b> (with preset swatches, color picker, and hex input), <b>Apply</b> checkbox, <b>note</b>, <b>priority</b>, <b>meta only</b> (category tag  organize catalogs only, not selectable on nodes/mappings), and <b>category</b> (assign meta-only tags for catalog grouping).</li>
  <li><b>Priority</b> determines display order everywhere. Drag tags in the manager to reorder, or use the arrow buttons.</li>
  <li>Tags are assigned to nodes in the node editor (details pane), to edges in the mapping editor, and to other catalog items (tags, attributes, transforms) in their inline editors.</li>
  <li>Up to 3 tags are shown per field in the viewer; the rest are visible on hover or in the details pane.</li>
</ul>

<h3>Transforms</h3>
<p>Transforms describe data conversion operations applied to mappings (e.g. trim, uppercase, type cast). They are an ordered sequence per mapping.</p>
<ul>
  <li>Each transform has: <b>id</b>, <b>label</b>, <b>abbreviation</b>, <b>emoji</b> (optional), <b>display mode</b> (Abbr/Emoji), <b>note</b>, optional <b>color</b> (with hex input and Apply checkbox), and optional <b>params</b> (parameter schema).</li>
  <li>Params define per-instance configuration: each param has an <b>id</b>, <b>label</b>, <b>type</b> (text or number), and optional <b>default</b>. Param IDs also auto-generate from the label.</li>
  <li>The same transform can be added <b>multiple times</b> to a mapping&rsquo;s chain &mdash; each instance can have different parameter values (e.g. two REPLACE transforms with different substitutions).</li>
  <li>Transforms are assigned to mappings in the mapping editor. Their <b>order matters</b> &mdash; drag to reorder. Click a parameterized chip to edit its parameters.</li>
  <li>Transforms appear as numbered chips (1, 2, 3&hellip;) on mapping details. Parameterized transforms show <code>(&hellip;)</code> in their abbreviation.</li>
</ul>

<h3>Custom attributes</h3>
<p>Custom attributes add domain-specific metadata to nodes (e.g. data type, sensitivity classification).</p>
<ul>
  <li>Each attribute has: <b>id</b>, <b>label</b>, <b>abbreviation</b>, <b>emoji</b> (optional), <b>display mode</b> (Abbr/Emoji), <b>note</b>, a list of <b>values</b>, a <b>multi</b> flag, and an optional <b>color</b> with Apply checkbox. Each value has its own <b>abbreviation</b>, <b>emoji</b>, <b>display mode</b>, and optional <b>color</b> with Apply checkbox.</li>
  <li>If <b>multi</b> is true, fields can have multiple values for that attribute (checkboxes). Otherwise, single-select (radio).</li>
  <li>Attribute values can have their own notes.</li>
  <li><b>Attribute-level color</b>: the attribute itself can have a color with an Apply checkbox. When enabled, values that don&rsquo;t have their own color applied will inherit the attribute&rsquo;s color for node pills.</li>
  <li><b>Value color Apply</b>: each value&rsquo;s color has an explicit Apply toggle. When unchecked, the color is stored but not used &mdash; the value inherits from the attribute color instead. For &ldquo;Color mappings by&rdquo;, values with disabled colors fall back to the default palette rather than using their stored color.</li>
  <li>The catalog overview shows a colored dot next to each value that has a custom color. Values with disabled colors appear slightly dimmed. Attributes with an applied color show a dot next to the attribute name.</li>
  <li><b>Value color editing</b>: inline color picker with &#x1f3a8; swatch toggle (10 presets), hex input, Apply checkbox, and &#x21ba; reset per value row. Colors are also available when creating new values.</li>
  <li>Attributes appear as compact pills in the viewer and as full details in the details pane.</li>
</ul>

<h3>Filters</h3>
<p>Filters are rule-based visual highlights. They follow the same inline creation and editing pattern as other catalogs, with additional controls for highlight style (background, stripe, mapping color, frame, bold, emoji) and condition rules.</p>

<h3>Import</h3>
<p>Bulk-import catalog items from the Import toolbar menu, or via the <b>Import&hellip;</b> button inside each catalog modal (Tags, Attributes, Transforms). All import modals support:</p>
<ul>
  <li><b>Plain lines</b>: one item per line. For attributes, indented lines become values of the parent attribute.</li>
  <li><b>Tab-separated</b>: paste from a spreadsheet. First row = headers. Recognized headers vary by catalog type:
    <ul style="margin:4px 0 2px;">
      <li><b>Tags</b>: label, id, color, emoji, note, abbr, metaOnly, tag</li>
      <li><b>Attributes</b>: label, id, type (single/multi), values (semicolon-separated), color, emoji, note, abbr, displayOnNode, tag</li>
      <li><b>Transforms</b>: label, id, color, emoji, note, abbr, tag</li>
    </ul>
  </li>
  <li><b>File upload</b>: click &ldquo;Upload file&rdquo; to load a <code>.csv</code>, <code>.tsv</code>, or <code>.txt</code> file into the textarea.</li>
  <li><b>Match &amp; merge</b>: items are matched to existing catalog entries by <b>ID</b> first, then by <b>label</b>. Matched items are updated (non-empty imported properties overwrite existing values; for attributes, new values are added without removing existing ones). New items are created. The preview shows <b>new</b>, <b>will update</b>, or <b>exists &mdash; no changes</b> badges.</li>
  <li><b>Custom IDs</b>: add an <code>id</code> column in TSV imports to set or match by custom identifier. IDs are preserved as-is (auto-deduplicated if conflicting).</li>
  <li><b>Live preview</b>: shows exactly what will be created before you commit. Press <b>Ctrl+Enter</b> to import.</li>
  <li><b>Preset fills</b>: each import modal shows a <b>Presets</b> bar with domain-specific one-click fills (Database, API/JSON, Data Governance, ETL/Integration). Click a preset to populate the textarea with curated items for that domain, then customize before importing.</li>
</ul>

<h3>Preset bundles</h3>
<p>For quick project setup, use <b>Catalogs &rarr; Load preset bundle&hellip;</b> (also in the command palette) to populate tags, attributes, and transforms in a single click. Four built-in domain bundles are available:</p>
<ul>
  <li><b> Database</b> &mdash; SQL/relational modeling: tags (Active, PII, Primary Key&hellip;), attributes (Data Type, Length, Nullable&hellip;), transforms (Trim, Cast, Coalesce&hellip;)</li>
  <li><b> API / JSON</b> &mdash; REST API & JSON schema: tags (Required, Optional, Deprecated&hellip;), attributes (Data Type, Format, Constraints&hellip;), transforms (Serialize, Validate, Map fields&hellip;)</li>
  <li><b> Data Governance</b> &mdash; Privacy & compliance: tags (PII, PHI, GDPR&hellip;), attributes (Sensitivity, Retention, Data Domain&hellip;), transforms (Mask, Hash, Encrypt&hellip;)</li>
  <li><b> ETL / Integration</b> &mdash; Data pipeline design: tags (Source, Target, Staging&hellip;), attributes (Load Strategy, Frequency, SCD Type&hellip;), transforms (Lookup, Pivot, Deduplicate&hellip;)</li>
</ul>
<p>Bundles are additive &mdash; existing items are preserved and only new items are added. The preview shows which items will be created vs. which already exist. Multiple bundles can be applied to the same project.</p>

<h3>Views</h3>
<p>Views are saved snapshots of the viewer state &mdash; filters, selection, arrows, collapse state, hidden columns, and display settings. They let you bookmark presentation-ready states and switch between them with one click.</p>
<ul>
  <li><b>Toolbar access</b>: the <b>Views</b> toolbar button opens a quick-apply dropdown listing all saved views. Click a view to apply it instantly. Click the active view again to deactivate (toggle off).</li>
  <li><b>View pill</b>: when a view is active, a compact indicator appears in the viewer header showing the emoji and label. Use the &#x2039;/&#x203A; buttons to navigate between views, the dropdown to switch, or &#xD7; to deactivate.</li>
  <li><b>Save current view</b> (<b>Ctrl+Alt+S</b>): captures all current viewer settings into a new named view. Available from the dropdown, command palette, or keyboard shortcut.</li>
  <li><b>Previous / Next view</b> (<b>,</b> / <b>.</b>): navigate between saved views. The current state is auto-saved before applying, so you can toggle back and forth.</li>
  <li><b>Reset view</b> (<b>Ctrl+Alt+0</b>): clears all filters, search, selection, hidden columns, collapsed groups, arrows, mapping colors, node colors, and dim mode. Returns to a clean-slate default state.</li>
  <li><b>Catalog management</b>: open the Views catalog from Catalogs &rarr; Views or via <b>Manage views&hellip;</b> in the dropdown. Inline editing: click any view to edit its label, emoji, note; drag to reorder; update snapshot to capture current state; delete.</li>
  <li><b>State captured</b>: active filters, filter mode/logic, &ldquo;only mapped&rdquo;, search text, node selection, highlight mode (chain/direct/selected), arrow mode (selected/all/off), mapping scope (same-column/distant), selection dim mode, hidden columns, collapsed groups, mapping color scheme, node color mode, mapping label display mode, tag pill visibility, and attribute pill visibility.</li>
  <li><b>State not captured</b>: panel position/size, editor mode, scroll position, pan mode &mdash; these are device- or workflow-specific.</li>
  <li><b>Command palette</b>: type a view name to apply it directly. Also includes &ldquo;Save current view&rdquo;, &ldquo;Reset view&rdquo;, and per-view entries.</li>
  <li>Each view has an <b>emoji</b> for quick visual identification in the dropdown, pill indicator, and catalog.</li>
</ul>

<h2>Project properties</h2>
<p>Click the <b>&#x24D8;</b> button next to the project title to open the Project Properties modal. Available fields:</p>
<ul>
  <li><b>Title</b>, <b>Subtitle</b>, <b>Description</b> (multiline), <b>Author</b>, <b>Organization</b>, <b>Contact</b>, <b>URL</b>, <b>Version</b>, <b>Date</b>.</li>
  <li>The title is also editable by clicking it directly in the header.</li>
  <li>App version and last-saved timestamp are shown as read-only metadata.</li>
</ul>

<h2>Undo / Redo</h2>
<ul>
  <li><b>Ctrl+Z</b> / <b>Ctrl+Y</b> (or Cmd on Mac) to undo and redo.</li>
  <li>Toolbar buttons are also available in the top bar.</li>
  <li>Each meaningful action creates exactly one undo entry (no duplicates from intermediate steps).</li>
  <li>All data mutations are undoable  node edits, mapping changes, catalog additions/deletions, highlight color changes, and filter updates.</li>
  <li>Undo/redo automatically refreshes open catalog modals and restores highlight CSS variables to match the restored state.</li>
  <li>Undo history is cleared when loading a new project or starting a new mapping.</li>
</ul>

<h2>Dirty state &amp; saving</h2>
<p>The <b>Save project</b> button shows a blue highlight when there are unsaved changes. The dirty indicator tracks all edits and resets on save, load, or undo-back-to-clean-state.</p>
<ul>
  <li><b>Save project</b>: downloads the complete JSON with app metadata (<code>_app</code>), timestamp (<code>_savedAt</code>), and custom highlight colors (<code>_highlightColors</code>) if set.</li>
  <li><b>Open project</b>: loads a JSON file, validates it, and resets undo history.</li>
  <li>Files are saved and loaded locally &mdash; nothing is sent to a server.</li>
  <li><b>Editor dirty guards</b>: navigating away from an unsaved editor (catalog item, filter, node, or create modal) prompts for confirmation. Bulk edit modals track whether changes were made before enabling Apply.</li>
</ul>

<h2>Export</h2>
<ul>
  <li><b>Export CSV</b>: exports all currently visible mappings as a CSV file (from, to, cardinality, transforms, default, note).</li>
  <li><b>Export report</b>: generates a self-contained HTML snapshot with all mapping details, suitable for sharing with stakeholders who don't have the tool.</li>
</ul>

<h2>JSON format</h2>
<p>The project file is a single JSON object:</p>
<pre><code>{
  "title": "Project title",
  "subtitle": "...",
  "description": "...",
  "author": "...",
  "organization": "...",
  "contact": "...",
  "url": "...",
  "projectVersion": "1.0",
  "date": "2026-01-15",
  "_app": { "name": "Dunnode", "version": "1.7.2", "schema": 1 },
  "_savedAt": "2026-02-19T12:00:00.000Z",
  "columns": [
    {
      "id": "mc",
      "label": "Mission Control",
      "note": "Source of truth for mission parameters.",
      "color": "#3b82f6",
      "schema": {
        "id": "mc",
        "label": "Mission Control",
        "type": "group",
        "children": [
          {
            "id": "mc.mission",
            "label": "Mission",
            "type": "group",
            "children": [
              {
                "id": "mc.mission.missionId",
                "label": "MissionId",
                "type": "field",
                "tags": ["active"],
                "customAttributes": { "format": "string" },
                "note": "Primary mission identifier."
              }
            ]
          }
        ]
      }
    }
  ],
  "mappings": [
    {
      "from": "mc.mission.missionId",
      "to": "sat.vehicle.vehicleCode",
      "cardinality": "1:1",
      "transforms": ["trim", "upper"],
      "default": "",
      "note": "Mission ID becomes vehicle code."
    }
  ],
  "tagCatalog": [
    { "id": "active", "label": "Active", "abbr": "A",
      "color": "#22c55e", "note": "...", "priority": 1,
      "tags": ["status"] }
  ],
  "transformCatalog": [
    { "id": "trim", "label": "Trim whitespace",
      "abbr": "TR", "note": "...", "tags": ["category"] }
  ],
  "customAttributeCatalog": [
    { "id": "format", "_autoId": true, "_autoAbbr": true, "label": "Format", "abbr": "FM",
      "note": "...", "multi": false, "tags": ["category"],
      "color": "#6b7280", "colorEnabled": false,
      "values": [
        { "id": "string", "label": "String", "note": "...",
          "color": "#22c55e", "colorEnabled": true }
      ] }
  ],
  "filterCatalog": [
    { "id": "f1", "label": "Critical & Unmapped",
      "priority": 1,
      "rules": [{ "field": "tag", "op": "has", "value": "active" }],
      "highlight": { "bg": "#f43f5e", "border": "#f43f5e",
        "edgeColor": "#f43f5e", "frameColor": "#f43f5e",
        "bgEnabled": true, "borderEnabled": true,
        "edgeEnabled": false, "bold": true,
        "frame": false, "emoji": "" } }
  ],
  "viewCatalog": [
    { "id": "v1", "label": "Full Overview", "emoji": "",
      "note": "All columns visible, no filters",
      "state": {
        "activeFilterIds": [], "filterMode": "hide",
        "filterLogic": "or", "onlyMapped": false,
        "search": "", "selection": [],
        "highlightMode": "chain", "arrowMode": "selected",
        "showSameColumn": true, "showDistant": true,
        "selectionDim": "all", "hiddenColumns": [],
        "collapsedGroups": [], "edgeColorScheme": "",
        "nodeColorMode": "all" } }
  ]
}</code></pre>

<h3>Schema tree nodes</h3>
<ul>
  <li><code>type: "group"</code> &mdash; container node with <code>children: []</code>.</li>
  <li><code>type: "field"</code> &mdash; leaf node, no children.</li>
  <li>Each node must have a unique <code>id</code>.</li>
  <li>Optional properties: <code>label</code> (display name), <code>tags</code> (array of tag ids), <code>customAttributes</code> (object mapping attribute id to value id), <code>color</code> (hex color string for custom tint), <code>note</code> (free text).</li>
  <li><b>Color inheritance:</b> a node&rsquo;s effective background tint follows the hierarchy: own <code>color</code> (applied) &rarr; nearest ancestor group with <code>color</code> &rarr; column <code>color</code> &rarr; none. Groups with color cascade to all descendants until overridden.</li>
  <li><b>ID convention:</b> field ids should start with <code>&lt;columnId&gt;.</code> (e.g. <code>lab.experiment.payload_mass</code>) so the tool can infer column membership.</li>
</ul>

<h3>Column object</h3>
<ul>
  <li><code>id</code> &mdash; unique column identifier.</li>
  <li><code>label</code> &mdash; display name.</li>
  <li><code>note</code> &mdash; optional free text.</li>
  <li><code>color</code> &mdash; optional hex color. When present, tints the column header and acts as the fallback color for all descendant nodes without their own applied color.</li>
  <li><code>schema</code> &mdash; root group node containing the tree.</li>
</ul>

<h3>Mapping object</h3>
<ul>
  <li><code>from</code> &mdash; field id (source).</li>
  <li><code>to</code> &mdash; field id (target). In v4 this is always a single string.</li>
  <li><code>cardinality</code> &mdash; one of: <code>1:1</code>, <code>1:n</code>, <code>n:1</code>, <code>n:n</code>, or empty.</li>
  <li><code>transforms</code> &mdash; ordered array of transform catalog ids.</li>
  <li><code>default</code> &mdash; default value when source is null/empty.</li>
  <li><code>note</code> &mdash; free text annotation.</li>
  <li><code>color</code> &mdash; optional hex color for custom arrow coloring.</li>
  <li><code>direction</code> &mdash; one of: <code>forward</code> (default), <code>both</code> (bidirectional), or <code>none</code> (directionless).</li>
</ul>

<h3>Catalog items (tags, attributes, transforms)</h3>
<ul>
  <li>All catalog item types support a <code>tags</code> array of tag ids for categorization. Only meta-only tags can be assigned as categories on catalog items.</li>
  <li>Assigned category tags appear as small pills in catalog lists and can be edited via the Category selector row in each catalog editor.</li>
  <li>Tags cannot reference themselves (self-tagging is excluded from the dropdown).</li>
  <li>Tags with <code>"metaOnly": true</code> are <b>category tags</b> &mdash; they are hidden from node/mapping tag selectors. Tags, attributes, and transforms that have a meta-only tag in their <code>tags</code> array are grouped under that meta tag&rsquo;s label (as optgroup headers) in their respective selector dropdowns. Items with multiple meta tags appear in all matching groups.</li>
</ul>

<h2>Command palette</h2>
<p>Press <b>Ctrl+K</b> (Cmd+K on Mac) or click the <b></b> button in the header to open the command palette.</p>
<ul>
  <li>Type to fuzzy-search all available commands (open catalogs, toggle modes, change views, undo/redo, etc.).</li>
  <li>The palette also searches all <b>nodes and fields</b> by name or ID  selecting one expands parent groups, selects the node, and scrolls it into view.</li>
  <li>Use <b></b> to navigate, <b>Enter</b> to execute, <b>Escape</b> to close.</li>
</ul>

<h2>Keyboard shortcuts</h2>
<p><b>Navigation</b>:</p>
<ul>
  <li><b> / </b> &mdash; Move selection to previous/next visible node</li>
  <li><b>Shift+ / Shift+</b> &mdash; Extend multi-selection up/down</li>
  <li><b>Space</b> &mdash; Toggle collapse/expand on selected group(s)</li>
  <li><b>Enter</b> &mdash; Focus the label field in the details editor (opens panel if hidden)</li>
  <li><b>Esc</b> &mdash; Clear selection and search / cancel edit / close modal</li>
</ul>
<p><b>Editing</b> (Editor mode):</p>
<ul>
  <li><b>Ctrl+</b> (Cmd+ on Mac) &mdash; Insert new field below selection with inline rename</li>
  <li><b>Ctrl+</b> (Cmd+ on Mac) &mdash; Insert new field above selection</li>
  <li><b>Ctrl+Alt+</b> / <b>Ctrl+Alt+</b> &mdash; Insert new group below/above</li>
  <li><b>Ctrl+</b> (Cmd+ on Mac) &mdash; Add child field inside selected group</li>
  <li><b>Ctrl+Alt+</b> &mdash; Add child group inside selected group</li>
  <li><b>Alt+ / Alt+</b> &mdash; Move node(s) up/down among siblings</li>
  <li><b>Alt+ / Alt+</b> &mdash; Indent / outdent node(s)</li>
  <li><b>Ctrl+C</b> (Cmd+C) &mdash; Copy selected node(s) to clipboard</li>
  <li><b>Ctrl+V</b> (Cmd+V) &mdash; Paste node(s) from clipboard (as siblings below selection)</li>
  <li><b>Ctrl+D</b> (Cmd+D) &mdash; Duplicate selected node(s) with mappings</li>
  <li><b>Ctrl+G</b> (Cmd+G) &mdash; Wrap selected siblings in a new group</li>
  <li><b>Ctrl+Shift+G</b> (Cmd+Shift+G) &mdash; Ungroup: dissolve group, move children to parent level</li>
  <li><b>Delete</b> &mdash; Delete selected node(s) with confirmation</li>
</ul>
<p><b>Inline rename</b>: when creating via keyboard, an inline input appears. Type a label and press <b>Enter</b> to commit (or <b>Escape</b> to cancel and remove). Press another create shortcut (Ctrl+) to commit the current name and immediately create the next node  empty labels default to "New Field" / "New Group".</p>
<p><b>General</b>:</p>
<ul>
  <li><b>Ctrl+K</b> (Cmd+K on Mac) &mdash; Open command palette  search commands, nodes, and documentation</li>
  <li><b>Ctrl+A</b> (Cmd+A on Mac) &mdash; Select all visible nodes</li>
  <li><b>Ctrl+Shift+I</b> (Cmd+Shift+I on Mac) &mdash; Invert current selection</li>
  <li><b>Ctrl+Z</b> (Cmd+Z on Mac) &mdash; Undo</li>
  <li><b>Ctrl+Y</b> (Cmd+Y / Cmd+Shift+Z on Mac) &mdash; Redo</li>
  <li><b>?</b> &mdash; Open quick help</li>
  <li><b>D</b> &mdash; Toggle details panel (cycles: show  hide  show)</li>
  <li><b>P</b> &mdash; Toggle pan mode (drag to scroll the viewer). Press P or Esc to exit</li>
</ul>
<p><b>Project</b>:</p>
<ul>
  <li><b>Alt+N</b> &mdash; New project</li>
  <li><b>Alt+O</b> &mdash; Open project</li>
  <li><b>Alt+S</b> &mdash; Save project</li>
  <li><b>Alt+E</b> &mdash; Toggle editor mode</li>
</ul>
<p><b>Views</b>:</p>
<ul>
  <li><b>Ctrl+Alt+S</b> (Cmd+Alt+S) &mdash; Save current view</li>
  <li><b>,</b> / <b>.</b> &mdash; Previous / next view</li>
  <li><b>Ctrl+Alt+0</b> &mdash; Reset view to defaults</li>
</ul>
<p><b>Drag-and-drop modifiers</b> (hold during drag in Editor mode):</p>
<ul>
  <li><b>No modifier</b> &mdash; Move node (removes from source)</li>
  <li><b>Alt / Option</b> &mdash; Create mapping between source and target</li>
  <li><b>Alt + Shift</b> &mdash; Create bidirectional mapping () between source and target</li>
  <li><b>Alt + Shift + Ctrl / Cmd</b> &mdash; Create directionless link () between source and target</li>
  <li><b>Ctrl / Cmd</b> &mdash; Copy node to drop location</li>
  <li><b>Ctrl / Cmd + Alt / Option</b> &mdash; Copy node and duplicate all its mappings</li>
</ul>
<p>When multiple nodes are selected, dragging any selected node applies the same modifiers to the entire selection (bulk Move, Map, Copy, or Copy+). The drag ghost shows a &times;N count badge.</p>

<h2>Glossary</h2>
<ul>
  <li><b>Column</b> &mdash; a system or data source, rendered as a vertical tree.</li>
  <li><b>Field</b> &mdash; a leaf node in a schema tree. Mappings connect fields.</li>
  <li><b>Group</b> &mdash; a container node with children (can be nested).</li>
  <li><b>Edge / Mapping</b> &mdash; a connection from one field to another, with optional metadata (cardinality, transforms, default, note).</li>
  <li><b>Tag</b> &mdash; a colored label attached to nodes, mappings, and catalog items for categorization. Tags with <b>Meta only</b> enabled act as category headers and are hidden from node/mapping selectors.</li>
  <li><b>Transform</b> &mdash; a data conversion step attached to a mapping.</li>
  <li><b>Custom attribute</b> &mdash; domain-specific metadata attached to nodes (fields and groups) and mappings.</li>
  <li><b>Filter</b> &mdash; a rule-based condition set that visually highlights matching nodes with colors, borders, bold text, and emojis. Managed via the filter catalog.</li>
  <li><b>Bidirectional mapping</b> &mdash; when two mappings exist between the same pair in both directions, shown as a single arrow with a direction indicator.</li>
  <li><b>Non-adjacent mapping</b> &mdash; a mapping that skips one or more columns (shown as a long bezier curve).</li>
  <li><b>Virtual mapping</b> &mdash; when a column in the middle of a chain is hidden, the tool draws a dashed arrow connecting visible endpoints.</li>
</ul>

<h2>Tips &amp; best practices</h2>
<ul>
  <li>Start in viewer mode to explore data, switch to editor mode to make changes.</li>
  <li>Use tags to track mapping status (e.g. Active, Draft, Retired).</li>
  <li>Use custom attributes for domain metadata (e.g. data types, sensitivity flags).</li>
  <li>For large projects, hide columns you are not working on to reduce visual noise.</li>
  <li>Use "Only mapped" to focus on fields that participate in the integration.</li>
  <li>Save frequently &mdash; the dirty-state indicator (blue Save button) reminds you of unsaved changes. Individual editor Save buttons turn yellow when there are pending changes.</li>
  <li>Create filters for common review tasks (e.g. "unmapped critical fields") and toggle them on/off via filter bar chips.</li>
  <li>Use <b>Highlight</b> display mode when you want to see filter matches in context without hiding anything.</li>
  <li>Save <b>views</b> for common review states &mdash; e.g. a "Critical Gaps" view with unmapped filters active, or a "Data Formats" view focused on type attributes. Navigate between them with <b>,</b> / <b>.</b></li>
  <li>Use Export Report to share a read-only snapshot with reviewers who don't have the tool.</li>
</ul>

<h2>Known limitations</h2>
<ul>
  <li>Very large graphs (thousands of mappings) can be slow with arrow mode set to <b>All</b>. Use <b>Selected</b> mode instead.</li>
  <li>Bezier arrow routing is simple &mdash; dense non-adjacent mappings may overlap. Use filtering, mapping scope toggles, or hide intermediate columns.</li>
  <li>All data is local &mdash; no collaboration, versioning, or server-side storage. Use your own file management for team workflows.</li>
  <li><b>Safari</b>: drag-and-drop operations (reorder, move, copy, map nodes) are not supported due to Safari&rsquo;s non-standard handling of the HTML Drag and Drop API. Use a Chromium-based browser (Chrome, Edge, Arc, etc.) for full functionality.</li>
</ul>

<h2>Privacy &amp; Data Handling</h2>
<p>Dunnode runs entirely in your browser. No project data is transmitted, uploaded, or stored on any server.</p>
<p>All processing happens client-side. Your project files remain local unless you explicitly export or share them.</p>

<h2>License</h2>
<p>MIT License</p>
<p style="font-size:11.5px;opacity:.7;line-height:1.7;">Copyright &copy; 2026 Oliv&eacute;r B&aacute;n</p>
<p style="font-size:11px;opacity:.6;line-height:1.7;">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &ldquo;Software&rdquo;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p style="font-size:11px;opacity:.6;line-height:1.7;">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p style="font-size:11px;opacity:.6;line-height:1.7;">THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>

<div style="margin-top:28px;padding-top:16px;border-top:1px solid var(--border);text-align:center;">
<div style="font-size:12px;font-weight:700;opacity:.5;letter-spacing:.3px;">Dunnode. Done. Now.</div>
<div style="font-size:10px;opacity:.3;margin-top:4px;">v` + APP_VERSION + `</div>
</div>
  `.trim();

  docsBody.innerHTML = docs;

  // Generate table of contents  group h3s under their parent h2
  const headings = docsBody.querySelectorAll('h2, h3');
  headings.forEach(h => {
    h.id = 'doc-' + h.textContent.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/,'');
  });
  const sections = [];
  Array.from(headings).forEach(h => {
    if(h.tagName === 'H2') sections.push({ el: h, subs: [] });
    else if(sections.length) sections[sections.length - 1].subs.push(h);
  });
  const sectionHtml = sections.map(s => {
    const subsHtml = s.subs.length
      ? '<div class="tocSubs">' + s.subs.map(sub => '<a href="#' + sub.id + '">' + sub.textContent + '</a>').join('') + '</div>'
      : '';
    return '<div class="tocSection"><a class="main" href="#' + s.el.id + '">' + s.el.textContent + '</a>' + subsHtml + '</div>';
  }).join('');
  const tocHtml = '<div class="docsToc"><div class="tocTitle">Contents</div><div class="tocGrid">' + sectionHtml + '</div></div>';
  const docsLogoHeader = docsBody.firstElementChild;
  if(docsLogoHeader) docsLogoHeader.insertAdjacentHTML('afterend', tocHtml);
  else docsBody.insertAdjacentHTML('afterbegin', tocHtml);

  // Smooth scroll for TOC links
  docsBody.querySelectorAll('.docsToc a').forEach(a => {
    a.addEventListener('click', e => {
      e.preventDefault();
      const target = docsBody.querySelector(a.getAttribute('href'));
      if(target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });
  });
}


/* =========================
   Boot
========================= */
function init(){
  // Start with a blank project
  const blankData = createBlankMappingData();
  jsonArea.value = JSON.stringify(blankData, null, 2);
  validateEditor();

  state.data = blankData;
  // build structured editor list
  rebuildStructuredList();
  renderAll();
  markClean(); // Fresh on load (after renderAll normalizes data)


  // default UI state
  svgOverlay.style.display = "block";
  setTab("viewer");
}

init();


/* =========================
 v19  Drag & Drop for nodes + Cross-column mapping via drag
  - Reorder within same column (before/after)
  - Nest into a group (indent)
  - Move whole groups with children
  - Drag a field onto a field in another column to create a mapping (from = dragged, to = dropped)
  - Clear visual intent while hovering (status line + drop caret)
========================= */
(function(){
  window.__ENHANCED_DND = true;

  // runtime guard: only add once
  if(window.__MS_V19_DND_INSTALLED__) return; 
  window.__MS_V19_DND_INSTALLED__ = true;

  const DROP_LINE_ID = 'ms_drop_line_v19';
  let DND = { dragging: null, overId: null, intent: null, overEl: null };

  function ensureDropLine(){
    let el = document.getElementById(DROP_LINE_ID);
    if(!el){
      el = document.createElement('div');
      el.id = DROP_LINE_ID;
      el.style.position = 'fixed';
      el.style.zIndex = '2000';
      el.style.pointerEvents = 'none';
      el.style.height = '2px';
      el.style.background = 'rgba(59,130,246,.95)';
      el.style.boxShadow = '0 0 0 1px rgba(59,130,246,.55)';
      el.style.display = 'none';
      (document.getElementById('dndOverlay')||document.body).appendChild(el);
    }
    return el;
  }
  function hideDropLine(){
    const el = ensureDropLine();
    el.style.display = 'none';
  }
  function showDropLineAt(row, pos){
    const el = ensureDropLine();
    const r = row.getBoundingClientRect();
    const y = (pos==='before') ? r.top : (r.bottom);
    el.style.left = (r.left) + 'px';
    el.style.width = (r.width) + 'px';
    el.style.top = (Math.round(y)-1) + 'px';
    el.style.display = 'block';
  }

  function clearHoverClasses(){
    if(DND.overEl){ DND.overEl.classList.remove('dropTarget'); }
    hideDropLine();
  }

  function computeIntent(src, targetRow, clientX, clientY){
    if(!targetRow) return null;
    const tid = targetRow.dataset.nodeId;
    const tcol = targetRow.dataset.columnId;
    const tnode = IDX?.nodeById?.get(tid);
    if(!tid || !tcol || !tnode) return null;

    if(src.colId !== tcol){
      // Cross-column: only fieldfield mapping
      if(src.type==='field' && tnode.type==='field') return { kind:'map', targetId: tid, targetColId: tcol };
      return null;
    }

    // Same column: move operations
    const r = targetRow.getBoundingClientRect();
    const y = clientY - r.top; // 0..h
    const h = r.height || 1;
    const third = h/3;
    if(y < third){ return { kind:'before', targetId: tid, targetColId: tcol }; }
    if(y > 2*third){ return { kind:'after', targetId: tid, targetColId: tcol }; }
    // middle zone: into (only if target is a group)
    if(tnode.type !== 'field'){ return { kind:'into', targetId: tid, targetColId: tcol }; }
    // If middle but field, fall back to after
    return { kind:'after', targetId: tid, targetColId: tcol };
  }

  function beginDrag(row){
    const id = row?.dataset?.nodeId;
    const colId = row?.dataset?.columnId;
    if(!id || !colId) return false;
    const node = IDX?.nodeById?.get(id);
    if(!node) return false;
    DND.dragging = { id, colId, type: node.type };
    row.classList.add('dragging');
    setViewerStatus('Dragging: ' + id + '  Alt=Map, Alt+Shift=Map, Alt+Shift+Ctrl=Map, Ctrl=Copy, Ctrl+Alt=COPY+');
    return true;
  }
  function endDrag(){
    const rows = document.querySelectorAll('.row.dragging');
    rows.forEach(r=>r.classList.remove('dragging'));
    clearHoverClasses();
    DND.dragging = null; DND.overId = null; DND.intent = null; DND.overEl = null;
  }

  function describeIntent(intent){
    if(!intent) return '';
    const t = intent.targetId;
    if(intent.kind==='map') return 'Create mapping: ' + (DND.dragging?.id||'') + '  ' + t;
    if(intent.kind==='before') return 'Move before: ' + t;
    if(intent.kind==='after') return 'Move after: ' + t;
    if(intent.kind==='into') return 'Nest into group: ' + t;
    return '';
  }

  function performMove(srcId, intent){
    // If nothing is selected, lock the dragged node so the undo snapshot captures it
    if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
      state.lockedId = srcId;
    }
    recordChange(); // Save state BEFORE move
    
    const colId = columnOf(srcId);
    const col = findColumnById(colId);
    if(!col || !col.schema) return;
    const srcLoc = locateNode(col.schema, srcId);
    const tgtLoc = locateNode(col.schema, intent.targetId);
    if(!srcLoc || !tgtLoc) return;
    if(srcLoc.node.id === tgtLoc.node.id) return;

    // Remove src from its current siblings (unless root)
    let nodeToMove = srcLoc.node;
    if(srcLoc.parent && srcLoc.siblings && srcLoc.idx!=null){
      srcLoc.siblings.splice(srcLoc.idx, 1);
    } else {
      // Moving the root is not supported
      return;
    }

    if(intent.kind==='into'){
      // Ensure group and append as last child
      ensureGroup(tgtLoc.node);
      (tgtLoc.node.children = tgtLoc.node.children || []).push(nodeToMove);
    } else {
      const parent = tgtLoc.parent;
      const siblings = tgtLoc.siblings;
      const idx = tgtLoc.idx;
      if(!parent || !siblings || idx==null){
        // target is root  append as last child of root
        ensureGroup(tgtLoc.node);
        (tgtLoc.node.children = tgtLoc.node.children || []).push(nodeToMove);
      } else {
        const insertAt = intent.kind==='before' ? idx : (idx+1);
        siblings.splice(Math.max(0, Math.min(insertAt, siblings.length)), 0, nodeToMove);
      }
    }
  }

  function performDrop(){
    // v19.5: legacy performDrop disabled when enhanced DND is available
    if(window.__ENHANCED_DND){ try{ hideDropLine && hideDropLine(); }catch(e){} return; }
    const src = DND.dragging; const intent = DND.intent;
    if(!src || !intent) return;

    if(intent.kind==='map'){
      ensureMapping(src.id, intent.targetId);
      // Re-render to get fresh edges and select the new edge
      renderAll();
      // Find edge id
      const ee = (IDX && IDX.edges) ? IDX.edges.find(e => e.from===src.id && e.to===intent.targetId) : null;
      if(ee){
        selectEdge(ee.id);
        setViewerStatus('Created mapping: ' + ee.from + '  ' + ee.to);
      } else {
        applyHighlight();
      }
      return;
    }

    // Moves apply only within same column
    performMove(src.id, intent);
    // Sync editor JSON textarea if present
    if(typeof syncJsonAreaFromObj==='function'){
      try { syncJsonAreaFromObj(); } catch(e){}
    }
    // Re-render and keep selection on moved node
    renderAll();
    lockSelection(src.id);
    scrollIntoView(src.id);
    setViewerStatus(describeIntent(intent));
  }

  function onDragStart(e){
    if(!state.editorMode) { e.preventDefault(); return; }
    const row = e.target.closest('.row');
    if(!row) return;
    if(!beginDrag(row)) { e.preventDefault(); return; }
    try{ e.dataTransfer.setData('text/plain', row.dataset.nodeId||''); }catch(err){}
    try{ e.dataTransfer.effectAllowed = 'move'; }catch(err){}
  }
  function onDragEnd(){ endDrag(); }

  function onDragOver(e){
    if(!state.editorMode || !DND.dragging) return;
    const row = e.target.closest('.row');
    if(!row) return;
    const src = DND.dragging;
    const intent = computeIntent(src, row, e.clientX, e.clientY);
    if(!intent){ clearHoverClasses(); return; }
    e.preventDefault(); // allow drop

    // Visuals
    if(DND.overEl !== row){
      if(DND.overEl) DND.overEl.classList.remove('dropTarget');
      DND.overEl = row;
    }
    row.classList.add('dropTarget');

    if(intent.kind==='before' || intent.kind==='after'){
      showDropLineAt(row, intent.kind);
    } else {
      hideDropLine();
    }

    DND.intent = intent;
    setViewerStatus(describeIntent(intent));
  }
  function onDrop(e){
    if(!state.editorMode || !DND.dragging) return;
    const row = e.target.closest('.row');
    if(!row) return;
    const src = DND.dragging;
    const intent = computeIntent(src, row, e.clientX, e.clientY);
    if(!intent) return;
    e.preventDefault();
    performDrop();
    endDrag();
  }

  // Attach DnD handlers after each render
  const __orig_createNodeElement = createNodeElement;
  window.createNodeElement = function(node, columnId){
    const el = __orig_createNodeElement(node, columnId);
    const row = el.querySelector(':scope > .row');
    if(row){
      // draggable rows only when editorMode (we still set attribute; we gate in dragstart)
      /* v19.5 disabled draggable */;
      /* v19.5 disabled */
      /* v19.5 disabled */
      /* v19.5 disabled */
      /* v19.5 disabled */
    }
    return el;
  };
})();

/* =========================
 v19.2  Drag & Drop (Move / Map / Copy) with Ghost, Tooltip, Samecolumn map
  - Default drag action is configurable: Move | Map | Copy
  - Modifiers always work to override default:
      Alt  Map,  Ctrl  Copy,  Shift  Move
  - Move supports crosscolumn (IDs rewritten to target prefix)
  - Copy duplicates node (deep) and rewrites IDs; mappings are not duplicated
  - Samecolumn map: hold Alt while dragging a field over another field
  - Visuals: colored intent outlines, ghost preview with fade, floating tooltip
========================= */
(function(){
  window.__ENHANCED_DND = true;

  if(window.__MS_V192_DND_INSTALLED__) return; window.__MS_V192_DND_INSTALLED__ = true;

  // --- Styles (ghost + outlines + tooltip) ---
  const style = document.createElement('style');
  style.textContent = `
  .row.dropTarget.moveIntent{outline: 2px solid rgba(59,130,246,.85)!important; background: rgba(59,130,246,.14)!important;}
  .row.dropTarget.mapIntent {outline: 2px solid rgba(255,208,92,.92)!important; background: rgba(255,208,92,.20)!important;}
  .row.dropTarget.copyIntent{outline: 2px solid rgba(34,197,94,.90)!important; background: rgba(34,197,94,.18)!important;}
  .row.dropTarget.copyPlusIntent{outline: 2px solid rgba(132,204,22,.95)!important; background: rgba(132,204,22,.20)!important;}
  .dndGhost{position:fixed; left:-2000px; top:-2000px; z-index:9999; pointer-events:none; opacity:0; transform: scale(.98);
            box-shadow:0 12px 40px rgba(0,0,0,.45); transition: opacity .12s ease, transform .12s ease;}
  .dragTip{position:fixed; z-index:99999; pointer-events:none; font: 11px/1.2 var(--sans);
           color:#0b1020; background: rgba(255,255,255,.96); border:1px solid rgba(0,0,0,.15);
           border-radius:10px; padding:6px 8px; box-shadow:0 10px 30px rgba(0,0,0,.35); opacity:0;
           transform: translateY(4px); transition: opacity .08s ease, transform .08s ease;}
  .dragTip.show{opacity:1; transform: translateY(0);} 
  `;
  document.head.appendChild(style);

  // Floating tooltip element
  const tip = document.createElement('div'); tip.className='dragTip'; (document.getElementById('dndOverlay')||document.body).appendChild(tip);
  function showTip(txt, x, y){ tip.textContent = txt; tip.style.left=(x+14)+'px'; tip.style.top=(y+10)+'px'; tip.classList.add('show'); }
  function hideTip(){ tip.classList.remove('show'); }

  // Detect macOS for drag-and-drop workarounds
  const isMacOS = /Mac|iPhone|iPad|iPod/.test(navigator.platform) || /Mac|iPhone|iPad|iPod/.test(navigator.userAgent);

  const DROP_LINE_ID = 'ms_drop_line_v192';
  let DND = { dragging: null, overEl: null, intent: null, ghost: null, dropHandled: false, lastModifiers: null,
    multiIds: null,   // Set of deduped root node IDs for multi-select drag (or null for single)
    multiFields: null  // Set of field-only IDs for MAP during multi-select (or null)
  };
  // Expose multi-select state for ghost IIFE
  window.__DND_MULTI = DND;

  function ensureDropLine(){
    let el = document.getElementById(DROP_LINE_ID);
    if(!el){ el = document.createElement('div'); el.id = DROP_LINE_ID; el.style.position='fixed'; el.style.zIndex='2000'; el.style.pointerEvents='none'; el.style.height='2px'; el.style.background='rgba(59,130,246,.95)'; el.style.boxShadow='0 0 0 1px rgba(59,130,246,.55)'; el.style.display='none'; (document.getElementById('dndOverlay')||document.body).appendChild(el);} 
    return el;
  }
  function hideDropLine(){ ensureDropLine().style.display='none'; }
  function showDropLineAt(row, pos){ const el=ensureDropLine(); const r=row.getBoundingClientRect(); const y=(pos==='before')?r.top:r.bottom; el.style.left=r.left+'px'; el.style.width=r.width+'px'; el.style.top=(Math.round(y)-1)+'px'; el.style.display='block'; }

  // --- Cancel and Bin drop zones ---
  let cancelZone = null;
  let binZone = null;
  
  function ensureDropZones(){
    // Use pre-existing HTML elements in #dndOverlay  no DOM insertion during drag
    if(!cancelZone){
      cancelZone = document.getElementById('cancelZone');
      if(!cancelZone) return;
      
      cancelZone.addEventListener('dragover', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        cancelZone.classList.add('dragover');
        clearHover();
        DND.intent = null;
        DND.overEl = null;
        try{ e.dataTransfer.dropEffect = 'none'; }catch(_){}
      });
      
      cancelZone.addEventListener('dragleave', ()=>{
        cancelZone.classList.remove('dragover');
      });
      
      cancelZone.addEventListener('drop', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        DND.dropHandled = true;
        const ghostEl = document.getElementById('dragGhost');
        if(ghostEl) ghostEl.style.display = 'none';
        endDrag();
        setViewerStatus('Drop cancelled');
      });
    }
    
    if(!binZone){
      binZone = document.getElementById('binZone');
      if(!binZone) return;
      
      binZone.addEventListener('dragover', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        binZone.classList.add('dragover');
        // Clear intent and overEl so dragend fallback doesn't execute
        clearHover();
        DND.intent = null;
        DND.overEl = null;
        try{ e.dataTransfer.dropEffect = 'move'; }catch(_){}
      });
      
      binZone.addEventListener('dragleave', ()=>{
        binZone.classList.remove('dragover');
      });
      
      binZone.addEventListener('drop', async (e)=>{
        e.preventDefault();
        e.stopPropagation();
        DND.dropHandled = true;
        
        // Manually hide visual ghost since stopPropagation prevents document handler
        const ghostEl = document.getElementById('dragGhost');
        if(ghostEl) ghostEl.style.display = 'none';
        
        if(!DND.dragging){
          console.error('Delete failed: DND.dragging is null');
          endDrag();
          return;
        }
        
        const isMulti = !!(DND.multiIds && DND.multiIds.size >= 1);
        
        if(isMulti){
          // --- Multi-select bin delete ---
          const rootIds = DND.multiIds;
          // Collect all field IDs in subtrees for mapping cleanup
          const allFieldIds = new Set();
          for(const nid of rootIds){
            const node = IDX?.nodeById?.get(nid);
            if(node) for(const f of collectFieldIdsFromNode(node)) allFieldIds.add(f);
          }
          const mapCount = (state.data?.mappings||[]).filter(m => m && (allFieldIds.has(m.from) || allFieldIds.has(m.to))).length;
          const mapInfo = mapCount > 0 ? `\n${mapCount} related mapping${mapCount>1?'s':''} will be removed.` : '';
          if(!await customConfirm(`Delete ${rootIds.size} selected node${rootIds.size>1?'s':''}?${mapInfo}\n\nThis action can be undone with Ctrl+Z.`)){
            endDrag();
            return;
          }
          pushUndo();
          removeMappingsReferencingInState(allFieldIds);
          for(const nid of rootIds){
            const colId = nid.split('.')[0] || nid;
            const col = findColumnById(colId);
            if(!col || !col.schema) continue;
            const loc = locateNode(col.schema, nid);
            if(loc && loc.siblings && loc.idx != null){
              loc.siblings.splice(loc.idx, 1);
            }
          }
          state.multiSelection.clear();
          state.lockedId = null;
          state.hoverId = null;
          state.selectedEdgeId = null;
          markDirty();
          renderAll();
          showToast(`Deleted ${rootIds.size} nodes`);
          setViewerStatus(`Deleted ${rootIds.size} nodes`);
          endDrag();
          return;
        }
        
        // --- Single node bin delete (original) ---
        const srcId = DND.dragging.id;
        if(!srcId){
          console.error('Delete failed: srcId is null');
          endDrag();
          return;
        }
        
        // Show confirmation dialog
        const srcNode = IDX?.nodeById?.get(srcId);
        const srcType = srcNode?.type === 'field' ? 'field' : 'group';
        const srcLabel = srcNode?.label || srcId;
        if(!await customConfirm(`Delete ${srcType} "${srcLabel}" (${srcId})? This will remove related mappings too.`)){
          endDrag();
          return;
        }
        
        try{
          // If nothing is selected, lock the dragged node so the undo snapshot captures it
          if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
            state.lockedId = srcId;
          }
          recordChange(); // Save state before delete
          
          // Delete the node - get colId with fallback
          let srcColId = null;
          if(DND.dragging && DND.dragging.colId){
            srcColId = DND.dragging.colId;
          } else {
            // Fallback: derive from node ID (format: colId.rest)
            const dotIndex = srcId.indexOf('.');
            srcColId = dotIndex > 0 ? srcId.substring(0, dotIndex) : srcId;
          }
          
          if(!srcColId){
            console.error('Delete failed: Could not determine srcColId from', srcId);
            endDrag();
            return;
          }
          
          const srcCol = findColumnById(srcColId);
          if(srcCol && srcCol.schema){
            const loc = locateNode(srcCol.schema, srcId);
            if(loc && loc.siblings && loc.idx != null){
              loc.siblings.splice(loc.idx, 1);
              // Remove any mappings involving this node
              if(state.data && Array.isArray(state.data.mappings)){
                state.data.mappings = state.data.mappings.filter(m => 
                  m && m.from !== srcId && m.to !== srcId && 
                  (!Array.isArray(m.to) || !m.to.includes(srcId))
                );
              }
              // Clear selection
              state.lockedId = null;
              state.hoverId = null;
              state.selectedEdgeId = null;
              
              try{ syncJsonAreaFromObj(); }catch(e){}
              renderAll();
              if(typeof applyHighlight==='function') applyHighlight();
              setViewerStatus('Deleted: ' + srcId);
            } else {
              console.error('Delete failed: Could not locate node', srcId);
            }
          } else {
            console.error('Delete failed: Could not find column', srcColId);
          }
        }catch(err){ 
          console.error('Delete failed:', err);
          console.error('Stack:', err.stack);
        }
        
        endDrag();
      });
    }
  }
  
  function showDropZones(isMove){
    ensureDropZones();
    cancelZone.classList.add('visible');
    if(isMove){
      binZone.classList.add('visible');
    } else {
      binZone.classList.remove('visible');
    }
  }
  
  function hideDropZones(){
    if(cancelZone) cancelZone.classList.remove('visible', 'dragover');
    if(binZone) binZone.classList.remove('visible', 'dragover');
  }

  function clearHover(){ if(DND.overEl){ DND.overEl.classList.remove('dropTarget','moveIntent','mapIntent','copyIntent','illegal'); } hideDropLine(); hideTip(); }

  function beginDrag(row, e){
    const id = row?.dataset?.nodeId; const colId = row?.dataset?.columnId; if(!id||!colId) return false; const n=IDX?.nodeById?.get(id); if(!n) return false;
    DND.dragging = { id, colId, type: n.type };
    DND.dropHandled = false;
    DND.multiIds = null;
    DND.multiFields = null;
    row.classList.add('dragging');

    // --- Multi-select drag detection ---
    if(state.multiSelection.size >= 2 && state.multiSelection.has(id)){
      // Compute deduplicated root set: exclude nodes whose parent is also selected
      const selSet = state.multiSelection;
      const roots = new Set();
      const fields = new Set();
      for(const nid of selSet){
        const node = IDX?.nodeById?.get(nid);
        if(!node) continue;
        // Walk up: if any ancestor is in the selection, skip (it's implicitly included)
        let dominated = false;
        let p = IDX.parentById?.get(nid);
        while(p){
          if(selSet.has(p)){ dominated = true; break; }
          p = IDX.parentById.get(p);
        }
        if(!dominated) roots.add(nid);
        if(node.type === 'field') fields.add(nid);
      }
      if(roots.size >= 1){
        DND.multiIds = roots;
        DND.multiFields = fields;
      }
    }

    // Build ghost
    try{
      const ghost = row.cloneNode(true); ghost.classList.add('dndGhost');
      ghost.style.width = row.getBoundingClientRect().width + 'px'; (document.getElementById('dndOverlay')||document.body).appendChild(ghost); DND.ghost = ghost;
      requestAnimationFrame(()=>{ ghost.style.opacity='1'; ghost.style.transform='scale(1)'; });
      e.dataTransfer.setDragImage(ghost, Math.min(24, ghost.getBoundingClientRect().width*0.15), 12);
    }catch(err){}
    // Show drop zones (bin only for move initially, will update in dragover)
    showDropZones(false);
    const multiInfo = DND.multiIds ? ` (${DND.multiIds.size} nodes)` : '';
    setViewerStatus('Dragging: ' + id + multiInfo + '  Alt=Map, Alt+Shift=Map, Alt+Shift+Ctrl=Map, Ctrl=Copy, Ctrl+Alt=COPY+');
    return true;
  }
  function endDrag(){ document.querySelectorAll('.row.dragging').forEach(r=>r.classList.remove('dragging')); try{ if(DND.ghost && DND.ghost.parentNode){ DND.ghost.style.opacity='0'; DND.ghost.style.transform='scale(.98)'; setTimeout(()=>{ try{DND.ghost.remove();}catch(e){} }, 120);} }catch(err){}
    DND.ghost=null; clearHover(); DND.dragging=null; DND.intent=null; DND.overEl=null; DND.multiIds=null; DND.multiFields=null; hideTip(); hideDropZones(); }

  // Utilities for moves/copies between columns
  function findColumnById(colId){ return (state.data?.columns||[]).find(c=>c&&c.id===colId); }
  function locateNode(root, targetId, parent=null){ if(!root) return null; if(root.id===targetId) return { node: root, parent, idx:null, siblings:null}; const kids=root.children||[]; for(let i=0;i<kids.length;i++){ const ch=kids[i]; if(ch&&ch.id===targetId) return { node: ch, parent: root, idx:i, siblings:kids}; const deep=locateNode(ch, targetId, root); if(deep) return deep; } return null; }
  function ensureGroup(node){ if(!node.children) node.children=[]; node.type = (node.type!=='field') ? 'group' : node.type; return node; }
  function idPartFromLabel(label){ let s=String(label||'').trim().normalize('NFD').replace(/[\u0300-\u036f]/g,''); s=s.replace(/\s+/g,'_').replace(/[^A-Za-z0-9_]/g,'').replace(/_+/g,'_'); if(!s) s='node'; if(/^\d/.test(s)) s='n_'+s; return s; }
  function ensureUniqueId(base, taken){ let id=base, i=2; while(taken.has(id)){ id=base+'_'+i; i++; } return id; }

  function collectNodeIds(col){ const ids=new Set(); (function walk(n){ if(!n||typeof n!=='object') return; if(n.id) ids.add(n.id); (n.children||[]).forEach(walk); })(col.schema); return ids; }
  function buildSubtreeIdMap(node, oldPrefix, newPrefix, out){ if(!node||typeof node!=='object') return; const oldId=node.id; const newId=(oldId===oldPrefix)?newPrefix:(newPrefix+oldId.slice(oldPrefix.length)); out[oldId]=newId; node.id=newId; (node.children||[]).forEach(ch=>buildSubtreeIdMap(ch, oldPrefix, newPrefix, out)); }
  function replaceIdsInMappings(idMap){ if(!state.data||!Array.isArray(state.data.mappings)) return; state.data.mappings.forEach(m=>{ if(!m||typeof m!=='object') return; if(typeof m.from==='string' && idMap[m.from]) m.from=idMap[m.from]; if(typeof m.to==='string' && idMap[m.to]) m.to=idMap[m.to]; }); }

  
  // --- Toast helpers ---
  function ensureToast(){
    let t = document.getElementById('ms_toast');
    if(!t){
      t = document.createElement('div'); t.id='ms_toast';
      t.style.position='fixed'; t.style.right='16px'; t.style.bottom='16px';
      t.style.zIndex='99999'; t.style.maxWidth='46vw'; t.style.padding='10px 12px';
      t.style.border='1px solid rgba(255,255,255,.14)'; t.style.borderRadius='12px';
      t.style.background='rgba(11,16,32,.96)'; t.style.color='rgba(232,238,252,.96)';
      t.style.font='12px var(--sans)'; t.style.boxShadow='0 18px 55px rgba(0,0,0,.55)';
      t.style.opacity='0'; t.style.transform='translateY(6px)';
      t.style.transition='opacity .16s ease, transform .16s ease';
      (document.getElementById('dndOverlay')||document.body).appendChild(t);
    }
    return t;
  }
  function showToast(msg){
    try{
      const t = ensureToast();
      t.textContent = msg;
      requestAnimationFrame(()=>{ t.style.opacity='1'; t.style.transform='translateY(0)'; });
      clearTimeout(window.__ms_toast_timer);
      window.__ms_toast_timer = setTimeout(()=>{ try{ t.style.opacity='0'; t.style.transform='translateY(6px)'; }catch(e){} }, 2200);
    }catch(e){}
  }

  // --- Copy edges preference & helper ---
  const COPY_EDGES_PREF_KEY = 'ms_v192_copy_edges'; // 'structure' | 'structure_edges' | 'ask'
  function getCopyEdgesPref(){
    try{ const v = localStorage.getItem(COPY_EDGES_PREF_KEY); return (v==='structure' || v==='structure_edges' || v==='ask') ? v : 'structure'; }catch(e){ return 'structure'; }
  }
  function setCopyEdgesPref(v){ try{ localStorage.setItem(COPY_EDGES_PREF_KEY, v); }catch(e){} }
  function duplicateEdgesByIdMap(idMap){
    if(!state || !state.data || !Array.isArray(state.data.mappings)) return 0;
    const out = [];
    const hasPair = (from,to)=> (state.data.mappings||[]).some(m=>m && m.from===from && m.to===to);
    for(const m of (state.data.mappings||[])){
      if(!(m && typeof m==='object')) continue;
      const nf = idMap[m.from] || null; const nt = idMap[m.to] || null;
      if(!nf && !nt) continue; // mapping not touching subtree
      const from2 = nf || m.from; const to2 = nt || m.to;
      if(from2===m.from && to2===m.to) continue;
      if(hasPair(from2,to2)) continue;
      const clone = Object.assign({}, m, { from: from2, to: to2 });
      out.push(clone);
    }
    if(out.length){ (state.data.mappings = state.data.mappings || []).push(...out); }
    return out.length;
  }
function cloneNodeDeep(node){ return JSON.parse(JSON.stringify(node)); }

  function performMoveOrCopy({kind, srcId, targetId, targetColId, where, copyEdges=false}){
  // If nothing is selected, lock the dragged node so the undo snapshot captures it
  // (otherwise undoing a drag on an unselected node leaves nothing selected)
  if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
    state.lockedId = srcId;
  }
  // Save state BEFORE any modifications
  recordChange();
  
  // Block dropping into any descendant of self (all actions)
  { let p=IDX.parentById?.get(targetId); while(p){ if(p===srcId) return null; p = IDX.parentById?.get(p); } }
  if(!state||!state.data) return;
  if(!srcId||!targetId) return;
  // Self-drop: move always blocked; copy allowed before/after but not into
  if(srcId===targetId){
    if(kind==='copy'){
      if(where==='into') return null;
    } else {
      return null;
    }
  }
  const srcColId = (srcId.split('.')[0]||srcId);
  const srcCol = findColumnById(srcColId); const tgtCol = findColumnById(targetColId);
  if(!srcCol||!tgtCol) return;
  const srcLoc = locateNode(srcCol.schema, srcId); const tgtLoc0 = locateNode(tgtCol.schema, targetId);
  if(!srcLoc||!tgtLoc0) return;
  const movingNode = (kind==='copy') ? cloneNodeDeep(srcLoc.node) : srcLoc.node;
  const oldParentId = srcLoc.parent ? srcLoc.parent.id : null;
  // Remove source first for MOVE so target indices are computed on the final array
  if(kind!=='copy'){ if(srcLoc.parent && srcLoc.siblings && srcLoc.idx!=null) srcLoc.siblings.splice(srcLoc.idx,1); }
  // Recompute target AFTER possible removal to avoid index drift
  const tgtLoc = locateNode(tgtCol.schema, targetId); if(!tgtLoc) return;
  // Insert node at target
  if(where==='into'){
    ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(movingNode);
  } else {
    const sib=tgtLoc.siblings, idx=tgtLoc.idx;
    if(!sib||idx==null){ ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(movingNode); }
    else { let insertIndex = idx + (where==='after'?1:0); if(insertIndex<0) insertIndex=0; if(insertIndex>sib.length) insertIndex=sib.length; sib.splice(insertIndex,0,movingNode); }
  }
  // Determine new parent after insertion
  let newParentId;
  if(where==='into'){ newParentId = tgtLoc.node.id; }
  else { newParentId = tgtLoc.parent ? tgtLoc.parent.id : tgtCol.schema.id; }
  // If parent changed, column changed, or we created a copy, recompute IDs for subtree to match new location
  const parentChanged = (srcColId!==targetColId) || (oldParentId!==newParentId) || (kind==='copy');
  if(parentChanged){
    // Build taken set from siblings under the new parent (sibling-scope, not whole column)
    const __parentNode = (where==='into') ? tgtLoc.node : (tgtLoc.parent ? tgtLoc.parent : tgtCol.schema);
    const __siblings = Array.isArray(__parentNode.children) ? __parentNode.children : [];
    const taken = new Set(__siblings.map(n => n && n.id).filter(Boolean));
    // If this is a MOVE, the original node has already been removed from its old siblings;
    // do not remove the id on COPY (original still exists), otherwise we would allow a collision.
    if(kind !== 'copy') taken.delete(movingNode.id);
    const baseId = (newParentId===tgtCol.id?tgtCol.id:newParentId) + '.' + localIdSegment(movingNode.id);
    const newId = ensureUniqueId(baseId, taken);
    const idMap = {};
    const oldId = movingNode.id;
    buildSubtreeIdMap(movingNode, oldId, newId, idMap);
    if(kind!=='copy'){ replaceIdsInMappings(idMap); } else {
      if(copyEdges){ const __n = duplicateEdgesByIdMap(idMap); if(__n) try{ showToast('Cloned '+__n+' mapping'+(__n===1?'':'s')+'.'); }catch(e){} }
    }
  }
  return movingNode && movingNode.id;
}



  function describeIntent(src, intent){
    if(!intent) return '';
    const act = (intent.action==='copy_plus' ? 'COPY+' : intent.action.toUpperCase());
    const isMulti = !!(DND.multiIds && DND.multiIds.size >= 1);
    const srcLabel = isMulti ? `[${DND.multiIds.size} nodes]` : src.id;
    if(intent.kind==='map'){
      const mapCount = isMulti ? (DND.multiFields ? DND.multiFields.size : 0) : 1;
      return `${srcLabel}  ${intent.targetId}   MAP${isMulti ? ' '+mapCount : ''}`;
    }
    if(intent.kind==='before'||intent.kind==='after') return `${act} ${srcLabel} ${intent.kind} ${intent.targetId}`;
    if(intent.kind==='into') return `${act} ${srcLabel} into ${intent.targetId}`;
    return '';
  }

  function computeAction(mod){
    // Shift+Alt combos = special map types (bidirectional/directionless), even with Ctrl
    if(mod && mod.altKey && mod.shiftKey) return 'map';
    if(mod && (mod.ctrlKey||mod.metaKey) && mod.altKey) return 'copy_plus';
    if(mod && mod.altKey) return 'map';
    if(mod && (mod.ctrlKey||mod.metaKey)) return 'copy';
    return 'move';
  }

  function computeIntent(src, targetRow, clientX, clientY, mod){
    if(!targetRow) return null; const tid=targetRow.dataset.nodeId; const tcol=targetRow.dataset.columnId; const tnode = IDX?.nodeById?.get(tid); if(!tid||!tcol||!tnode) return null;
    const action = computeAction(mod);
    const isMulti = !!(DND.multiIds && DND.multiIds.size >= 1);

    // --- Multi-select validity checks ---
    if(isMulti){
      const selSet = state.multiSelection;
      if(action === 'map'){
        // MAP: target must not be in the selected set
        if(selSet.has(tid)) return null;
        // Only fields can be mapped
        if(tnode.type !== 'field') return null;
        // Need at least one field in selection
        if(!DND.multiFields || DND.multiFields.size === 0) return null;
        return { action, kind:'map', targetId: tid, targetColId: tcol };
      }
      // MOVE / COPY / COPY+: target must not be inside any selected subtree
      // Walk up from target: if a proper ancestor is selected, always block (inside subtree)
      { let p = IDX.parentById?.get(tid);
        while(p){
          if(selSet.has(p)) return null; // target is inside a selected node's subtree
          p = IDX.parentById?.get(p);
        }
      }
      // Determine landing position
      const r = targetRow.getBoundingClientRect(); const y=clientY - r.top; const h=r.height||1; const third=h/3;
      let kind; if(y<third) kind='before'; else if(y>2*third) kind='after'; else kind = (tnode.type!=='field') ? 'into' : 'after';
      // If target itself is a selected node:
      // Move: block entirely. Copy/Copy+: allow before/after, block into.
      if(selSet.has(tid)){
        if(action === 'copy' || action === 'copy_plus'){
          if(kind === 'into') return null;
        } else {
          return null;
        }
      }
      return {action, kind, targetId: tid, targetColId: tcol};
    }

    // --- Single-node validity checks ---
    // Block dropping into any descendant of self (all actions)
    { let p = IDX.parentById?.get(tid); while(p){ if(p === src.id) return null; p = IDX.parentById?.get(p); } }

    // Mapping (fieldfield only)
    if(action==='map'){
      if(src.type==='field' && tnode.type==='field' && src.id!==tid) return {action, kind:'map', targetId: tid, targetColId: tcol};
      return null;
    }

    // Moving/copying nodes
    // Decide landing position based on vertical thirds
    const r = targetRow.getBoundingClientRect(); const y=clientY - r.top; const h=r.height||1; const third=h/3;
    let kind; if(y<third) kind='before'; else if(y>2*third) kind='after'; else kind = (tnode.type!=='field') ? 'into' : 'after';

    // Self-drop rules:
    // Move onto self: always blocked
    // Copy/Copy+ before/after self: allowed (duplicate in place)
    // Copy/Copy+ into self: blocked (recursive)
    if(src.id === tid){
      if(action === 'copy' || action === 'copy_plus'){
        if(kind === 'into') return null; // block copy into self
      } else {
        return null; // block move onto self entirely
      }
    }

    return {action, kind, targetId: tid, targetColId: tcol};
  }

  function performDrop(src, intent){
    if(!src || !intent) return;
    const isMulti = !!(DND.multiIds && DND.multiIds.size >= 1);

    // === MULTI-SELECT DROP ===
    if(isMulti){
      // --- Multi MAP ---
      if(intent.action==='map' && intent.kind==='map'){
        const fieldIds = DND.multiFields;
        if(!fieldIds || fieldIds.size === 0) return;
        pushUndo();
        const _multiDir = __lastDragModifiers ? _dirFromModifiers(__lastDragModifiers) : 'forward';
        let created = 0;
        for(const fid of fieldIds){
          const exists = (state.data.mappings||[]).some(m=> m && m.from===fid && m.to===intent.targetId);
          if(!exists){
            state.data.mappings = state.data.mappings || [];
            state.data.mappings.push({ from: fid, to: intent.targetId, cardinality:'', transforms:[], label:'', note:'', default:'', direction: _multiDir });
            created++;
          }
        }
        markDirty();
        renderAll();
        // Switch selection to the target
        state.multiSelection.clear();
        state.lockedId = intent.targetId;
        state.hoverId = null;
        state.selectedColumnId = null;
        state.selectedEdgeId = null;
        applyHighlight();
        scrollIntoView(intent.targetId);
        savePostSelection(); // Remember post-action selection for redo
        showToast(`Mapped ${created} field${created===1?'':'s'}  ${intent.targetId}`);
        setViewerStatus(`Created ${created} mapping${created===1?'':'s'}  ${intent.targetId}`);
        return;
      }

      // --- Multi MOVE / COPY / COPY+ ---
      const op = (intent.action==='copy' || intent.action==='copy_plus') ? 'copy' : 'move';
      const wantCopyEdges = (intent.action==='copy_plus');
      const rootIds = DND.multiIds;

      // Sort roots in visual/tree order: collect from all columns in order
      const orderedRoots = [];
      for(const col of (state.data?.columns||[])){
        if(!col || !col.schema) continue;
        (function walk(n){
          if(!n) return;
          if(rootIds.has(n.id)) orderedRoots.push(n.id);
          (n.children||[]).forEach(walk);
        })(col.schema);
      }

      pushUndo();
      const newIds = [];
      // For MOVE: process in reverse order to avoid index shift issues during removal,
      // then insert in forward order at the target position
      if(op === 'move'){
        // Phase 1: Remove all source nodes (reverse order)
        const removedNodes = new Map(); // id  { node, colId }
        for(let i = orderedRoots.length - 1; i >= 0; i--){
          const nid = orderedRoots[i];
          const srcColId = nid.split('.')[0] || nid;
          const srcCol = findColumnById(srcColId);
          if(!srcCol) continue;
          const loc = locateNode(srcCol.schema, nid);
          if(loc && loc.siblings && loc.idx != null){
            const removed = loc.siblings.splice(loc.idx, 1)[0];
            removedNodes.set(nid, { node: removed, colId: srcColId });
          }
        }
        // Phase 2: Insert at target in forward order
        for(const nid of orderedRoots){
          const entry = removedNodes.get(nid);
          if(!entry) continue;
          // Re-locate target after previous insertions
          const tgtCol = findColumnById(intent.targetColId);
          if(!tgtCol) continue;
          const tgtLoc = locateNode(tgtCol.schema, intent.targetId);
          if(!tgtLoc) continue;
          const movingNode = entry.node;
          const oldParentId = entry.colId; // approximate
          if(intent.kind==='into'){
            ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(movingNode);
          } else {
            const sib=tgtLoc.siblings, idx=tgtLoc.idx;
            if(!sib||idx==null){ ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(movingNode); }
            else {
              // Insert after previous insertions: first root goes before/after target, subsequent go after each previous
              let insertIndex;
              if(newIds.length === 0){
                insertIndex = idx + (intent.kind==='after'?1:0);
              } else {
                // Find last inserted node and place after it
                const lastInserted = newIds[newIds.length-1];
                const lastIdx = sib.findIndex(n => n && n.id === lastInserted);
                insertIndex = lastIdx >= 0 ? lastIdx + 1 : idx + (intent.kind==='after'?1:0);
              }
              if(insertIndex<0) insertIndex=0; if(insertIndex>sib.length) insertIndex=sib.length;
              sib.splice(insertIndex, 0, movingNode);
            }
          }
          // Rewrite IDs to new location
          const newParentId = (intent.kind==='into') ? tgtLoc.node.id : (tgtLoc.parent ? tgtLoc.parent.id : tgtCol.schema.id);
          const srcColId = entry.colId;
          if(srcColId !== intent.targetColId || true){
            // Get siblings for uniqueness check
            const __parentNode = (intent.kind==='into') ? tgtLoc.node : (tgtLoc.parent ? tgtLoc.parent : tgtCol.schema);
            const __siblings = Array.isArray(__parentNode.children) ? __parentNode.children : [];
            const taken = new Set(__siblings.map(n => n && n.id).filter(Boolean));
            taken.delete(movingNode.id);
            const baseId = (newParentId===tgtCol.id?tgtCol.id:newParentId) + '.' + localIdSegment(movingNode.id);
            const newId = ensureUniqueId(baseId, taken);
            const idMap = {};
            buildSubtreeIdMap(movingNode, movingNode.id, newId, idMap);
            replaceIdsInMappings(idMap);
          }
          newIds.push(movingNode.id);
        }
      } else {
        // COPY / COPY+: clone and insert in forward order
        for(const nid of orderedRoots){
          const srcColId = nid.split('.')[0] || nid;
          const srcCol = findColumnById(srcColId);
          if(!srcCol) continue;
          const srcLoc = locateNode(srcCol.schema, nid);
          if(!srcLoc) continue;
          const clone = cloneNodeDeep(srcLoc.node);
          // Re-locate target after previous insertions
          const tgtCol = findColumnById(intent.targetColId);
          if(!tgtCol) continue;
          const tgtLoc = locateNode(tgtCol.schema, intent.targetId);
          if(!tgtLoc) continue;
          if(intent.kind==='into'){
            ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(clone);
          } else {
            const sib=tgtLoc.siblings, idx=tgtLoc.idx;
            if(!sib||idx==null){ ensureGroup(tgtLoc.node); (tgtLoc.node.children=tgtLoc.node.children||[]).push(clone); }
            else {
              let insertIndex;
              if(newIds.length === 0){
                insertIndex = idx + (intent.kind==='after'?1:0);
              } else {
                const lastInserted = newIds[newIds.length-1];
                const lastIdx = sib.findIndex(n => n && n.id === lastInserted);
                insertIndex = lastIdx >= 0 ? lastIdx + 1 : idx + (intent.kind==='after'?1:0);
              }
              if(insertIndex<0) insertIndex=0; if(insertIndex>sib.length) insertIndex=sib.length;
              sib.splice(insertIndex, 0, clone);
            }
          }
          // Rewrite IDs
          const newParentId = (intent.kind==='into') ? tgtLoc.node.id : (tgtLoc.parent ? tgtLoc.parent.id : tgtCol.schema.id);
          const __parentNode = (intent.kind==='into') ? tgtLoc.node : (tgtLoc.parent ? tgtLoc.parent : tgtCol.schema);
          const __siblings = Array.isArray(__parentNode.children) ? __parentNode.children : [];
          const taken = new Set(__siblings.map(n => n && n.id).filter(Boolean));
          const baseId = (newParentId===tgtCol.id?tgtCol.id:newParentId) + '.' + localIdSegment(clone.id);
          const newId = ensureUniqueId(baseId, taken);
          const idMap = {};
          buildSubtreeIdMap(clone, clone.id, newId, idMap);
          if(wantCopyEdges){
            const __n = duplicateEdgesByIdMap(idMap);
            if(__n) try{ showToast('Cloned '+__n+' mapping'+(__n===1?'':'s')+'.'); }catch(e){}
          }
          newIds.push(clone.id);
        }
      }

      // Finalize
      markDirty();
      try{ syncJsonAreaFromObj(); }catch(e){}
      renderAll();
      // Update multi-selection to the new nodes
      state.multiSelection.clear();
      if(newIds.length === 1){
        state.lockedId = newIds[0];
      } else {
        for(const nid of newIds) state.multiSelection.add(nid);
        state.lockedId = null;
      }
      state.hoverId = null;
      applyHighlight();
      if(newIds.length > 0) scrollIntoView(newIds[0]);
      savePostSelection(); // Remember post-action selection for redo
      const opLabel = op==='copy' ? (wantCopyEdges ? 'Copied+' : 'Copied') : 'Moved';
      showToast(`${opLabel} ${orderedRoots.length} node${orderedRoots.length===1?'':'s'}`);
      setViewerStatus(`${opLabel} ${orderedRoots.length} node${orderedRoots.length===1?'':'s'}: ${describeIntent(src,intent)}`);
      return;
    }

    // === SINGLE-NODE DROP (original logic) ===
    // If nothing is selected, lock the dragged node so the undo snapshot captures it
    if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
      state.lockedId = src.id;
    }
    if(intent.action==='map' && intent.kind==='map'){ hideDropLine && hideDropLine(); const _dir = __lastDragModifiers ? _dirFromModifiers(__lastDragModifiers) : 'forward'; ensureMapping(src.id, intent.targetId, _dir); renderAll(); const ee=(IDX&&IDX.edges)?IDX.edges.find(e=>e.from===src.id && e.to===intent.targetId):null; if(ee){ selectEdge(ee.id); } else { applyHighlight(); } return; }
    if(!src || !intent) return;
    if(intent.action==='map' && intent.kind==='map'){
      const _dir2 = __lastDragModifiers ? _dirFromModifiers(__lastDragModifiers) : 'forward';
      ensureMapping(src.id, intent.targetId, _dir2);
      renderAll(); const ee = (IDX && IDX.edges) ? IDX.edges.find(e=>e.from===src.id && e.to===intent.targetId) : null; if(ee){ selectEdge(ee.id); setViewerStatus('Created mapping: '+ee.from+'  '+ee.to);} else { applyHighlight(); }
      return;
    }
    // Move or Copy
    const wantCopyEdges = (intent.action==='copy_plus');
    const op = (intent.action==='copy' || intent.action==='copy_plus') ? 'copy' : 'move';
    const __newId = performMoveOrCopy({kind: op, srcId: src.id, targetId: intent.targetId, targetColId: intent.targetColId, where: intent.kind, copyEdges: wantCopyEdges});
    try{ syncJsonAreaFromObj(); }catch(e){}
    renderAll(); const __focus = __newId || src.id; lockSelection(__focus); scrollIntoView(__focus); savePostSelection(); setViewerStatus((op==='copy'?'Copied':'Moved')+': '+describeIntent(src,intent));
  }

  function onDragStart(e){ if(!state.editorMode){ e.preventDefault(); return; } const row=e.target.closest('.row'); if(!row) return; if(!beginDrag(row,e)){ e.preventDefault(); return; } try{ e.dataTransfer.setData('text/plain', row.dataset.nodeId||''); e.dataTransfer.effectAllowed='all'; }catch(err){} }
  function onDragEnd(){ 
    // macOS fallback: if drop wasn't handled but we have a valid intent, perform it now
    // (macOS blocks drop event when Cmd is held, but dragend still fires)
    if(isMacOS && !DND.dropHandled && DND.dragging && DND.intent && DND.overEl){
      try{
        performDrop(DND.dragging, DND.intent);
      }catch(err){ console.error('Fallback drop failed:', err); }
    }
    endDrag(); 
  }
  function onDragOver(e){ if(!state.editorMode || !DND.dragging) return; const row=e.target.closest('.row'); if(!row) return; 
    // Store modifier state for macOS compatibility (modifiers may not be available in drop event)
    if(isMacOS) DND.lastModifiers = {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, shiftKey:e.shiftKey};
    const modifiers = isMacOS && DND.lastModifiers ? DND.lastModifiers : {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, shiftKey:e.shiftKey};
    const intent=computeIntent(DND.dragging, row, e.clientX, e.clientY, modifiers); 
    // Update bin zone visibility based on modifier keys (not intent validity  bin should show
    // even when hovering illegal targets so the user can still drag to the bin)
    const actionFromKeys = computeAction(modifiers);
    const isMove = (actionFromKeys !== 'copy' && actionFromKeys !== 'copy_plus' && actionFromKeys !== 'map');
    if(binZone) binZone.classList.toggle('visible', isMove);
    if(!intent){ try{e.dataTransfer.dropEffect='none';}catch(err){} if(DND.overEl){ DND.overEl.classList.add('illegal'); } return; } e.preventDefault(); if(DND.overEl!==row){ if(DND.overEl) DND.overEl.classList.remove('dropTarget','moveIntent','mapIntent','copyIntent','illegal'); DND.overEl=row; }
    row.classList.remove('illegal'); row.classList.add('dropTarget'); row.classList.toggle('mapIntent', intent.action==='map'); row.classList.toggle('moveIntent', intent.action!=='map' && intent.action!=='copy' && intent.action!=='copy_plus'); row.classList.toggle('copyIntent', intent.action==='copy'); row.classList.toggle('copyPlusIntent', intent.action==='copy_plus');
    if(intent.action==='map'){ hideDropLine(); } else if(intent.kind==='before'||intent.kind==='after'){ showDropLineAt(row, intent.kind); } else { hideDropLine(); }
    DND.intent=intent; setViewerStatus(describeIntent(DND.dragging, intent)); }
  function onDrop(e){ if(!state.editorMode || !DND.dragging) return; const row=e.target.closest('.row'); if(!row) return; 
    // Use stored modifiers from dragover on macOS (may not be available in drop event)
    const modifiers = (isMacOS && DND.lastModifiers) ? DND.lastModifiers : {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, shiftKey:e.shiftKey};
    __lastDragModifiers = modifiers;
    const intent=computeIntent(DND.dragging, row, e.clientX, e.clientY, modifiers); if(!intent) return; e.preventDefault(); 
    DND.dropHandled = true;
    DND.intent=intent; performDrop(DND.dragging, intent); __lastDragModifiers = null; endDrag(); }

  // Hook createNodeElement to make rows draggable
  const __orig_createNodeElement = window.createNodeElement;
  window.createNodeElement = function(node, columnId){ const el = __orig_createNodeElement(node, columnId); const row = el.querySelector(':scope > .row'); if(row){ row.setAttribute('draggable','true'); row.addEventListener('dragstart', onDragStart); row.addEventListener('dragend', onDragEnd); row.addEventListener('dragover', onDragOver); row.addEventListener('drop', onDrop); } return el; };

  // Document-level dragover: show bin zone when cursor is outside any row during move drag
  document.addEventListener('dragover', (e)=>{
    if(!DND.dragging) return;
    const row = e.target.closest('.row');
    if(row) return; // row-level handler manages bin in this case
    // Outside any row  show/hide bin based on modifier keys
    const mod = {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, shiftKey:e.shiftKey};
    const action = computeAction(mod);
    const isMove = (action !== 'copy' && action !== 'copy_plus' && action !== 'map');
    if(binZone) binZone.classList.toggle('visible', isMove);
    // Clear any stale row hover styling
    if(DND.overEl){ DND.overEl.classList.remove('dropTarget','moveIntent','mapIntent','copyIntent','copyPlusIntent','illegal'); DND.overEl = null; }
    hideDropLine();
  });

})();

;


/* === Custom drag ghost with action chip (visual-only)  disables native badge === */
(function(){
  function markRowsDraggable(on){
    try{ columnsRow.querySelectorAll('.node .row')
      .forEach(r=>r.setAttribute('draggable', on?'true':'false')); }catch(e){}
  }
  if(editorModeToggle && !editorModeToggle.__ghostWired3){
    editorModeToggle.__ghostWired3 = true;
    editorModeToggle.addEventListener('change', ()=>markRowsDraggable(!!editorModeToggle.checked));
    markRowsDraggable(!!editorModeToggle.checked);
  }
  try{
    const mo = new MutationObserver(()=>{
      if(editorModeToggle && editorModeToggle.checked) markRowsDraggable(true);
    });
    mo.observe(columnsRow, {childList:true, subtree:true});
  }catch(e){}

  let ghostEl=null, ghostRow=null, savedTitle=null, dragging=false;
  function ensureGhost(){
    if(!ghostEl){
      ghostEl = document.createElement('div');
      ghostEl.id='dragGhost';
      ghostEl.innerHTML = '<div class="top"><span class="chip move" id="ghostOp">MOVE</span><span class="multiBadge" id="ghostMulti"></span><span class="label" id="ghostLabel"></span></div><div class="body" id="ghostBody"></div>';
      (document.getElementById('dndOverlay')||document.body).appendChild(ghostEl);
    }
    return ghostEl;
  }
  function setOpChip(evt){
    let op, chipClass, chipText;
    if(evt.altKey && evt.shiftKey && (evt.ctrlKey||evt.metaKey)){
      op = 'map'; chipClass = 'mapNone'; chipText = 'MAP ';
    } else if(evt.altKey && evt.shiftKey){
      op = 'map'; chipClass = 'mapBidi'; chipText = 'MAP ';
    } else if((evt.ctrlKey||evt.metaKey) && evt.altKey){
      op = 'copyPlus'; chipClass = 'copyPlus'; chipText = 'COPY+';
    } else if(evt.altKey){
      op = 'map'; chipClass = 'map'; chipText = 'MAP';
    } else if(evt.ctrlKey||evt.metaKey){
      op = 'copy'; chipClass = 'copy'; chipText = 'COPY';
    } else {
      op = 'move'; chipClass = 'move'; chipText = 'MOVE';
    }
    const chip = document.getElementById('ghostOp'); if(!chip) return;
    chip.className = 'chip ' + chipClass;
    chip.textContent = chipText;
    // Update multi badge
    const multiBadge = document.getElementById('ghostMulti');
    if(multiBadge){
      const dnd = window.__DND_MULTI || null;
      const isMulti = dnd && dnd.multiIds && dnd.multiIds.size >= 1;
      if(isMulti){
        const count = (op === 'map' && dnd.multiFields) ? dnd.multiFields.size : (state.multiSelection ? state.multiSelection.size : dnd.multiIds.size);
        multiBadge.textContent = '' + count;
        multiBadge.style.display = '';
      } else {
        multiBadge.textContent = '';
        multiBadge.style.display = 'none';
      }
    }
  }
  function showGhostFromRow(row, evt){
    const el = ensureGhost();
    const labelEl = row.querySelector('.label .text') || row.querySelector('.label') || row;
    document.getElementById('ghostLabel').textContent = (labelEl.textContent||'').trim();
    const bodyEl = document.getElementById('ghostBody');
    // Show multi-select summary in ghost body
    const dnd = window.__DND_MULTI || null;
    if(dnd && dnd.multiIds && dnd.multiIds.size >= 1){
      const selCount = state.multiSelection ? state.multiSelection.size : dnd.multiIds.size;
      const others = selCount - 1;
      bodyEl.innerHTML = others > 0 ? `<span style="font-size:10px;opacity:.55;">+ ${others} more node${others===1?'':'s'}</span>` : '';
    } else {
      bodyEl.innerHTML = '';
    }
    setOpChip(evt);
    el.style.display='block';
  }
  function moveGhost(x,y){ if(!ghostEl) return; ghostEl.style.left=(x-18)+'px'; ghostEl.style.top=(y-36)+'px'; }
  function hideGhost(){ if(!ghostEl) return; ghostEl.style.display='none'; }

  function transparentDragImage(){
    const c=document.createElement('canvas'); c.width=1; c.height=1; c.getContext('2d').clearRect(0,0,1,1); return c;
  }
  function stripTitle(row){ if(!row) return; if(row.hasAttribute('title')){ savedTitle=row.getAttribute('title'); row.removeAttribute('title'); } else savedTitle=null; }
  function restoreTitle(row){ if(!row) return; if(savedTitle!==null) row.setAttribute('title', savedTitle); savedTitle=null; }

  document.addEventListener('dragstart', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const row = e.target?.closest?.('.node .row'); if(!row) return;
    try{ if(e.dataTransfer){ e.dataTransfer.setDragImage(transparentDragImage(), 0, 0); e.dataTransfer.effectAllowed='all'; } }catch(_){ }
    dragging=true; ghostRow=row; showGhostFromRow(row, e); stripTitle(row); moveGhost(e.clientX, e.clientY);
  }, {passive:true});

  document.addEventListener('dragover', (e)=>{
    if(!dragging) return; e.preventDefault(); moveGhost(e.clientX, e.clientY); setOpChip(e);
  }, {passive:false});

  function endDrag(e){ if(!dragging) return; dragging=false; hideGhost(); restoreTitle(ghostRow); ghostRow=null; }
  document.addEventListener('drop', endDrag, {passive:false});
  document.addEventListener('dragend', endDrag, {passive:true});
})();



// --- v20.5.1: Copy behavior helpers ---
if (typeof window.getCopyEdgesPref !== 'function') {
  window.getCopyEdgesPref = function(){
    try { return localStorage.getItem('ms_copy_edges_pref') || 'structure'; }
    catch(e){ return 'structure'; }
  };
}
if (typeof window.setCopyEdgesPref !== 'function') {
  window.setCopyEdgesPref = function(v){
    try { localStorage.setItem('ms_copy_edges_pref', v); } catch(e){}
    state.copyEdgesPref = v;
  };
}
async function shouldCopyEdgesForThisCopy() {
  const pref = (typeof getCopyEdgesPref==='function' ? getCopyEdgesPref() : 'structure');
  if (pref === 'structure') return false;
  if (pref === 'structure_edges') return true;
  return await customConfirm('Also copy mappings for the copied nodes?');
}
function duplicateEdgesForSubtree(idMap, data) {
  if (!data || !Array.isArray(data.mappings)) return;
  const out = [];
  const seen = new Set(data.mappings.map(m => `${m.from}${Array.isArray(m.to)?m.to[0]:m.to}`));
  for (const m of data.mappings) {
    if (!m || typeof m!=='object') continue;
    const toVal = Array.isArray(m.to) ? m.to[0] : m.to;
    const newFrom = idMap[m.from];
    const newTo   = idMap[toVal];
    if (!newFrom && !newTo) continue;
    const nm = { ...m, from: newFrom || m.from, to: newTo || toVal };
    const key = `${nm.from}${nm.to}`;
    if (!seen.has(key)) { out.push(nm); seen.add(key); }
  }
  data.mappings.push(...out);
}
// === v20.5: Empty-column placeholder (Move/Copy only) ===
(function(){
  if(window.__MS_EMPTY_DROP_INSTALLED__) return; window.__MS_EMPTY_DROP_INSTALLED__ = true;
  function colRootById(colId){ try{ return (state.data && Array.isArray(state.data.columns)) ? (state.data.columns.find(c=>c&&c.id===colId)?.schema||null) : null; }catch(_){ return null; } }
  function updateEmptyPlaceholders(){
    try{
      const panels = Array.from(document.querySelectorAll('.columnsRow .panel'));
      panels.forEach(p=>{
        const tree = p.querySelector(':scope > .tree');
        const isEmpty = !(tree && tree.querySelector('.node'));
        if(isEmpty){
          p.setAttribute('data-empty','1');
          if(tree && !tree.querySelector(':scope > .emptyDrop')){
            const ph = document.createElement('div'); ph.className='emptyDrop'; ph.textContent='Drop here to place at root';
            tree.appendChild(ph);
          }
        } else {
          p.removeAttribute('data-empty');
          const ph = tree && tree.querySelector(':scope > .emptyDrop'); if(ph) ph.remove();
        }
      });
    }catch(_){ }
  }
  // Run after renders
  const _mo = new MutationObserver(()=>{ updateEmptyPlaceholders(); });
  try{ _mo.observe(document.getElementById('columnsRow'), {childList:true, subtree:true}); }catch(_){}
  document.addEventListener('DOMContentLoaded', updateEmptyPlaceholders, {once:true});
  // Populate contact email (split to avoid email obfuscation)
  const _ce = document.getElementById('dunnodeContact');
  if(_ce){ _ce.textContent = 'hello' + '\x40' + 'dunnode.com'; _ce.addEventListener('click', ()=>{ location.href = 'mai' + 'lto:' + _ce.textContent; }); }

  // Global ESC key handler to reset selection
  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape'){
      // Reset edge and node selection
      if(state.selectedEdgeId || state.hoverEdgeId || state.lockedId || state.hoverId){
        state.selectedEdgeId = null;
        state.hoverEdgeId = null;
        state.lockedId = null;
        state.hoverId = null;
        // Clear any edit session in editor mode
        if(state.editorMode){
          try{ clearEdgeEditSession({clearSelection:true}); }catch(e){}
        }
        renderAll();
        applyHighlight();
      }
    }
  });

  // Helper: get current intent from modifiers
  function currentIntent(e){ return e.altKey ? 'map' : ((e.ctrlKey||e.metaKey) ? 'copy' : 'move'); }
  
  // Detect macOS for drag-and-drop workarounds
  const isMacOSEmpty = /Mac|iPhone|iPad|iPod/.test(navigator.platform) || /Mac|iPhone|iPad|iPod/.test(navigator.userAgent);
  
  // Store last modifier state for macOS compatibility
  let lastEmptyPanelModifiers = null;

  // Ensure we always set a node id on dragstart for rows
  document.addEventListener('dragstart', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const row = e.target && e.target.closest && e.target.closest('.node .row'); if(!row) return;
    const nodeId = row.dataset.nodeId || '';
    try{ if(e.dataTransfer){ e.dataTransfer.setData('text/x-node-id', nodeId); if(!e.dataTransfer.getData('text/plain')) e.dataTransfer.setData('text/plain', nodeId); e.dataTransfer.effectAllowed='all'; } }catch(_){ }
  });

  // Show placeholder on empty panel for move/copy; hide for map
  document.addEventListener('dragover', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const panel = e.target && e.target.closest && e.target.closest('.panel'); if(!panel) return;
    if(panel.getAttribute('data-empty') !== '1') return;
    // Store modifier state for macOS compatibility
    if(isMacOSEmpty) lastEmptyPanelModifiers = {altKey:e.altKey, ctrlKey:e.ctrlKey||e.metaKey, metaKey:e.metaKey};
    const intent = currentIntent(e);
    if(intent==='map'){ panel.classList.remove('dropOpen'); return; }
    panel.classList.add('dropOpen');
    const tree = panel.querySelector(':scope > .tree'); const ph = tree && tree.querySelector(':scope > .emptyDrop'); if(ph){ ph.classList.remove('move','copy'); ph.classList.add(intent); }
    try{ if(e.dataTransfer){ e.dataTransfer.dropEffect = (intent==='copy' ? 'copy' : 'move'); } }catch(_){ }
    e.preventDefault();
  }, {passive:false});

  function getDraggedNodeId(e){
    let id = '';
    try{ id = e.dataTransfer && (e.dataTransfer.getData('text/x-node-id') || e.dataTransfer.getData('text/plain')) || ''; }catch(_){ id=''; }
    return (id||'').trim();
  }
  
  // Helper to get intent with fallback to stored modifiers (for macOS)
  function getIntentWithFallback(e){
    if(isMacOSEmpty && lastEmptyPanelModifiers){
      return lastEmptyPanelModifiers.altKey ? 'map' : ((lastEmptyPanelModifiers.ctrlKey||lastEmptyPanelModifiers.metaKey) ? 'copy' : 'move');
    }
    return currentIntent(e);
  }

  // Perform move/copy into empty column root on drop
  document.addEventListener('drop', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const panel = e.target && e.target.closest && e.target.closest('.panel'); if(!panel) return;
    if(panel.getAttribute('data-empty') !== '1') return;
    const intent = getIntentWithFallback(e);
    if(intent==='map') return; // not supported into empty
    const targetColId = panel.dataset.columnId; if(!targetColId) return;
    const srcId = getDraggedNodeId(e); if(!srcId) return;
    e.preventDefault();

    try{
      // If nothing is selected, lock the dragged node so the undo snapshot captures it
      if(!state.lockedId && !state.selectedEdgeId && state.multiSelection.size === 0){
        state.lockedId = srcId;
      }
      recordChange(); // Save state BEFORE move to empty column
      
      const data = state.data; if(!data) return;
      const srcColId = (function(){ const i=srcId.indexOf('.'); return i>0 ? srcId.slice(0,i) : srcId; 
// --- v20.5.1: Auto-scroll while dragging (horizontal + vertical) ---
(function(){
  const sc = document.getElementById('columnsScroller');
  if(!sc) return;
  const H_MARGIN = 32;      // px from left/right edge
  const H_SPEED  = 16;      // px per event
  const V_MARGIN = 28;      // px from top/bottom inside a tree
  const V_SPEED  = 14;      // px per event

  sc.addEventListener('dragover', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const r = sc.getBoundingClientRect();
    if(e.clientX > r.right - H_MARGIN) sc.scrollLeft += H_SPEED;
    else if(e.clientX < r.left + H_MARGIN) sc.scrollLeft -= H_SPEED;
  }, {passive:false});

  // Vertical autoscroll inside individual column trees
  document.addEventListener('dragover', (e)=>{
    if(!(editorModeToggle && editorModeToggle.checked)) return;
    const tree = e.target && e.target.closest && e.target.closest('.panel .tree');
    if(!tree) return;
    const rt = tree.getBoundingClientRect();
    if(e.clientY > rt.bottom - V_MARGIN) tree.scrollTop += V_SPEED;
    else if(e.clientY < rt.top + V_MARGIN) tree.scrollTop -= V_SPEED;
  }, {passive:false});
})();
})();
      const srcCol = data.columns.find(c=>c&&c.id===srcColId); if(!srcCol||!srcCol.schema) return;
      const targetCol = data.columns.find(c=>c&&c.id===targetColId); if(!targetCol||!targetCol.schema) return;
      const targetRoot = targetCol.schema; if(!Array.isArray(targetRoot.children)) targetRoot.children=[];

      // locate source node in its column
      function locateNode(root, targetId, parent=null){ if(!root) return null; if(root.id===targetId) return {node:root,parent,idx:null,siblings:null}; const kids=root.children||[]; for(let i=0;i<kids.length;i++){ const ch=kids[i]; if(ch&&ch.id===targetId) return {node:ch,parent:root,idx:i,siblings:kids}; const deep=locateNode(ch,targetId,root); if(deep) return deep; } return null; }

      // Unique id helpers from file scope (fallbacks if not found)
      function idPartFromLabel(label){ try{ return (label||'').toString().trim().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/\s+/g,'_').replace(/[^A-Za-z0-9_]/g,'').replace(/_+/g,'_')||'node'; }catch(_){ return 'node'; } }
      function ensureUniqueId(base, taken){ let id=base, i=2; while(taken.has(id)) { id = base+'_'+i++; } return id; }
      function collectIds(n, set){ if(!n) return set; set.add(n.id); (n.children||[]).forEach(ch=>collectIds(ch,set)); return set; }
      function buildSubtreeIdMap(node, oldPrefix, newPrefix, out){ if(!node) return; const oldId=node.id; const newId=(oldId===oldPrefix)?newPrefix:(newPrefix+oldId.slice(oldPrefix.length)); out[oldId]=newId; node.id=newId; (node.children||[]).forEach(ch=>buildSubtreeIdMap(ch, oldPrefix, newPrefix, out)); }
      function replaceIdsInMappings(data, idMap){ if(!data||!Array.isArray(data.mappings)) return; data.mappings.forEach(m=>{ if(!m||typeof m!=='object') return; if(typeof m.from==='string' && idMap[m.from]) m.from=idMap[m.from]; if(Array.isArray(m.to)) m.to = m.to.map(t=> (typeof t==='string' && idMap[t]) ? idMap[t] : t); else if(typeof m.to==='string' && idMap[m.to]) m.to=idMap[m.to]; }); }

      // Compute node to insert
      let nodeToInsert=null;
      if(intent==='copy'){
        const srcLoc = locateNode(srcCol.schema, srcId); if(!srcLoc||!srcLoc.node) return;
        nodeToInsert = JSON.parse(JSON.stringify(srcLoc.node));
      } else { // move
        const srcLoc = locateNode(srcCol.schema, srcId); if(!srcLoc||!srcLoc.node||!srcLoc.siblings) return;
        nodeToInsert = srcLoc.node;
        const idx = srcLoc.idx; if(idx!=null && idx>=0) srcLoc.siblings.splice(idx,1);
      }

      // Re-id subtree for target root uniqueness
      const taken = collectIds(targetRoot, new Set());
      const base = targetRoot.id + '.' + idPartFromLabel(nodeToInsert.label||'node');
      const newId = ensureUniqueId(base, taken);
      const idMap = {}; buildSubtreeIdMap(nodeToInsert, nodeToInsert.id, newId, idMap);
      if(intent==='move'){ replaceIdsInMappings(data, idMap); } else { if(shouldCopyEdgesForThisCopy()) duplicateEdgesForSubtree(idMap, data); }

      targetRoot.children.push(nodeToInsert);

      // Sync UI
      try{ if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2); }catch(_){}
      if(typeof renderAll==='function') renderAll();
      if(typeof applyHighlight==='function') applyHighlight();
      try{ if(typeof lockSelection==='function') lockSelection(newId); if(typeof scrollIntoView==='function') scrollIntoView(newId); if(typeof applyHighlight==='function') applyHighlight(); }catch(_){ }
      if(typeof setGlobalStatus==='function') setGlobalStatus((intent==='copy'?'Copied ':'Moved ') + newId + ' into empty column ' + targetColId);
    }catch(err){ console.error(err); }
  }, {passive:false});

  // Cleanup placeholder state on dragend
  document.addEventListener('dragend', ()=>{
    document.querySelectorAll('.panel.dropOpen').forEach(p=>p.classList.remove('dropOpen'));
  }, {passive:true});
})();




// --- Project title inline handler ---
(function(){
  const titleInput = document.getElementById('projectTitle');
  if(!titleInput) return;
  let __snap = '';

  function updateEditability(){
    const isEd = editorModeToggle && editorModeToggle.checked;
    titleInput.readOnly = !isEd;
    titleInput.style.cursor = isEd ? 'text' : 'default';
    titleInput.style.opacity = isEd ? '1' : '0.6';
    titleInput.title = isEd ? 'Project title (click to edit)' : 'Enable Editor mode to edit title';
  }
  if(editorModeToggle) editorModeToggle.addEventListener('change', updateEditability);
  updateEditability();

  titleInput.addEventListener('focus', ()=>{
    __snap = titleInput.value;
    titleInput.style.background = 'rgba(255,255,255,.12)';
    titleInput.style.borderColor = 'rgba(59,130,246,.55)';
  });
  titleInput.addEventListener('blur', ()=>{
    titleInput.style.background = 'rgba(255,255,255,.08)';
    titleInput.style.borderColor = 'rgba(255,255,255,.15)';
    const newVal = (titleInput.value||'').trim() || 'New Project';
    if(state.data && newVal !== __snap){
      recordChange();
      state.data.title = newVal;
      titleInput.value = newVal;
      syncBrowserTitle();
      try{ if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2); }catch(e){}
    }
  });
  titleInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){ e.preventDefault(); titleInput.blur(); }
    if(e.key === 'Escape'){ e.preventDefault(); titleInput.value = __snap; titleInput.blur(); }
  });

  // Sync __snap when undo/redo updates the input externally
  const origUndo = window.__origUndo = undo;
  const origRedo = window.__origRedo = redo;
  undo = function(){
    // Blur to commit/discard any pending inline edit before undo changes data
    if(document.activeElement === titleInput) titleInput.blur();
    origUndo();
    __snap = titleInput.value; // sync after undo updated the input
  };
  redo = function(){
    if(document.activeElement === titleInput) titleInput.blur();
    origRedo();
    __snap = titleInput.value;
  };
})();

// --- Command palette (Ctrl/Cmd+K) ---
(function(){
  const mask = document.getElementById('cmdPaletteMask');
  const palette = document.getElementById('cmdPalette');
  const input = document.getElementById('cmdPaletteInput');
  const results = document.getElementById('cmdPaletteResults');
  const openBtn = document.getElementById('cmdPaletteBtn');
  if(!mask || !input || !results) return;

  let _activeIdx = 0;
  let _flatItems = []; // current rendered items [{el, action}]

  // --- Command registry ---
  const isMac = /Mac|iPhone|iPad/.test(navigator.platform||'');
  const mod = isMac ? '' : 'Ctrl';

  const COMMANDS = [
    // Project
    { cat:'Project', icon:'', label:'New project',           action:()=> document.getElementById('newMappingBtn')?.click(), hint:'Start blank', kbd:'Alt+N' },
    { cat:'Project', icon:'', label:'Open project',          action:()=> document.getElementById('openProjectBtn')?.click(), kbd:'Alt+O' },
    { cat:'Project', icon:'', label:'Save project',           action:()=> document.getElementById('saveProjectBtn')?.click(), kbd:'Alt+S' },
    { cat:'Project', icon:'',  label:'Project properties',    action:()=> document.getElementById('projectInfoBtn')?.click() },
    { cat:'Project', icon:'', label:'Load example project',   action:()=> document.getElementById('loadExampleBtn')?.click() },

    // Catalogs
    { cat:'Catalogs', icon:'', label:'Tags catalog',           action:()=> openTags() },
    { cat:'Catalogs', icon:'', label:'Transforms catalog',     action:()=> openTransforms() },
    { cat:'Catalogs', icon:'', label:'Attributes catalog',    action:()=> openCustomAttrs() },
    { cat:'Catalogs', icon:'', label:'Filters',               action:()=> openFilters() },
    { cat:'Catalogs', icon:'', label:'Views catalog',          action:()=> openViews() },
    { cat:'Catalogs', icon:'', label:'Save current view',       action:()=> document.getElementById('viewsSaveCurrentBtn')?.click(), kbd:'Ctrl+Alt+S' },
    { cat:'Catalogs', icon:'', label:'Previous view',            action:()=> document.getElementById('viewsRestorePrevBtn')?.click(), kbd:',' },
    { cat:'Catalogs', icon:'', label:'Next view',                action:()=> document.getElementById('viewsNextBtn')?.click(), kbd:'.' },
    { cat:'Catalogs', icon:'', label:'Reset view',               action:()=> resetViewState(), kbd:'Ctrl+Alt+0' },
    { cat:'Catalogs', icon:'', label:'Highlight colors',      action:()=> document.getElementById('hlColorsBtn')?.click() },

    // View
    { cat:'View', icon:'', label:'Expand all groups',      action:()=> setAllGroupsCollapsed(false) },
    { cat:'View', icon:'', label:'Collapse all groups',    action:()=> setAllGroupsCollapsed(true) },
    { cat:'View', icon:'', label:'Toggle collapse/expand',  action:()=>{ const ids = state.multiSelection.size>0 ? [...state.multiSelection] : (state.lockedId?[state.lockedId]:[]); for(const nid of ids){ const n=IDX.nodeById.get(nid); if(n&&n.type==='group') toggleCollapse(nid,null,true); } applyHighlight(); scheduleArrowsUpdate(); }, kbd:'Space' },
    { cat:'View', icon:'', label:'Toggle bright/dark mode', action:()=> document.getElementById('brightModeBtn')?.click() },
    { cat:'View', icon:'', label:'Toggle pan mode',         action:()=> document.getElementById('panToggleBtn')?.click(), kbd:'P' },
    { cat:'View', icon:'', label:'Clear selection',           action:()=> document.getElementById('clearSelBtn')?.click(), kbd:'Esc' },
    { cat:'View', icon:'', label:'Select all visible nodes',  action:()=> selectAllNodes(), kbd:mod+'+A' },
    { cat:'View', icon:'', label:'Invert selection',          action:()=> invertSelection(), kbd:mod+'+Shift+I' },

    // Details panel
    { cat:'View', icon:'', label:'Details panel: Left',    action:()=> setTab('left') },
    { cat:'View', icon:'', label:'Details panel: Right',   action:()=> setTab('right') },
    { cat:'View', icon:'', label:'Details panel: Bottom',  action:()=> setTab('bottom') },
    { cat:'View', icon:'', label:'Details panel: Float',   action:()=> setTab('float') },
    { cat:'View', icon:'', label:'Details panel: Hidden',  action:()=> setTab('hidden'), kbd:'D' },

    // Edit
    { cat:'Edit', icon:'', label:'Toggle editor mode',     action:()=> document.getElementById('editorModeToggle')?.click(), kbd:'Alt+E' },
    { cat:'Edit', icon:'', label:'Undo',                   action:()=> undo(), kbd:mod+'+Z' },
    { cat:'Edit', icon:'', label:'Redo',                   action:()=> redo(), kbd:mod+'+Y' },
    { cat:'Edit', icon:'', label:'Insert field below',     action:()=> quickCreateNode('below','field'), kbd:mod+'+' },
    { cat:'Edit', icon:'', label:'Insert field above',     action:()=> quickCreateNode('above','field'), kbd:mod+'+' },
    { cat:'Edit', icon:'', label:'Insert group below',     action:()=> quickCreateNode('below','group'), kbd:mod+'+Alt+' },
    { cat:'Edit', icon:'', label:'Insert group above',     action:()=> quickCreateNode('above','group'), kbd:mod+'+Alt+' },
    { cat:'Edit', icon:'', label:'Add child field',        action:()=> quickCreateNode('child','field'), kbd:mod+'+' },
    { cat:'Edit', icon:'', label:'Add child group',        action:()=> quickCreateNode('child','group'), kbd:mod+'+Alt+' },
    { cat:'Edit', icon:'', label:'Indent node(s)',           action:()=>{ if(state.multiSelection.size>1) bulkIndent(); else if(state.lockedId) inlineIndent(state.lockedId, columnOf(state.lockedId)); }, kbd:'Alt+' },
    { cat:'Edit', icon:'', label:'Outdent node(s)',          action:()=>{ if(state.multiSelection.size>1) bulkOutdent(); else if(state.lockedId) inlineOutdent(state.lockedId, columnOf(state.lockedId)); }, kbd:'Alt+' },
    { cat:'Edit', icon:'', label:'Copy node(s)',            action:()=> copyNodes(), kbd:mod+'+C' },
    { cat:'Edit', icon:'', label:'Paste node(s)',           action:()=> pasteNodes(), kbd:mod+'+V' },
    { cat:'Edit', icon:'', label:'Duplicate node(s)',       action:()=> duplicateNodes(), kbd:mod+'+D' },
    { cat:'Edit', icon:'', label:'Group selection',         action:()=> groupSelection(), kbd:mod+'+G' },
    { cat:'Edit', icon:'', label:'Ungroup',                 action:()=> ungroupNode(), kbd:mod+'+Shift+G' },
    { cat:'Edit', icon:'', label:'Delete node(s)',          action:()=> bulkDelete(), kbd:'Delete' },
    { cat:'Edit', icon:'', label:'Convert to group',        action:()=>{ if(state.lockedId){ const c=columnOf(state.lockedId); if(c) convertNodeType(state.lockedId,c); } } },
    { cat:'Edit', icon:'', label:'Convert to field',        action:()=>{ if(state.lockedId){ const c=columnOf(state.lockedId); if(c) convertNodeType(state.lockedId,c); } } },
    { cat:'Edit', icon:'', label:'Import fields',        action:()=>{ const cid = state.selectedColumnId || (state.lockedId && columnOf(state.lockedId)); if(cid) openImportFields(cid); else customAlert('Select a column first to import fields into.'); } },
    { cat:'Edit', icon:'', label:'Import columns',       action:()=>{ if(!state.data){ customAlert('Load or create a project first.'); return; } openImportColumns(); } },
    { cat:'Edit', icon:'', label:'Import SQL/DDL',       action:()=> openImportSql() },
    { cat:'Edit', icon:'', label:'Import CSV/TSV file',  action:()=> openImportCsvFile() },
    { cat:'Edit', icon:'', label:'Import mappings',     action:()=> openImportMappings() },
    { cat:'Edit', icon:'', label:'Import from project',  action:()=>{ if(!state.data){ customAlert('Load or create a project first.'); return; } document.getElementById('importProjectFileInput')?.click(); } },
    { cat:'Edit', icon:'', label:'Import tags',          action:()=> openImportCatalog('tag') },
    { cat:'Edit', icon:'', label:'Import attributes',    action:()=> openImportCatalog('attribute') },
    { cat:'Edit', icon:'', label:'Import transforms',    action:()=> openImportCatalog('transform') },
    { cat:'Edit', icon:'', label:'Load preset bundle',   action:()=> openPresetBundle() },

    // Help
    { cat:'Help', icon:'', label:'Quick Start Guide',      action:()=> openHelp(), kbd:'?' },
    { cat:'Help', icon:'', label:'Keyboard shortcuts',     action:()=> openKbdShortcuts() },
    { cat:'Help', icon:'', label:'Documentation',          action:()=> openDocs() },
    { cat:'Help', icon:'', label:'Release notes',           action:()=> openReleaseNotes() },
    { cat:'Help', icon:'', label:'About Dunnode',           action:()=> document.getElementById('aboutBtn')?.click() },
  ];

  // Add dynamic per-view entries
  // (refreshed each time the palette opens via _refreshDynamicCommands)
  let _dynamicViewStart = COMMANDS.length;
  function _refreshDynamicCommands(){
    // Remove old dynamic entries
    COMMANDS.length = _dynamicViewStart;
    const viewCat = state.data?.viewCatalog;
    if(Array.isArray(viewCat)){
      viewCat.forEach(v => {
        COMMANDS.push({
          cat: 'Views', icon: v.emoji || '',
          label: 'Apply view: ' + (v.label || v.id),
          hint: v.note || '',
          action: ()=>{ _applyView(v); }
        });
      });
    }
  }

  // --- Fuzzy match ---
  function fuzzyMatch(query, text){
    const q = query.toLowerCase();
    const t = text.toLowerCase();
    if(!q) return { match:true, score:0, ranges:[] };
    // Substring match first (stronger)
    const subIdx = t.indexOf(q);
    if(subIdx >= 0) return { match:true, score: 100 - subIdx, ranges:[[subIdx, subIdx+q.length]] };
    // Char-by-char fuzzy
    let qi = 0, score = 0;
    const ranges = [];
    let rangeStart = -1;
    for(let ti = 0; ti < t.length && qi < q.length; ti++){
      if(t[ti] === q[qi]){
        if(rangeStart < 0) rangeStart = ti;
        qi++;
        score += (ti === 0 || t[ti-1] === ' ' || t[ti-1] === '.') ? 10 : 1;
      } else {
        if(rangeStart >= 0){ ranges.push([rangeStart, ti]); rangeStart = -1; }
      }
    }
    if(rangeStart >= 0) ranges.push([rangeStart, ranges.length ? ranges[ranges.length-1][1] : rangeStart + qi]);
    if(qi < q.length) return { match:false, score:0, ranges:[] };
    return { match:true, score, ranges };
  }

  function highlightText(text, ranges){
    if(!ranges.length) return escapeHtml(text);
    let out = '', last = 0;
    for(const [s,e] of ranges){
      if(s > last) out += escapeHtml(text.slice(last, s));
      out += '<mark>' + escapeHtml(text.slice(s, e)) + '</mark>';
      last = e;
    }
    if(last < text.length) out += escapeHtml(text.slice(last));
    return out;
  }

  // --- Node search ---
  function searchNodes(query, max){
    if(!IDX || !IDX.nodeById) return [];
    const found = [];
    for(const [id, node] of IDX.nodeById.entries()){
      const label = node.label || node.id || id;
      const matchLabel = fuzzyMatch(query, label);
      const matchId = fuzzyMatch(query, id);
      const best = matchLabel.score >= matchId.score ? matchLabel : matchId;
      if(!best.match) continue;
      const colId = IDX.nodeColumnById?.get(id) || '';
      const col = IDX.columns?.find(c=>c.id===colId);
      const colLabel = col ? (col.label || col.id) : colId;
      const isField = IDX.fieldIds?.has(id);
      found.push({
        id, label, nodeId: id,
        icon: isField ? '' : '',
        hint: colLabel,
        score: best.score,
        ranges: matchLabel.score >= matchId.score ? best.ranges : [],
        labelText: label,
        idText: id,
        idRanges: matchId.score > matchLabel.score ? matchId.ranges : [],
      });
    }
    found.sort((a,b) => b.score - a.score);
    return found.slice(0, max || 20);
  }

  function selectNode(nodeId){
    if(!nodeId) return;
    // Expand all parent groups so node is visible
    let cur = nodeId;
    const toExpand = [];
    while(IDX.parentById?.has(cur)){
      cur = IDX.parentById.get(cur);
      toExpand.push(cur);
    }
    for(const gid of toExpand){
      const g = IDX.nodeById?.get(gid);
      if(g && g.__collapsed) g.__collapsed = false;
    }
    state.lockedId = nodeId;
    state.hoverId = nodeId;
    state.selectedEdgeId = null;
    state.hoverEdgeId = null;
    renderAll();
    applyHighlight();
    // Scroll into view
    requestAnimationFrame(()=>{
      const el = document.querySelector(`.row[data-node-id="${CSS.escape(nodeId)}"]`);
      if(el) el.scrollIntoView({ behavior:'smooth', block:'center', inline:'center' });
    });
  }

  // --- Documentation search ---
  let _docSections = null;
  function getDocSections(){
    if(_docSections) return _docSections;
    _docSections = [];
    // Build docs if not yet built
    buildDocs();
    const body = document.getElementById('docsBody');
    if(!body) return _docSections;
    const headings = body.querySelectorAll('h2, h3');
    headings.forEach((h, i) => {
      // Collect text until next heading
      const level = h.tagName;
      const title = h.textContent.trim();
      // Generate a stable ID for scrolling
      const hId = 'doc-' + title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/,'');
      h.id = hId;
      let text = title;
      let el = h.nextElementSibling;
      while(el && el.tagName !== 'H2' && el.tagName !== 'H3'){
        text += ' ' + el.textContent.trim();
        el = el.nextElementSibling;
      }
      _docSections.push({ title, text: text.slice(0, 500), hId, level });
    });
    return _docSections;
  }

  function searchDocs(query, max){
    const sections = getDocSections();
    const found = [];
    for(const sec of sections){
      const m = fuzzyMatch(query, sec.text);
      if(!m.match) continue;
      // Find snippet around match
      const lowerText = sec.text.toLowerCase();
      const qi = lowerText.indexOf(query.toLowerCase());
      let snippet = '';
      if(qi >= 0){
        const start = Math.max(0, qi - 30);
        const end = Math.min(sec.text.length, qi + query.length + 60);
        snippet = (start > 0 ? '' : '') + sec.text.slice(start, end).trim() + (end < sec.text.length ? '' : '');
      } else {
        snippet = sec.text.slice(0, 80).trim() + (sec.text.length > 80 ? '' : '');
      }
      found.push({ ...sec, score: m.score + (sec.level === 'H2' ? 5 : 0), snippet });
    }
    found.sort((a,b) => b.score - a.score);
    return found.slice(0, max || 6);
  }

  // --- Render results ---
  function renderResults(query){
    const q = (query||'').trim();
    _flatItems = [];
    _activeIdx = 0;

    if(!q){
      // Show all commands grouped by category
      let html = '';
      let lastCat = '';
      COMMANDS.forEach((cmd, i)=>{
        if(cmd.cat !== lastCat){ html += `<div class="cmdCat">${escapeHtml(cmd.cat)}</div>`; lastCat = cmd.cat; }
        html += renderItem(cmd.icon, cmd.label, '', cmd.hint||'', cmd.kbd||'', i);
      });
      results.innerHTML = html;
      bindItems(COMMANDS.map(c => c.action));
      updateActive();
      return;
    }

    // Filter commands
    const cmdMatches = [];
    COMMANDS.forEach(cmd=>{
      const m = fuzzyMatch(q, cmd.label);
      // Also match category
      const cm = fuzzyMatch(q, cmd.cat + ' ' + cmd.label);
      const best = cm.score > m.score ? cm : m;
      if(best.match) cmdMatches.push({ ...cmd, score:best.score, ranges:m.match ? m.ranges : [] });
    });
    cmdMatches.sort((a,b) => b.score - a.score);

    // Search nodes
    const nodeMatches = searchNodes(q, 15);

    // Search documentation (only for queries of 3+ chars)
    const docMatches = q.length >= 3 ? searchDocs(q, 6) : [];

    let html = '';
    const actions = [];

    if(cmdMatches.length){
      html += '<div class="cmdCat">Commands</div>';
      cmdMatches.forEach(cmd=>{
        html += renderItem(cmd.icon, cmd.label, '', cmd.hint||'', cmd.kbd||'', actions.length, cmd.ranges);
        actions.push(cmd.action);
      });
    }

    if(nodeMatches.length){
      html += '<div class="cmdCat">Nodes & Fields</div>';
      nodeMatches.forEach(n=>{
        const displayLabel = highlightText(n.labelText, n.ranges);
        const idPart = n.idText !== n.labelText ? `<span style="opacity:.4;font-size:11px;margin-left:6px;">${highlightText(n.idText, n.idRanges)}</span>` : '';
        html += `<div class="cmdItem" data-idx="${actions.length}">
          <span class="cmdIcon" style="opacity:.4;">${n.icon}</span>
          <span class="cmdLabel">${displayLabel}${idPart}</span>
          <span class="cmdHint">${escapeHtml(n.hint)}</span>
        </div>`;
        actions.push(()=> selectNode(n.nodeId));
      });
    }

    if(docMatches.length){
      html += '<div class="cmdCat">Documentation</div>';
      docMatches.forEach(doc=>{
        const levelIcon = doc.level === 'H2' ? '' : '';
        html += `<div class="cmdItem" data-idx="${actions.length}">
          <span class="cmdIcon" style="opacity:.35;">${levelIcon}</span>
          <span class="cmdLabel">${escapeHtml(doc.title)}<br/><span style="font-size:10.5px;opacity:.45;font-weight:400;line-height:1.3;">${escapeHtml(doc.snippet)}</span></span>
        </div>`;
        actions.push(()=>{
          openDocs();
          requestAnimationFrame(()=>{
            const el = document.getElementById(doc.hId);
            if(el) el.scrollIntoView({ behavior:'smooth', block:'start' });
          });
        });
      });
    }

    results.innerHTML = html || '';
    bindItems(actions);
    updateActive();
  }

  function renderItem(icon, label, extra, hint, kbd, idx, ranges){
    const labelHtml = ranges && ranges.length ? highlightText(label, ranges) : escapeHtml(label);
    return `<div class="cmdItem" data-idx="${idx}">
      <span class="cmdIcon">${icon}</span>
      <span class="cmdLabel">${labelHtml}${extra}</span>
      ${hint ? `<span class="cmdHint">${escapeHtml(hint)}</span>` : ''}
      ${kbd ? `<span class="cmdKbd">${escapeHtml(platformKbd(kbd))}</span>` : ''}
    </div>`;
  }

  function bindItems(actions){
    _flatItems = [];
    results.querySelectorAll('.cmdItem').forEach(el=>{
      const idx = Number(el.dataset.idx);
      _flatItems.push({ el, action: actions[idx] });
      el.addEventListener('click', ()=>{ closePalette(); actions[idx]?.(); });
      el.addEventListener('mouseenter', ()=>{
        _activeIdx = _flatItems.indexOf(_flatItems.find(f=>f.el===el));
        updateActive();
      });
    });
  }

  function updateActive(){
    _flatItems.forEach((f,i) => f.el.classList.toggle('active', i === _activeIdx));
    const active = _flatItems[_activeIdx];
    if(active) active.el.scrollIntoView({ block:'nearest' });
  }

  // --- Open/close ---
  function openPalette(){
    _refreshDynamicCommands();
    input.value = '';
    renderResults('');
    mask.classList.add('active');
    requestAnimationFrame(()=> input.focus());
  }
  function closePalette(){
    mask.classList.remove('active');
    input.blur();
  }

  // Event wiring
  input.addEventListener('input', ()=> renderResults(input.value));
  input.addEventListener('keydown', (e)=>{
    if(e.key === 'ArrowDown'){ e.preventDefault(); _activeIdx = Math.min(_activeIdx+1, _flatItems.length-1); updateActive(); }
    else if(e.key === 'ArrowUp'){ e.preventDefault(); _activeIdx = Math.max(_activeIdx-1, 0); updateActive(); }
    else if(e.key === 'Enter'){ e.preventDefault(); closePalette(); _flatItems[_activeIdx]?.action?.(); }
    else if(e.key === 'Escape'){ e.preventDefault(); closePalette(); }
  });
  mask.addEventListener('click', (e)=>{ if(e.target === mask) closePalette(); });
  if(openBtn) openBtn.addEventListener('click', openPalette);

  // Global Ctrl/Cmd+K
  document.addEventListener('keydown', (e)=>{
    if((e.ctrlKey || e.metaKey) && e.key === 'k'){
      e.preventDefault();
      if(mask.classList.contains('active')) closePalette(); else openPalette();
    }
  });
})();

// --- Project properties modal ---
(function(){
  const PROJECT_FIELDS = [
    { key:'title',          label:'Title',        type:'text',     placeholder:'Project title' },
    { key:'subtitle',       label:'Subtitle',     type:'text',     placeholder:'Short subtitle' },
    { key:'author',         label:'Author',       type:'text',     placeholder:'Author name' },
    { key:'organization',   label:'Organization', type:'text',     placeholder:'Company or team' },
    { key:'contact',        label:'Contact',      type:'text',     placeholder:'Email or contact info' },
    { key:'url',            label:'URL',          type:'url',      placeholder:'https://' },
    { key:'projectVersion', label:'Version',       type:'text',     placeholder:'e.g. 1.0' },
    { key:'date',           label:'Date',         type:'date',     placeholder:'YYYY-MM-DD' },
    { key:'description',    label:'Description',  type:'textarea', placeholder:'Project description' },
  ];

  const modal = document.getElementById('projectPropsModal');
  const mask = document.getElementById('projPropsMask');
  const body = document.getElementById('projPropsBody');
  const saveBtn = document.getElementById('projPropsSave');
  const cancelBtn = document.getElementById('projPropsCancel');
  const openBtn = document.getElementById('projectInfoBtn');
  if(!modal || !body || !openBtn) return;

  let __propSnap = null;

  function propsDirty(){
    if(!__propSnap) return false;
    for(const f of PROJECT_FIELDS){
      const el = document.getElementById('pp_'+f.key);
      const v = el ? (el.value||'').trim() : '';
      if(v !== (__propSnap[f.key]||'')) return true;
    }
    return false;
  }

  async function guardedClose(){
    if(state.editorMode && propsDirty()){
      const ok = await customConfirm('Abandon unsaved changes to project properties?');
      if(!ok) return;
    }
    closeProjectProps();
  }

  function openProjectProps(){
    if(!state.data) return;
    const isEd = state.editorMode;
    // Capture snapshot of all fields
    __propSnap = {};
    PROJECT_FIELDS.forEach(f=>{ __propSnap[f.key] = state.data[f.key] || ''; });

    // Render form
    const ro = isEd ? '' : ' readonly disabled';
    const rows = PROJECT_FIELDS.map(f=>{
      const val = escapeHtml(state.data[f.key] || '');
      if(f.type==='textarea'){
        return `<div class="k">${f.label}</div><div class="v"><textarea id="pp_${f.key}" class="inp" rows="5" placeholder="${f.placeholder}" style="resize:vertical;font-size:12px;line-height:1.5;"${ro}>${val}</textarea></div>`;
      }
      return `<div class="k">${f.label}</div><div class="v"><input id="pp_${f.key}" class="inp" type="${f.type}" value="${val}" placeholder="${f.placeholder}"${ro}/></div>`;
    }).join('\n');

    body.innerHTML = `<div class="kv" style="grid-template-columns:100px 1fr;">${rows}</div>`;

    // Show read-only file metadata if present
    const appObj = state.data._app;
    const appN = (typeof appObj === 'object' && appObj) ? appObj.name : (typeof appObj === 'string' ? appObj : '');
    const appV = (typeof appObj === 'object' && appObj) ? appObj.version : (state.data._appVersion || '');
    const savedAt = state.data._savedAt || '';
    if(appN || appV || savedAt){
      const metaParts = [];
      if(appN) metaParts.push(`<span>${escapeHtml(appN)}${appV ? ' v'+escapeHtml(appV) : ''}</span>`);
      else if(appV) metaParts.push(`<span>App version: <strong>${escapeHtml(appV)}</strong></span>`);
      if(savedAt){
        let display = savedAt;
        try{ display = new Date(savedAt).toLocaleString(); }catch(e){}
        metaParts.push(`<span>Last saved: <strong>${escapeHtml(display)}</strong></span>`);
      }
      body.innerHTML += `<div style="margin-top:12px;padding-top:10px;border-top:1px solid var(--border);display:flex;gap:20px;flex-wrap:wrap;font-size:11px;opacity:.55;">${metaParts.join('')}</div>`;
    }

    // Show/hide Save button based on mode
    saveBtn.style.display = isEd ? '' : 'none';
    cancelBtn.textContent = isEd ? 'Cancel' : 'Close';

    modal.classList.add('active');
    if(mask) mask.classList.add('active');
    if(isEd){
      const first = document.getElementById('pp_title');
      if(first) setTimeout(()=> first.focus(), 100);
      wireDirtyHighlight(body, saveBtn, propsDirty);
    }
  }

  function closeProjectProps(){
    modal.classList.remove('active');
    if(mask) mask.classList.remove('active');
    __propSnap = null;
  }

  function saveProjectProps(){
    if(!state.data || !__propSnap) { closeProjectProps(); return; }
    // Read all form values
    const newVals = {};
    let changed = false;
    PROJECT_FIELDS.forEach(f=>{
      const el = document.getElementById('pp_'+f.key);
      const v = el ? (el.value||'').trim() : (__propSnap[f.key]||'');
      newVals[f.key] = v;
      if(v !== (__propSnap[f.key]||'')) changed = true;
    });
    if(changed){
      recordChange();
      PROJECT_FIELDS.forEach(f=>{ state.data[f.key] = newVals[f.key]; });
      // Sync title input in header
      const titleInput = document.getElementById('projectTitle');
      if(titleInput) titleInput.value = state.data.title || 'New Project';
      syncBrowserTitle();
      try{ if(jsonArea) jsonArea.value = JSON.stringify(state.data, null, 2); }catch(e){}
      renderAll();
      setGlobalStatus('Project properties saved.');
    }
    closeProjectProps();
  }

  openBtn.addEventListener('click', openProjectProps);
  saveBtn.addEventListener('click', saveProjectProps);
  cancelBtn.addEventListener('click', guardedClose);
  if(mask) mask.addEventListener('click', guardedClose);

  // Allow Escape to cancel (with guard)
  modal.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){ e.preventDefault(); guardedClose(); }
  });
})();

</script>
</body>
</html>
